// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions. For more information, see [Access Management](https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html) in the IAM User Guide.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DevOpsGuruClientTypes.AccountHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case insight = "Insight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let insight = insight {
            try encodeContainer.encode(insight, forKey: .insight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let insightDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AccountInsightHealth.self, forKey: .insight)
        insight = insightDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Returns the number of open reactive insights, the number of open proactive insights, and the number of metrics analyzed in your Amazon Web Services account. Use these numbers to gauge the health of operations in your Amazon Web Services account.
    public struct AccountHealth: Swift.Equatable {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// Information about the health of the Amazon Web Services resources in your account, including the number of open proactive, open reactive insights, and the Mean Time to Recover (MTTR) of closed insights.
        public var insight: DevOpsGuruClientTypes.AccountInsightHealth?

        public init (
            accountId: Swift.String? = nil,
            insight: DevOpsGuruClientTypes.AccountInsightHealth? = nil
        )
        {
            self.accountId = accountId
            self.insight = insight
        }
    }

}

extension DevOpsGuruClientTypes.AccountInsightHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if openProactiveInsights != 0 {
            try encodeContainer.encode(openProactiveInsights, forKey: .openProactiveInsights)
        }
        if openReactiveInsights != 0 {
            try encodeContainer.encode(openReactiveInsights, forKey: .openReactiveInsights)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openProactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .openProactiveInsights)
        openProactiveInsights = openProactiveInsightsDecoded
        let openReactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .openReactiveInsights)
        openReactiveInsights = openReactiveInsightsDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the number of open reactive and proactive insights that can be used to gauge the health of your system.
    public struct AccountInsightHealth: Swift.Equatable {
        /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
        public var openProactiveInsights: Swift.Int
        /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
        public var openReactiveInsights: Swift.Int

        public init (
            openProactiveInsights: Swift.Int = 0,
            openReactiveInsights: Swift.Int = 0
        )
        {
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }
    }

}

extension AddNotificationChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            try encodeContainer.encode(config, forKey: .config)
        }
    }
}

extension AddNotificationChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct AddNotificationChannelInput: Swift.Equatable {
    /// A NotificationChannelConfig object that specifies what type of notification channel to add. The one supported notification channel is Amazon Simple Notification Service (Amazon SNS).
    /// This member is required.
    public var config: DevOpsGuruClientTypes.NotificationChannelConfig?

    public init (
        config: DevOpsGuruClientTypes.NotificationChannelConfig? = nil
    )
    {
        self.config = config
    }
}

struct AddNotificationChannelInputBody: Swift.Equatable {
    let config: DevOpsGuruClientTypes.NotificationChannelConfig?
}

extension AddNotificationChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.NotificationChannelConfig.self, forKey: .config)
        config = configDecoded
    }
}

extension AddNotificationChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddNotificationChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddNotificationChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddNotificationChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddNotificationChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct AddNotificationChannelOutputResponse: Swift.Equatable {
    /// The ID of the added notification channel.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct AddNotificationChannelOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
}

extension AddNotificationChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DevOpsGuruClientTypes.AnomalyReportedTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case closeTime = "CloseTime"
        case openTime = "OpenTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let closeTime = closeTime {
            try encodeContainer.encode(closeTime.timeIntervalSince1970, forKey: .closeTime)
        }
        if let openTime = openTime {
            try encodeContainer.encode(openTime.timeIntervalSince1970, forKey: .openTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .openTime)
        openTime = openTimeDecoded
        let closeTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .closeTime)
        closeTime = closeTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A time range that specifies when DevOps Guru opens and then closes an anomaly. This is different from AnomalyTimeRange, which specifies the time range when DevOps Guru actually observes the anomalous behavior.
    public struct AnomalyReportedTimeRange: Swift.Equatable {
        /// The time when an anomaly is closed.
        public var closeTime: ClientRuntime.Date?
        /// The time when an anomaly is opened.
        /// This member is required.
        public var openTime: ClientRuntime.Date?

        public init (
            closeTime: ClientRuntime.Date? = nil,
            openTime: ClientRuntime.Date? = nil
        )
        {
            self.closeTime = closeTime
            self.openTime = openTime
        }
    }

}

extension DevOpsGuruClientTypes.AnomalyResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The Amazon Web Services resources in which DevOps Guru detected unusual behavior that resulted in the generation of an anomaly. When DevOps Guru detects multiple related anomalies, it creates and insight with details about the anomalous behavior and suggestions about how to correct the problem.
    public struct AnomalyResource: Swift.Equatable {
        /// The name of the Amazon Web Services resource.
        public var name: Swift.String?
        /// The type of the Amazon Web Services resource.
        public var type: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum AnomalySeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalySeverity] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalySeverity(rawValue: rawValue) ?? AnomalySeverity.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.AnomalySourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchMetrics = "CloudWatchMetrics"
        case performanceInsightsMetrics = "PerformanceInsightsMetrics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchMetrics = cloudWatchMetrics {
            var cloudWatchMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchMetrics)
            for cloudwatchmetricsdetails0 in cloudWatchMetrics {
                try cloudWatchMetricsContainer.encode(cloudwatchmetricsdetails0)
            }
        }
        if let performanceInsightsMetrics = performanceInsightsMetrics {
            var performanceInsightsMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .performanceInsightsMetrics)
            for performanceinsightsmetricsdetails0 in performanceInsightsMetrics {
                try performanceInsightsMetricsContainer.encode(performanceinsightsmetricsdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchMetricsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.CloudWatchMetricsDetail?].self, forKey: .cloudWatchMetrics)
        var cloudWatchMetricsDecoded0:[DevOpsGuruClientTypes.CloudWatchMetricsDetail]? = nil
        if let cloudWatchMetricsContainer = cloudWatchMetricsContainer {
            cloudWatchMetricsDecoded0 = [DevOpsGuruClientTypes.CloudWatchMetricsDetail]()
            for structure0 in cloudWatchMetricsContainer {
                if let structure0 = structure0 {
                    cloudWatchMetricsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchMetrics = cloudWatchMetricsDecoded0
        let performanceInsightsMetricsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail?].self, forKey: .performanceInsightsMetrics)
        var performanceInsightsMetricsDecoded0:[DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail]? = nil
        if let performanceInsightsMetricsContainer = performanceInsightsMetricsContainer {
            performanceInsightsMetricsDecoded0 = [DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail]()
            for structure0 in performanceInsightsMetricsContainer {
                if let structure0 = structure0 {
                    performanceInsightsMetricsDecoded0?.append(structure0)
                }
            }
        }
        performanceInsightsMetrics = performanceInsightsMetricsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Details about the source of the anomalous operational data that triggered the anomaly.
    public struct AnomalySourceDetails: Swift.Equatable {
        /// An array of CloudWatchMetricsDetail objects that contain information about analyzed CloudWatch metrics that show anomalous behavior.
        public var cloudWatchMetrics: [DevOpsGuruClientTypes.CloudWatchMetricsDetail]?
        /// An array of PerformanceInsightsMetricsDetail objects that contain information about analyzed Performance Insights metrics that show anomalous behavior.
        public var performanceInsightsMetrics: [DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail]?

        public init (
            cloudWatchMetrics: [DevOpsGuruClientTypes.CloudWatchMetricsDetail]? = nil,
            performanceInsightsMetrics: [DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail]? = nil
        )
        {
            self.cloudWatchMetrics = cloudWatchMetrics
            self.performanceInsightsMetrics = performanceInsightsMetrics
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum AnomalyStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case ongoing
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyStatus] {
            return [
                .closed,
                .ongoing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .ongoing: return "ONGOING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalyStatus(rawValue: rawValue) ?? AnomalyStatus.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.AnomalyTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
    public struct AnomalyTimeRange: Swift.Equatable {
        /// The time when the anomalous behavior ended.
        public var endTime: ClientRuntime.Date?
        /// The time when the anomalous behavior started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum AnomalyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case causal
        case contextual
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyType] {
            return [
                .causal,
                .contextual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .causal: return "CAUSAL"
            case .contextual: return "CONTEXTUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalyType(rawValue: rawValue) ?? AnomalyType.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.CloudFormationCollection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackNames = "StackNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackNames = stackNames {
            var stackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackNames)
            for stacknames0 in stackNames {
                try stackNamesContainer.encode(stacknames0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackNames)
        var stackNamesDecoded0:[Swift.String]? = nil
        if let stackNamesContainer = stackNamesContainer {
            stackNamesDecoded0 = [Swift.String]()
            for string0 in stackNamesContainer {
                if let string0 = string0 {
                    stackNamesDecoded0?.append(string0)
                }
            }
        }
        stackNames = stackNamesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about Amazon Web Services CloudFormation stacks. You can use up to 500 stacks to specify which Amazon Web Services resources in your account to analyze. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
    public struct CloudFormationCollection: Swift.Equatable {
        /// An array of CloudFormation stack names.
        public var stackNames: [Swift.String]?

        public init (
            stackNames: [Swift.String]? = nil
        )
        {
            self.stackNames = stackNames
        }
    }

}

extension DevOpsGuruClientTypes.CloudFormationCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackNames = "StackNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackNames = stackNames {
            var stackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackNames)
            for stacknames0 in stackNames {
                try stackNamesContainer.encode(stacknames0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackNames)
        var stackNamesDecoded0:[Swift.String]? = nil
        if let stackNamesContainer = stackNamesContainer {
            stackNamesDecoded0 = [Swift.String]()
            for string0 in stackNamesContainer {
                if let string0 = string0 {
                    stackNamesDecoded0?.append(string0)
                }
            }
        }
        stackNames = stackNamesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about Amazon Web Services CloudFormation stacks. You can use up to 500 stacks to specify which Amazon Web Services resources in your account to analyze. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
    public struct CloudFormationCollectionFilter: Swift.Equatable {
        /// An array of CloudFormation stack names.
        public var stackNames: [Swift.String]?

        public init (
            stackNames: [Swift.String]? = nil
        )
        {
            self.stackNames = stackNames
        }
    }

}

extension DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackNames = "StackNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackNames = stackNames {
            var stackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackNames)
            for costestimationstacknames0 in stackNames {
                try stackNamesContainer.encode(costestimationstacknames0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackNames)
        var stackNamesDecoded0:[Swift.String]? = nil
        if let stackNamesContainer = stackNamesContainer {
            stackNamesDecoded0 = [Swift.String]()
            for string0 in stackNamesContainer {
                if let string0 = string0 {
                    stackNamesDecoded0?.append(string0)
                }
            }
        }
        stackNames = stackNamesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an Amazon Web Services CloudFormation stack used to create a monthly cost estimate for DevOps Guru to analyze Amazon Web Services resources. The maximum number of stacks you can specify for a cost estimate is one. The estimate created is for the cost to analyze the Amazon Web Services resources defined by the stack. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
    public struct CloudFormationCostEstimationResourceCollectionFilter: Swift.Equatable {
        /// An array of CloudFormation stack names. Its size is fixed at 1 item.
        public var stackNames: [Swift.String]?

        public init (
            stackNames: [Swift.String]? = nil
        )
        {
            self.stackNames = stackNames
        }
    }

}

extension DevOpsGuruClientTypes.CloudFormationHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insight = "Insight"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insight = insight {
            try encodeContainer.encode(insight, forKey: .insight)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let insightDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightHealth.self, forKey: .insight)
        insight = insightDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the health of Amazon Web Services resources in your account that are specified by an Amazon Web Services CloudFormation stack.
    public struct CloudFormationHealth: Swift.Equatable {
        /// Information about the health of the Amazon Web Services resources in your account that are specified by an Amazon Web Services CloudFormation stack, including the number of open proactive, open reactive insights, and the Mean Time to Recover (MTTR) of closed insights.
        public var insight: DevOpsGuruClientTypes.InsightHealth?
        /// The name of the CloudFormation stack.
        public var stackName: Swift.String?

        public init (
            insight: DevOpsGuruClientTypes.InsightHealth? = nil,
            stackName: Swift.String? = nil
        )
        {
            self.insight = insight
            self.stackName = stackName
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum CloudWatchMetricDataStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case internalError
        case partialData
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchMetricDataStatusCode] {
            return [
                .complete,
                .internalError,
                .partialData,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .internalError: return "InternalError"
            case .partialData: return "PartialData"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudWatchMetricDataStatusCode(rawValue: rawValue) ?? CloudWatchMetricDataStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.CloudWatchMetricsDataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode = "StatusCode"
        case timestampMetricValuePairList = "TimestampMetricValuePairList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let timestampMetricValuePairList = timestampMetricValuePairList {
            var timestampMetricValuePairListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timestampMetricValuePairList)
            for timestampmetricvaluepairlist0 in timestampMetricValuePairList {
                try timestampMetricValuePairListContainer.encode(timestampmetricvaluepairlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampMetricValuePairListContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.TimestampMetricValuePair?].self, forKey: .timestampMetricValuePairList)
        var timestampMetricValuePairListDecoded0:[DevOpsGuruClientTypes.TimestampMetricValuePair]? = nil
        if let timestampMetricValuePairListContainer = timestampMetricValuePairListContainer {
            timestampMetricValuePairListDecoded0 = [DevOpsGuruClientTypes.TimestampMetricValuePair]()
            for structure0 in timestampMetricValuePairListContainer {
                if let structure0 = structure0 {
                    timestampMetricValuePairListDecoded0?.append(structure0)
                }
            }
        }
        timestampMetricValuePairList = timestampMetricValuePairListDecoded0
        let statusCodeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CloudWatchMetricDataStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Contains information about the analyzed metrics that displayed anomalous behavior.
    public struct CloudWatchMetricsDataSummary: Swift.Equatable {
        /// This is an enum of the status showing whether the metric value pair list has partial or complete data, or if there was an error.
        public var statusCode: DevOpsGuruClientTypes.CloudWatchMetricDataStatusCode?
        /// This is a list of Amazon CloudWatch metric values at given timestamp.
        public var timestampMetricValuePairList: [DevOpsGuruClientTypes.TimestampMetricValuePair]?

        public init (
            statusCode: DevOpsGuruClientTypes.CloudWatchMetricDataStatusCode? = nil,
            timestampMetricValuePairList: [DevOpsGuruClientTypes.TimestampMetricValuePair]? = nil
        )
        {
            self.statusCode = statusCode
            self.timestampMetricValuePairList = timestampMetricValuePairList
        }
    }

}

extension DevOpsGuruClientTypes.CloudWatchMetricsDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case metricDataSummary = "MetricDataSummary"
        case metricName = "MetricName"
        case namespace = "Namespace"
        case period = "Period"
        case stat = "Stat"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for cloudwatchmetricsdimensions0 in dimensions {
                try dimensionsContainer.encode(cloudwatchmetricsdimensions0)
            }
        }
        if let metricDataSummary = metricDataSummary {
            try encodeContainer.encode(metricDataSummary, forKey: .metricDataSummary)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if period != 0 {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let stat = stat {
            try encodeContainer.encode(stat.rawValue, forKey: .stat)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.CloudWatchMetricsDimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[DevOpsGuruClientTypes.CloudWatchMetricsDimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [DevOpsGuruClientTypes.CloudWatchMetricsDimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let statDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CloudWatchMetricsStat.self, forKey: .stat)
        stat = statDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let periodDecoded = try containerValues.decode(Swift.Int.self, forKey: .period)
        period = periodDecoded
        let metricDataSummaryDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CloudWatchMetricsDataSummary.self, forKey: .metricDataSummary)
        metricDataSummary = metricDataSummaryDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an Amazon CloudWatch metric.
    public struct CloudWatchMetricsDetail: Swift.Equatable {
        /// An array of CloudWatch dimensions associated with
        public var dimensions: [DevOpsGuruClientTypes.CloudWatchMetricsDimension]?
        /// This object returns anomaly metric data.
        public var metricDataSummary: DevOpsGuruClientTypes.CloudWatchMetricsDataSummary?
        /// The name of the CloudWatch metric.
        public var metricName: Swift.String?
        /// The namespace of the CloudWatch metric. A namespace is a container for CloudWatch metrics.
        public var namespace: Swift.String?
        /// The length of time associated with the CloudWatch metric in number of seconds.
        public var period: Swift.Int
        /// The type of statistic associated with the CloudWatch metric. For more information, see [Statistics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Statistic) in the Amazon CloudWatch User Guide.
        public var stat: DevOpsGuruClientTypes.CloudWatchMetricsStat?
        /// The unit of measure used for the CloudWatch metric. For example, Bytes, Seconds, Count, and Percent.
        public var unit: Swift.String?

        public init (
            dimensions: [DevOpsGuruClientTypes.CloudWatchMetricsDimension]? = nil,
            metricDataSummary: DevOpsGuruClientTypes.CloudWatchMetricsDataSummary? = nil,
            metricName: Swift.String? = nil,
            namespace: Swift.String? = nil,
            period: Swift.Int = 0,
            stat: DevOpsGuruClientTypes.CloudWatchMetricsStat? = nil,
            unit: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.metricDataSummary = metricDataSummary
            self.metricName = metricName
            self.namespace = namespace
            self.period = period
            self.stat = stat
            self.unit = unit
        }
    }

}

extension DevOpsGuruClientTypes.CloudWatchMetricsDimension: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The dimension of am Amazon CloudWatch metric that is used when DevOps Guru analyzes the resources in your account for operational problems and anomalous behavior. A dimension is a name/value pair that is part of the identity of a metric. A metric can have up to 10 dimensions. For more information, see [Dimensions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Dimension) in the Amazon CloudWatch User Guide.
    public struct CloudWatchMetricsDimension: Swift.Equatable {
        /// The name of the CloudWatch dimension.
        public var name: Swift.String?
        /// The value of the CloudWatch dimension.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum CloudWatchMetricsStat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case average
        case maximum
        case minimum
        case p50
        case p90
        case p99
        case sampleCount
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchMetricsStat] {
            return [
                .average,
                .maximum,
                .minimum,
                .p50,
                .p90,
                .p99,
                .sampleCount,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "Average"
            case .maximum: return "Maximum"
            case .minimum: return "Minimum"
            case .p50: return "p50"
            case .p90: return "p90"
            case .p99: return "p99"
            case .sampleCount: return "SampleCount"
            case .sum: return "Sum"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudWatchMetricsStat(rawValue: rawValue) ?? CloudWatchMetricsStat.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception that is thrown when a conflict occurs.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the Amazon Web Services resource in which a conflict occurred.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the Amazon Web Services resource in which a conflict occurred.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFormation = "CloudFormation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormation = cloudFormation {
            try encodeContainer.encode(cloudFormation, forKey: .cloudFormation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagcostestimationresourcecollectionfilters0 in tags {
                try tagsContainer.encode(tagcostestimationresourcecollectionfilters0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter.self, forKey: .cloudFormation)
        cloudFormation = cloudFormationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter?].self, forKey: .tags)
        var tagsDecoded0:[DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a filter used to specify which Amazon Web Services resources are analyzed to create a monthly DevOps Guru cost estimate. For more information, see [Estimate your Amazon DevOps Guru costs](https://docs.aws.amazon.com/devops-guru/latest/userguide/cost-estimate.html) and [Amazon DevOps Guru pricing](http://aws.amazon.com/devops-guru/pricing/).
    public struct CostEstimationResourceCollectionFilter: Swift.Equatable {
        /// An object that specifies the CloudFormation stack that defines the Amazon Web Services resources used to create a monthly estimate for DevOps Guru.
        public var cloudFormation: DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter?
        /// The Amazon Web Services tags used to filter the resource collection that is used for a cost estimate. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf) whitepaper. Each Amazon Web Services tag has two parts.
        ///
        /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
        ///
        /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
        ///
        ///
        /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be Devops-guru-deployment-application or Devops-guru-rds-application. While keys are case-sensitive, the case of key characters don't matter to DevOps Guru. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var tags: [DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter]?

        public init (
            cloudFormation: DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter? = nil,
            tags: [DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter]? = nil
        )
        {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum CostEstimationServiceResourceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [CostEstimationServiceResourceState] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostEstimationServiceResourceState(rawValue: rawValue) ?? CostEstimationServiceResourceState.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes {
    public enum CostEstimationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case ongoing
        case sdkUnknown(Swift.String)

        public static var allCases: [CostEstimationStatus] {
            return [
                .completed,
                .ongoing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .ongoing: return "ONGOING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostEstimationStatus(rawValue: rawValue) ?? CostEstimationStatus.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.CostEstimationTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The time range of a cost estimation.
    public struct CostEstimationTimeRange: Swift.Equatable {
        /// The end time of the cost estimation.
        public var endTime: ClientRuntime.Date?
        /// The start time of the cost estimation.
        public var startTime: ClientRuntime.Date?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension DescribeAccountHealthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accounts/health"
    }
}

public struct DescribeAccountHealthInput: Swift.Equatable {

}

struct DescribeAccountHealthInputBody: Swift.Equatable {
}

extension DescribeAccountHealthInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountHealthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountHealthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountHealthOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountHealthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountHealthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricsAnalyzed = output.metricsAnalyzed
            self.openProactiveInsights = output.openProactiveInsights
            self.openReactiveInsights = output.openReactiveInsights
            self.resourceHours = output.resourceHours
        } else {
            self.metricsAnalyzed = 0
            self.openProactiveInsights = 0
            self.openReactiveInsights = 0
            self.resourceHours = nil
        }
    }
}

public struct DescribeAccountHealthOutputResponse: Swift.Equatable {
    /// An integer that specifies the number of metrics that have been analyzed in your Amazon Web Services account.
    /// This member is required.
    public var metricsAnalyzed: Swift.Int
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    /// This member is required.
    public var openProactiveInsights: Swift.Int
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    /// This member is required.
    public var openReactiveInsights: Swift.Int
    /// The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour.
    /// This member is required.
    public var resourceHours: Swift.Int?

    public init (
        metricsAnalyzed: Swift.Int = 0,
        openProactiveInsights: Swift.Int = 0,
        openReactiveInsights: Swift.Int = 0,
        resourceHours: Swift.Int? = nil
    )
    {
        self.metricsAnalyzed = metricsAnalyzed
        self.openProactiveInsights = openProactiveInsights
        self.openReactiveInsights = openReactiveInsights
        self.resourceHours = resourceHours
    }
}

struct DescribeAccountHealthOutputResponseBody: Swift.Equatable {
    let openReactiveInsights: Swift.Int
    let openProactiveInsights: Swift.Int
    let metricsAnalyzed: Swift.Int
    let resourceHours: Swift.Int?
}

extension DescribeAccountHealthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricsAnalyzed = "MetricsAnalyzed"
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
        case resourceHours = "ResourceHours"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openReactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .openReactiveInsights)
        openReactiveInsights = openReactiveInsightsDecoded
        let openProactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .openProactiveInsights)
        openProactiveInsights = openProactiveInsightsDecoded
        let metricsAnalyzedDecoded = try containerValues.decode(Swift.Int.self, forKey: .metricsAnalyzed)
        metricsAnalyzed = metricsAnalyzedDecoded
        let resourceHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resourceHours)
        resourceHours = resourceHoursDecoded
    }
}

extension DescribeAccountOverviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromTime = fromTime {
            try encodeContainer.encode(fromTime.timeIntervalSince1970, forKey: .fromTime)
        }
        if let toTime = toTime {
            try encodeContainer.encode(toTime.timeIntervalSince1970, forKey: .toTime)
        }
    }
}

extension DescribeAccountOverviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accounts/overview"
    }
}

public struct DescribeAccountOverviewInput: Swift.Equatable {
    /// The start of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred after this day.
    /// This member is required.
    public var fromTime: ClientRuntime.Date?
    /// The end of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred before this day. If this is not specified, then the current day is used.
    public var toTime: ClientRuntime.Date?

    public init (
        fromTime: ClientRuntime.Date? = nil,
        toTime: ClientRuntime.Date? = nil
    )
    {
        self.fromTime = fromTime
        self.toTime = toTime
    }
}

struct DescribeAccountOverviewInputBody: Swift.Equatable {
    let fromTime: ClientRuntime.Date?
    let toTime: ClientRuntime.Date?
}

extension DescribeAccountOverviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .toTime)
        toTime = toTimeDecoded
    }
}

extension DescribeAccountOverviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountOverviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountOverviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountOverviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountOverviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.meanTimeToRecoverInMilliseconds = output.meanTimeToRecoverInMilliseconds
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.meanTimeToRecoverInMilliseconds = nil
            self.proactiveInsights = 0
            self.reactiveInsights = 0
        }
    }
}

public struct DescribeAccountOverviewOutputResponse: Swift.Equatable {
    /// The Mean Time to Recover (MTTR) for all closed insights that were created during the time range passed in.
    /// This member is required.
    public var meanTimeToRecoverInMilliseconds: Swift.Int?
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account that were created during the time range passed in.
    /// This member is required.
    public var proactiveInsights: Swift.Int
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account that were created during the time range passed in.
    /// This member is required.
    public var reactiveInsights: Swift.Int

    public init (
        meanTimeToRecoverInMilliseconds: Swift.Int? = nil,
        proactiveInsights: Swift.Int = 0,
        reactiveInsights: Swift.Int = 0
    )
    {
        self.meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct DescribeAccountOverviewOutputResponseBody: Swift.Equatable {
    let reactiveInsights: Swift.Int
    let proactiveInsights: Swift.Int
    let meanTimeToRecoverInMilliseconds: Swift.Int?
}

extension DescribeAccountOverviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meanTimeToRecoverInMilliseconds = "MeanTimeToRecoverInMilliseconds"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .reactiveInsights)
        reactiveInsights = reactiveInsightsDecoded
        let proactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .proactiveInsights)
        proactiveInsights = proactiveInsightsDecoded
        let meanTimeToRecoverInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .meanTimeToRecoverInMilliseconds)
        meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMillisecondsDecoded
    }
}

extension DescribeAnomalyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let accountId = accountId {
            let accountIdQueryItem = ClientRuntime.URLQueryItem(name: "AccountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            items.append(accountIdQueryItem)
        }
        return items
    }
}

extension DescribeAnomalyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/anomalies/\(id.urlPercentEncoding())"
    }
}

public struct DescribeAnomalyInput: Swift.Equatable {
    /// The ID of the member account.
    public var accountId: Swift.String?
    /// The ID of the anomaly.
    /// This member is required.
    public var id: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.id = id
    }
}

struct DescribeAnomalyInputBody: Swift.Equatable {
}

extension DescribeAnomalyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAnomalyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnomalyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAnomalyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnomalyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAnomalyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proactiveAnomaly = output.proactiveAnomaly
            self.reactiveAnomaly = output.reactiveAnomaly
        } else {
            self.proactiveAnomaly = nil
            self.reactiveAnomaly = nil
        }
    }
}

public struct DescribeAnomalyOutputResponse: Swift.Equatable {
    /// A ProactiveAnomaly object that represents the requested anomaly.
    public var proactiveAnomaly: DevOpsGuruClientTypes.ProactiveAnomaly?
    /// A ReactiveAnomaly object that represents the requested anomaly.
    public var reactiveAnomaly: DevOpsGuruClientTypes.ReactiveAnomaly?

    public init (
        proactiveAnomaly: DevOpsGuruClientTypes.ProactiveAnomaly? = nil,
        reactiveAnomaly: DevOpsGuruClientTypes.ReactiveAnomaly? = nil
    )
    {
        self.proactiveAnomaly = proactiveAnomaly
        self.reactiveAnomaly = reactiveAnomaly
    }
}

struct DescribeAnomalyOutputResponseBody: Swift.Equatable {
    let proactiveAnomaly: DevOpsGuruClientTypes.ProactiveAnomaly?
    let reactiveAnomaly: DevOpsGuruClientTypes.ReactiveAnomaly?
}

extension DescribeAnomalyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proactiveAnomaly = "ProactiveAnomaly"
        case reactiveAnomaly = "ReactiveAnomaly"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveAnomalyDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ProactiveAnomaly.self, forKey: .proactiveAnomaly)
        proactiveAnomaly = proactiveAnomalyDecoded
        let reactiveAnomalyDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ReactiveAnomaly.self, forKey: .reactiveAnomaly)
        reactiveAnomaly = reactiveAnomalyDecoded
    }
}

extension DescribeFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightId = "InsightId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightId = insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
    }
}

extension DescribeFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/feedback"
    }
}

public struct DescribeFeedbackInput: Swift.Equatable {
    /// The ID of the insight for which the feedback was provided.
    public var insightId: Swift.String?

    public init (
        insightId: Swift.String? = nil
    )
    {
        self.insightId = insightId
    }
}

struct DescribeFeedbackInputBody: Swift.Equatable {
    let insightId: Swift.String?
}

extension DescribeFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightId = "InsightId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
    }
}

extension DescribeFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFeedbackOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFeedbackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.insightFeedback = output.insightFeedback
        } else {
            self.insightFeedback = nil
        }
    }
}

public struct DescribeFeedbackOutputResponse: Swift.Equatable {
    /// Information about insight feedback received from a customer.
    public var insightFeedback: DevOpsGuruClientTypes.InsightFeedback?

    public init (
        insightFeedback: DevOpsGuruClientTypes.InsightFeedback? = nil
    )
    {
        self.insightFeedback = insightFeedback
    }
}

struct DescribeFeedbackOutputResponseBody: Swift.Equatable {
    let insightFeedback: DevOpsGuruClientTypes.InsightFeedback?
}

extension DescribeFeedbackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightFeedback = "InsightFeedback"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightFeedbackDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightFeedback.self, forKey: .insightFeedback)
        insightFeedback = insightFeedbackDecoded
    }
}

extension DescribeInsightInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let accountId = accountId {
            let accountIdQueryItem = ClientRuntime.URLQueryItem(name: "AccountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            items.append(accountIdQueryItem)
        }
        return items
    }
}

extension DescribeInsightInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/insights/\(id.urlPercentEncoding())"
    }
}

public struct DescribeInsightInput: Swift.Equatable {
    /// The ID of the member account in the organization.
    public var accountId: Swift.String?
    /// The ID of the insight.
    /// This member is required.
    public var id: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.id = id
    }
}

struct DescribeInsightInputBody: Swift.Equatable {
}

extension DescribeInsightInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeInsightOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInsightOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInsightOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInsightOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInsightOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proactiveInsight = output.proactiveInsight
            self.reactiveInsight = output.reactiveInsight
        } else {
            self.proactiveInsight = nil
            self.reactiveInsight = nil
        }
    }
}

public struct DescribeInsightOutputResponse: Swift.Equatable {
    /// A ProactiveInsight object that represents the requested insight.
    public var proactiveInsight: DevOpsGuruClientTypes.ProactiveInsight?
    /// A ReactiveInsight object that represents the requested insight.
    public var reactiveInsight: DevOpsGuruClientTypes.ReactiveInsight?

    public init (
        proactiveInsight: DevOpsGuruClientTypes.ProactiveInsight? = nil,
        reactiveInsight: DevOpsGuruClientTypes.ReactiveInsight? = nil
    )
    {
        self.proactiveInsight = proactiveInsight
        self.reactiveInsight = reactiveInsight
    }
}

struct DescribeInsightOutputResponseBody: Swift.Equatable {
    let proactiveInsight: DevOpsGuruClientTypes.ProactiveInsight?
    let reactiveInsight: DevOpsGuruClientTypes.ReactiveInsight?
}

extension DescribeInsightOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proactiveInsight = "ProactiveInsight"
        case reactiveInsight = "ReactiveInsight"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ProactiveInsight.self, forKey: .proactiveInsight)
        proactiveInsight = proactiveInsightDecoded
        let reactiveInsightDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ReactiveInsight.self, forKey: .reactiveInsight)
        reactiveInsight = reactiveInsightDecoded
    }
}

extension DescribeOrganizationHealthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case organizationalUnitIds = "OrganizationalUnitIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
        if let organizationalUnitIds = organizationalUnitIds {
            var organizationalUnitIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitIds)
            for organizationalunitidlist0 in organizationalUnitIds {
                try organizationalUnitIdsContainer.encode(organizationalunitidlist0)
            }
        }
    }
}

extension DescribeOrganizationHealthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/health"
    }
}

public struct DescribeOrganizationHealthInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountIds: [Swift.String]?
    /// The ID of the organizational unit.
    public var organizationalUnitIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil,
        organizationalUnitIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
        self.organizationalUnitIds = organizationalUnitIds
    }
}

struct DescribeOrganizationHealthInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let organizationalUnitIds: [Swift.String]?
}

extension DescribeOrganizationHealthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case organizationalUnitIds = "OrganizationalUnitIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let organizationalUnitIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitIds)
        var organizationalUnitIdsDecoded0:[Swift.String]? = nil
        if let organizationalUnitIdsContainer = organizationalUnitIdsContainer {
            organizationalUnitIdsDecoded0 = [Swift.String]()
            for string0 in organizationalUnitIdsContainer {
                if let string0 = string0 {
                    organizationalUnitIdsDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitIds = organizationalUnitIdsDecoded0
    }
}

extension DescribeOrganizationHealthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationHealthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationHealthOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationHealthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOrganizationHealthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricsAnalyzed = output.metricsAnalyzed
            self.openProactiveInsights = output.openProactiveInsights
            self.openReactiveInsights = output.openReactiveInsights
            self.resourceHours = output.resourceHours
        } else {
            self.metricsAnalyzed = 0
            self.openProactiveInsights = 0
            self.openReactiveInsights = 0
            self.resourceHours = nil
        }
    }
}

public struct DescribeOrganizationHealthOutputResponse: Swift.Equatable {
    /// An integer that specifies the number of metrics that have been analyzed in your organization.
    /// This member is required.
    public var metricsAnalyzed: Swift.Int
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    /// This member is required.
    public var openProactiveInsights: Swift.Int
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    /// This member is required.
    public var openReactiveInsights: Swift.Int
    /// The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour.
    /// This member is required.
    public var resourceHours: Swift.Int?

    public init (
        metricsAnalyzed: Swift.Int = 0,
        openProactiveInsights: Swift.Int = 0,
        openReactiveInsights: Swift.Int = 0,
        resourceHours: Swift.Int? = nil
    )
    {
        self.metricsAnalyzed = metricsAnalyzed
        self.openProactiveInsights = openProactiveInsights
        self.openReactiveInsights = openReactiveInsights
        self.resourceHours = resourceHours
    }
}

struct DescribeOrganizationHealthOutputResponseBody: Swift.Equatable {
    let openReactiveInsights: Swift.Int
    let openProactiveInsights: Swift.Int
    let metricsAnalyzed: Swift.Int
    let resourceHours: Swift.Int?
}

extension DescribeOrganizationHealthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricsAnalyzed = "MetricsAnalyzed"
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
        case resourceHours = "ResourceHours"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openReactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .openReactiveInsights)
        openReactiveInsights = openReactiveInsightsDecoded
        let openProactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .openProactiveInsights)
        openProactiveInsights = openProactiveInsightsDecoded
        let metricsAnalyzedDecoded = try containerValues.decode(Swift.Int.self, forKey: .metricsAnalyzed)
        metricsAnalyzed = metricsAnalyzedDecoded
        let resourceHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resourceHours)
        resourceHours = resourceHoursDecoded
    }
}

extension DescribeOrganizationOverviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case fromTime = "FromTime"
        case organizationalUnitIds = "OrganizationalUnitIds"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
        if let fromTime = fromTime {
            try encodeContainer.encode(fromTime.timeIntervalSince1970, forKey: .fromTime)
        }
        if let organizationalUnitIds = organizationalUnitIds {
            var organizationalUnitIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitIds)
            for organizationalunitidlist0 in organizationalUnitIds {
                try organizationalUnitIdsContainer.encode(organizationalunitidlist0)
            }
        }
        if let toTime = toTime {
            try encodeContainer.encode(toTime.timeIntervalSince1970, forKey: .toTime)
        }
    }
}

extension DescribeOrganizationOverviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/overview"
    }
}

public struct DescribeOrganizationOverviewInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountIds: [Swift.String]?
    /// The start of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred after this day.
    /// This member is required.
    public var fromTime: ClientRuntime.Date?
    /// The ID of the organizational unit.
    public var organizationalUnitIds: [Swift.String]?
    /// The end of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred before this day. If this is not specified, then the current day is used.
    public var toTime: ClientRuntime.Date?

    public init (
        accountIds: [Swift.String]? = nil,
        fromTime: ClientRuntime.Date? = nil,
        organizationalUnitIds: [Swift.String]? = nil,
        toTime: ClientRuntime.Date? = nil
    )
    {
        self.accountIds = accountIds
        self.fromTime = fromTime
        self.organizationalUnitIds = organizationalUnitIds
        self.toTime = toTime
    }
}

struct DescribeOrganizationOverviewInputBody: Swift.Equatable {
    let fromTime: ClientRuntime.Date?
    let toTime: ClientRuntime.Date?
    let accountIds: [Swift.String]?
    let organizationalUnitIds: [Swift.String]?
}

extension DescribeOrganizationOverviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case fromTime = "FromTime"
        case organizationalUnitIds = "OrganizationalUnitIds"
        case toTime = "ToTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .toTime)
        toTime = toTimeDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let organizationalUnitIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitIds)
        var organizationalUnitIdsDecoded0:[Swift.String]? = nil
        if let organizationalUnitIdsContainer = organizationalUnitIdsContainer {
            organizationalUnitIdsDecoded0 = [Swift.String]()
            for string0 in organizationalUnitIdsContainer {
                if let string0 = string0 {
                    organizationalUnitIdsDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitIds = organizationalUnitIdsDecoded0
    }
}

extension DescribeOrganizationOverviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationOverviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationOverviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationOverviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOrganizationOverviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.proactiveInsights = 0
            self.reactiveInsights = 0
        }
    }
}

public struct DescribeOrganizationOverviewOutputResponse: Swift.Equatable {
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    /// This member is required.
    public var proactiveInsights: Swift.Int
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    /// This member is required.
    public var reactiveInsights: Swift.Int

    public init (
        proactiveInsights: Swift.Int = 0,
        reactiveInsights: Swift.Int = 0
    )
    {
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct DescribeOrganizationOverviewOutputResponseBody: Swift.Equatable {
    let reactiveInsights: Swift.Int
    let proactiveInsights: Swift.Int
}

extension DescribeOrganizationOverviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .reactiveInsights)
        reactiveInsights = reactiveInsightsDecoded
        let proactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .proactiveInsights)
        proactiveInsights = proactiveInsightsDecoded
    }
}

extension DescribeOrganizationResourceCollectionHealthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationResourceCollectionType = "OrganizationResourceCollectionType"
        case organizationalUnitIds = "OrganizationalUnitIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationResourceCollectionType = organizationResourceCollectionType {
            try encodeContainer.encode(organizationResourceCollectionType.rawValue, forKey: .organizationResourceCollectionType)
        }
        if let organizationalUnitIds = organizationalUnitIds {
            var organizationalUnitIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitIds)
            for organizationalunitidlist0 in organizationalUnitIds {
                try organizationalUnitIdsContainer.encode(organizationalunitidlist0)
            }
        }
    }
}

extension DescribeOrganizationResourceCollectionHealthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/health/resource-collection"
    }
}

public struct DescribeOrganizationResourceCollectionHealthInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountIds: [Swift.String]?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// An Amazon Web Services resource collection type. This type specifies how analyzed Amazon Web Services resources are defined. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    /// This member is required.
    public var organizationResourceCollectionType: DevOpsGuruClientTypes.OrganizationResourceCollectionType?
    /// The ID of the organizational unit.
    public var organizationalUnitIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationResourceCollectionType: DevOpsGuruClientTypes.OrganizationResourceCollectionType? = nil,
        organizationalUnitIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationResourceCollectionType = organizationResourceCollectionType
        self.organizationalUnitIds = organizationalUnitIds
    }
}

struct DescribeOrganizationResourceCollectionHealthInputBody: Swift.Equatable {
    let organizationResourceCollectionType: DevOpsGuruClientTypes.OrganizationResourceCollectionType?
    let accountIds: [Swift.String]?
    let organizationalUnitIds: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeOrganizationResourceCollectionHealthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationResourceCollectionType = "OrganizationResourceCollectionType"
        case organizationalUnitIds = "OrganizationalUnitIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationResourceCollectionTypeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OrganizationResourceCollectionType.self, forKey: .organizationResourceCollectionType)
        organizationResourceCollectionType = organizationResourceCollectionTypeDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let organizationalUnitIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitIds)
        var organizationalUnitIdsDecoded0:[Swift.String]? = nil
        if let organizationalUnitIdsContainer = organizationalUnitIdsContainer {
            organizationalUnitIdsDecoded0 = [Swift.String]()
            for string0 in organizationalUnitIdsContainer {
                if let string0 = string0 {
                    organizationalUnitIdsDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitIds = organizationalUnitIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeOrganizationResourceCollectionHealthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationResourceCollectionHealthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationResourceCollectionHealthOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationResourceCollectionHealthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOrganizationResourceCollectionHealthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.account = output.account
            self.cloudFormation = output.cloudFormation
            self.nextToken = output.nextToken
            self.service = output.service
        } else {
            self.account = nil
            self.cloudFormation = nil
            self.nextToken = nil
            self.service = nil
        }
    }
}

public struct DescribeOrganizationResourceCollectionHealthOutputResponse: Swift.Equatable {
    /// The name of the organization's account.
    public var account: [DevOpsGuruClientTypes.AccountHealth]?
    /// The returned CloudFormationHealthOverview object that contains an InsightHealthOverview object with the requested system health information.
    public var cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An array of ServiceHealth objects that describes the health of the Amazon Web Services services associated with the resources in the collection.
    public var service: [DevOpsGuruClientTypes.ServiceHealth]?

    public init (
        account: [DevOpsGuruClientTypes.AccountHealth]? = nil,
        cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]? = nil,
        nextToken: Swift.String? = nil,
        service: [DevOpsGuruClientTypes.ServiceHealth]? = nil
    )
    {
        self.account = account
        self.cloudFormation = cloudFormation
        self.nextToken = nextToken
        self.service = service
    }
}

struct DescribeOrganizationResourceCollectionHealthOutputResponseBody: Swift.Equatable {
    let cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]?
    let service: [DevOpsGuruClientTypes.ServiceHealth]?
    let account: [DevOpsGuruClientTypes.AccountHealth]?
    let nextToken: Swift.String?
}

extension DescribeOrganizationResourceCollectionHealthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case cloudFormation = "CloudFormation"
        case nextToken = "NextToken"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.CloudFormationHealth?].self, forKey: .cloudFormation)
        var cloudFormationDecoded0:[DevOpsGuruClientTypes.CloudFormationHealth]? = nil
        if let cloudFormationContainer = cloudFormationContainer {
            cloudFormationDecoded0 = [DevOpsGuruClientTypes.CloudFormationHealth]()
            for structure0 in cloudFormationContainer {
                if let structure0 = structure0 {
                    cloudFormationDecoded0?.append(structure0)
                }
            }
        }
        cloudFormation = cloudFormationDecoded0
        let serviceContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ServiceHealth?].self, forKey: .service)
        var serviceDecoded0:[DevOpsGuruClientTypes.ServiceHealth]? = nil
        if let serviceContainer = serviceContainer {
            serviceDecoded0 = [DevOpsGuruClientTypes.ServiceHealth]()
            for structure0 in serviceContainer {
                if let structure0 = structure0 {
                    serviceDecoded0?.append(structure0)
                }
            }
        }
        service = serviceDecoded0
        let accountContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.AccountHealth?].self, forKey: .account)
        var accountDecoded0:[DevOpsGuruClientTypes.AccountHealth]? = nil
        if let accountContainer = accountContainer {
            accountDecoded0 = [DevOpsGuruClientTypes.AccountHealth]()
            for structure0 in accountContainer {
                if let structure0 = structure0 {
                    accountDecoded0?.append(structure0)
                }
            }
        }
        account = accountDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeResourceCollectionHealthInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension DescribeResourceCollectionHealthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceCollectionType = resourceCollectionType else {
            return nil
        }
        return "/accounts/health/resource-collection/\(resourceCollectionType.rawValue.urlPercentEncoding())"
    }
}

public struct DescribeResourceCollectionHealthInput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// An Amazon Web Services resource collection type. This type specifies how analyzed Amazon Web Services resources are defined. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    /// This member is required.
    public var resourceCollectionType: DevOpsGuruClientTypes.ResourceCollectionType?

    public init (
        nextToken: Swift.String? = nil,
        resourceCollectionType: DevOpsGuruClientTypes.ResourceCollectionType? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceCollectionType = resourceCollectionType
    }
}

struct DescribeResourceCollectionHealthInputBody: Swift.Equatable {
}

extension DescribeResourceCollectionHealthInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeResourceCollectionHealthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourceCollectionHealthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResourceCollectionHealthOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourceCollectionHealthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeResourceCollectionHealthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cloudFormation = output.cloudFormation
            self.nextToken = output.nextToken
            self.service = output.service
            self.tags = output.tags
        } else {
            self.cloudFormation = nil
            self.nextToken = nil
            self.service = nil
            self.tags = nil
        }
    }
}

public struct DescribeResourceCollectionHealthOutputResponse: Swift.Equatable {
    /// The returned CloudFormationHealthOverview object that contains an InsightHealthOverview object with the requested system health information.
    public var cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An array of ServiceHealth objects that describes the health of the Amazon Web Services services associated with the resources in the collection.
    public var service: [DevOpsGuruClientTypes.ServiceHealth]?
    /// The Amazon Web Services tags that are used by resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf) whitepaper. Each Amazon Web Services tag has two parts.
    ///
    /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
    ///
    /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
    ///
    ///
    /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be Devops-guru-deployment-application or Devops-guru-rds-application. While keys are case-sensitive, the case of key characters don't matter to DevOps Guru. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
    public var tags: [DevOpsGuruClientTypes.TagHealth]?

    public init (
        cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]? = nil,
        nextToken: Swift.String? = nil,
        service: [DevOpsGuruClientTypes.ServiceHealth]? = nil,
        tags: [DevOpsGuruClientTypes.TagHealth]? = nil
    )
    {
        self.cloudFormation = cloudFormation
        self.nextToken = nextToken
        self.service = service
        self.tags = tags
    }
}

struct DescribeResourceCollectionHealthOutputResponseBody: Swift.Equatable {
    let cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]?
    let service: [DevOpsGuruClientTypes.ServiceHealth]?
    let nextToken: Swift.String?
    let tags: [DevOpsGuruClientTypes.TagHealth]?
}

extension DescribeResourceCollectionHealthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFormation = "CloudFormation"
        case nextToken = "NextToken"
        case service = "Service"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.CloudFormationHealth?].self, forKey: .cloudFormation)
        var cloudFormationDecoded0:[DevOpsGuruClientTypes.CloudFormationHealth]? = nil
        if let cloudFormationContainer = cloudFormationContainer {
            cloudFormationDecoded0 = [DevOpsGuruClientTypes.CloudFormationHealth]()
            for structure0 in cloudFormationContainer {
                if let structure0 = structure0 {
                    cloudFormationDecoded0?.append(structure0)
                }
            }
        }
        cloudFormation = cloudFormationDecoded0
        let serviceContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ServiceHealth?].self, forKey: .service)
        var serviceDecoded0:[DevOpsGuruClientTypes.ServiceHealth]? = nil
        if let serviceContainer = serviceContainer {
            serviceDecoded0 = [DevOpsGuruClientTypes.ServiceHealth]()
            for structure0 in serviceContainer {
                if let structure0 = structure0 {
                    serviceDecoded0?.append(structure0)
                }
            }
        }
        service = serviceDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.TagHealth?].self, forKey: .tags)
        var tagsDecoded0:[DevOpsGuruClientTypes.TagHealth]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DevOpsGuruClientTypes.TagHealth]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeServiceIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-integrations"
    }
}

public struct DescribeServiceIntegrationInput: Swift.Equatable {

}

struct DescribeServiceIntegrationInputBody: Swift.Equatable {
}

extension DescribeServiceIntegrationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeServiceIntegrationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServiceIntegrationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceIntegrationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceIntegrationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServiceIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceIntegration = output.serviceIntegration
        } else {
            self.serviceIntegration = nil
        }
    }
}

public struct DescribeServiceIntegrationOutputResponse: Swift.Equatable {
    /// Information about the integration of DevOps Guru with another Amazon Web Services service, such as Amazon Web Services Systems Manager.
    public var serviceIntegration: DevOpsGuruClientTypes.ServiceIntegrationConfig?

    public init (
        serviceIntegration: DevOpsGuruClientTypes.ServiceIntegrationConfig? = nil
    )
    {
        self.serviceIntegration = serviceIntegration
    }
}

struct DescribeServiceIntegrationOutputResponseBody: Swift.Equatable {
    let serviceIntegration: DevOpsGuruClientTypes.ServiceIntegrationConfig?
}

extension DescribeServiceIntegrationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceIntegration = "ServiceIntegration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIntegrationDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceIntegrationConfig.self, forKey: .serviceIntegration)
        serviceIntegration = serviceIntegrationDecoded
    }
}

extension DevOpsGuruClientTypes.EndTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromTime = fromTime {
            try encodeContainer.encode(fromTime.timeIntervalSince1970, forKey: .fromTime)
        }
        if let toTime = toTime {
            try encodeContainer.encode(toTime.timeIntervalSince1970, forKey: .toTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .toTime)
        toTime = toTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A range of time that specifies when anomalous behavior in an anomaly or insight ended.
    public struct EndTimeRange: Swift.Equatable {
        /// The earliest end time in the time range.
        public var fromTime: ClientRuntime.Date?
        /// The latest end time in the time range.
        public var toTime: ClientRuntime.Date?

        public init (
            fromTime: ClientRuntime.Date? = nil,
            toTime: ClientRuntime.Date? = nil
        )
        {
            self.fromTime = fromTime
            self.toTime = toTime
        }
    }

}

extension DevOpsGuruClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case eventClass = "EventClass"
        case eventSource = "EventSource"
        case id = "Id"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case resources = "Resources"
        case time = "Time"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let eventClass = eventClass {
            try encodeContainer.encode(eventClass.rawValue, forKey: .eventClass)
        }
        if let eventSource = eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for eventresources0 in resources {
                try resourcesContainer.encode(eventresources0)
            }
        }
        if let time = time {
            try encodeContainer.encode(time.timeIntervalSince1970, forKey: .time)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let timeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .time)
        time = timeDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventDataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let eventClassDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventClass.self, forKey: .eventClass)
        eventClass = eventClassDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.EventResource?].self, forKey: .resources)
        var resourcesDecoded0:[DevOpsGuruClientTypes.EventResource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [DevOpsGuruClientTypes.EventResource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// An Amazon Web Services resource event. Amazon Web Services resource events and metrics are analyzed by DevOps Guru to find anomalous behavior and provide recommendations to improve your operational solutions.
    public struct Event: Swift.Equatable {
        /// The source, AWS_CLOUD_TRAIL or AWS_CODE_DEPLOY, where DevOps Guru analysis found the event.
        public var dataSource: DevOpsGuruClientTypes.EventDataSource?
        /// The class of the event. The class specifies what the event is related to, such as an infrastructure change, a deployment, or a schema change.
        public var eventClass: DevOpsGuruClientTypes.EventClass?
        /// The Amazon Web Services source that emitted the event.
        public var eventSource: Swift.String?
        /// The ID of the event.
        public var id: Swift.String?
        /// The name of the event.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// An EventResource object that contains information about the resource that emitted the event.
        public var resources: [DevOpsGuruClientTypes.EventResource]?
        /// A Timestamp that specifies the time the event occurred.
        public var time: ClientRuntime.Date?

        public init (
            dataSource: DevOpsGuruClientTypes.EventDataSource? = nil,
            eventClass: DevOpsGuruClientTypes.EventClass? = nil,
            eventSource: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            resources: [DevOpsGuruClientTypes.EventResource]? = nil,
            time: ClientRuntime.Date? = nil
        )
        {
            self.dataSource = dataSource
            self.eventClass = eventClass
            self.eventSource = eventSource
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.resources = resources
            self.time = time
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum EventClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configChange
        case deployment
        case infrastructure
        case schemaChange
        case securityChange
        case sdkUnknown(Swift.String)

        public static var allCases: [EventClass] {
            return [
                .configChange,
                .deployment,
                .infrastructure,
                .schemaChange,
                .securityChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configChange: return "CONFIG_CHANGE"
            case .deployment: return "DEPLOYMENT"
            case .infrastructure: return "INFRASTRUCTURE"
            case .schemaChange: return "SCHEMA_CHANGE"
            case .securityChange: return "SECURITY_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventClass(rawValue: rawValue) ?? EventClass.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes {
    public enum EventDataSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsCloudTrail
        case awsCodeDeploy
        case sdkUnknown(Swift.String)

        public static var allCases: [EventDataSource] {
            return [
                .awsCloudTrail,
                .awsCodeDeploy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsCloudTrail: return "AWS_CLOUD_TRAIL"
            case .awsCodeDeploy: return "AWS_CODE_DEPLOY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventDataSource(rawValue: rawValue) ?? EventDataSource.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.EventResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The Amazon Web Services resource that emitted an event. Amazon Web Services resource events and metrics are analyzed by DevOps Guru to find anomalous behavior and provide recommendations to improve your operational solutions.
    public struct EventResource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource that emitted an event.
        public var arn: Swift.String?
        /// The name of the resource that emitted an event.
        public var name: Swift.String?
        /// The type of resource that emitted an event.
        public var type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes.EventTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromTime = fromTime {
            try encodeContainer.encode(fromTime.timeIntervalSince1970, forKey: .fromTime)
        }
        if let toTime = toTime {
            try encodeContainer.encode(toTime.timeIntervalSince1970, forKey: .toTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .toTime)
        toTime = toTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The time range during which an Amazon Web Services event occurred. Amazon Web Services resource events and metrics are analyzed by DevOps Guru to find anomalous behavior and provide recommendations to improve your operational solutions.
    public struct EventTimeRange: Swift.Equatable {
        /// The time when the event started.
        /// This member is required.
        public var fromTime: ClientRuntime.Date?
        /// The time when the event ended.
        /// This member is required.
        public var toTime: ClientRuntime.Date?

        public init (
            fromTime: ClientRuntime.Date? = nil,
            toTime: ClientRuntime.Date? = nil
        )
        {
            self.fromTime = fromTime
            self.toTime = toTime
        }
    }

}

extension GetCostEstimationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetCostEstimationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cost-estimation"
    }
}

public struct GetCostEstimationInput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct GetCostEstimationInputBody: Swift.Equatable {
}

extension GetCostEstimationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCostEstimationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCostEstimationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCostEstimationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCostEstimationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCostEstimationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.costs = output.costs
            self.nextToken = output.nextToken
            self.resourceCollection = output.resourceCollection
            self.status = output.status
            self.timeRange = output.timeRange
            self.totalCost = output.totalCost
        } else {
            self.costs = nil
            self.nextToken = nil
            self.resourceCollection = nil
            self.status = nil
            self.timeRange = nil
            self.totalCost = 0.0
        }
    }
}

public struct GetCostEstimationOutputResponse: Swift.Equatable {
    /// An array of ResourceCost objects that each contains details about the monthly cost estimate to analyze one of your Amazon Web Services resources.
    public var costs: [DevOpsGuruClientTypes.ServiceResourceCost]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The collection of the Amazon Web Services resources used to create your monthly DevOps Guru cost estimate.
    public var resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter?
    /// The status of creating this cost estimate. If it's still in progress, the status ONGOING is returned. If it is finished, the status COMPLETED is returned.
    public var status: DevOpsGuruClientTypes.CostEstimationStatus?
    /// The start and end time of the cost estimation.
    public var timeRange: DevOpsGuruClientTypes.CostEstimationTimeRange?
    /// The estimated monthly cost to analyze the Amazon Web Services resources. This value is the sum of the estimated costs to analyze each resource in the Costs object in this response.
    public var totalCost: Swift.Double

    public init (
        costs: [DevOpsGuruClientTypes.ServiceResourceCost]? = nil,
        nextToken: Swift.String? = nil,
        resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter? = nil,
        status: DevOpsGuruClientTypes.CostEstimationStatus? = nil,
        timeRange: DevOpsGuruClientTypes.CostEstimationTimeRange? = nil,
        totalCost: Swift.Double = 0.0
    )
    {
        self.costs = costs
        self.nextToken = nextToken
        self.resourceCollection = resourceCollection
        self.status = status
        self.timeRange = timeRange
        self.totalCost = totalCost
    }
}

struct GetCostEstimationOutputResponseBody: Swift.Equatable {
    let resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter?
    let status: DevOpsGuruClientTypes.CostEstimationStatus?
    let costs: [DevOpsGuruClientTypes.ServiceResourceCost]?
    let timeRange: DevOpsGuruClientTypes.CostEstimationTimeRange?
    let totalCost: Swift.Double
    let nextToken: Swift.String?
}

extension GetCostEstimationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costs = "Costs"
        case nextToken = "NextToken"
        case resourceCollection = "ResourceCollection"
        case status = "Status"
        case timeRange = "TimeRange"
        case totalCost = "TotalCost"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CostEstimationStatus.self, forKey: .status)
        status = statusDecoded
        let costsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ServiceResourceCost?].self, forKey: .costs)
        var costsDecoded0:[DevOpsGuruClientTypes.ServiceResourceCost]? = nil
        if let costsContainer = costsContainer {
            costsDecoded0 = [DevOpsGuruClientTypes.ServiceResourceCost]()
            for structure0 in costsContainer {
                if let structure0 = structure0 {
                    costsDecoded0?.append(structure0)
                }
            }
        }
        costs = costsDecoded0
        let timeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CostEstimationTimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
        let totalCostDecoded = try containerValues.decode(Swift.Double.self, forKey: .totalCost)
        totalCost = totalCostDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceCollectionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetResourceCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceCollectionType = resourceCollectionType else {
            return nil
        }
        return "/resource-collections/\(resourceCollectionType.rawValue.urlPercentEncoding())"
    }
}

public struct GetResourceCollectionInput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The type of Amazon Web Services resource collections to return. The one valid value is CLOUD_FORMATION for Amazon Web Services CloudFormation stacks.
    /// This member is required.
    public var resourceCollectionType: DevOpsGuruClientTypes.ResourceCollectionType?

    public init (
        nextToken: Swift.String? = nil,
        resourceCollectionType: DevOpsGuruClientTypes.ResourceCollectionType? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceCollectionType = resourceCollectionType
    }
}

struct GetResourceCollectionInputBody: Swift.Equatable {
}

extension GetResourceCollectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceCollectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceCollectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceCollection = output.resourceCollection
        } else {
            self.nextToken = nil
            self.resourceCollection = nil
        }
    }
}

public struct GetResourceCollectionOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The requested list of Amazon Web Services resource collections. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    public var resourceCollection: DevOpsGuruClientTypes.ResourceCollectionFilter?

    public init (
        nextToken: Swift.String? = nil,
        resourceCollection: DevOpsGuruClientTypes.ResourceCollectionFilter? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceCollection = resourceCollection
    }
}

struct GetResourceCollectionOutputResponseBody: Swift.Equatable {
    let resourceCollection: DevOpsGuruClientTypes.ResourceCollectionFilter?
    let nextToken: Swift.String?
}

extension GetResourceCollectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceCollection = "ResourceCollection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollectionFilter.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DevOpsGuruClientTypes.InsightFeedback: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case feedback = "Feedback"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let feedback = feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightFeedbackOption.self, forKey: .feedback)
        feedback = feedbackDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about insight feedback received from a customer.
    public struct InsightFeedback: Swift.Equatable {
        /// The feedback provided by the customer.
        public var feedback: DevOpsGuruClientTypes.InsightFeedbackOption?
        /// The insight feedback ID.
        public var id: Swift.String?

        public init (
            feedback: DevOpsGuruClientTypes.InsightFeedbackOption? = nil,
            id: Swift.String? = nil
        )
        {
            self.feedback = feedback
            self.id = id
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum InsightFeedbackOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alertTooSensitive
        case dataIncorrect
        case dataNoisyAnomaly
        case recommendationUseful
        case validCollection
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightFeedbackOption] {
            return [
                .alertTooSensitive,
                .dataIncorrect,
                .dataNoisyAnomaly,
                .recommendationUseful,
                .validCollection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alertTooSensitive: return "ALERT_TOO_SENSITIVE"
            case .dataIncorrect: return "DATA_INCORRECT"
            case .dataNoisyAnomaly: return "DATA_NOISY_ANOMALY"
            case .recommendationUseful: return "RECOMMENDATION_USEFUL"
            case .validCollection: return "VALID_COLLECTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightFeedbackOption(rawValue: rawValue) ?? InsightFeedbackOption.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.InsightHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meanTimeToRecoverInMilliseconds = "MeanTimeToRecoverInMilliseconds"
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds {
            try encodeContainer.encode(meanTimeToRecoverInMilliseconds, forKey: .meanTimeToRecoverInMilliseconds)
        }
        if openProactiveInsights != 0 {
            try encodeContainer.encode(openProactiveInsights, forKey: .openProactiveInsights)
        }
        if openReactiveInsights != 0 {
            try encodeContainer.encode(openReactiveInsights, forKey: .openReactiveInsights)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openProactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .openProactiveInsights)
        openProactiveInsights = openProactiveInsightsDecoded
        let openReactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .openReactiveInsights)
        openReactiveInsights = openReactiveInsightsDecoded
        let meanTimeToRecoverInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .meanTimeToRecoverInMilliseconds)
        meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMillisecondsDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the number of open reactive and proactive insights that can be used to gauge the health of your system.
    public struct InsightHealth: Swift.Equatable {
        /// The Meant Time to Recover (MTTR) for the insight.
        public var meanTimeToRecoverInMilliseconds: Swift.Int?
        /// The number of open proactive insights.
        public var openProactiveInsights: Swift.Int
        /// The number of open reactive insights.
        public var openReactiveInsights: Swift.Int

        public init (
            meanTimeToRecoverInMilliseconds: Swift.Int? = nil,
            openProactiveInsights: Swift.Int = 0,
            openReactiveInsights: Swift.Int = 0
        )
        {
            self.meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum InsightSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightSeverity] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightSeverity(rawValue: rawValue) ?? InsightSeverity.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes {
    public enum InsightStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case ongoing
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightStatus] {
            return [
                .closed,
                .ongoing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .ongoing: return "ONGOING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightStatus(rawValue: rawValue) ?? InsightStatus.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.InsightTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A time ranged that specifies when the observed behavior in an insight started and ended.
    public struct InsightTimeRange: Swift.Equatable {
        /// The time when the behavior described in an insight ended.
        public var endTime: ClientRuntime.Date?
        /// The time when the behavior described in an insight started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum InsightType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case proactive
        case reactive
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightType] {
            return [
                .proactive,
                .reactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .proactive: return "PROACTIVE"
            case .reactive: return "REACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightType(rawValue: rawValue) ?? InsightType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal failure in an Amazon service occurred.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The number of seconds after which the action that caused the internal server exception can be retried.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAnomaliesForInsightInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeRange = startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
    }
}

extension ListAnomaliesForInsightInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let insightId = insightId else {
            return nil
        }
        return "/anomalies/insight/\(insightId.urlPercentEncoding())"
    }
}

public struct ListAnomaliesForInsightInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountId: Swift.String?
    /// The ID of the insight. The returned anomalies belong to this insight.
    /// This member is required.
    public var insightId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// A time range used to specify when the requested anomalies started. All returned anomalies started during this time range.
    public var startTimeRange: DevOpsGuruClientTypes.StartTimeRange?

    public init (
        accountId: Swift.String? = nil,
        insightId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeRange: DevOpsGuruClientTypes.StartTimeRange? = nil
    )
    {
        self.accountId = accountId
        self.insightId = insightId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeRange = startTimeRange
    }
}

struct ListAnomaliesForInsightInputBody: Swift.Equatable {
    let startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountId: Swift.String?
}

extension ListAnomaliesForInsightInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.StartTimeRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ListAnomaliesForInsightOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnomaliesForInsightOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnomaliesForInsightOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnomaliesForInsightOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAnomaliesForInsightOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proactiveAnomalies = output.proactiveAnomalies
            self.reactiveAnomalies = output.reactiveAnomalies
        } else {
            self.nextToken = nil
            self.proactiveAnomalies = nil
            self.reactiveAnomalies = nil
        }
    }
}

public struct ListAnomaliesForInsightOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An array of ProactiveAnomalySummary objects that represent the requested anomalies
    public var proactiveAnomalies: [DevOpsGuruClientTypes.ProactiveAnomalySummary]?
    /// An array of ReactiveAnomalySummary objects that represent the requested anomalies
    public var reactiveAnomalies: [DevOpsGuruClientTypes.ReactiveAnomalySummary]?

    public init (
        nextToken: Swift.String? = nil,
        proactiveAnomalies: [DevOpsGuruClientTypes.ProactiveAnomalySummary]? = nil,
        reactiveAnomalies: [DevOpsGuruClientTypes.ReactiveAnomalySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveAnomalies = proactiveAnomalies
        self.reactiveAnomalies = reactiveAnomalies
    }
}

struct ListAnomaliesForInsightOutputResponseBody: Swift.Equatable {
    let proactiveAnomalies: [DevOpsGuruClientTypes.ProactiveAnomalySummary]?
    let reactiveAnomalies: [DevOpsGuruClientTypes.ReactiveAnomalySummary]?
    let nextToken: Swift.String?
}

extension ListAnomaliesForInsightOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proactiveAnomalies = "ProactiveAnomalies"
        case reactiveAnomalies = "ReactiveAnomalies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveAnomaliesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ProactiveAnomalySummary?].self, forKey: .proactiveAnomalies)
        var proactiveAnomaliesDecoded0:[DevOpsGuruClientTypes.ProactiveAnomalySummary]? = nil
        if let proactiveAnomaliesContainer = proactiveAnomaliesContainer {
            proactiveAnomaliesDecoded0 = [DevOpsGuruClientTypes.ProactiveAnomalySummary]()
            for structure0 in proactiveAnomaliesContainer {
                if let structure0 = structure0 {
                    proactiveAnomaliesDecoded0?.append(structure0)
                }
            }
        }
        proactiveAnomalies = proactiveAnomaliesDecoded0
        let reactiveAnomaliesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ReactiveAnomalySummary?].self, forKey: .reactiveAnomalies)
        var reactiveAnomaliesDecoded0:[DevOpsGuruClientTypes.ReactiveAnomalySummary]? = nil
        if let reactiveAnomaliesContainer = reactiveAnomaliesContainer {
            reactiveAnomaliesDecoded0 = [DevOpsGuruClientTypes.ReactiveAnomalySummary]()
            for structure0 in reactiveAnomaliesContainer {
                if let structure0 = structure0 {
                    reactiveAnomaliesDecoded0?.append(structure0)
                }
            }
        }
        reactiveAnomalies = reactiveAnomaliesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DevOpsGuruClientTypes.ListEventsFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case eventClass = "EventClass"
        case eventSource = "EventSource"
        case eventTimeRange = "EventTimeRange"
        case insightId = "InsightId"
        case resourceCollection = "ResourceCollection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let eventClass = eventClass {
            try encodeContainer.encode(eventClass.rawValue, forKey: .eventClass)
        }
        if let eventSource = eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let eventTimeRange = eventTimeRange {
            try encodeContainer.encode(eventTimeRange, forKey: .eventTimeRange)
        }
        if let insightId = insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let eventTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventTimeRange.self, forKey: .eventTimeRange)
        eventTimeRange = eventTimeRangeDecoded
        let eventClassDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventClass.self, forKey: .eventClass)
        eventClass = eventClassDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventDataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Filters you can use to specify which events are returned when ListEvents is called.
    public struct ListEventsFilters: Swift.Equatable {
        /// The source, AWS_CLOUD_TRAIL or AWS_CODE_DEPLOY, of the events you want returned.
        public var dataSource: DevOpsGuruClientTypes.EventDataSource?
        /// The class of the events you want to filter for, such as an infrastructure change, a deployment, or a schema change.
        public var eventClass: DevOpsGuruClientTypes.EventClass?
        /// The Amazon Web Services source that emitted the events you want to filter for.
        public var eventSource: Swift.String?
        /// A time range during which you want the filtered events to have occurred.
        public var eventTimeRange: DevOpsGuruClientTypes.EventTimeRange?
        /// An ID of an insight that is related to the events you want to filter for.
        public var insightId: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?

        public init (
            dataSource: DevOpsGuruClientTypes.EventDataSource? = nil,
            eventClass: DevOpsGuruClientTypes.EventClass? = nil,
            eventSource: Swift.String? = nil,
            eventTimeRange: DevOpsGuruClientTypes.EventTimeRange? = nil,
            insightId: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil
        )
        {
            self.dataSource = dataSource
            self.eventClass = eventClass
            self.eventSource = eventSource
            self.eventTimeRange = eventTimeRange
            self.insightId = insightId
            self.resourceCollection = resourceCollection
        }
    }

}

extension ListEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/events"
    }
}

public struct ListEventsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountId: Swift.String?
    /// A ListEventsFilters object used to specify which events to return.
    /// This member is required.
    public var filters: DevOpsGuruClientTypes.ListEventsFilters?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        filters: DevOpsGuruClientTypes.ListEventsFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventsInputBody: Swift.Equatable {
    let filters: DevOpsGuruClientTypes.ListEventsFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountId: Swift.String?
}

extension ListEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListEventsFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ListEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventsOutputResponse: Swift.Equatable {
    /// A list of the requested events.
    /// This member is required.
    public var events: [DevOpsGuruClientTypes.Event]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        events: [DevOpsGuruClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct ListEventsOutputResponseBody: Swift.Equatable {
    let events: [DevOpsGuruClientTypes.Event]?
    let nextToken: Swift.String?
}

extension ListEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[DevOpsGuruClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [DevOpsGuruClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DevOpsGuruClientTypes.ListInsightsAnyStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startTimeRange = startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightType.self, forKey: .type)
        type = typeDecoded
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.StartTimeRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Used to filter for insights that have any status.
    public struct ListInsightsAnyStatusFilter: Swift.Equatable {
        /// A time range used to specify when the behavior of the filtered insights started.
        /// This member is required.
        public var startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
        /// Use to filter for either REACTIVE or PROACTIVE insights.
        /// This member is required.
        public var type: DevOpsGuruClientTypes.InsightType?

        public init (
            startTimeRange: DevOpsGuruClientTypes.StartTimeRange? = nil,
            type: DevOpsGuruClientTypes.InsightType? = nil
        )
        {
            self.startTimeRange = startTimeRange
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes.ListInsightsClosedStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTimeRange = "EndTimeRange"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimeRange = endTimeRange {
            try encodeContainer.encode(endTimeRange, forKey: .endTimeRange)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightType.self, forKey: .type)
        type = typeDecoded
        let endTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EndTimeRange.self, forKey: .endTimeRange)
        endTimeRange = endTimeRangeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Used to filter for insights that have the status CLOSED.
    public struct ListInsightsClosedStatusFilter: Swift.Equatable {
        /// A time range used to specify when the behavior of the filtered insights ended.
        /// This member is required.
        public var endTimeRange: DevOpsGuruClientTypes.EndTimeRange?
        /// Use to filter for either REACTIVE or PROACTIVE insights.
        /// This member is required.
        public var type: DevOpsGuruClientTypes.InsightType?

        public init (
            endTimeRange: DevOpsGuruClientTypes.EndTimeRange? = nil,
            type: DevOpsGuruClientTypes.InsightType? = nil
        )
        {
            self.endTimeRange = endTimeRange
            self.type = type
        }
    }

}

extension ListInsightsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case statusFilter = "StatusFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let statusFilter = statusFilter {
            try encodeContainer.encode(statusFilter, forKey: .statusFilter)
        }
    }
}

extension ListInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights"
    }
}

public struct ListInsightsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// A filter used to filter the returned insights by their status. You can specify one status filter.
    /// This member is required.
    public var statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.statusFilter = statusFilter
    }
}

struct ListInsightsInputBody: Swift.Equatable {
    let statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListInsightsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case statusFilter = "StatusFilter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusFilterDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListInsightsStatusFilter.self, forKey: .statusFilter)
        statusFilter = statusFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Used to filter for insights that have the status ONGOING.
    public struct ListInsightsOngoingStatusFilter: Swift.Equatable {
        /// Use to filter for either REACTIVE or PROACTIVE insights.
        /// This member is required.
        public var type: DevOpsGuruClientTypes.InsightType?

        public init (
            type: DevOpsGuruClientTypes.InsightType? = nil
        )
        {
            self.type = type
        }
    }

}

extension ListInsightsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInsightsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInsightsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInsightsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInsightsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.nextToken = nil
            self.proactiveInsights = nil
            self.reactiveInsights = nil
        }
    }
}

public struct ListInsightsOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The returned list of proactive insights.
    public var proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    /// The returned list of reactive insights.
    public var reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?

    public init (
        nextToken: Swift.String? = nil,
        proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil,
        reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct ListInsightsOutputResponseBody: Swift.Equatable {
    let proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    let reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?
    let nextToken: Swift.String?
}

extension ListInsightsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ProactiveInsightSummary?].self, forKey: .proactiveInsights)
        var proactiveInsightsDecoded0:[DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil
        if let proactiveInsightsContainer = proactiveInsightsContainer {
            proactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ProactiveInsightSummary]()
            for structure0 in proactiveInsightsContainer {
                if let structure0 = structure0 {
                    proactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        proactiveInsights = proactiveInsightsDecoded0
        let reactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ReactiveInsightSummary?].self, forKey: .reactiveInsights)
        var reactiveInsightsDecoded0:[DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
        if let reactiveInsightsContainer = reactiveInsightsContainer {
            reactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ReactiveInsightSummary]()
            for structure0 in reactiveInsightsContainer {
                if let structure0 = structure0 {
                    reactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        reactiveInsights = reactiveInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DevOpsGuruClientTypes.ListInsightsStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case any = "Any"
        case closed = "Closed"
        case ongoing = "Ongoing"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let any = any {
            try encodeContainer.encode(any, forKey: .any)
        }
        if let closed = closed {
            try encodeContainer.encode(closed, forKey: .closed)
        }
        if let ongoing = ongoing {
            try encodeContainer.encode(ongoing, forKey: .ongoing)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ongoingDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter.self, forKey: .ongoing)
        ongoing = ongoingDecoded
        let closedDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListInsightsClosedStatusFilter.self, forKey: .closed)
        closed = closedDecoded
        let anyDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListInsightsAnyStatusFilter.self, forKey: .any)
        any = anyDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A filter used by ListInsights to specify which insights to return.
    public struct ListInsightsStatusFilter: Swift.Equatable {
        /// A ListInsightsAnyStatusFilter that specifies insights of any status that are either REACTIVE or PROACTIVE.
        public var any: DevOpsGuruClientTypes.ListInsightsAnyStatusFilter?
        /// A ListInsightsClosedStatusFilter that specifies closed insights that are either REACTIVE or PROACTIVE.
        public var closed: DevOpsGuruClientTypes.ListInsightsClosedStatusFilter?
        /// A ListInsightsAnyStatusFilter that specifies ongoing insights that are either REACTIVE or PROACTIVE.
        public var ongoing: DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter?

        public init (
            any: DevOpsGuruClientTypes.ListInsightsAnyStatusFilter? = nil,
            closed: DevOpsGuruClientTypes.ListInsightsClosedStatusFilter? = nil,
            ongoing: DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter? = nil
        )
        {
            self.any = any
            self.closed = closed
            self.ongoing = ongoing
        }
    }

}

extension ListNotificationChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListNotificationChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListNotificationChannelsInput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListNotificationChannelsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListNotificationChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNotificationChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNotificationChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNotificationChannelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNotificationChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNotificationChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListNotificationChannelsOutputResponse: Swift.Equatable {
    /// An array that contains the requested notification channels.
    public var channels: [DevOpsGuruClientTypes.NotificationChannel]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        channels: [DevOpsGuruClientTypes.NotificationChannel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListNotificationChannelsOutputResponseBody: Swift.Equatable {
    let channels: [DevOpsGuruClientTypes.NotificationChannel]?
    let nextToken: Swift.String?
}

extension ListNotificationChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.NotificationChannel?].self, forKey: .channels)
        var channelsDecoded0:[DevOpsGuruClientTypes.NotificationChannel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [DevOpsGuruClientTypes.NotificationChannel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrganizationInsightsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationalUnitIds = "OrganizationalUnitIds"
        case statusFilter = "StatusFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for listinsightsaccountidlist0 in accountIds {
                try accountIdsContainer.encode(listinsightsaccountidlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationalUnitIds = organizationalUnitIds {
            var organizationalUnitIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitIds)
            for listinsightsorganizationalunitidlist0 in organizationalUnitIds {
                try organizationalUnitIdsContainer.encode(listinsightsorganizationalunitidlist0)
            }
        }
        if let statusFilter = statusFilter {
            try encodeContainer.encode(statusFilter, forKey: .statusFilter)
        }
    }
}

extension ListOrganizationInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/insights"
    }
}

public struct ListOrganizationInsightsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountIds: [Swift.String]?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The ID of the organizational unit.
    public var organizationalUnitIds: [Swift.String]?
    /// A filter used by ListInsights to specify which insights to return.
    /// This member is required.
    public var statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter?

    public init (
        accountIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationalUnitIds: [Swift.String]? = nil,
        statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter? = nil
    )
    {
        self.accountIds = accountIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationalUnitIds = organizationalUnitIds
        self.statusFilter = statusFilter
    }
}

struct ListOrganizationInsightsInputBody: Swift.Equatable {
    let statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter?
    let maxResults: Swift.Int?
    let accountIds: [Swift.String]?
    let organizationalUnitIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListOrganizationInsightsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationalUnitIds = "OrganizationalUnitIds"
        case statusFilter = "StatusFilter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusFilterDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListInsightsStatusFilter.self, forKey: .statusFilter)
        statusFilter = statusFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let organizationalUnitIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitIds)
        var organizationalUnitIdsDecoded0:[Swift.String]? = nil
        if let organizationalUnitIdsContainer = organizationalUnitIdsContainer {
            organizationalUnitIdsDecoded0 = [Swift.String]()
            for string0 in organizationalUnitIdsContainer {
                if let string0 = string0 {
                    organizationalUnitIdsDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitIds = organizationalUnitIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrganizationInsightsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationInsightsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOrganizationInsightsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationInsightsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOrganizationInsightsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.nextToken = nil
            self.proactiveInsights = nil
            self.reactiveInsights = nil
        }
    }
}

public struct ListOrganizationInsightsOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    public var proactiveInsights: [DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary]?
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    public var reactiveInsights: [DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary]?

    public init (
        nextToken: Swift.String? = nil,
        proactiveInsights: [DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary]? = nil,
        reactiveInsights: [DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct ListOrganizationInsightsOutputResponseBody: Swift.Equatable {
    let proactiveInsights: [DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary]?
    let reactiveInsights: [DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary]?
    let nextToken: Swift.String?
}

extension ListOrganizationInsightsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary?].self, forKey: .proactiveInsights)
        var proactiveInsightsDecoded0:[DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary]? = nil
        if let proactiveInsightsContainer = proactiveInsightsContainer {
            proactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary]()
            for structure0 in proactiveInsightsContainer {
                if let structure0 = structure0 {
                    proactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        proactiveInsights = proactiveInsightsDecoded0
        let reactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary?].self, forKey: .reactiveInsights)
        var reactiveInsightsDecoded0:[DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary]? = nil
        if let reactiveInsightsContainer = reactiveInsightsContainer {
            reactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary]()
            for structure0 in reactiveInsightsContainer {
                if let structure0 = structure0 {
                    reactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        reactiveInsights = reactiveInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case insightId = "InsightId"
        case locale = "Locale"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let insightId = insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/recommendations"
    }
}

public struct ListRecommendationsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountId: Swift.String?
    /// The ID of the requested insight.
    /// This member is required.
    public var insightId: Swift.String?
    /// A locale that specifies the language to use for recommendations.
    public var locale: DevOpsGuruClientTypes.Locale?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        insightId: Swift.String? = nil,
        locale: DevOpsGuruClientTypes.Locale? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.insightId = insightId
        self.locale = locale
        self.nextToken = nextToken
    }
}

struct ListRecommendationsInputBody: Swift.Equatable {
    let insightId: Swift.String?
    let nextToken: Swift.String?
    let locale: DevOpsGuruClientTypes.Locale?
    let accountId: Swift.String?
}

extension ListRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case insightId = "InsightId"
        case locale = "Locale"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let localeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ListRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommendations = output.recommendations
        } else {
            self.nextToken = nil
            self.recommendations = nil
        }
    }
}

public struct ListRecommendationsOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An array of the requested recommendations.
    public var recommendations: [DevOpsGuruClientTypes.Recommendation]?

    public init (
        nextToken: Swift.String? = nil,
        recommendations: [DevOpsGuruClientTypes.Recommendation]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendations = recommendations
    }
}

struct ListRecommendationsOutputResponseBody: Swift.Equatable {
    let recommendations: [DevOpsGuruClientTypes.Recommendation]?
    let nextToken: Swift.String?
}

extension ListRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recommendations = "Recommendations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.Recommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[DevOpsGuruClientTypes.Recommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [DevOpsGuruClientTypes.Recommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DevOpsGuruClientTypes {
    public enum Locale: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enGb
        case enUs
        case esEs
        case frFr
        case itIt
        case jaJp
        case koKr
        case ptBr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [Locale] {
            return [
                .deDe,
                .enGb,
                .enUs,
                .esEs,
                .frFr,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .zhCn,
                .zhTw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "DE_DE"
            case .enGb: return "EN_GB"
            case .enUs: return "EN_US"
            case .esEs: return "ES_ES"
            case .frFr: return "FR_FR"
            case .itIt: return "IT_IT"
            case .jaJp: return "JA_JP"
            case .koKr: return "KO_KR"
            case .ptBr: return "PT_BR"
            case .zhCn: return "ZH_CN"
            case .zhTw: return "ZH_TW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Locale(rawValue: rawValue) ?? Locale.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.NotificationChannel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            try encodeContainer.encode(config, forKey: .config)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let configDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.NotificationChannelConfig.self, forKey: .config)
        config = configDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a notification channel. A notification channel is used to notify you when DevOps Guru creates an insight. The one supported notification channel is Amazon Simple Notification Service (Amazon SNS). If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission to it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account. For more information, see [Permissions for cross account Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-required-permissions.html). If you use an Amazon SNS topic that is encrypted by an Amazon Web Services Key Management Service customer-managed key (CMK), then you must add permissions to the CMK. For more information, see [Permissions for Amazon Web Services KMSencrypted Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-kms-permissions.html).
    public struct NotificationChannel: Swift.Equatable {
        /// A NotificationChannelConfig object that contains information about configured notification channels.
        public var config: DevOpsGuruClientTypes.NotificationChannelConfig?
        /// The ID of a notification channel.
        public var id: Swift.String?

        public init (
            config: DevOpsGuruClientTypes.NotificationChannelConfig? = nil,
            id: Swift.String? = nil
        )
        {
            self.config = config
            self.id = id
        }
    }

}

extension DevOpsGuruClientTypes.NotificationChannelConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sns = "Sns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sns = sns {
            try encodeContainer.encode(sns, forKey: .sns)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.SnsChannelConfig.self, forKey: .sns)
        sns = snsDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about notification channels you have configured with DevOps Guru. The one supported notification channel is Amazon Simple Notification Service (Amazon SNS).
    public struct NotificationChannelConfig: Swift.Equatable {
        /// Information about a notification channel configured in DevOps Guru to send notifications when insights are created. If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission to it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account. For more information, see [Permissions for cross account Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-required-permissions.html). If you use an Amazon SNS topic that is encrypted by an Amazon Web Services Key Management Service customer-managed key (CMK), then you must add permissions to the CMK. For more information, see [Permissions for Amazon Web Services KMSencrypted Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-kms-permissions.html).
        /// This member is required.
        public var sns: DevOpsGuruClientTypes.SnsChannelConfig?

        public init (
            sns: DevOpsGuruClientTypes.SnsChannelConfig? = nil
        )
        {
            self.sns = sns
        }
    }

}

extension DevOpsGuruClientTypes.OpsCenterIntegration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optInStatus = optInStatus {
            try encodeContainer.encode(optInStatus.rawValue, forKey: .optInStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optInStatusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OptInStatus.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager OpsCenter for each created insight.
    public struct OpsCenterIntegration: Swift.Equatable {
        /// Specifies if DevOps Guru is enabled to create an Amazon Web Services Systems Manager OpsItem for each created insight.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?

        public init (
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil
        )
        {
            self.optInStatus = optInStatus
        }
    }

}

extension DevOpsGuruClientTypes.OpsCenterIntegrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optInStatus = optInStatus {
            try encodeContainer.encode(optInStatus.rawValue, forKey: .optInStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optInStatusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OptInStatus.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager OpsCenter for each created insight.
    public struct OpsCenterIntegrationConfig: Swift.Equatable {
        /// Specifies if DevOps Guru is enabled to create an Amazon Web Services Systems Manager OpsItem for each created insight.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?

        public init (
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil
        )
        {
            self.optInStatus = optInStatus
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Specifies if DevOps Guru is enabled to create an Amazon Web Services Systems Manager OpsItem for each created insight.
    public enum OptInStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OptInStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptInStatus(rawValue: rawValue) ?? OptInStatus.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes {
    public enum OrganizationResourceCollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsAccount
        case awsCloudFormation
        case awsService
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationResourceCollectionType] {
            return [
                .awsAccount,
                .awsCloudFormation,
                .awsService,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsAccount: return "AWS_ACCOUNT"
            case .awsCloudFormation: return "AWS_CLOUD_FORMATION"
            case .awsService: return "AWS_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrganizationResourceCollectionType(rawValue: rawValue) ?? OrganizationResourceCollectionType.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case group = "Group"
        case limit = "Limit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for performanceinsightsmetricdimensions0 in dimensions {
                try dimensionsContainer.encode(performanceinsightsmetricdimensions0)
            }
        }
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0:[Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String]()
            for string0 in dimensionsContainer {
                if let string0 = string0 {
                    dimensionsDecoded0?.append(string0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A logical grouping of Performance Insights metrics for a related subject area. For example, the db.sql dimension group consists of the following dimensions: db.sql.id, db.sql.db_id, db.sql.statement, and db.sql.tokenized_id. Each response element returns a maximum of 500 bytes. For larger elements, such as SQL statements, only the first 500 bytes are returned. Amazon RDS Performance Insights enables you to monitor and explore different dimensions of database load based on data captured from a running DB instance. DB load is measured as average active sessions. Performance Insights provides the data to API consumers as a two-dimensional time-series dataset. The time dimension provides DB load data for each time point in the queried time range. Each time point decomposes overall load in relation to the requested dimensions, measured at that time point. Examples include SQL, Wait event, User, and Host.
    ///
    /// * To learn more about Performance Insights and Amazon Aurora DB instances, go to the [ Amazon Aurora User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights.html).
    ///
    /// * To learn more about Performance Insights and Amazon RDS DB instances, go to the [ Amazon RDS User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html).
    public struct PerformanceInsightsMetricDimensionGroup: Swift.Equatable {
        /// A list of specific dimensions from a dimension group. If this parameter is not present, then it signifies that all of the dimensions in the group were requested or are present in the response. Valid values for elements in the Dimensions array are:
        ///
        /// * db.application.name - The name of the application that is connected to the database (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.host.id - The host ID of the connected client (all engines)
        ///
        /// * db.host.name - The host name of the connected client (all engines)
        ///
        /// * db.name - The name of the database to which the client is connected (only Aurora PostgreSQL, Amazon RDS PostgreSQL, Aurora MySQL, Amazon RDS MySQL, and MariaDB)
        ///
        /// * db.session_type.name - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.sql.id - The SQL ID generated by Performance Insights (all engines)
        ///
        /// * db.sql.db_id - The SQL ID generated by the database (all engines)
        ///
        /// * db.sql.statement - The SQL text that is being executed (all engines)
        ///
        /// * db.sql.tokenized_id
        ///
        /// * db.sql_tokenized.id - The SQL digest ID generated by Performance Insights (all engines)
        ///
        /// * db.sql_tokenized.db_id - SQL digest ID generated by the database (all engines)
        ///
        /// * db.sql_tokenized.statement - The SQL digest text (all engines)
        ///
        /// * db.user.id - The ID of the user logged in to the database (all engines)
        ///
        /// * db.user.name - The name of the user logged in to the database (all engines)
        ///
        /// * db.wait_event.name - The event for which the backend is waiting (all engines)
        ///
        /// * db.wait_event.type - The type of event for which the backend is waiting (all engines)
        ///
        /// * db.wait_event_type.name - The name of the event type for which the backend is waiting (all engines)
        public var dimensions: [Swift.String]?
        /// The name of the dimension group. Its valid values are:
        ///
        /// * db - The name of the database to which the client is connected (only Aurora PostgreSQL, Amazon RDS PostgreSQL, Aurora MySQL, Amazon RDS MySQL, and MariaDB)
        ///
        /// * db.application - The name of the application that is connected to the database (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.host - The host name of the connected client (all engines)
        ///
        /// * db.session_type - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.sql - The SQL that is currently executing (all engines)
        ///
        /// * db.sql_tokenized - The SQL digest (all engines)
        ///
        /// * db.wait_event - The event for which the database backend is waiting (all engines)
        ///
        /// * db.wait_event_type - The type of event for which the database backend is waiting (all engines)
        ///
        /// * db.user - The user logged in to the database (all engines)
        public var group: Swift.String?
        /// The maximum number of items to fetch for this dimension group.
        public var limit: Swift.Int?

        public init (
            dimensions: [Swift.String]? = nil,
            group: Swift.String? = nil,
            limit: Swift.Int? = nil
        )
        {
            self.dimensions = dimensions
            self.group = group
            self.limit = limit
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsMetricQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case groupBy = "GroupBy"
        case metric = "Metric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, performanceinsightsmetricfiltermap0) in filter {
                try filterContainer.encode(performanceinsightsmetricfiltermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let groupBy = groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:Swift.String]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:Swift.String]()
            for (key0, performanceinsightsmetricfiltervalue0) in filterContainer {
                if let performanceinsightsmetricfiltervalue0 = performanceinsightsmetricfiltervalue0 {
                    filterDecoded0?[key0] = performanceinsightsmetricfiltervalue0
                }
            }
        }
        filter = filterDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A single query to be processed. Use these parameters to query the Performance Insights GetResourceMetrics API to retrieve the metrics for an anomaly. For more information, see [GetResourceMetrics](https://docs.aws.amazon.com/performance-insights/latest/APIReference/API_GetResourceMetrics.html) in the Amazon RDS Performance Insights API Reference. Amazon RDS Performance Insights enables you to monitor and explore different dimensions of database load based on data captured from a running DB instance. DB load is measured as average active sessions. Performance Insights provides the data to API consumers as a two-dimensional time-series dataset. The time dimension provides DB load data for each time point in the queried time range. Each time point decomposes overall load in relation to the requested dimensions, measured at that time point. Examples include SQL, Wait event, User, and Host.
    ///
    /// * To learn more about Performance Insights and Amazon Aurora DB instances, go to the [ Amazon Aurora User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights.html).
    ///
    /// * To learn more about Performance Insights and Amazon RDS DB instances, go to the [ Amazon RDS User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html).
    public struct PerformanceInsightsMetricQuery: Swift.Equatable {
        /// One or more filters to apply to a Performance Insights GetResourceMetrics API query. Restrictions:
        ///
        /// * Any number of filters by the same dimension, as specified in the GroupBy parameter.
        ///
        /// * A single filter for any other dimension in this dimension group.
        public var filter: [Swift.String:Swift.String]?
        /// The specification for how to aggregate the data points from a Performance Insights GetResourceMetrics API query. The Performance Insights query returns all of the dimensions within that group, unless you provide the names of specific dimensions within that group. You can also request that Performance Insights return a limited number of values for a dimension.
        public var groupBy: DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup?
        /// The name of the meteric used used when querying an Performance Insights GetResourceMetrics API for anomaly metrics. Valid values for Metric are:
        ///
        /// * db.load.avg - a scaled representation of the number of active sessions for the database engine.
        ///
        /// * db.sampledload.avg - the raw number of active sessions for the database engine.
        ///
        ///
        /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
        public var metric: Swift.String?

        public init (
            filter: [Swift.String:Swift.String]? = nil,
            groupBy: DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup? = nil,
            metric: Swift.String? = nil
        )
        {
            self.filter = filter
            self.groupBy = groupBy
            self.metric = metric
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDisplayName = "MetricDisplayName"
        case metricQuery = "MetricQuery"
        case referenceData = "ReferenceData"
        case statsAtAnomaly = "StatsAtAnomaly"
        case statsAtBaseline = "StatsAtBaseline"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDisplayName = metricDisplayName {
            try encodeContainer.encode(metricDisplayName, forKey: .metricDisplayName)
        }
        if let metricQuery = metricQuery {
            try encodeContainer.encode(metricQuery, forKey: .metricQuery)
        }
        if let referenceData = referenceData {
            var referenceDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceData)
            for performanceinsightsreferencedatalist0 in referenceData {
                try referenceDataContainer.encode(performanceinsightsreferencedatalist0)
            }
        }
        if let statsAtAnomaly = statsAtAnomaly {
            var statsAtAnomalyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statsAtAnomaly)
            for performanceinsightsstats0 in statsAtAnomaly {
                try statsAtAnomalyContainer.encode(performanceinsightsstats0)
            }
        }
        if let statsAtBaseline = statsAtBaseline {
            var statsAtBaselineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statsAtBaseline)
            for performanceinsightsstats0 in statsAtBaseline {
                try statsAtBaselineContainer.encode(performanceinsightsstats0)
            }
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricDisplayName)
        metricDisplayName = metricDisplayNameDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let metricQueryDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PerformanceInsightsMetricQuery.self, forKey: .metricQuery)
        metricQuery = metricQueryDecoded
        let referenceDataContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.PerformanceInsightsReferenceData?].self, forKey: .referenceData)
        var referenceDataDecoded0:[DevOpsGuruClientTypes.PerformanceInsightsReferenceData]? = nil
        if let referenceDataContainer = referenceDataContainer {
            referenceDataDecoded0 = [DevOpsGuruClientTypes.PerformanceInsightsReferenceData]()
            for structure0 in referenceDataContainer {
                if let structure0 = structure0 {
                    referenceDataDecoded0?.append(structure0)
                }
            }
        }
        referenceData = referenceDataDecoded0
        let statsAtAnomalyContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.PerformanceInsightsStat?].self, forKey: .statsAtAnomaly)
        var statsAtAnomalyDecoded0:[DevOpsGuruClientTypes.PerformanceInsightsStat]? = nil
        if let statsAtAnomalyContainer = statsAtAnomalyContainer {
            statsAtAnomalyDecoded0 = [DevOpsGuruClientTypes.PerformanceInsightsStat]()
            for structure0 in statsAtAnomalyContainer {
                if let structure0 = structure0 {
                    statsAtAnomalyDecoded0?.append(structure0)
                }
            }
        }
        statsAtAnomaly = statsAtAnomalyDecoded0
        let statsAtBaselineContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.PerformanceInsightsStat?].self, forKey: .statsAtBaseline)
        var statsAtBaselineDecoded0:[DevOpsGuruClientTypes.PerformanceInsightsStat]? = nil
        if let statsAtBaselineContainer = statsAtBaselineContainer {
            statsAtBaselineDecoded0 = [DevOpsGuruClientTypes.PerformanceInsightsStat]()
            for structure0 in statsAtBaselineContainer {
                if let structure0 = structure0 {
                    statsAtBaselineDecoded0?.append(structure0)
                }
            }
        }
        statsAtBaseline = statsAtBaselineDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Details about Performance Insights metrics. Amazon RDS Performance Insights enables you to monitor and explore different dimensions of database load based on data captured from a running DB instance. DB load is measured as average active sessions. Performance Insights provides the data to API consumers as a two-dimensional time-series dataset. The time dimension provides DB load data for each time point in the queried time range. Each time point decomposes overall load in relation to the requested dimensions, measured at that time point. Examples include SQL, Wait event, User, and Host.
    ///
    /// * To learn more about Performance Insights and Amazon Aurora DB instances, go to the [ Amazon Aurora User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights.html).
    ///
    /// * To learn more about Performance Insights and Amazon RDS DB instances, go to the [ Amazon RDS User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html).
    public struct PerformanceInsightsMetricsDetail: Swift.Equatable {
        /// The name used for a specific Performance Insights metric.
        public var metricDisplayName: Swift.String?
        /// A single query to be processed for the metric. For more information, see [PerformanceInsightsMetricQuery](https://docs.aws.amazon.com/devops-guru/latest/APIReference/API_PerformanceInsightsMetricQuery.html).
        public var metricQuery: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery?
        /// For more information, see [PerformanceInsightsReferenceData](https://docs.aws.amazon.com/devops-guru/latest/APIReference/API_PerformanceInsightsReferenceData.html).
        public var referenceData: [DevOpsGuruClientTypes.PerformanceInsightsReferenceData]?
        /// The metric statistics during the anomalous period detected by DevOps Guru;
        public var statsAtAnomaly: [DevOpsGuruClientTypes.PerformanceInsightsStat]?
        /// Typical metric statistics that are not considered anomalous. When DevOps Guru analyzes metrics, it compares them to StatsAtBaseline to help determine if they are anomalous.
        public var statsAtBaseline: [DevOpsGuruClientTypes.PerformanceInsightsStat]?
        /// The unit of measure for a metric. For example, a session or a process.
        public var unit: Swift.String?

        public init (
            metricDisplayName: Swift.String? = nil,
            metricQuery: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery? = nil,
            referenceData: [DevOpsGuruClientTypes.PerformanceInsightsReferenceData]? = nil,
            statsAtAnomaly: [DevOpsGuruClientTypes.PerformanceInsightsStat]? = nil,
            statsAtBaseline: [DevOpsGuruClientTypes.PerformanceInsightsStat]? = nil,
            unit: Swift.String? = nil
        )
        {
            self.metricDisplayName = metricDisplayName
            self.metricQuery = metricQuery
            self.referenceData = referenceData
            self.statsAtAnomaly = statsAtAnomaly
            self.statsAtBaseline = statsAtBaseline
            self.unit = unit
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case referenceMetric = "ReferenceMetric"
        case referenceScalar = "ReferenceScalar"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceMetric = referenceMetric {
            try encodeContainer.encode(referenceMetric, forKey: .referenceMetric)
        }
        if let referenceScalar = referenceScalar {
            try encodeContainer.encode(referenceScalar, forKey: .referenceScalar)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceScalarDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar.self, forKey: .referenceScalar)
        referenceScalar = referenceScalarDecoded
        let referenceMetricDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric.self, forKey: .referenceMetric)
        referenceMetric = referenceMetricDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Reference scalar values and other metrics that DevOps Guru displays on a graph in its console along with the actual metrics it analyzed. Compare these reference values to your actual metrics to help you understand anomalous behavior that DevOps Guru detected.
    public struct PerformanceInsightsReferenceComparisonValues: Swift.Equatable {
        /// A metric that DevOps Guru compares to actual metric values. This reference metric is used to determine if an actual metric should be considered anomalous.
        public var referenceMetric: DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric?
        /// A scalar value DevOps Guru for a metric that DevOps Guru compares to actual metric values. This reference value is used to determine if an actual metric value should be considered anomalous.
        public var referenceScalar: DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar?

        public init (
            referenceMetric: DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric? = nil,
            referenceScalar: DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar? = nil
        )
        {
            self.referenceMetric = referenceMetric
            self.referenceScalar = referenceScalar
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsReferenceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonValues = "ComparisonValues"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonValues = comparisonValues {
            try encodeContainer.encode(comparisonValues, forKey: .comparisonValues)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let comparisonValuesDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues.self, forKey: .comparisonValues)
        comparisonValues = comparisonValuesDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Reference data used to evaluate Performance Insights to determine if its performance is anomalous or not.
    public struct PerformanceInsightsReferenceData: Swift.Equatable {
        /// The specific reference values used to evaluate the Performance Insights. For more information, see [PerformanceInsightsReferenceComparisonValues](https://docs.aws.amazon.com/devops-guru/latest/APIReference/API_PerformanceInsightsReferenceComparisonValues.html).
        public var comparisonValues: DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues?
        /// The name of the reference data.
        public var name: Swift.String?

        public init (
            comparisonValues: DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues? = nil,
            name: Swift.String? = nil
        )
        {
            self.comparisonValues = comparisonValues
            self.name = name
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricQuery = "MetricQuery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricQuery = metricQuery {
            try encodeContainer.encode(metricQuery, forKey: .metricQuery)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricQueryDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PerformanceInsightsMetricQuery.self, forKey: .metricQuery)
        metricQuery = metricQueryDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a reference metric used to evaluate Performance Insights.
    public struct PerformanceInsightsReferenceMetric: Swift.Equatable {
        /// A query to be processed on the metric.
        public var metricQuery: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery?

        public init (
            metricQuery: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery? = nil
        )
        {
            self.metricQuery = metricQuery
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A reference value to compare Performance Insights metrics against to determine if the metrics demonstrate anomalous behavior.
    public struct PerformanceInsightsReferenceScalar: Swift.Equatable {
        /// The reference value.
        public var value: Swift.Double?

        public init (
            value: Swift.Double? = nil
        )
        {
            self.value = value
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsStat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A statistic in a Performance Insights collection.
    public struct PerformanceInsightsStat: Swift.Equatable {
        /// The statistic type.
        public var type: Swift.String?
        /// The value of the statistic.
        public var value: Swift.Double?

        public init (
            type: Swift.String? = nil,
            value: Swift.Double? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension DevOpsGuruClientTypes.PredictionTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
    public struct PredictionTimeRange: Swift.Equatable {
        /// The time when the behavior in a proactive insight is expected to end.
        public var endTime: ClientRuntime.Date?
        /// The time range during which a metric limit is expected to be exceeded. This applies to proactive insights only.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension DevOpsGuruClientTypes.ProactiveAnomaly: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyReportedTimeRange = "AnomalyReportedTimeRange"
        case anomalyTimeRange = "AnomalyTimeRange"
        case associatedInsightId = "AssociatedInsightId"
        case id = "Id"
        case limit = "Limit"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case sourceDetails = "SourceDetails"
        case status = "Status"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyReportedTimeRange = anomalyReportedTimeRange {
            try encodeContainer.encode(anomalyReportedTimeRange, forKey: .anomalyReportedTimeRange)
        }
        if let anomalyTimeRange = anomalyTimeRange {
            try encodeContainer.encode(anomalyTimeRange, forKey: .anomalyTimeRange)
        }
        if let associatedInsightId = associatedInsightId {
            try encodeContainer.encode(associatedInsightId, forKey: .associatedInsightId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let predictionTimeRange = predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let sourceDetails = sourceDetails {
            try encodeContainer.encode(sourceDetails, forKey: .sourceDetails)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyStatus.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let anomalyTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyTimeRange.self, forKey: .anomalyTimeRange)
        anomalyTimeRange = anomalyTimeRangeDecoded
        let anomalyReportedTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyReportedTimeRange.self, forKey: .anomalyReportedTimeRange)
        anomalyReportedTimeRange = anomalyReportedTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let sourceDetailsDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySourceDetails.self, forKey: .sourceDetails)
        sourceDetails = sourceDetailsDecoded
        let associatedInsightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedInsightId)
        associatedInsightId = associatedInsightIdDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an anomaly. This object is returned by ListAnomalies.
    public struct ProactiveAnomaly: Swift.Equatable {
        /// An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        public var anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange?
        /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
        public var anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange?
        /// The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public var associatedInsightId: Swift.String?
        /// The ID of a proactive anomaly.
        public var id: Swift.String?
        /// A threshold that was exceeded by behavior in analyzed resources. Exceeding this threshold is related to the anomalous behavior that generated this anomaly.
        public var limit: Swift.Double?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate an insight determine that insight's severity. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.AnomalySeverity?
        /// Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public var sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails?
        /// The status of a proactive anomaly.
        public var status: DevOpsGuruClientTypes.AnomalyStatus?
        /// The time of the anomaly's most recent update.
        public var updateTime: ClientRuntime.Date?

        public init (
            anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange? = nil,
            anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange? = nil,
            associatedInsightId: Swift.String? = nil,
            id: Swift.String? = nil,
            limit: Swift.Double? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.AnomalySeverity? = nil,
            sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails? = nil,
            status: DevOpsGuruClientTypes.AnomalyStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.id = id
            self.limit = limit
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension DevOpsGuruClientTypes.ProactiveAnomalySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyReportedTimeRange = "AnomalyReportedTimeRange"
        case anomalyTimeRange = "AnomalyTimeRange"
        case associatedInsightId = "AssociatedInsightId"
        case id = "Id"
        case limit = "Limit"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case sourceDetails = "SourceDetails"
        case status = "Status"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyReportedTimeRange = anomalyReportedTimeRange {
            try encodeContainer.encode(anomalyReportedTimeRange, forKey: .anomalyReportedTimeRange)
        }
        if let anomalyTimeRange = anomalyTimeRange {
            try encodeContainer.encode(anomalyTimeRange, forKey: .anomalyTimeRange)
        }
        if let associatedInsightId = associatedInsightId {
            try encodeContainer.encode(associatedInsightId, forKey: .associatedInsightId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let predictionTimeRange = predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let sourceDetails = sourceDetails {
            try encodeContainer.encode(sourceDetails, forKey: .sourceDetails)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyStatus.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let anomalyTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyTimeRange.self, forKey: .anomalyTimeRange)
        anomalyTimeRange = anomalyTimeRangeDecoded
        let anomalyReportedTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyReportedTimeRange.self, forKey: .anomalyReportedTimeRange)
        anomalyReportedTimeRange = anomalyReportedTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let sourceDetailsDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySourceDetails.self, forKey: .sourceDetails)
        sourceDetails = sourceDetailsDecoded
        let associatedInsightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedInsightId)
        associatedInsightId = associatedInsightIdDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a proactive anomaly. This object is returned by DescribeAnomaly.
    public struct ProactiveAnomalySummary: Swift.Equatable {
        /// An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        public var anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange?
        /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
        public var anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange?
        /// The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public var associatedInsightId: Swift.String?
        /// The ID of the anomaly.
        public var id: Swift.String?
        /// A threshold that was exceeded by behavior in analyzed resources. Exceeding this threshold is related to the anomalous behavior that generated this anomaly.
        public var limit: Swift.Double?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate an insight determine that insight's severity. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.AnomalySeverity?
        /// Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public var sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails?
        /// The status of the anomaly.
        public var status: DevOpsGuruClientTypes.AnomalyStatus?
        /// The time of the anomaly's most recent update.
        public var updateTime: ClientRuntime.Date?

        public init (
            anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange? = nil,
            anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange? = nil,
            associatedInsightId: Swift.String? = nil,
            id: Swift.String? = nil,
            limit: Swift.Double? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.AnomalySeverity? = nil,
            sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails? = nil,
            status: DevOpsGuruClientTypes.AnomalyStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.id = id
            self.limit = limit
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension DevOpsGuruClientTypes.ProactiveInsight: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case ssmOpsItemId = "SsmOpsItemId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predictionTimeRange = predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let ssmOpsItemId = ssmOpsItemId {
            try encodeContainer.encode(ssmOpsItemId, forKey: .ssmOpsItemId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let ssmOpsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmOpsItemId)
        ssmOpsItemId = ssmOpsItemIdDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a proactive insight. This object is returned by ListInsights.
    public struct ProactiveInsight: Swift.Equatable {
        /// The ID of the proactive insight.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of the proactive insight.
        public var name: Swift.String?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the insight. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// The ID of the Amazon Web Services System Manager OpsItem created for this insight. You must enable the creation of OpstItems insights before they are created for each insight.
        public var ssmOpsItemId: Swift.String?
        /// The status of the proactive insight.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init (
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            ssmOpsItemId: Swift.String? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.ssmOpsItemId = ssmOpsItemId
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes.ProactiveInsightSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceArns = "AssociatedResourceArns"
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severity = "Severity"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedResourceArns = associatedResourceArns {
            var associatedResourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedResourceArns)
            for associatedresourcearns0 in associatedResourceArns {
                try associatedResourceArnsContainer.encode(associatedresourcearns0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predictionTimeRange = predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
        let associatedResourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedResourceArns)
        var associatedResourceArnsDecoded0:[Swift.String]? = nil
        if let associatedResourceArnsContainer = associatedResourceArnsContainer {
            associatedResourceArnsDecoded0 = [Swift.String]()
            for string0 in associatedResourceArnsContainer {
                if let string0 = string0 {
                    associatedResourceArnsDecoded0?.append(string0)
                }
            }
        }
        associatedResourceArns = associatedResourceArnsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a proactive insight. This object is returned by DescribeInsight.
    public struct ProactiveInsightSummary: Swift.Equatable {
        /// The Amazon Resource Names (ARNs) of the Amazon Web Services resources that generated this insight.
        public var associatedResourceArns: [Swift.String]?
        /// The ID of the proactive insight.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of the proactive insight.
        public var name: Swift.String?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// The severity of the insight. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// The status of the proactive insight.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init (
            associatedResourceArns: [Swift.String]? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.associatedResourceArns = associatedResourceArns
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case organizationalUnitId = "OrganizationalUnitId"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severity = "Severity"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationalUnitId = organizationalUnitId {
            try encodeContainer.encode(organizationalUnitId, forKey: .organizationalUnitId)
        }
        if let predictionTimeRange = predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationalUnitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitId)
        organizationalUnitId = organizationalUnitIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a proactive insight. This object is returned by DescribeInsight.
    public struct ProactiveOrganizationInsightSummary: Swift.Equatable {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ID of the insight summary.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of the insight summary.
        public var name: Swift.String?
        /// The ID of the organizational unit.
        public var organizationalUnitId: Swift.String?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// An array of severity values used to search for insights. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// An array of status values used to search for insights.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init (
            accountId: Swift.String? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            organizationalUnitId: Swift.String? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.accountId = accountId
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.organizationalUnitId = organizationalUnitId
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }
    }

}

extension PutFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightFeedback = "InsightFeedback"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightFeedback = insightFeedback {
            try encodeContainer.encode(insightFeedback, forKey: .insightFeedback)
        }
    }
}

extension PutFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/feedback"
    }
}

public struct PutFeedbackInput: Swift.Equatable {
    /// The feedback from customers is about the recommendations in this insight.
    public var insightFeedback: DevOpsGuruClientTypes.InsightFeedback?

    public init (
        insightFeedback: DevOpsGuruClientTypes.InsightFeedback? = nil
    )
    {
        self.insightFeedback = insightFeedback
    }
}

struct PutFeedbackInputBody: Swift.Equatable {
    let insightFeedback: DevOpsGuruClientTypes.InsightFeedback?
}

extension PutFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightFeedback = "InsightFeedback"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightFeedbackDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightFeedback.self, forKey: .insightFeedback)
        insightFeedback = insightFeedbackDecoded
    }
}

extension PutFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFeedbackOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutFeedbackOutputResponse: Swift.Equatable {

}

extension DevOpsGuruClientTypes.ReactiveAnomaly: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyReportedTimeRange = "AnomalyReportedTimeRange"
        case anomalyResources = "AnomalyResources"
        case anomalyTimeRange = "AnomalyTimeRange"
        case associatedInsightId = "AssociatedInsightId"
        case causalAnomalyId = "CausalAnomalyId"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case sourceDetails = "SourceDetails"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyReportedTimeRange = anomalyReportedTimeRange {
            try encodeContainer.encode(anomalyReportedTimeRange, forKey: .anomalyReportedTimeRange)
        }
        if let anomalyResources = anomalyResources {
            var anomalyResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .anomalyResources)
            for anomalyresources0 in anomalyResources {
                try anomalyResourcesContainer.encode(anomalyresources0)
            }
        }
        if let anomalyTimeRange = anomalyTimeRange {
            try encodeContainer.encode(anomalyTimeRange, forKey: .anomalyTimeRange)
        }
        if let associatedInsightId = associatedInsightId {
            try encodeContainer.encode(associatedInsightId, forKey: .associatedInsightId)
        }
        if let causalAnomalyId = causalAnomalyId {
            try encodeContainer.encode(causalAnomalyId, forKey: .causalAnomalyId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let sourceDetails = sourceDetails {
            try encodeContainer.encode(sourceDetails, forKey: .sourceDetails)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyStatus.self, forKey: .status)
        status = statusDecoded
        let anomalyTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyTimeRange.self, forKey: .anomalyTimeRange)
        anomalyTimeRange = anomalyTimeRangeDecoded
        let anomalyReportedTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyReportedTimeRange.self, forKey: .anomalyReportedTimeRange)
        anomalyReportedTimeRange = anomalyReportedTimeRangeDecoded
        let sourceDetailsDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySourceDetails.self, forKey: .sourceDetails)
        sourceDetails = sourceDetailsDecoded
        let associatedInsightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedInsightId)
        associatedInsightId = associatedInsightIdDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let causalAnomalyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .causalAnomalyId)
        causalAnomalyId = causalAnomalyIdDecoded
        let anomalyResourcesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.AnomalyResource?].self, forKey: .anomalyResources)
        var anomalyResourcesDecoded0:[DevOpsGuruClientTypes.AnomalyResource]? = nil
        if let anomalyResourcesContainer = anomalyResourcesContainer {
            anomalyResourcesDecoded0 = [DevOpsGuruClientTypes.AnomalyResource]()
            for structure0 in anomalyResourcesContainer {
                if let structure0 = structure0 {
                    anomalyResourcesDecoded0?.append(structure0)
                }
            }
        }
        anomalyResources = anomalyResourcesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a reactive anomaly. This object is returned by ListAnomalies.
    public struct ReactiveAnomaly: Swift.Equatable {
        /// An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        public var anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange?
        /// The Amazon Web Services resources in which anomalous behavior was detected by DevOps Guru.
        public var anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]?
        /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
        public var anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange?
        /// The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public var associatedInsightId: Swift.String?
        /// The ID of the causal anomaly that is associated with this reactive anomaly. The ID of a `CAUSAL` anomaly is always `NULL`.
        public var causalAnomalyId: Swift.String?
        /// A description of the reactive anomaly.
        public var description: Swift.String?
        /// The ID of the reactive anomaly.
        public var id: Swift.String?
        /// The name of the reactive anomaly.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate an insight determine that insight's severity. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.AnomalySeverity?
        /// Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public var sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails?
        /// The status of the anomaly.
        public var status: DevOpsGuruClientTypes.AnomalyStatus?
        /// The type of the reactive anomaly. It can be one of the following types.
        ///
        /// * CAUSAL - the anomaly can cause a new insight.
        ///
        /// * CONTEXTUAL - the anomaly contains additional information about an insight or its causal anomaly.
        public var type: DevOpsGuruClientTypes.AnomalyType?

        public init (
            anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange? = nil,
            anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]? = nil,
            anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange? = nil,
            associatedInsightId: Swift.String? = nil,
            causalAnomalyId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.AnomalySeverity? = nil,
            sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails? = nil,
            status: DevOpsGuruClientTypes.AnomalyStatus? = nil,
            type: DevOpsGuruClientTypes.AnomalyType? = nil
        )
        {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.causalAnomalyId = causalAnomalyId
            self.description = description
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes.ReactiveAnomalySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyReportedTimeRange = "AnomalyReportedTimeRange"
        case anomalyResources = "AnomalyResources"
        case anomalyTimeRange = "AnomalyTimeRange"
        case associatedInsightId = "AssociatedInsightId"
        case causalAnomalyId = "CausalAnomalyId"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case sourceDetails = "SourceDetails"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyReportedTimeRange = anomalyReportedTimeRange {
            try encodeContainer.encode(anomalyReportedTimeRange, forKey: .anomalyReportedTimeRange)
        }
        if let anomalyResources = anomalyResources {
            var anomalyResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .anomalyResources)
            for anomalyresources0 in anomalyResources {
                try anomalyResourcesContainer.encode(anomalyresources0)
            }
        }
        if let anomalyTimeRange = anomalyTimeRange {
            try encodeContainer.encode(anomalyTimeRange, forKey: .anomalyTimeRange)
        }
        if let associatedInsightId = associatedInsightId {
            try encodeContainer.encode(associatedInsightId, forKey: .associatedInsightId)
        }
        if let causalAnomalyId = causalAnomalyId {
            try encodeContainer.encode(causalAnomalyId, forKey: .causalAnomalyId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let sourceDetails = sourceDetails {
            try encodeContainer.encode(sourceDetails, forKey: .sourceDetails)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyStatus.self, forKey: .status)
        status = statusDecoded
        let anomalyTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyTimeRange.self, forKey: .anomalyTimeRange)
        anomalyTimeRange = anomalyTimeRangeDecoded
        let anomalyReportedTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyReportedTimeRange.self, forKey: .anomalyReportedTimeRange)
        anomalyReportedTimeRange = anomalyReportedTimeRangeDecoded
        let sourceDetailsDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySourceDetails.self, forKey: .sourceDetails)
        sourceDetails = sourceDetailsDecoded
        let associatedInsightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedInsightId)
        associatedInsightId = associatedInsightIdDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let causalAnomalyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .causalAnomalyId)
        causalAnomalyId = causalAnomalyIdDecoded
        let anomalyResourcesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.AnomalyResource?].self, forKey: .anomalyResources)
        var anomalyResourcesDecoded0:[DevOpsGuruClientTypes.AnomalyResource]? = nil
        if let anomalyResourcesContainer = anomalyResourcesContainer {
            anomalyResourcesDecoded0 = [DevOpsGuruClientTypes.AnomalyResource]()
            for structure0 in anomalyResourcesContainer {
                if let structure0 = structure0 {
                    anomalyResourcesDecoded0?.append(structure0)
                }
            }
        }
        anomalyResources = anomalyResourcesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a reactive anomaly. This object is returned by DescribeAnomaly.
    public struct ReactiveAnomalySummary: Swift.Equatable {
        /// An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        public var anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange?
        /// The Amazon Web Services resources in which anomalous behavior was detected by DevOps Guru.
        public var anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]?
        /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
        public var anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange?
        /// The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public var associatedInsightId: Swift.String?
        /// The ID of the causal anomaly that is associated with this reactive anomaly. The ID of a `CAUSAL` anomaly is always `NULL`.
        public var causalAnomalyId: Swift.String?
        /// A description of the reactive anomaly.
        public var description: Swift.String?
        /// The ID of the reactive anomaly.
        public var id: Swift.String?
        /// The name of the reactive anomaly.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate an insight determine that insight's severity. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.AnomalySeverity?
        /// Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public var sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails?
        /// The status of the reactive anomaly.
        public var status: DevOpsGuruClientTypes.AnomalyStatus?
        /// The type of the reactive anomaly. It can be one of the following types.
        ///
        /// * CAUSAL - the anomaly can cause a new insight.
        ///
        /// * CONTEXTUAL - the anomaly contains additional information about an insight or its causal anomaly.
        public var type: DevOpsGuruClientTypes.AnomalyType?

        public init (
            anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange? = nil,
            anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]? = nil,
            anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange? = nil,
            associatedInsightId: Swift.String? = nil,
            causalAnomalyId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.AnomalySeverity? = nil,
            sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails? = nil,
            status: DevOpsGuruClientTypes.AnomalyStatus? = nil,
            type: DevOpsGuruClientTypes.AnomalyType? = nil
        )
        {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.causalAnomalyId = causalAnomalyId
            self.description = description
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes.ReactiveInsight: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case ssmOpsItemId = "SsmOpsItemId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let ssmOpsItemId = ssmOpsItemId {
            try encodeContainer.encode(ssmOpsItemId, forKey: .ssmOpsItemId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let ssmOpsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmOpsItemId)
        ssmOpsItemId = ssmOpsItemIdDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a reactive insight. This object is returned by ListInsights.
    public struct ReactiveInsight: Swift.Equatable {
        /// The ID of a reactive insight.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of a reactive insight.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the insight. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// The ID of the Amazon Web Services System Manager OpsItem created for this insight. You must enable the creation of OpstItems insights before they are created for each insight.
        public var ssmOpsItemId: Swift.String?
        /// The status of a reactive insight.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init (
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            ssmOpsItemId: Swift.String? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.ssmOpsItemId = ssmOpsItemId
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes.ReactiveInsightSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceArns = "AssociatedResourceArns"
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severity = "Severity"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedResourceArns = associatedResourceArns {
            var associatedResourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedResourceArns)
            for associatedresourcearns0 in associatedResourceArns {
                try associatedResourceArnsContainer.encode(associatedresourcearns0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
        let associatedResourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedResourceArns)
        var associatedResourceArnsDecoded0:[Swift.String]? = nil
        if let associatedResourceArnsContainer = associatedResourceArnsContainer {
            associatedResourceArnsDecoded0 = [Swift.String]()
            for string0 in associatedResourceArnsContainer {
                if let string0 = string0 {
                    associatedResourceArnsDecoded0?.append(string0)
                }
            }
        }
        associatedResourceArns = associatedResourceArnsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a reactive insight. This object is returned by DescribeInsight.
    public struct ReactiveInsightSummary: Swift.Equatable {
        /// The Amazon Resource Names (ARNs) of the Amazon Web Services resources that generated this insight.
        public var associatedResourceArns: [Swift.String]?
        /// The ID of a reactive summary.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of a reactive insight.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// The severity of the insight. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// The status of a reactive insight.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init (
            associatedResourceArns: [Swift.String]? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.associatedResourceArns = associatedResourceArns
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case organizationalUnitId = "OrganizationalUnitId"
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severity = "Severity"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationalUnitId = organizationalUnitId {
            try encodeContainer.encode(organizationalUnitId, forKey: .organizationalUnitId)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationalUnitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitId)
        organizationalUnitId = organizationalUnitIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a reactive insight. This object is returned by DescribeInsight.
    public struct ReactiveOrganizationInsightSummary: Swift.Equatable {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ID of the insight summary.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of the insight summary.
        public var name: Swift.String?
        /// The ID of the organizational unit.
        public var organizationalUnitId: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// An array of severity values used to search for insights. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// An array of status values used to search for insights.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init (
            accountId: Swift.String? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            organizationalUnitId: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.accountId = accountId
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.organizationalUnitId = organizationalUnitId
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case link = "Link"
        case name = "Name"
        case reason = "Reason"
        case relatedAnomalies = "RelatedAnomalies"
        case relatedEvents = "RelatedEvents"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let link = link {
            try encodeContainer.encode(link, forKey: .link)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let relatedAnomalies = relatedAnomalies {
            var relatedAnomaliesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedAnomalies)
            for recommendationrelatedanomalies0 in relatedAnomalies {
                try relatedAnomaliesContainer.encode(recommendationrelatedanomalies0)
            }
        }
        if let relatedEvents = relatedEvents {
            var relatedEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedEvents)
            for recommendationrelatedevents0 in relatedEvents {
                try relatedEventsContainer.encode(recommendationrelatedevents0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let linkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .link)
        link = linkDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let relatedEventsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.RecommendationRelatedEvent?].self, forKey: .relatedEvents)
        var relatedEventsDecoded0:[DevOpsGuruClientTypes.RecommendationRelatedEvent]? = nil
        if let relatedEventsContainer = relatedEventsContainer {
            relatedEventsDecoded0 = [DevOpsGuruClientTypes.RecommendationRelatedEvent]()
            for structure0 in relatedEventsContainer {
                if let structure0 = structure0 {
                    relatedEventsDecoded0?.append(structure0)
                }
            }
        }
        relatedEvents = relatedEventsDecoded0
        let relatedAnomaliesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.RecommendationRelatedAnomaly?].self, forKey: .relatedAnomalies)
        var relatedAnomaliesDecoded0:[DevOpsGuruClientTypes.RecommendationRelatedAnomaly]? = nil
        if let relatedAnomaliesContainer = relatedAnomaliesContainer {
            relatedAnomaliesDecoded0 = [DevOpsGuruClientTypes.RecommendationRelatedAnomaly]()
            for structure0 in relatedAnomaliesContainer {
                if let structure0 = structure0 {
                    relatedAnomaliesDecoded0?.append(structure0)
                }
            }
        }
        relatedAnomalies = relatedAnomaliesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Recommendation information to help you remediate detected anomalous behavior that generated an insight.
    public struct Recommendation: Swift.Equatable {
        /// A description of the problem.
        public var description: Swift.String?
        /// A hyperlink to information to help you address the problem.
        public var link: Swift.String?
        /// The name of the recommendation.
        public var name: Swift.String?
        /// The reason DevOps Guru flagged the anomalous behavior as a problem.
        public var reason: Swift.String?
        /// Anomalies that are related to the problem. Use these Anomalies to learn more about what's happening and to help address the issue.
        public var relatedAnomalies: [DevOpsGuruClientTypes.RecommendationRelatedAnomaly]?
        /// Events that are related to the problem. Use these events to learn more about what's happening and to help address the issue.
        public var relatedEvents: [DevOpsGuruClientTypes.RecommendationRelatedEvent]?

        public init (
            description: Swift.String? = nil,
            link: Swift.String? = nil,
            name: Swift.String? = nil,
            reason: Swift.String? = nil,
            relatedAnomalies: [DevOpsGuruClientTypes.RecommendationRelatedAnomaly]? = nil,
            relatedEvents: [DevOpsGuruClientTypes.RecommendationRelatedEvent]? = nil
        )
        {
            self.description = description
            self.link = link
            self.name = name
            self.reason = reason
            self.relatedAnomalies = relatedAnomalies
            self.relatedEvents = relatedEvents
        }
    }

}

extension DevOpsGuruClientTypes.RecommendationRelatedAnomaly: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyId = "AnomalyId"
        case resources = "Resources"
        case sourceDetails = "SourceDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyId = anomalyId {
            try encodeContainer.encode(anomalyId, forKey: .anomalyId)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for recommendationrelatedanomalyresources0 in resources {
                try resourcesContainer.encode(recommendationrelatedanomalyresources0)
            }
        }
        if let sourceDetails = sourceDetails {
            var sourceDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceDetails)
            for relatedanomalysourcedetails0 in sourceDetails {
                try sourceDetailsContainer.encode(relatedanomalysourcedetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource?].self, forKey: .resources)
        var resourcesDecoded0:[DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let sourceDetailsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail?].self, forKey: .sourceDetails)
        var sourceDetailsDecoded0:[DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail]? = nil
        if let sourceDetailsContainer = sourceDetailsContainer {
            sourceDetailsDecoded0 = [DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail]()
            for structure0 in sourceDetailsContainer {
                if let structure0 = structure0 {
                    sourceDetailsDecoded0?.append(structure0)
                }
            }
        }
        sourceDetails = sourceDetailsDecoded0
        let anomalyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyId)
        anomalyId = anomalyIdDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an anomaly that is related to a recommendation.
    public struct RecommendationRelatedAnomaly: Swift.Equatable {
        /// The ID of an anomaly that generated the insight with this recommendation.
        public var anomalyId: Swift.String?
        /// An array of objects that represent resources in which DevOps Guru detected anomalous behavior. Each object contains the name and type of the resource.
        public var resources: [DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource]?
        /// Information about where the anomalous behavior related the recommendation was found. For example, details in Amazon CloudWatch metrics.
        public var sourceDetails: [DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail]?

        public init (
            anomalyId: Swift.String? = nil,
            resources: [DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource]? = nil,
            sourceDetails: [DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail]? = nil
        )
        {
            self.anomalyId = anomalyId
            self.resources = resources
            self.sourceDetails = sourceDetails
        }
    }

}

extension DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a resource in which DevOps Guru detected anomalous behavior.
    public struct RecommendationRelatedAnomalyResource: Swift.Equatable {
        /// The name of the resource.
        public var name: Swift.String?
        /// The type of the resource. Resource types take the same form that is used by Amazon Web Services CloudFormation resource type identifiers, service-provider::service-name::data-type-name. For example, AWS::RDS::DBCluster. For more information, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the Amazon Web Services CloudFormation User Guide.
        public var type: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchMetrics = "CloudWatchMetrics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchMetrics = cloudWatchMetrics {
            var cloudWatchMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchMetrics)
            for recommendationrelatedcloudwatchmetricssourcedetails0 in cloudWatchMetrics {
                try cloudWatchMetricsContainer.encode(recommendationrelatedcloudwatchmetricssourcedetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchMetricsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail?].self, forKey: .cloudWatchMetrics)
        var cloudWatchMetricsDecoded0:[DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail]? = nil
        if let cloudWatchMetricsContainer = cloudWatchMetricsContainer {
            cloudWatchMetricsDecoded0 = [DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail]()
            for structure0 in cloudWatchMetricsContainer {
                if let structure0 = structure0 {
                    cloudWatchMetricsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchMetrics = cloudWatchMetricsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Contains an array of RecommendationRelatedCloudWatchMetricsSourceDetail objects that contain the name and namespace of an Amazon CloudWatch metric.
    public struct RecommendationRelatedAnomalySourceDetail: Swift.Equatable {
        /// An array of CloudWatchMetricsDetail objects that contains information about the analyzed metrics that displayed anomalous behavior.
        public var cloudWatchMetrics: [DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail]?

        public init (
            cloudWatchMetrics: [DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail]? = nil
        )
        {
            self.cloudWatchMetrics = cloudWatchMetrics
        }
    }

}

extension DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName = "MetricName"
        case namespace = "Namespace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an Amazon CloudWatch metric that is analyzed by DevOps Guru. It is one of many analyzed metrics that are used to generate insights.
    public struct RecommendationRelatedCloudWatchMetricsSourceDetail: Swift.Equatable {
        /// The name of the CloudWatch metric.
        public var metricName: Swift.String?
        /// The namespace of the CloudWatch metric. A namespace is a container for CloudWatch metrics.
        public var namespace: Swift.String?

        public init (
            metricName: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.namespace = namespace
        }
    }

}

extension DevOpsGuruClientTypes.RecommendationRelatedEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resources = "Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for recommendationrelatedeventresources0 in resources {
                try resourcesContainer.encode(recommendationrelatedeventresources0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.RecommendationRelatedEventResource?].self, forKey: .resources)
        var resourcesDecoded0:[DevOpsGuruClientTypes.RecommendationRelatedEventResource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [DevOpsGuruClientTypes.RecommendationRelatedEventResource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an event that is related to a recommendation.
    public struct RecommendationRelatedEvent: Swift.Equatable {
        /// The name of the event. This corresponds to the Name field in an Event object.
        public var name: Swift.String?
        /// A ResourceCollection object that contains arrays of the names of Amazon Web Services CloudFormation stacks. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resources: [DevOpsGuruClientTypes.RecommendationRelatedEventResource]?

        public init (
            name: Swift.String? = nil,
            resources: [DevOpsGuruClientTypes.RecommendationRelatedEventResource]? = nil
        )
        {
            self.name = name
            self.resources = resources
        }
    }

}

extension DevOpsGuruClientTypes.RecommendationRelatedEventResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an Amazon Web Services resource that emitted and event that is related to a recommendation in an insight.
    public struct RecommendationRelatedEventResource: Swift.Equatable {
        /// The name of the resource that emitted the event. This corresponds to the Name field in an EventResource object.
        public var name: Swift.String?
        /// The type of the resource that emitted the event. This corresponds to the Type field in an EventResource object.
        public var type: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension RemoveNotificationChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())"
    }
}

public struct RemoveNotificationChannelInput: Swift.Equatable {
    /// The ID of the notification channel to be removed.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct RemoveNotificationChannelInputBody: Swift.Equatable {
}

extension RemoveNotificationChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveNotificationChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveNotificationChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveNotificationChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveNotificationChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveNotificationChannelOutputResponse: Swift.Equatable {

}

extension DevOpsGuruClientTypes.ResourceCollection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFormation = "CloudFormation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormation = cloudFormation {
            try encodeContainer.encode(cloudFormation, forKey: .cloudFormation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagcollections0 in tags {
                try tagsContainer.encode(tagcollections0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CloudFormationCollection.self, forKey: .cloudFormation)
        cloudFormation = cloudFormationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.TagCollection?].self, forKey: .tags)
        var tagsDecoded0:[DevOpsGuruClientTypes.TagCollection]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DevOpsGuruClientTypes.TagCollection]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    public struct ResourceCollection: Swift.Equatable {
        /// An array of the names of Amazon Web Services CloudFormation stacks. The stacks define Amazon Web Services resources that DevOps Guru analyzes. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var cloudFormation: DevOpsGuruClientTypes.CloudFormationCollection?
        /// The Amazon Web Services tags that are used by resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf) whitepaper. Each Amazon Web Services tag has two parts.
        ///
        /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
        ///
        /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
        ///
        ///
        /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be Devops-guru-deployment-application or Devops-guru-rds-application. While keys are case-sensitive, the case of key characters don't matter to DevOps Guru. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var tags: [DevOpsGuruClientTypes.TagCollection]?

        public init (
            cloudFormation: DevOpsGuruClientTypes.CloudFormationCollection? = nil,
            tags: [DevOpsGuruClientTypes.TagCollection]? = nil
        )
        {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }
    }

}

extension DevOpsGuruClientTypes.ResourceCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFormation = "CloudFormation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormation = cloudFormation {
            try encodeContainer.encode(cloudFormation, forKey: .cloudFormation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagcollectionfilters0 in tags {
                try tagsContainer.encode(tagcollectionfilters0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CloudFormationCollectionFilter.self, forKey: .cloudFormation)
        cloudFormation = cloudFormationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.TagCollectionFilter?].self, forKey: .tags)
        var tagsDecoded0:[DevOpsGuruClientTypes.TagCollectionFilter]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DevOpsGuruClientTypes.TagCollectionFilter]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a filter used to specify which Amazon Web Services resources are analyzed for anomalous behavior by DevOps Guru.
    public struct ResourceCollectionFilter: Swift.Equatable {
        /// Information about Amazon Web Services CloudFormation stacks. You can use up to 500 stacks to specify which Amazon Web Services resources in your account to analyze. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
        public var cloudFormation: DevOpsGuruClientTypes.CloudFormationCollectionFilter?
        /// The Amazon Web Services tags used to filter the resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf) whitepaper. Each Amazon Web Services tag has two parts.
        ///
        /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
        ///
        /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
        ///
        ///
        /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be Devops-guru-deployment-application or Devops-guru-rds-application. While keys are case-sensitive, the case of key characters don't matter to DevOps Guru. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var tags: [DevOpsGuruClientTypes.TagCollectionFilter]?

        public init (
            cloudFormation: DevOpsGuruClientTypes.CloudFormationCollectionFilter? = nil,
            tags: [DevOpsGuruClientTypes.TagCollectionFilter]? = nil
        )
        {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum ResourceCollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsCloudFormation
        case awsService
        case awsTags
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceCollectionType] {
            return [
                .awsCloudFormation,
                .awsService,
                .awsTags,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsCloudFormation: return "AWS_CLOUD_FORMATION"
            case .awsService: return "AWS_SERVICE"
            case .awsTags: return "AWS_TAGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceCollectionType(rawValue: rawValue) ?? ResourceCollectionType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A requested resource could not be found
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the Amazon Web Services resource that could not be found.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the Amazon Web Services resource that could not be found.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DevOpsGuruClientTypes.SearchInsightsFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severities = "Severities"
        case statuses = "Statuses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severities = severities {
            var severitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severities)
            for insightseverities0 in severities {
                try severitiesContainer.encode(insightseverities0.rawValue)
            }
        }
        if let statuses = statuses {
            var statusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statuses)
            for insightstatuses0 in statuses {
                try statusesContainer.encode(insightstatuses0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severitiesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.InsightSeverity?].self, forKey: .severities)
        var severitiesDecoded0:[DevOpsGuruClientTypes.InsightSeverity]? = nil
        if let severitiesContainer = severitiesContainer {
            severitiesDecoded0 = [DevOpsGuruClientTypes.InsightSeverity]()
            for string0 in severitiesContainer {
                if let string0 = string0 {
                    severitiesDecoded0?.append(string0)
                }
            }
        }
        severities = severitiesDecoded0
        let statusesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.InsightStatus?].self, forKey: .statuses)
        var statusesDecoded0:[DevOpsGuruClientTypes.InsightStatus]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [DevOpsGuruClientTypes.InsightStatus]()
            for string0 in statusesContainer {
                if let string0 = string0 {
                    statusesDecoded0?.append(string0)
                }
            }
        }
        statuses = statusesDecoded0
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Specifies one or more severity values and one or more status values that are used to search for insights.
    public struct SearchInsightsFilters: Swift.Equatable {
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// An array of severity values used to search for insights.
        public var severities: [DevOpsGuruClientTypes.InsightSeverity]?
        /// An array of status values used to search for insights.
        public var statuses: [DevOpsGuruClientTypes.InsightStatus]?

        public init (
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severities: [DevOpsGuruClientTypes.InsightSeverity]? = nil,
            statuses: [DevOpsGuruClientTypes.InsightStatus]? = nil
        )
        {
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severities = severities
            self.statuses = statuses
        }
    }

}

extension SearchInsightsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeRange = startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension SearchInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights/search"
    }
}

public struct SearchInsightsInput: Swift.Equatable {
    /// A SearchInsightsFilters object that is used to set the severity and status filters on your insight search.
    public var filters: DevOpsGuruClientTypes.SearchInsightsFilters?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The start of the time range passed in. Returned insights occurred after this time.
    /// This member is required.
    public var startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
    /// The type of insights you are searching for (REACTIVE or PROACTIVE).
    /// This member is required.
    public var type: DevOpsGuruClientTypes.InsightType?

    public init (
        filters: DevOpsGuruClientTypes.SearchInsightsFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeRange: DevOpsGuruClientTypes.StartTimeRange? = nil,
        type: DevOpsGuruClientTypes.InsightType? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeRange = startTimeRange
        self.type = type
    }
}

struct SearchInsightsInputBody: Swift.Equatable {
    let startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
    let filters: DevOpsGuruClientTypes.SearchInsightsFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let type: DevOpsGuruClientTypes.InsightType?
}

extension SearchInsightsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.StartTimeRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.SearchInsightsFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SearchInsightsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchInsightsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchInsightsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchInsightsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchInsightsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.nextToken = nil
            self.proactiveInsights = nil
            self.reactiveInsights = nil
        }
    }
}

public struct SearchInsightsOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The returned proactive insights.
    public var proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    /// The returned reactive insights.
    public var reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?

    public init (
        nextToken: Swift.String? = nil,
        proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil,
        reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct SearchInsightsOutputResponseBody: Swift.Equatable {
    let proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    let reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?
    let nextToken: Swift.String?
}

extension SearchInsightsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ProactiveInsightSummary?].self, forKey: .proactiveInsights)
        var proactiveInsightsDecoded0:[DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil
        if let proactiveInsightsContainer = proactiveInsightsContainer {
            proactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ProactiveInsightSummary]()
            for structure0 in proactiveInsightsContainer {
                if let structure0 = structure0 {
                    proactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        proactiveInsights = proactiveInsightsDecoded0
        let reactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ReactiveInsightSummary?].self, forKey: .reactiveInsights)
        var reactiveInsightsDecoded0:[DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
        if let reactiveInsightsContainer = reactiveInsightsContainer {
            reactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ReactiveInsightSummary]()
            for structure0 in reactiveInsightsContainer {
                if let structure0 = structure0 {
                    reactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        reactiveInsights = reactiveInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DevOpsGuruClientTypes.SearchOrganizationInsightsFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severities = "Severities"
        case statuses = "Statuses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severities = severities {
            var severitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severities)
            for insightseverities0 in severities {
                try severitiesContainer.encode(insightseverities0.rawValue)
            }
        }
        if let statuses = statuses {
            var statusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statuses)
            for insightstatuses0 in statuses {
                try statusesContainer.encode(insightstatuses0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severitiesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.InsightSeverity?].self, forKey: .severities)
        var severitiesDecoded0:[DevOpsGuruClientTypes.InsightSeverity]? = nil
        if let severitiesContainer = severitiesContainer {
            severitiesDecoded0 = [DevOpsGuruClientTypes.InsightSeverity]()
            for string0 in severitiesContainer {
                if let string0 = string0 {
                    severitiesDecoded0?.append(string0)
                }
            }
        }
        severities = severitiesDecoded0
        let statusesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.InsightStatus?].self, forKey: .statuses)
        var statusesDecoded0:[DevOpsGuruClientTypes.InsightStatus]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [DevOpsGuruClientTypes.InsightStatus]()
            for string0 in statusesContainer {
                if let string0 = string0 {
                    statusesDecoded0?.append(string0)
                }
            }
        }
        statuses = statusesDecoded0
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Filters you can use to specify which events are returned when ListEvents is called.
    public struct SearchOrganizationInsightsFilters: Swift.Equatable {
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// An array of severity values used to search for insights.
        public var severities: [DevOpsGuruClientTypes.InsightSeverity]?
        /// An array of status values used to search for insights.
        public var statuses: [DevOpsGuruClientTypes.InsightStatus]?

        public init (
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severities: [DevOpsGuruClientTypes.InsightSeverity]? = nil,
            statuses: [DevOpsGuruClientTypes.InsightStatus]? = nil
        )
        {
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severities = severities
            self.statuses = statuses
        }
    }

}

extension SearchOrganizationInsightsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for searchinsightsaccountidlist0 in accountIds {
                try accountIdsContainer.encode(searchinsightsaccountidlist0)
            }
        }
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeRange = startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension SearchOrganizationInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/insights/search"
    }
}

public struct SearchOrganizationInsightsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// A SearchOrganizationInsightsFilters object that is used to set the severity and status filters on your insight search.
    public var filters: DevOpsGuruClientTypes.SearchOrganizationInsightsFilters?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// A time range used to specify when the behavior of an insight or anomaly started.
    /// This member is required.
    public var startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
    /// The type of insights you are searching for (REACTIVE or PROACTIVE).
    /// This member is required.
    public var type: DevOpsGuruClientTypes.InsightType?

    public init (
        accountIds: [Swift.String]? = nil,
        filters: DevOpsGuruClientTypes.SearchOrganizationInsightsFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeRange: DevOpsGuruClientTypes.StartTimeRange? = nil,
        type: DevOpsGuruClientTypes.InsightType? = nil
    )
    {
        self.accountIds = accountIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeRange = startTimeRange
        self.type = type
    }
}

struct SearchOrganizationInsightsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
    let filters: DevOpsGuruClientTypes.SearchOrganizationInsightsFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let type: DevOpsGuruClientTypes.InsightType?
}

extension SearchOrganizationInsightsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.StartTimeRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.SearchOrganizationInsightsFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SearchOrganizationInsightsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchOrganizationInsightsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchOrganizationInsightsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchOrganizationInsightsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchOrganizationInsightsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.nextToken = nil
            self.proactiveInsights = nil
            self.reactiveInsights = nil
        }
    }
}

public struct SearchOrganizationInsightsOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    public var proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    public var reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?

    public init (
        nextToken: Swift.String? = nil,
        proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil,
        reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct SearchOrganizationInsightsOutputResponseBody: Swift.Equatable {
    let proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    let reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?
    let nextToken: Swift.String?
}

extension SearchOrganizationInsightsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ProactiveInsightSummary?].self, forKey: .proactiveInsights)
        var proactiveInsightsDecoded0:[DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil
        if let proactiveInsightsContainer = proactiveInsightsContainer {
            proactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ProactiveInsightSummary]()
            for structure0 in proactiveInsightsContainer {
                if let structure0 = structure0 {
                    proactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        proactiveInsights = proactiveInsightsDecoded0
        let reactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ReactiveInsightSummary?].self, forKey: .reactiveInsights)
        var reactiveInsightsDecoded0:[DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
        if let reactiveInsightsContainer = reactiveInsightsContainer {
            reactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ReactiveInsightSummary]()
            for structure0 in reactiveInsightsContainer {
                if let structure0 = structure0 {
                    reactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        reactiveInsights = reactiveInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DevOpsGuruClientTypes.ServiceCollection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceNames = "ServiceNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceNames = serviceNames {
            var serviceNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceNames)
            for servicenames0 in serviceNames {
                try serviceNamesContainer.encode(servicenames0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNamesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ServiceName?].self, forKey: .serviceNames)
        var serviceNamesDecoded0:[DevOpsGuruClientTypes.ServiceName]? = nil
        if let serviceNamesContainer = serviceNamesContainer {
            serviceNamesDecoded0 = [DevOpsGuruClientTypes.ServiceName]()
            for string0 in serviceNamesContainer {
                if let string0 = string0 {
                    serviceNamesDecoded0?.append(string0)
                }
            }
        }
        serviceNames = serviceNamesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A collection of the names of Amazon Web Services services.
    public struct ServiceCollection: Swift.Equatable {
        /// An array of strings that each specifies the name of an Amazon Web Services service.
        public var serviceNames: [DevOpsGuruClientTypes.ServiceName]?

        public init (
            serviceNames: [DevOpsGuruClientTypes.ServiceName]? = nil
        )
        {
            self.serviceNames = serviceNames
        }
    }

}

extension DevOpsGuruClientTypes.ServiceHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insight = "Insight"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insight = insight {
            try encodeContainer.encode(insight, forKey: .insight)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let insightDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceInsightHealth.self, forKey: .insight)
        insight = insightDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Represents the health of an Amazon Web Services service.
    public struct ServiceHealth: Swift.Equatable {
        /// Represents the health of an Amazon Web Services service. This is a ServiceInsightHealth that contains the number of open proactive and reactive insights for this service.
        public var insight: DevOpsGuruClientTypes.ServiceInsightHealth?
        /// The name of the Amazon Web Services service.
        public var serviceName: DevOpsGuruClientTypes.ServiceName?

        public init (
            insight: DevOpsGuruClientTypes.ServiceInsightHealth? = nil,
            serviceName: DevOpsGuruClientTypes.ServiceName? = nil
        )
        {
            self.insight = insight
            self.serviceName = serviceName
        }
    }

}

extension DevOpsGuruClientTypes.ServiceInsightHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if openProactiveInsights != 0 {
            try encodeContainer.encode(openProactiveInsights, forKey: .openProactiveInsights)
        }
        if openReactiveInsights != 0 {
            try encodeContainer.encode(openReactiveInsights, forKey: .openReactiveInsights)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openProactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .openProactiveInsights)
        openProactiveInsights = openProactiveInsightsDecoded
        let openReactiveInsightsDecoded = try containerValues.decode(Swift.Int.self, forKey: .openReactiveInsights)
        openReactiveInsights = openReactiveInsightsDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Contains the number of open proactive and reactive insights in an analyzed Amazon Web Services service.
    public struct ServiceInsightHealth: Swift.Equatable {
        /// The number of open proactive insights in the Amazon Web Services service
        public var openProactiveInsights: Swift.Int
        /// The number of open reactive insights in the Amazon Web Services service
        public var openReactiveInsights: Swift.Int

        public init (
            openProactiveInsights: Swift.Int = 0,
            openReactiveInsights: Swift.Int = 0
        )
        {
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }
    }

}

extension DevOpsGuruClientTypes.ServiceIntegrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsCenter = "OpsCenter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsCenter = opsCenter {
            try encodeContainer.encode(opsCenter, forKey: .opsCenter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsCenterDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OpsCenterIntegration.self, forKey: .opsCenter)
        opsCenter = opsCenterDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the integration of DevOps Guru with another Amazon Web Services service, such as Amazon Web Services Systems Manager.
    public struct ServiceIntegrationConfig: Swift.Equatable {
        /// Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager OpsCenter for each created insight.
        public var opsCenter: DevOpsGuruClientTypes.OpsCenterIntegration?

        public init (
            opsCenter: DevOpsGuruClientTypes.OpsCenterIntegration? = nil
        )
        {
            self.opsCenter = opsCenter
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum ServiceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiGateway
        case applicationElb
        case autoScalingGroup
        case cloudFront
        case dynamoDb
        case ec2
        case ecs
        case eks
        case elasticBeanstalk
        case elastiCache
        case elb
        case es
        case kinesis
        case lambda
        case natGateway
        case networkElb
        case rds
        case redshift
        case route53
        case s3
        case sageMaker
        case sns
        case sqs
        case stepFunctions
        case swf
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceName] {
            return [
                .apiGateway,
                .applicationElb,
                .autoScalingGroup,
                .cloudFront,
                .dynamoDb,
                .ec2,
                .ecs,
                .eks,
                .elasticBeanstalk,
                .elastiCache,
                .elb,
                .es,
                .kinesis,
                .lambda,
                .natGateway,
                .networkElb,
                .rds,
                .redshift,
                .route53,
                .s3,
                .sageMaker,
                .sns,
                .sqs,
                .stepFunctions,
                .swf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiGateway: return "API_GATEWAY"
            case .applicationElb: return "APPLICATION_ELB"
            case .autoScalingGroup: return "AUTO_SCALING_GROUP"
            case .cloudFront: return "CLOUD_FRONT"
            case .dynamoDb: return "DYNAMO_DB"
            case .ec2: return "EC2"
            case .ecs: return "ECS"
            case .eks: return "EKS"
            case .elasticBeanstalk: return "ELASTIC_BEANSTALK"
            case .elastiCache: return "ELASTI_CACHE"
            case .elb: return "ELB"
            case .es: return "ES"
            case .kinesis: return "KINESIS"
            case .lambda: return "LAMBDA"
            case .natGateway: return "NAT_GATEWAY"
            case .networkElb: return "NETWORK_ELB"
            case .rds: return "RDS"
            case .redshift: return "REDSHIFT"
            case .route53: return "ROUTE_53"
            case .s3: return "S3"
            case .sageMaker: return "SAGE_MAKER"
            case .sns: return "SNS"
            case .sqs: return "SQS"
            case .stepFunctions: return "STEP_FUNCTIONS"
            case .swf: return "SWF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceName(rawValue: rawValue) ?? ServiceName.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request contains a value that exceeds a maximum quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DevOpsGuruClientTypes.ServiceResourceCost: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cost = "Cost"
        case count = "Count"
        case state = "State"
        case type = "Type"
        case unitCost = "UnitCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cost != 0.0 {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if unitCost != 0.0 {
            try encodeContainer.encode(unitCost, forKey: .unitCost)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CostEstimationServiceResourceState.self, forKey: .state)
        state = stateDecoded
        let countDecoded = try containerValues.decode(Swift.Int.self, forKey: .count)
        count = countDecoded
        let unitCostDecoded = try containerValues.decode(Swift.Double.self, forKey: .unitCost)
        unitCost = unitCostDecoded
        let costDecoded = try containerValues.decode(Swift.Double.self, forKey: .cost)
        cost = costDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// An object that contains information about the estimated monthly cost to analyze an Amazon Web Services resource. For more information, see [Estimate your Amazon DevOps Guru costs](https://docs.aws.amazon.com/devops-guru/latest/userguide/cost-estimate.html) and [Amazon DevOps Guru pricing](http://aws.amazon.com/devops-guru/pricing/).
    public struct ServiceResourceCost: Swift.Equatable {
        /// The total estimated monthly cost to analyze the active resources for this resource.
        public var cost: Swift.Double
        /// The number of active resources analyzed for this service to create a monthly cost estimate.
        public var count: Swift.Int
        /// The state of the resource. The resource is ACTIVE if it produces metrics, events, or logs within an hour, otherwise it is INACTIVE. You pay for the number of active Amazon Web Services resource hours analyzed for each resource. Inactive resources are not charged.
        public var state: DevOpsGuruClientTypes.CostEstimationServiceResourceState?
        /// The type of the Amazon Web Services resource.
        public var type: Swift.String?
        /// The price per hour to analyze the resources in the service. For more information, see [Estimate your Amazon DevOps Guru costs](https://docs.aws.amazon.com/devops-guru/latest/userguide/cost-estimate.html) and [Amazon DevOps Guru pricing](http://aws.amazon.com/devops-guru/pricing/).
        public var unitCost: Swift.Double

        public init (
            cost: Swift.Double = 0.0,
            count: Swift.Int = 0,
            state: DevOpsGuruClientTypes.CostEstimationServiceResourceState? = nil,
            type: Swift.String? = nil,
            unitCost: Swift.Double = 0.0
        )
        {
            self.cost = cost
            self.count = count
            self.state = state
            self.type = type
            self.unitCost = unitCost
        }
    }

}

extension DevOpsGuruClientTypes.SnsChannelConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Contains the Amazon Resource Name (ARN) of an Amazon Simple Notification Service topic. If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission to it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account. For more information, see [Permissions for cross account Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-required-permissions.html). If you use an Amazon SNS topic that is encrypted by an Amazon Web Services Key Management Service customer-managed key (CMK), then you must add permissions to the CMK. For more information, see [Permissions for Amazon Web Services KMSencrypted Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-kms-permissions.html).
    public struct SnsChannelConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon Simple Notification Service topic.
        public var topicArn: Swift.String?

        public init (
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension StartCostEstimationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case resourceCollection = "ResourceCollection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
    }
}

extension StartCostEstimationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cost-estimation"
    }
}

public struct StartCostEstimationInput: Swift.Equatable {
    /// The idempotency token used to identify each cost estimate request.
    public var clientToken: Swift.String?
    /// The collection of Amazon Web Services resources used to create a monthly DevOps Guru cost estimate.
    /// This member is required.
    public var resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter?

    public init (
        clientToken: Swift.String? = nil,
        resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceCollection = resourceCollection
    }
}

struct StartCostEstimationInputBody: Swift.Equatable {
    let resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter?
    let clientToken: Swift.String?
}

extension StartCostEstimationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case resourceCollection = "ResourceCollection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartCostEstimationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCostEstimationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartCostEstimationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCostEstimationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartCostEstimationOutputResponse: Swift.Equatable {

}

extension DevOpsGuruClientTypes.StartTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromTime = fromTime {
            try encodeContainer.encode(fromTime.timeIntervalSince1970, forKey: .fromTime)
        }
        if let toTime = toTime {
            try encodeContainer.encode(toTime.timeIntervalSince1970, forKey: .toTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .toTime)
        toTime = toTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A time range used to specify when the behavior of an insight or anomaly started.
    public struct StartTimeRange: Swift.Equatable {
        /// The start time of the time range.
        public var fromTime: ClientRuntime.Date?
        /// The end time of the time range.
        public var toTime: ClientRuntime.Date?

        public init (
            fromTime: ClientRuntime.Date? = nil,
            toTime: ClientRuntime.Date? = nil
        )
        {
            self.fromTime = fromTime
            self.toTime = toTime
        }
    }

}

extension DevOpsGuruClientTypes.TagCollection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBoundaryKey = "AppBoundaryKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBoundaryKey = appBoundaryKey {
            try encodeContainer.encode(appBoundaryKey, forKey: .appBoundaryKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvalues0 in tagValues {
                try tagValuesContainer.encode(tagvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBoundaryKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBoundaryKey)
        appBoundaryKey = appBoundaryKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A collection of Amazon Web Services stags. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf) whitepaper. Each Amazon Web Services tag has two parts.
    ///
    /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
    ///
    /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
    ///
    ///
    /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be Devops-guru-deployment-application or Devops-guru-rds-application. While keys are case-sensitive, the case of key characters don't matter to DevOps Guru. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
    public struct TagCollection: Swift.Equatable {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be Devops-guru-deployment-application or Devops-guru-rds-application. While keys are case-sensitive, the case of key characters don't matter to DevOps Guru. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        /// This member is required.
        public var appBoundaryKey: Swift.String?
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init (
            appBoundaryKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }
    }

}

extension DevOpsGuruClientTypes.TagCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBoundaryKey = "AppBoundaryKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBoundaryKey = appBoundaryKey {
            try encodeContainer.encode(appBoundaryKey, forKey: .appBoundaryKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvalues0 in tagValues {
                try tagValuesContainer.encode(tagvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBoundaryKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBoundaryKey)
        appBoundaryKey = appBoundaryKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A collection of Amazon Web Services tags used to filter insights. This is used to return insights generated from only resources that contain the tags in the tag collection.
    public struct TagCollectionFilter: Swift.Equatable {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be Devops-guru-deployment-application or Devops-guru-rds-application. While keys are case-sensitive, the case of key characters don't matter to DevOps Guru. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        /// This member is required.
        public var appBoundaryKey: Swift.String?
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init (
            appBoundaryKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }
    }

}

extension DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBoundaryKey = "AppBoundaryKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBoundaryKey = appBoundaryKey {
            try encodeContainer.encode(appBoundaryKey, forKey: .appBoundaryKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for costestimationtagvalues0 in tagValues {
                try tagValuesContainer.encode(costestimationtagvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBoundaryKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBoundaryKey)
        appBoundaryKey = appBoundaryKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a collection of Amazon Web Services resources that are identified by an Amazon Web Services tag. This collection of resources is used to create a monthly cost estimate for DevOps Guru to analyze Amazon Web Services resources. The maximum number of tags you can specify for a cost estimate is one. The estimate created is for the cost to analyze the Amazon Web Services resources defined by the tag. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
    public struct TagCostEstimationResourceCollectionFilter: Swift.Equatable {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be Devops-guru-deployment-application or Devops-guru-rds-application. While keys are case-sensitive, the case of key characters don't matter to DevOps Guru. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        /// This member is required.
        public var appBoundaryKey: Swift.String?
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init (
            appBoundaryKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }
    }

}

extension DevOpsGuruClientTypes.TagHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBoundaryKey = "AppBoundaryKey"
        case insight = "Insight"
        case tagValue = "TagValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBoundaryKey = appBoundaryKey {
            try encodeContainer.encode(appBoundaryKey, forKey: .appBoundaryKey)
        }
        if let insight = insight {
            try encodeContainer.encode(insight, forKey: .insight)
        }
        if let tagValue = tagValue {
            try encodeContainer.encode(tagValue, forKey: .tagValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBoundaryKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBoundaryKey)
        appBoundaryKey = appBoundaryKeyDecoded
        let tagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagValue)
        tagValue = tagValueDecoded
        let insightDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightHealth.self, forKey: .insight)
        insight = insightDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the health of Amazon Web Services resources in your account that are specified by an Amazon Web Services tag key.
    public struct TagHealth: Swift.Equatable {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be Devops-guru-deployment-application or Devops-guru-rds-application. While keys are case-sensitive, the case of key characters don't matter to DevOps Guru. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var appBoundaryKey: Swift.String?
        /// Information about the health of the Amazon Web Services resources in your account that are specified by an Amazon Web Services tag, including the number of open proactive, open reactive insights, and the Mean Time to Recover (MTTR) of closed insights.
        public var insight: DevOpsGuruClientTypes.InsightHealth?
        /// The value in an Amazon Web Services tag. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        public var tagValue: Swift.String?

        public init (
            appBoundaryKey: Swift.String? = nil,
            insight: DevOpsGuruClientTypes.InsightHealth? = nil,
            tagValue: Swift.String? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.insight = insight
            self.tagValue = tagValue
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to a request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The code of the quota that was exceeded, causing the throttling exception.
    public var quotaCode: Swift.String?
    /// The number of seconds after which the action that caused the throttling exception can be retried.
    public var retryAfterSeconds: Swift.Int
    /// The code of the service that caused the throttling exception.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension DevOpsGuruClientTypes.TimestampMetricValuePair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricValue = "MetricValue"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricValue = metricValue {
            try encodeContainer.encode(metricValue, forKey: .metricValue)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let metricValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .metricValue)
        metricValue = metricValueDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A pair that contains metric values at the respective timestamp.
    public struct TimestampMetricValuePair: Swift.Equatable {
        /// Value of the anomalous metric data point at respective Timestamp.
        public var metricValue: Swift.Double?
        /// A Timestamp that specifies the time the event occurred.
        public var timestamp: ClientRuntime.Date?

        public init (
            metricValue: Swift.Double? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.metricValue = metricValue
            self.timestamp = timestamp
        }
    }

}

extension DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackNames = "StackNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackNames = stackNames {
            var stackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackNames)
            for updatestacknames0 in stackNames {
                try stackNamesContainer.encode(updatestacknames0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackNames)
        var stackNamesDecoded0:[Swift.String]? = nil
        if let stackNamesContainer = stackNamesContainer {
            stackNamesDecoded0 = [Swift.String]()
            for string0 in stackNamesContainer {
                if let string0 = string0 {
                    stackNamesDecoded0?.append(string0)
                }
            }
        }
        stackNames = stackNamesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Contains the names of Amazon Web Services CloudFormation stacks used to update a collection of stacks. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    public struct UpdateCloudFormationCollectionFilter: Swift.Equatable {
        /// An array of the names of the Amazon Web Services CloudFormation stacks to update. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var stackNames: [Swift.String]?

        public init (
            stackNames: [Swift.String]? = nil
        )
        {
            self.stackNames = stackNames
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum UpdateResourceCollectionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateResourceCollectionAction] {
            return [
                .add,
                .remove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateResourceCollectionAction(rawValue: rawValue) ?? UpdateResourceCollectionAction.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.UpdateResourceCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFormation = "CloudFormation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormation = cloudFormation {
            try encodeContainer.encode(cloudFormation, forKey: .cloudFormation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for updatetagcollectionfilters0 in tags {
                try tagsContainer.encode(updatetagcollectionfilters0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter.self, forKey: .cloudFormation)
        cloudFormation = cloudFormationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.UpdateTagCollectionFilter?].self, forKey: .tags)
        var tagsDecoded0:[DevOpsGuruClientTypes.UpdateTagCollectionFilter]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DevOpsGuruClientTypes.UpdateTagCollectionFilter]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Contains information used to update a collection of Amazon Web Services resources.
    public struct UpdateResourceCollectionFilter: Swift.Equatable {
        /// A collection of Amazon Web Services CloudFormation stacks. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var cloudFormation: DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter?
        /// The updated Amazon Web Services tags used to filter the resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://d1.awsstatic.com/whitepapers/aws-tagging-best-practices.pdf) whitepaper. Each Amazon Web Services tag has two parts.
        ///
        /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
        ///
        /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
        ///
        ///
        /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be Devops-guru-deployment-application or Devops-guru-rds-application. While keys are case-sensitive, the case of key characters don't matter to DevOps Guru. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var tags: [DevOpsGuruClientTypes.UpdateTagCollectionFilter]?

        public init (
            cloudFormation: DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter? = nil,
            tags: [DevOpsGuruClientTypes.UpdateTagCollectionFilter]? = nil
        )
        {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }
    }

}

extension UpdateResourceCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case resourceCollection = "ResourceCollection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let resourceCollection = resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
    }
}

extension UpdateResourceCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resource-collections"
    }
}

public struct UpdateResourceCollectionInput: Swift.Equatable {
    /// Specifies if the resource collection in the request is added or deleted to the resource collection.
    /// This member is required.
    public var action: DevOpsGuruClientTypes.UpdateResourceCollectionAction?
    /// Contains information used to update a collection of Amazon Web Services resources.
    /// This member is required.
    public var resourceCollection: DevOpsGuruClientTypes.UpdateResourceCollectionFilter?

    public init (
        action: DevOpsGuruClientTypes.UpdateResourceCollectionAction? = nil,
        resourceCollection: DevOpsGuruClientTypes.UpdateResourceCollectionFilter? = nil
    )
    {
        self.action = action
        self.resourceCollection = resourceCollection
    }
}

struct UpdateResourceCollectionInputBody: Swift.Equatable {
    let action: DevOpsGuruClientTypes.UpdateResourceCollectionAction?
    let resourceCollection: DevOpsGuruClientTypes.UpdateResourceCollectionFilter?
}

extension UpdateResourceCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case resourceCollection = "ResourceCollection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.UpdateResourceCollectionAction.self, forKey: .action)
        action = actionDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.UpdateResourceCollectionFilter.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
    }
}

extension UpdateResourceCollectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceCollectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceCollectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceCollectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceCollectionOutputResponse: Swift.Equatable {

}

extension DevOpsGuruClientTypes.UpdateServiceIntegrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opsCenter = "OpsCenter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsCenter = opsCenter {
            try encodeContainer.encode(opsCenter, forKey: .opsCenter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsCenterDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OpsCenterIntegrationConfig.self, forKey: .opsCenter)
        opsCenter = opsCenterDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about updating the integration status of an Amazon Web Services service, such as Amazon Web Services Systems Manager, with DevOps Guru.
    public struct UpdateServiceIntegrationConfig: Swift.Equatable {
        /// Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager OpsCenter for each created insight.
        public var opsCenter: DevOpsGuruClientTypes.OpsCenterIntegrationConfig?

        public init (
            opsCenter: DevOpsGuruClientTypes.OpsCenterIntegrationConfig? = nil
        )
        {
            self.opsCenter = opsCenter
        }
    }

}

extension UpdateServiceIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceIntegration = "ServiceIntegration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceIntegration = serviceIntegration {
            try encodeContainer.encode(serviceIntegration, forKey: .serviceIntegration)
        }
    }
}

extension UpdateServiceIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-integrations"
    }
}

public struct UpdateServiceIntegrationInput: Swift.Equatable {
    /// An IntegratedServiceConfig object used to specify the integrated service you want to update, and whether you want to update it to enabled or disabled.
    /// This member is required.
    public var serviceIntegration: DevOpsGuruClientTypes.UpdateServiceIntegrationConfig?

    public init (
        serviceIntegration: DevOpsGuruClientTypes.UpdateServiceIntegrationConfig? = nil
    )
    {
        self.serviceIntegration = serviceIntegration
    }
}

struct UpdateServiceIntegrationInputBody: Swift.Equatable {
    let serviceIntegration: DevOpsGuruClientTypes.UpdateServiceIntegrationConfig?
}

extension UpdateServiceIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceIntegration = "ServiceIntegration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIntegrationDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.UpdateServiceIntegrationConfig.self, forKey: .serviceIntegration)
        serviceIntegration = serviceIntegrationDecoded
    }
}

extension UpdateServiceIntegrationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceIntegrationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceIntegrationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceIntegrationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateServiceIntegrationOutputResponse: Swift.Equatable {

}

extension DevOpsGuruClientTypes.UpdateTagCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBoundaryKey = "AppBoundaryKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBoundaryKey = appBoundaryKey {
            try encodeContainer.encode(appBoundaryKey, forKey: .appBoundaryKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for updatetagvalues0 in tagValues {
                try tagValuesContainer.encode(updatetagvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBoundaryKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBoundaryKey)
        appBoundaryKey = appBoundaryKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A new collection of Amazon Web Services resources that are defined by an Amazon Web Services tag or tag key/value pair.
    public struct UpdateTagCollectionFilter: Swift.Equatable {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be Devops-guru-deployment-application or Devops-guru-rds-application. While keys are case-sensitive, the case of key characters don't matter to DevOps Guru. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        /// This member is required.
        public var appBoundaryKey: Swift.String?
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init (
            appBoundaryKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Contains information about data passed in to a field during a request that is not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// An array of fields that are associated with the validation exception.
    public var fields: [DevOpsGuruClientTypes.ValidationExceptionField]?
    /// A message that describes the validation exception.
    /// This member is required.
    public var message: Swift.String?
    /// The reason the validation exception was thrown.
    public var reason: DevOpsGuruClientTypes.ValidationExceptionReason?

    public init (
        fields: [DevOpsGuruClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: DevOpsGuruClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: DevOpsGuruClientTypes.ValidationExceptionReason?
    let fields: [DevOpsGuruClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[DevOpsGuruClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [DevOpsGuruClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension DevOpsGuruClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The field associated with the validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message associated with the validation exception with information to help determine its cause.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case invalidParameterCombination
        case other
        case parameterInconsistentWithServiceState
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .invalidParameterCombination,
                .other,
                .parameterInconsistentWithServiceState,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .invalidParameterCombination: return "INVALID_PARAMETER_COMBINATION"
            case .other: return "OTHER"
            case .parameterInconsistentWithServiceState: return "PARAMETER_INCONSISTENT_WITH_SERVICE_STATE"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
