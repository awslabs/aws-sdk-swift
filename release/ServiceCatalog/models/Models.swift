// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptPortfolioShareInputBodyMiddleware: Middleware {
    public let id: String = "AcceptPortfolioShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptPortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptPortfolioShareInput>
    public typealias MOutput = OperationOutput<AcceptPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptPortfolioShareOutputError>
}

extension AcceptPortfolioShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptPortfolioShareInput(acceptLanguage: \(String(describing: acceptLanguage)), portfolioId: \(String(describing: portfolioId)), portfolioShareType: \(String(describing: portfolioShareType)))"}
}

extension AcceptPortfolioShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case portfolioShareType = "PortfolioShareType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let portfolioShareType = portfolioShareType {
            try encodeContainer.encode(portfolioShareType.rawValue, forKey: .portfolioShareType)
        }
    }
}

public struct AcceptPortfolioShareInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptPortfolioShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptPortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptPortfolioShareInput>
    public typealias MOutput = OperationOutput<AcceptPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptPortfolioShareOutputError>
}

public struct AcceptPortfolioShareInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptPortfolioShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptPortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptPortfolioShareInput>
    public typealias MOutput = OperationOutput<AcceptPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptPortfolioShareOutputError>
}

public struct AcceptPortfolioShareInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?
    /// <p>The type of shared portfolios to accept. The default is to accept imported portfolios.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AWS_ORGANIZATIONS</code> - Accept portfolios shared by the management account of your
    ///                organization.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IMPORTED</code> - Accept imported portfolios.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AWS_SERVICECATALOG</code> - Not supported. (Throws ResourceNotFoundException.)</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, <code>aws servicecatalog accept-portfolio-share --portfolio-id "port-2qwzkwxt3y5fk" --portfolio-share-type AWS_ORGANIZATIONS</code>
    ///          </p>
    public let portfolioShareType: PortfolioShareType?

    public init (
        acceptLanguage: String? = nil,
        portfolioId: String? = nil,
        portfolioShareType: PortfolioShareType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.portfolioShareType = portfolioShareType
    }
}

struct AcceptPortfolioShareInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let portfolioShareType: PortfolioShareType?
}

extension AcceptPortfolioShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case portfolioShareType = "PortfolioShareType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let portfolioShareTypeDecoded = try containerValues.decodeIfPresent(PortfolioShareType.self, forKey: .portfolioShareType)
        portfolioShareType = portfolioShareTypeDecoded
    }
}

extension AcceptPortfolioShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptPortfolioShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptPortfolioShareOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptPortfolioShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptPortfolioShareOutputResponse()"}
}

extension AcceptPortfolioShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AcceptPortfolioShareOutputResponse: Equatable {

    public init() {}
}

struct AcceptPortfolioShareOutputResponseBody: Equatable {
}

extension AcceptPortfolioShareOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AccessLevelFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(AccessLevelFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AccessLevelFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessLevelFilter(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The access level to use to filter results.</p>
public struct AccessLevelFilter: Equatable {
    /// <p>The access level.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Account</code> - Filter results based on the account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Role</code> - Filter results based on the federated role of the specified user.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>User</code> - Filter results based on the specified user.</p>
    ///             </li>
    ///          </ul>
    public let key: AccessLevelFilterKey?
    /// <p>The user to which the access level applies. The only supported value is <code>Self</code>.</p>
    public let value: String?

    public init (
        key: AccessLevelFilterKey? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public enum AccessLevelFilterKey {
    case account
    case role
    case user
    case sdkUnknown(String)
}

extension AccessLevelFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccessLevelFilterKey] {
        return [
            .account,
            .role,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .account: return "Account"
        case .role: return "Role"
        case .user: return "User"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccessLevelFilterKey(rawValue: rawValue) ?? AccessLevelFilterKey.sdkUnknown(rawValue)
    }
}

public enum AccessStatus {
    case disabled
    case enabled
    case underChange
    case sdkUnknown(String)
}

extension AccessStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccessStatus] {
        return [
            .disabled,
            .enabled,
            .underChange,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case .underChange: return "UNDER_CHANGE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccessStatus(rawValue: rawValue) ?? AccessStatus.sdkUnknown(rawValue)
    }
}

public struct AssociateBudgetWithResourceInputBodyMiddleware: Middleware {
    public let id: String = "AssociateBudgetWithResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateBudgetWithResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateBudgetWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateBudgetWithResourceInput>
    public typealias MOutput = OperationOutput<AssociateBudgetWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateBudgetWithResourceOutputError>
}

extension AssociateBudgetWithResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateBudgetWithResourceInput(budgetName: \(String(describing: budgetName)), resourceId: \(String(describing: resourceId)))"}
}

extension AssociateBudgetWithResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case budgetName = "BudgetName"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct AssociateBudgetWithResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateBudgetWithResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateBudgetWithResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateBudgetWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateBudgetWithResourceInput>
    public typealias MOutput = OperationOutput<AssociateBudgetWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateBudgetWithResourceOutputError>
}

public struct AssociateBudgetWithResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateBudgetWithResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateBudgetWithResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateBudgetWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateBudgetWithResourceInput>
    public typealias MOutput = OperationOutput<AssociateBudgetWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateBudgetWithResourceOutputError>
}

public struct AssociateBudgetWithResourceInput: Equatable {
    /// <p>The name of the budget you want to associate.</p>
    public let budgetName: String?
    /// <p> The resource identifier. Either a portfolio-id or a product-id.</p>
    public let resourceId: String?

    public init (
        budgetName: String? = nil,
        resourceId: String? = nil
    )
    {
        self.budgetName = budgetName
        self.resourceId = resourceId
    }
}

struct AssociateBudgetWithResourceInputBody: Equatable {
    public let budgetName: String?
    public let resourceId: String?
}

extension AssociateBudgetWithResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case budgetName = "BudgetName"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension AssociateBudgetWithResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateBudgetWithResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateBudgetWithResourceOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateBudgetWithResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateBudgetWithResourceOutputResponse()"}
}

extension AssociateBudgetWithResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateBudgetWithResourceOutputResponse: Equatable {

    public init() {}
}

struct AssociateBudgetWithResourceOutputResponseBody: Equatable {
}

extension AssociateBudgetWithResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociatePrincipalWithPortfolioInputBodyMiddleware: Middleware {
    public let id: String = "AssociatePrincipalWithPortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociatePrincipalWithPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociatePrincipalWithPortfolioInput>
    public typealias MOutput = OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociatePrincipalWithPortfolioOutputError>
}

extension AssociatePrincipalWithPortfolioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociatePrincipalWithPortfolioInput(acceptLanguage: \(String(describing: acceptLanguage)), portfolioId: \(String(describing: portfolioId)), principalARN: \(String(describing: principalARN)), principalType: \(String(describing: principalType)))"}
}

extension AssociatePrincipalWithPortfolioInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case principalARN = "PrincipalARN"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let principalARN = principalARN {
            try encodeContainer.encode(principalARN, forKey: .principalARN)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

public struct AssociatePrincipalWithPortfolioInputHeadersMiddleware: Middleware {
    public let id: String = "AssociatePrincipalWithPortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociatePrincipalWithPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociatePrincipalWithPortfolioInput>
    public typealias MOutput = OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociatePrincipalWithPortfolioOutputError>
}

public struct AssociatePrincipalWithPortfolioInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociatePrincipalWithPortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociatePrincipalWithPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociatePrincipalWithPortfolioInput>
    public typealias MOutput = OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociatePrincipalWithPortfolioOutputError>
}

public struct AssociatePrincipalWithPortfolioInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?
    /// <p>The ARN of the principal (IAM user, role, or group).</p>
    public let principalARN: String?
    /// <p>The principal type. The supported value is <code>IAM</code>.</p>
    public let principalType: PrincipalType?

    public init (
        acceptLanguage: String? = nil,
        portfolioId: String? = nil,
        principalARN: String? = nil,
        principalType: PrincipalType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.principalARN = principalARN
        self.principalType = principalType
    }
}

struct AssociatePrincipalWithPortfolioInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let principalARN: String?
    public let principalType: PrincipalType?
}

extension AssociatePrincipalWithPortfolioInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case principalARN = "PrincipalARN"
        case principalType = "PrincipalType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let principalARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalARN)
        principalARN = principalARNDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension AssociatePrincipalWithPortfolioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociatePrincipalWithPortfolioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociatePrincipalWithPortfolioOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociatePrincipalWithPortfolioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociatePrincipalWithPortfolioOutputResponse()"}
}

extension AssociatePrincipalWithPortfolioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociatePrincipalWithPortfolioOutputResponse: Equatable {

    public init() {}
}

struct AssociatePrincipalWithPortfolioOutputResponseBody: Equatable {
}

extension AssociatePrincipalWithPortfolioOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateProductWithPortfolioInputBodyMiddleware: Middleware {
    public let id: String = "AssociateProductWithPortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateProductWithPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateProductWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateProductWithPortfolioInput>
    public typealias MOutput = OperationOutput<AssociateProductWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateProductWithPortfolioOutputError>
}

extension AssociateProductWithPortfolioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateProductWithPortfolioInput(acceptLanguage: \(String(describing: acceptLanguage)), portfolioId: \(String(describing: portfolioId)), productId: \(String(describing: productId)), sourcePortfolioId: \(String(describing: sourcePortfolioId)))"}
}

extension AssociateProductWithPortfolioInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case sourcePortfolioId = "SourcePortfolioId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let sourcePortfolioId = sourcePortfolioId {
            try encodeContainer.encode(sourcePortfolioId, forKey: .sourcePortfolioId)
        }
    }
}

public struct AssociateProductWithPortfolioInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateProductWithPortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateProductWithPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateProductWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateProductWithPortfolioInput>
    public typealias MOutput = OperationOutput<AssociateProductWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateProductWithPortfolioOutputError>
}

public struct AssociateProductWithPortfolioInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateProductWithPortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateProductWithPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateProductWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateProductWithPortfolioInput>
    public typealias MOutput = OperationOutput<AssociateProductWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateProductWithPortfolioOutputError>
}

public struct AssociateProductWithPortfolioInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?
    /// <p>The product identifier.</p>
    public let productId: String?
    /// <p>The identifier of the source portfolio.</p>
    public let sourcePortfolioId: String?

    public init (
        acceptLanguage: String? = nil,
        portfolioId: String? = nil,
        productId: String? = nil,
        sourcePortfolioId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.productId = productId
        self.sourcePortfolioId = sourcePortfolioId
    }
}

struct AssociateProductWithPortfolioInputBody: Equatable {
    public let acceptLanguage: String?
    public let productId: String?
    public let portfolioId: String?
    public let sourcePortfolioId: String?
}

extension AssociateProductWithPortfolioInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case sourcePortfolioId = "SourcePortfolioId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let sourcePortfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourcePortfolioId)
        sourcePortfolioId = sourcePortfolioIdDecoded
    }
}

extension AssociateProductWithPortfolioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateProductWithPortfolioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateProductWithPortfolioOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateProductWithPortfolioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateProductWithPortfolioOutputResponse()"}
}

extension AssociateProductWithPortfolioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateProductWithPortfolioOutputResponse: Equatable {

    public init() {}
}

struct AssociateProductWithPortfolioOutputResponseBody: Equatable {
}

extension AssociateProductWithPortfolioOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateServiceActionWithProvisioningArtifactInputBodyMiddleware: Middleware {
    public let id: String = "AssociateServiceActionWithProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateServiceActionWithProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateServiceActionWithProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateServiceActionWithProvisioningArtifactOutputError>
}

extension AssociateServiceActionWithProvisioningArtifactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateServiceActionWithProvisioningArtifactInput(acceptLanguage: \(String(describing: acceptLanguage)), productId: \(String(describing: productId)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), serviceActionId: \(String(describing: serviceActionId)))"}
}

extension AssociateServiceActionWithProvisioningArtifactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

public struct AssociateServiceActionWithProvisioningArtifactInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateServiceActionWithProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateServiceActionWithProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateServiceActionWithProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateServiceActionWithProvisioningArtifactOutputError>
}

public struct AssociateServiceActionWithProvisioningArtifactInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateServiceActionWithProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateServiceActionWithProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateServiceActionWithProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateServiceActionWithProvisioningArtifactOutputError>
}

public struct AssociateServiceActionWithProvisioningArtifactInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
    public let productId: String?
    /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
    public let provisioningArtifactId: String?
    /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
    public let serviceActionId: String?

    public init (
        acceptLanguage: String? = nil,
        productId: String? = nil,
        provisioningArtifactId: String? = nil,
        serviceActionId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
        self.serviceActionId = serviceActionId
    }
}

struct AssociateServiceActionWithProvisioningArtifactInputBody: Equatable {
    public let productId: String?
    public let provisioningArtifactId: String?
    public let serviceActionId: String?
    public let acceptLanguage: String?
}

extension AssociateServiceActionWithProvisioningArtifactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension AssociateServiceActionWithProvisioningArtifactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateServiceActionWithProvisioningArtifactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateServiceActionWithProvisioningArtifactOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateServiceActionWithProvisioningArtifactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateServiceActionWithProvisioningArtifactOutputResponse()"}
}

extension AssociateServiceActionWithProvisioningArtifactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateServiceActionWithProvisioningArtifactOutputResponse: Equatable {

    public init() {}
}

struct AssociateServiceActionWithProvisioningArtifactOutputResponseBody: Equatable {
}

extension AssociateServiceActionWithProvisioningArtifactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateTagOptionWithResourceInputBodyMiddleware: Middleware {
    public let id: String = "AssociateTagOptionWithResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateTagOptionWithResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateTagOptionWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateTagOptionWithResourceInput>
    public typealias MOutput = OperationOutput<AssociateTagOptionWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateTagOptionWithResourceOutputError>
}

extension AssociateTagOptionWithResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateTagOptionWithResourceInput(resourceId: \(String(describing: resourceId)), tagOptionId: \(String(describing: tagOptionId)))"}
}

extension AssociateTagOptionWithResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagOptionId = "TagOptionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagOptionId = tagOptionId {
            try encodeContainer.encode(tagOptionId, forKey: .tagOptionId)
        }
    }
}

public struct AssociateTagOptionWithResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateTagOptionWithResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateTagOptionWithResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateTagOptionWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateTagOptionWithResourceInput>
    public typealias MOutput = OperationOutput<AssociateTagOptionWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateTagOptionWithResourceOutputError>
}

public struct AssociateTagOptionWithResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateTagOptionWithResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateTagOptionWithResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateTagOptionWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateTagOptionWithResourceInput>
    public typealias MOutput = OperationOutput<AssociateTagOptionWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateTagOptionWithResourceOutputError>
}

public struct AssociateTagOptionWithResourceInput: Equatable {
    /// <p>The resource identifier.</p>
    public let resourceId: String?
    /// <p>The TagOption identifier.</p>
    public let tagOptionId: String?

    public init (
        resourceId: String? = nil,
        tagOptionId: String? = nil
    )
    {
        self.resourceId = resourceId
        self.tagOptionId = tagOptionId
    }
}

struct AssociateTagOptionWithResourceInputBody: Equatable {
    public let resourceId: String?
    public let tagOptionId: String?
}

extension AssociateTagOptionWithResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagOptionId = "TagOptionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagOptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagOptionId)
        tagOptionId = tagOptionIdDecoded
    }
}

extension AssociateTagOptionWithResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTagOptionWithResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateTagOptionWithResourceOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTagOptionWithResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateTagOptionWithResourceOutputResponse()"}
}

extension AssociateTagOptionWithResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateTagOptionWithResourceOutputResponse: Equatable {

    public init() {}
}

struct AssociateTagOptionWithResourceOutputResponseBody: Equatable {
}

extension AssociateTagOptionWithResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct BatchAssociateServiceActionWithProvisioningArtifactInputBodyMiddleware: Middleware {
    public let id: String = "BatchAssociateServiceActionWithProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateServiceActionWithProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateServiceActionWithProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateServiceActionWithProvisioningArtifactOutputError>
}

extension BatchAssociateServiceActionWithProvisioningArtifactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateServiceActionWithProvisioningArtifactInput(acceptLanguage: \(String(describing: acceptLanguage)), serviceActionAssociations: \(String(describing: serviceActionAssociations)))"}
}

extension BatchAssociateServiceActionWithProvisioningArtifactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case serviceActionAssociations = "ServiceActionAssociations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let serviceActionAssociations = serviceActionAssociations {
            var serviceActionAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceActionAssociations)
            for serviceactionassociations0 in serviceActionAssociations {
                try serviceActionAssociationsContainer.encode(serviceactionassociations0)
            }
        }
    }
}

public struct BatchAssociateServiceActionWithProvisioningArtifactInputHeadersMiddleware: Middleware {
    public let id: String = "BatchAssociateServiceActionWithProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateServiceActionWithProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateServiceActionWithProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateServiceActionWithProvisioningArtifactOutputError>
}

public struct BatchAssociateServiceActionWithProvisioningArtifactInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchAssociateServiceActionWithProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateServiceActionWithProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateServiceActionWithProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateServiceActionWithProvisioningArtifactOutputError>
}

public struct BatchAssociateServiceActionWithProvisioningArtifactInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>One or more associations, each consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.</p>
    public let serviceActionAssociations: [ServiceActionAssociation]?

    public init (
        acceptLanguage: String? = nil,
        serviceActionAssociations: [ServiceActionAssociation]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.serviceActionAssociations = serviceActionAssociations
    }
}

struct BatchAssociateServiceActionWithProvisioningArtifactInputBody: Equatable {
    public let serviceActionAssociations: [ServiceActionAssociation]?
    public let acceptLanguage: String?
}

extension BatchAssociateServiceActionWithProvisioningArtifactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case serviceActionAssociations = "ServiceActionAssociations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionAssociationsContainer = try containerValues.decodeIfPresent([ServiceActionAssociation?].self, forKey: .serviceActionAssociations)
        var serviceActionAssociationsDecoded0:[ServiceActionAssociation]? = nil
        if let serviceActionAssociationsContainer = serviceActionAssociationsContainer {
            serviceActionAssociationsDecoded0 = [ServiceActionAssociation]()
            for structure0 in serviceActionAssociationsContainer {
                if let structure0 = structure0 {
                    serviceActionAssociationsDecoded0?.append(structure0)
                }
            }
        }
        serviceActionAssociations = serviceActionAssociationsDecoded0
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAssociateServiceActionWithProvisioningArtifactOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateServiceActionWithProvisioningArtifactOutputResponse(failedServiceActionAssociations: \(String(describing: failedServiceActionAssociations)))"}
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchAssociateServiceActionWithProvisioningArtifactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedServiceActionAssociations = output.failedServiceActionAssociations
        } else {
            self.failedServiceActionAssociations = nil
        }
    }
}

public struct BatchAssociateServiceActionWithProvisioningArtifactOutputResponse: Equatable {
    /// <p>An object that contains a list of errors, along with information to help you identify the self-service action.</p>
    public let failedServiceActionAssociations: [FailedServiceActionAssociation]?

    public init (
        failedServiceActionAssociations: [FailedServiceActionAssociation]? = nil
    )
    {
        self.failedServiceActionAssociations = failedServiceActionAssociations
    }
}

struct BatchAssociateServiceActionWithProvisioningArtifactOutputResponseBody: Equatable {
    public let failedServiceActionAssociations: [FailedServiceActionAssociation]?
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedServiceActionAssociations = "FailedServiceActionAssociations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedServiceActionAssociationsContainer = try containerValues.decodeIfPresent([FailedServiceActionAssociation?].self, forKey: .failedServiceActionAssociations)
        var failedServiceActionAssociationsDecoded0:[FailedServiceActionAssociation]? = nil
        if let failedServiceActionAssociationsContainer = failedServiceActionAssociationsContainer {
            failedServiceActionAssociationsDecoded0 = [FailedServiceActionAssociation]()
            for structure0 in failedServiceActionAssociationsContainer {
                if let structure0 = structure0 {
                    failedServiceActionAssociationsDecoded0?.append(structure0)
                }
            }
        }
        failedServiceActionAssociations = failedServiceActionAssociationsDecoded0
    }
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactInputBodyMiddleware: Middleware {
    public let id: String = "BatchDisassociateServiceActionFromProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateServiceActionFromProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateServiceActionFromProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateServiceActionFromProvisioningArtifactOutputError>
}

extension BatchDisassociateServiceActionFromProvisioningArtifactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateServiceActionFromProvisioningArtifactInput(acceptLanguage: \(String(describing: acceptLanguage)), serviceActionAssociations: \(String(describing: serviceActionAssociations)))"}
}

extension BatchDisassociateServiceActionFromProvisioningArtifactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case serviceActionAssociations = "ServiceActionAssociations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let serviceActionAssociations = serviceActionAssociations {
            var serviceActionAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceActionAssociations)
            for serviceactionassociations0 in serviceActionAssociations {
                try serviceActionAssociationsContainer.encode(serviceactionassociations0)
            }
        }
    }
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDisassociateServiceActionFromProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateServiceActionFromProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateServiceActionFromProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateServiceActionFromProvisioningArtifactOutputError>
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDisassociateServiceActionFromProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateServiceActionFromProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateServiceActionFromProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateServiceActionFromProvisioningArtifactOutputError>
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>One or more associations, each consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.</p>
    public let serviceActionAssociations: [ServiceActionAssociation]?

    public init (
        acceptLanguage: String? = nil,
        serviceActionAssociations: [ServiceActionAssociation]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.serviceActionAssociations = serviceActionAssociations
    }
}

struct BatchDisassociateServiceActionFromProvisioningArtifactInputBody: Equatable {
    public let serviceActionAssociations: [ServiceActionAssociation]?
    public let acceptLanguage: String?
}

extension BatchDisassociateServiceActionFromProvisioningArtifactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case serviceActionAssociations = "ServiceActionAssociations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionAssociationsContainer = try containerValues.decodeIfPresent([ServiceActionAssociation?].self, forKey: .serviceActionAssociations)
        var serviceActionAssociationsDecoded0:[ServiceActionAssociation]? = nil
        if let serviceActionAssociationsContainer = serviceActionAssociationsContainer {
            serviceActionAssociationsDecoded0 = [ServiceActionAssociation]()
            for structure0 in serviceActionAssociationsContainer {
                if let structure0 = structure0 {
                    serviceActionAssociationsDecoded0?.append(structure0)
                }
            }
        }
        serviceActionAssociations = serviceActionAssociationsDecoded0
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisassociateServiceActionFromProvisioningArtifactOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse(failedServiceActionAssociations: \(String(describing: failedServiceActionAssociations)))"}
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDisassociateServiceActionFromProvisioningArtifactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedServiceActionAssociations = output.failedServiceActionAssociations
        } else {
            self.failedServiceActionAssociations = nil
        }
    }
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse: Equatable {
    /// <p>An object that contains a list of errors, along with information to help you identify the self-service action.</p>
    public let failedServiceActionAssociations: [FailedServiceActionAssociation]?

    public init (
        failedServiceActionAssociations: [FailedServiceActionAssociation]? = nil
    )
    {
        self.failedServiceActionAssociations = failedServiceActionAssociations
    }
}

struct BatchDisassociateServiceActionFromProvisioningArtifactOutputResponseBody: Equatable {
    public let failedServiceActionAssociations: [FailedServiceActionAssociation]?
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedServiceActionAssociations = "FailedServiceActionAssociations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedServiceActionAssociationsContainer = try containerValues.decodeIfPresent([FailedServiceActionAssociation?].self, forKey: .failedServiceActionAssociations)
        var failedServiceActionAssociationsDecoded0:[FailedServiceActionAssociation]? = nil
        if let failedServiceActionAssociationsContainer = failedServiceActionAssociationsContainer {
            failedServiceActionAssociationsDecoded0 = [FailedServiceActionAssociation]()
            for structure0 in failedServiceActionAssociationsContainer {
                if let structure0 = structure0 {
                    failedServiceActionAssociationsDecoded0?.append(structure0)
                }
            }
        }
        failedServiceActionAssociations = failedServiceActionAssociationsDecoded0
    }
}

extension BudgetDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension BudgetDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BudgetDetail(budgetName: \(String(describing: budgetName)))"}
}

/// <p>Information about a budget.</p>
public struct BudgetDetail: Equatable {
    /// <p>Name of the associated budget.</p>
    public let budgetName: String?

    public init (
        budgetName: String? = nil
    )
    {
        self.budgetName = budgetName
    }
}

public enum ChangeAction {
    case add
    case modify
    case remove
    case sdkUnknown(String)
}

extension ChangeAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeAction] {
        return [
            .add,
            .modify,
            .remove,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .add: return "ADD"
        case .modify: return "MODIFY"
        case .remove: return "REMOVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeAction(rawValue: rawValue) ?? ChangeAction.sdkUnknown(rawValue)
    }
}

extension CloudWatchDashboard: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CloudWatchDashboard: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchDashboard(name: \(String(describing: name)))"}
}

/// <p>Information about a CloudWatch dashboard.</p>
public struct CloudWatchDashboard: Equatable {
    /// <p>The name of the CloudWatch dashboard.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension ConstraintDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case constraintId = "ConstraintId"
        case description = "Description"
        case owner = "Owner"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraintId = constraintId {
            try encodeContainer.encode(constraintId, forKey: .constraintId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .constraintId)
        constraintId = constraintIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
    }
}

extension ConstraintDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConstraintDetail(constraintId: \(String(describing: constraintId)), description: \(String(describing: description)), owner: \(String(describing: owner)), portfolioId: \(String(describing: portfolioId)), productId: \(String(describing: productId)), type: \(String(describing: type)))"}
}

/// <p>Information about a constraint.</p>
public struct ConstraintDetail: Equatable {
    /// <p>The identifier of the constraint.</p>
    public let constraintId: String?
    /// <p>The description of the constraint.</p>
    public let description: String?
    /// <p>The owner of the constraint.</p>
    public let owner: String?
    /// <p>The identifier of the portfolio the product resides in. The constraint applies only to the instance of the product that lives within this portfolio.</p>
    public let portfolioId: String?
    /// <p>The identifier of the product the constraint applies to. Note that a constraint applies to a specific instance of a product within a certain portfolio.</p>
    public let productId: String?
    /// <p>The type of constraint.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LAUNCH</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOTIFICATION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>STACKSET</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TEMPLATE</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let type: String?

    public init (
        constraintId: String? = nil,
        description: String? = nil,
        owner: String? = nil,
        portfolioId: String? = nil,
        productId: String? = nil,
        type: String? = nil
    )
    {
        self.constraintId = constraintId
        self.description = description
        self.owner = owner
        self.portfolioId = portfolioId
        self.productId = productId
        self.type = type
    }
}

extension ConstraintSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ConstraintSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConstraintSummary(description: \(String(describing: description)), type: \(String(describing: type)))"}
}

/// <p>Summary information about a constraint.</p>
public struct ConstraintSummary: Equatable {
    /// <p>The description of the constraint.</p>
    public let description: String?
    /// <p>The type of constraint.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LAUNCH</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOTIFICATION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>STACKSET</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TEMPLATE</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let type: String?

    public init (
        description: String? = nil,
        type: String? = nil
    )
    {
        self.description = description
        self.type = type
    }
}

public enum CopyOption {
    case copytags
    case sdkUnknown(String)
}

extension CopyOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CopyOption] {
        return [
            .copytags,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .copytags: return "CopyTags"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CopyOption(rawValue: rawValue) ?? CopyOption.sdkUnknown(rawValue)
    }
}

public struct CopyProductInputBodyMiddleware: Middleware {
    public let id: String = "CopyProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyProductInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyProductInput>
    public typealias MOutput = OperationOutput<CopyProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyProductOutputError>
}

extension CopyProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyProductInput(acceptLanguage: \(String(describing: acceptLanguage)), copyOptions: \(String(describing: copyOptions)), idempotencyToken: \(String(describing: idempotencyToken)), sourceProductArn: \(String(describing: sourceProductArn)), sourceProvisioningArtifactIdentifiers: \(String(describing: sourceProvisioningArtifactIdentifiers)), targetProductId: \(String(describing: targetProductId)), targetProductName: \(String(describing: targetProductName)))"}
}

extension CopyProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case copyOptions = "CopyOptions"
        case idempotencyToken = "IdempotencyToken"
        case sourceProductArn = "SourceProductArn"
        case sourceProvisioningArtifactIdentifiers = "SourceProvisioningArtifactIdentifiers"
        case targetProductId = "TargetProductId"
        case targetProductName = "TargetProductName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let copyOptions = copyOptions {
            var copyOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .copyOptions)
            for copyoptions0 in copyOptions {
                try copyOptionsContainer.encode(copyoptions0.rawValue)
            }
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let sourceProductArn = sourceProductArn {
            try encodeContainer.encode(sourceProductArn, forKey: .sourceProductArn)
        }
        if let sourceProvisioningArtifactIdentifiers = sourceProvisioningArtifactIdentifiers {
            var sourceProvisioningArtifactIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceProvisioningArtifactIdentifiers)
            for sourceprovisioningartifactproperties0 in sourceProvisioningArtifactIdentifiers {
                var sourceprovisioningartifactproperties0Container = sourceProvisioningArtifactIdentifiersContainer.nestedContainer(keyedBy: Key.self)
                for (dictKey1, sourceprovisioningartifactpropertiesmap1) in sourceprovisioningartifactproperties0 {
                    try sourceprovisioningartifactproperties0Container.encode(sourceprovisioningartifactpropertiesmap1, forKey: Key(stringValue: dictKey1))
                }
            }
        }
        if let targetProductId = targetProductId {
            try encodeContainer.encode(targetProductId, forKey: .targetProductId)
        }
        if let targetProductName = targetProductName {
            try encodeContainer.encode(targetProductName, forKey: .targetProductName)
        }
    }
}

public struct CopyProductInputHeadersMiddleware: Middleware {
    public let id: String = "CopyProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyProductInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyProductInput>
    public typealias MOutput = OperationOutput<CopyProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyProductOutputError>
}

public struct CopyProductInputQueryItemMiddleware: Middleware {
    public let id: String = "CopyProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CopyProductInput>,
                  next: H) -> Swift.Result<OperationOutput<CopyProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CopyProductInput>
    public typealias MOutput = OperationOutput<CopyProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CopyProductOutputError>
}

public struct CopyProductInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The copy options. If the value is <code>CopyTags</code>, the tags from the source
    ///          product are copied to the target product.</p>
    public let copyOptions: [CopyOption]?
    /// <p> A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request. </p>
    public var idempotencyToken: String?
    /// <p>The Amazon Resource Name (ARN) of the source product.</p>
    public let sourceProductArn: String?
    /// <p>The identifiers of the provisioning artifacts (also known as versions) of the product to copy.
    ///          By default, all provisioning artifacts are copied.</p>
    public let sourceProvisioningArtifactIdentifiers: [[String:String]]?
    /// <p>The identifier of the target product. By default, a new product is created.</p>
    public let targetProductId: String?
    /// <p>A name for the target product. The default is the name of the source product.</p>
    public let targetProductName: String?

    public init (
        acceptLanguage: String? = nil,
        copyOptions: [CopyOption]? = nil,
        idempotencyToken: String? = nil,
        sourceProductArn: String? = nil,
        sourceProvisioningArtifactIdentifiers: [[String:String]]? = nil,
        targetProductId: String? = nil,
        targetProductName: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.copyOptions = copyOptions
        self.idempotencyToken = idempotencyToken
        self.sourceProductArn = sourceProductArn
        self.sourceProvisioningArtifactIdentifiers = sourceProvisioningArtifactIdentifiers
        self.targetProductId = targetProductId
        self.targetProductName = targetProductName
    }
}

struct CopyProductInputBody: Equatable {
    public let acceptLanguage: String?
    public let sourceProductArn: String?
    public let targetProductId: String?
    public let targetProductName: String?
    public let sourceProvisioningArtifactIdentifiers: [[String:String]]?
    public let copyOptions: [CopyOption]?
    public let idempotencyToken: String?
}

extension CopyProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case copyOptions = "CopyOptions"
        case idempotencyToken = "IdempotencyToken"
        case sourceProductArn = "SourceProductArn"
        case sourceProvisioningArtifactIdentifiers = "SourceProvisioningArtifactIdentifiers"
        case targetProductId = "TargetProductId"
        case targetProductName = "TargetProductName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let sourceProductArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceProductArn)
        sourceProductArn = sourceProductArnDecoded
        let targetProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetProductId)
        targetProductId = targetProductIdDecoded
        let targetProductNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetProductName)
        targetProductName = targetProductNameDecoded
        let sourceProvisioningArtifactIdentifiersContainer = try containerValues.decodeIfPresent([[String: String?]?].self, forKey: .sourceProvisioningArtifactIdentifiers)
        var sourceProvisioningArtifactIdentifiersDecoded0:[[String:String]]? = nil
        if let sourceProvisioningArtifactIdentifiersContainer = sourceProvisioningArtifactIdentifiersContainer {
            sourceProvisioningArtifactIdentifiersDecoded0 = [[String:String]]()
            for map0 in sourceProvisioningArtifactIdentifiersContainer {
                var sourceProvisioningArtifactIdentifiersContainerDecoded0: [String: String]? = nil
                if let map0 = map0 {
                    sourceProvisioningArtifactIdentifiersContainerDecoded0 = [String: String]()
                    for (key1, provisioningartifactpropertyvalue1) in map0 {
                        if let provisioningartifactpropertyvalue1 = provisioningartifactpropertyvalue1 {
                            sourceProvisioningArtifactIdentifiersContainerDecoded0?[key1] = provisioningartifactpropertyvalue1
                        }
                    }
                }
                if let sourceProvisioningArtifactIdentifiersContainerDecoded0 = sourceProvisioningArtifactIdentifiersContainerDecoded0 {
                    sourceProvisioningArtifactIdentifiersDecoded0?.append(sourceProvisioningArtifactIdentifiersContainerDecoded0)
                }
            }
        }
        sourceProvisioningArtifactIdentifiers = sourceProvisioningArtifactIdentifiersDecoded0
        let copyOptionsContainer = try containerValues.decodeIfPresent([CopyOption?].self, forKey: .copyOptions)
        var copyOptionsDecoded0:[CopyOption]? = nil
        if let copyOptionsContainer = copyOptionsContainer {
            copyOptionsDecoded0 = [CopyOption]()
            for string0 in copyOptionsContainer {
                if let string0 = string0 {
                    copyOptionsDecoded0?.append(string0)
                }
            }
        }
        copyOptions = copyOptionsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CopyProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyProductOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CopyProductOutputResponse(copyProductToken: \(String(describing: copyProductToken)))"}
}

extension CopyProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CopyProductOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.copyProductToken = output.copyProductToken
        } else {
            self.copyProductToken = nil
        }
    }
}

public struct CopyProductOutputResponse: Equatable {
    /// <p>The token to use to track the progress of the operation.</p>
    public let copyProductToken: String?

    public init (
        copyProductToken: String? = nil
    )
    {
        self.copyProductToken = copyProductToken
    }
}

struct CopyProductOutputResponseBody: Equatable {
    public let copyProductToken: String?
}

extension CopyProductOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case copyProductToken = "CopyProductToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyProductTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .copyProductToken)
        copyProductToken = copyProductTokenDecoded
    }
}

public enum CopyProductStatus {
    case failed
    case inProgress
    case succeeded
    case sdkUnknown(String)
}

extension CopyProductStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CopyProductStatus] {
        return [
            .failed,
            .inProgress,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CopyProductStatus(rawValue: rawValue) ?? CopyProductStatus.sdkUnknown(rawValue)
    }
}

public struct CreateConstraintInputBodyMiddleware: Middleware {
    public let id: String = "CreateConstraintInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConstraintInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConstraintInput>
    public typealias MOutput = OperationOutput<CreateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConstraintOutputError>
}

extension CreateConstraintInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConstraintInput(acceptLanguage: \(String(describing: acceptLanguage)), description: \(String(describing: description)), idempotencyToken: \(String(describing: idempotencyToken)), parameters: \(String(describing: parameters)), portfolioId: \(String(describing: portfolioId)), productId: \(String(describing: productId)), type: \(String(describing: type)))"}
}

extension CreateConstraintInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case parameters = "Parameters"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

public struct CreateConstraintInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConstraintInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConstraintInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConstraintInput>
    public typealias MOutput = OperationOutput<CreateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConstraintOutputError>
}

public struct CreateConstraintInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConstraintInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConstraintInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConstraintInput>
    public typealias MOutput = OperationOutput<CreateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConstraintOutputError>
}

public struct CreateConstraintInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The description of the constraint.</p>
    public let description: String?
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.</p>
    public var idempotencyToken: String?
    /// <p>The constraint parameters, in JSON format. The syntax depends on the constraint type as follows:</p>
    ///          <dl>
    ///             <dt>LAUNCH</dt>
    ///             <dd>
    ///                <p>You are required to specify either the <code>RoleArn</code> or the <code>LocalRoleName</code> but can't use both.</p>
    ///                <p>Specify the <code>RoleArn</code> property as follows:</p>
    ///                <p>
    ///                   <code>{"RoleArn" : "arn:aws:iam::123456789012:role/LaunchRole"}</code>
    ///                </p>
    ///                <p>Specify the <code>LocalRoleName</code> property as follows:</p>
    ///                <p>
    ///                   <code>{"LocalRoleName": "SCBasicLaunchRole"}</code>
    ///                </p>
    ///                <p>If you specify the <code>LocalRoleName</code> property, when an account uses the launch constraint, the IAM role with that name in the account will be used. This allows launch-role constraints to be
    ///                account-agnostic so the administrator can create fewer resources per shared account.</p>
    ///                <note>
    ///                   <p>The given role name must exist in the account used to create the launch constraint and the account of the user who launches a product with this launch constraint.</p>
    ///                </note>
    ///                <p>You cannot have both a <code>LAUNCH</code> and a <code>STACKSET</code> constraint.</p>
    ///                <p>You also cannot have more than one <code>LAUNCH</code> constraint on a product and portfolio.</p>
    ///             </dd>
    ///             <dt>NOTIFICATION</dt>
    ///             <dd>
    ///                <p>Specify the <code>NotificationArns</code> property as follows:</p>
    ///                <p>
    ///                   <code>{"NotificationArns" : ["arn:aws:sns:us-east-1:123456789012:Topic"]}</code>
    ///                </p>
    ///             </dd>
    ///             <dt>RESOURCE_UPDATE</dt>
    ///             <dd>
    ///                <p>Specify the <code>TagUpdatesOnProvisionedProduct</code> property as follows:</p>
    ///                <p>
    ///                   <code>{"Version":"2.0","Properties":{"TagUpdateOnProvisionedProduct":"String"}}</code>
    ///                </p>
    ///                <p>The <code>TagUpdatesOnProvisionedProduct</code> property accepts a string value of <code>ALLOWED</code> or <code>NOT_ALLOWED</code>.</p>
    ///             </dd>
    ///             <dt>STACKSET</dt>
    ///             <dd>
    ///                <p>Specify the <code>Parameters</code> property as follows:</p>
    ///                <p>
    ///                   <code>{"Version": "String", "Properties": {"AccountList": [ "String" ], "RegionList": [ "String" ], "AdminRole": "String", "ExecutionRole": "String"}}</code>
    ///                </p>
    ///                <p>You cannot have both a <code>LAUNCH</code> and a <code>STACKSET</code> constraint.</p>
    ///                <p>You also cannot have more than one <code>STACKSET</code> constraint on a product and portfolio.</p>
    ///                <p>Products with a <code>STACKSET</code> constraint will launch an AWS CloudFormation stack set.</p>
    ///             </dd>
    ///             <dt>TEMPLATE</dt>
    ///             <dd>
    ///                <p>Specify the <code>Rules</code> property. For more information, see
    ///                   <a href="http://docs.aws.amazon.com/servicecatalog/latest/adminguide/reference-template_constraint_rules.html">Template Constraint Rules</a>.</p>
    ///             </dd>
    ///          </dl>
    public let parameters: String?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?
    /// <p>The product identifier.</p>
    public let productId: String?
    /// <p>The type of constraint.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LAUNCH</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NOTIFICATION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RESOURCE_UPDATE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STACKSET</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TEMPLATE</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let type: String?

    public init (
        acceptLanguage: String? = nil,
        description: String? = nil,
        idempotencyToken: String? = nil,
        parameters: String? = nil,
        portfolioId: String? = nil,
        productId: String? = nil,
        type: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.idempotencyToken = idempotencyToken
        self.parameters = parameters
        self.portfolioId = portfolioId
        self.productId = productId
        self.type = type
    }
}

struct CreateConstraintInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let productId: String?
    public let parameters: String?
    public let type: String?
    public let description: String?
    public let idempotencyToken: String?
}

extension CreateConstraintInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case parameters = "Parameters"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameters)
        parameters = parametersDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateConstraintOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConstraintOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConstraintOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConstraintOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConstraintOutputResponse(constraintDetail: \(String(describing: constraintDetail)), constraintParameters: \(String(describing: constraintParameters)), status: \(String(describing: status)))"}
}

extension CreateConstraintOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConstraintOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.constraintDetail = output.constraintDetail
            self.constraintParameters = output.constraintParameters
            self.status = output.status
        } else {
            self.constraintDetail = nil
            self.constraintParameters = nil
            self.status = nil
        }
    }
}

public struct CreateConstraintOutputResponse: Equatable {
    /// <p>Information about the constraint.</p>
    public let constraintDetail: ConstraintDetail?
    /// <p>The constraint parameters.</p>
    public let constraintParameters: String?
    /// <p>The status of the current request.</p>
    public let status: Status?

    public init (
        constraintDetail: ConstraintDetail? = nil,
        constraintParameters: String? = nil,
        status: Status? = nil
    )
    {
        self.constraintDetail = constraintDetail
        self.constraintParameters = constraintParameters
        self.status = status
    }
}

struct CreateConstraintOutputResponseBody: Equatable {
    public let constraintDetail: ConstraintDetail?
    public let constraintParameters: String?
    public let status: Status?
}

extension CreateConstraintOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case constraintDetail = "ConstraintDetail"
        case constraintParameters = "ConstraintParameters"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDetailDecoded = try containerValues.decodeIfPresent(ConstraintDetail.self, forKey: .constraintDetail)
        constraintDetail = constraintDetailDecoded
        let constraintParametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .constraintParameters)
        constraintParameters = constraintParametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreatePortfolioInputBodyMiddleware: Middleware {
    public let id: String = "CreatePortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePortfolioInput>
    public typealias MOutput = OperationOutput<CreatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePortfolioOutputError>
}

extension CreatePortfolioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePortfolioInput(acceptLanguage: \(String(describing: acceptLanguage)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), idempotencyToken: \(String(describing: idempotencyToken)), providerName: \(String(describing: providerName)), tags: \(String(describing: tags)))"}
}

extension CreatePortfolioInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case providerName = "ProviderName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for addtags0 in tags {
                try tagsContainer.encode(addtags0)
            }
        }
    }
}

public struct CreatePortfolioInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePortfolioInput>
    public typealias MOutput = OperationOutput<CreatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePortfolioOutputError>
}

public struct CreatePortfolioInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePortfolioInput>
    public typealias MOutput = OperationOutput<CreatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePortfolioOutputError>
}

public struct CreatePortfolioInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The description of the portfolio.</p>
    public let description: String?
    /// <p>The name to use for display purposes.</p>
    public let displayName: String?
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.</p>
    public var idempotencyToken: String?
    /// <p>The name of the portfolio provider.</p>
    public let providerName: String?
    /// <p>One or more tags.</p>
    public let tags: [Tag]?

    public init (
        acceptLanguage: String? = nil,
        description: String? = nil,
        displayName: String? = nil,
        idempotencyToken: String? = nil,
        providerName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.displayName = displayName
        self.idempotencyToken = idempotencyToken
        self.providerName = providerName
        self.tags = tags
    }
}

struct CreatePortfolioInputBody: Equatable {
    public let acceptLanguage: String?
    public let displayName: String?
    public let description: String?
    public let providerName: String?
    public let tags: [Tag]?
    public let idempotencyToken: String?
}

extension CreatePortfolioInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case providerName = "ProviderName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreatePortfolioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePortfolioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePortfolioOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePortfolioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePortfolioOutputResponse(portfolioDetail: \(String(describing: portfolioDetail)), tags: \(String(describing: tags)))"}
}

extension CreatePortfolioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePortfolioOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.portfolioDetail = output.portfolioDetail
            self.tags = output.tags
        } else {
            self.portfolioDetail = nil
            self.tags = nil
        }
    }
}

public struct CreatePortfolioOutputResponse: Equatable {
    /// <p>Information about the portfolio.</p>
    public let portfolioDetail: PortfolioDetail?
    /// <p>Information about the tags associated with the portfolio.</p>
    public let tags: [Tag]?

    public init (
        portfolioDetail: PortfolioDetail? = nil,
        tags: [Tag]? = nil
    )
    {
        self.portfolioDetail = portfolioDetail
        self.tags = tags
    }
}

struct CreatePortfolioOutputResponseBody: Equatable {
    public let portfolioDetail: PortfolioDetail?
    public let tags: [Tag]?
}

extension CreatePortfolioOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case portfolioDetail = "PortfolioDetail"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailDecoded = try containerValues.decodeIfPresent(PortfolioDetail.self, forKey: .portfolioDetail)
        portfolioDetail = portfolioDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreatePortfolioShareInputBodyMiddleware: Middleware {
    public let id: String = "CreatePortfolioShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePortfolioShareInput>
    public typealias MOutput = OperationOutput<CreatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePortfolioShareOutputError>
}

extension CreatePortfolioShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePortfolioShareInput(acceptLanguage: \(String(describing: acceptLanguage)), accountId: \(String(describing: accountId)), organizationNode: \(String(describing: organizationNode)), portfolioId: \(String(describing: portfolioId)), shareTagOptions: \(String(describing: shareTagOptions)))"}
}

extension CreatePortfolioShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
        case shareTagOptions = "ShareTagOptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let organizationNode = organizationNode {
            try encodeContainer.encode(organizationNode, forKey: .organizationNode)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if shareTagOptions != false {
            try encodeContainer.encode(shareTagOptions, forKey: .shareTagOptions)
        }
    }
}

public struct CreatePortfolioShareInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePortfolioShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePortfolioShareInput>
    public typealias MOutput = OperationOutput<CreatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePortfolioShareOutputError>
}

public struct CreatePortfolioShareInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePortfolioShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePortfolioShareInput>
    public typealias MOutput = OperationOutput<CreatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePortfolioShareOutputError>
}

public struct CreatePortfolioShareInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The AWS account ID. For example, <code>123456789012</code>.</p>
    public let accountId: String?
    /// <p>The organization node to whom you are going to share. If <code>OrganizationNode</code>
    ///          is passed in, <code>PortfolioShare</code> will be created for the node an
    ///          ListOrganizationPortfolioAccessd its children (when applies), and a
    ///             <code>PortfolioShareToken</code> will be returned in the output in order for the
    ///          administrator to monitor the status of the <code>PortfolioShare</code> creation
    ///          process.</p>
    public let organizationNode: OrganizationNode?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?
    /// <p>Enables or disables <code>TagOptions </code> sharing when creating the portfolio share. If this flag is not provided, TagOptions sharing is disabled.</p>
    public let shareTagOptions: Bool

    public init (
        acceptLanguage: String? = nil,
        accountId: String? = nil,
        organizationNode: OrganizationNode? = nil,
        portfolioId: String? = nil,
        shareTagOptions: Bool = false
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accountId = accountId
        self.organizationNode = organizationNode
        self.portfolioId = portfolioId
        self.shareTagOptions = shareTagOptions
    }
}

struct CreatePortfolioShareInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let accountId: String?
    public let organizationNode: OrganizationNode?
    public let shareTagOptions: Bool
}

extension CreatePortfolioShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
        case shareTagOptions = "ShareTagOptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationNodeDecoded = try containerValues.decodeIfPresent(OrganizationNode.self, forKey: .organizationNode)
        organizationNode = organizationNodeDecoded
        let shareTagOptionsDecoded = try containerValues.decode(Bool.self, forKey: .shareTagOptions)
        shareTagOptions = shareTagOptionsDecoded
    }
}

extension CreatePortfolioShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePortfolioShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePortfolioShareOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePortfolioShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePortfolioShareOutputResponse(portfolioShareToken: \(String(describing: portfolioShareToken)))"}
}

extension CreatePortfolioShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePortfolioShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.portfolioShareToken = output.portfolioShareToken
        } else {
            self.portfolioShareToken = nil
        }
    }
}

public struct CreatePortfolioShareOutputResponse: Equatable {
    /// <p>The portfolio shares a unique identifier that only returns if the portfolio is shared to an organization node.</p>
    public let portfolioShareToken: String?

    public init (
        portfolioShareToken: String? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
    }
}

struct CreatePortfolioShareOutputResponseBody: Equatable {
    public let portfolioShareToken: String?
}

extension CreatePortfolioShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
    }
}

public struct CreateProductInputBodyMiddleware: Middleware {
    public let id: String = "CreateProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProductInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProductInput>
    public typealias MOutput = OperationOutput<CreateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProductOutputError>
}

extension CreateProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProductInput(acceptLanguage: \(String(describing: acceptLanguage)), description: \(String(describing: description)), distributor: \(String(describing: distributor)), idempotencyToken: \(String(describing: idempotencyToken)), name: \(String(describing: name)), owner: \(String(describing: owner)), productType: \(String(describing: productType)), provisioningArtifactParameters: \(String(describing: provisioningArtifactParameters)), supportDescription: \(String(describing: supportDescription)), supportEmail: \(String(describing: supportEmail)), supportUrl: \(String(describing: supportUrl)), tags: \(String(describing: tags)))"}
}

extension CreateProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case distributor = "Distributor"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case owner = "Owner"
        case productType = "ProductType"
        case provisioningArtifactParameters = "ProvisioningArtifactParameters"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributor = distributor {
            try encodeContainer.encode(distributor, forKey: .distributor)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let productType = productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let provisioningArtifactParameters = provisioningArtifactParameters {
            try encodeContainer.encode(provisioningArtifactParameters, forKey: .provisioningArtifactParameters)
        }
        if let supportDescription = supportDescription {
            try encodeContainer.encode(supportDescription, forKey: .supportDescription)
        }
        if let supportEmail = supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportUrl = supportUrl {
            try encodeContainer.encode(supportUrl, forKey: .supportUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for addtags0 in tags {
                try tagsContainer.encode(addtags0)
            }
        }
    }
}

public struct CreateProductInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProductInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProductInput>
    public typealias MOutput = OperationOutput<CreateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProductOutputError>
}

public struct CreateProductInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProductInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProductInput>
    public typealias MOutput = OperationOutput<CreateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProductOutputError>
}

public struct CreateProductInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The description of the product.</p>
    public let description: String?
    /// <p>The distributor of the product.</p>
    public let distributor: String?
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.</p>
    public var idempotencyToken: String?
    /// <p>The name of the product.</p>
    public let name: String?
    /// <p>The owner of the product.</p>
    public let owner: String?
    /// <p>The type of product.</p>
    public let productType: ProductType?
    /// <p>The configuration of the provisioning artifact. </p>
    public let provisioningArtifactParameters: ProvisioningArtifactProperties?
    /// <p>The support information about the product.</p>
    public let supportDescription: String?
    /// <p>The contact email for product support.</p>
    public let supportEmail: String?
    /// <p>The contact URL for product support.</p>
    ///          <p>
    ///             <code>^https?:\/\// </code>/ is the pattern used to validate SupportUrl.</p>
    public let supportUrl: String?
    /// <p>One or more tags.</p>
    public let tags: [Tag]?

    public init (
        acceptLanguage: String? = nil,
        description: String? = nil,
        distributor: String? = nil,
        idempotencyToken: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        productType: ProductType? = nil,
        provisioningArtifactParameters: ProvisioningArtifactProperties? = nil,
        supportDescription: String? = nil,
        supportEmail: String? = nil,
        supportUrl: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.distributor = distributor
        self.idempotencyToken = idempotencyToken
        self.name = name
        self.owner = owner
        self.productType = productType
        self.provisioningArtifactParameters = provisioningArtifactParameters
        self.supportDescription = supportDescription
        self.supportEmail = supportEmail
        self.supportUrl = supportUrl
        self.tags = tags
    }
}

struct CreateProductInputBody: Equatable {
    public let acceptLanguage: String?
    public let name: String?
    public let owner: String?
    public let description: String?
    public let distributor: String?
    public let supportDescription: String?
    public let supportEmail: String?
    public let supportUrl: String?
    public let productType: ProductType?
    public let tags: [Tag]?
    public let provisioningArtifactParameters: ProvisioningArtifactProperties?
    public let idempotencyToken: String?
}

extension CreateProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case distributor = "Distributor"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case owner = "Owner"
        case productType = "ProductType"
        case provisioningArtifactParameters = "ProvisioningArtifactParameters"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let distributorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributor)
        distributor = distributorDecoded
        let supportDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportDescription)
        supportDescription = supportDescriptionDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportUrl)
        supportUrl = supportUrlDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let provisioningArtifactParametersDecoded = try containerValues.decodeIfPresent(ProvisioningArtifactProperties.self, forKey: .provisioningArtifactParameters)
        provisioningArtifactParameters = provisioningArtifactParametersDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProductOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProductOutputResponse(productViewDetail: \(String(describing: productViewDetail)), provisioningArtifactDetail: \(String(describing: provisioningArtifactDetail)), tags: \(String(describing: tags)))"}
}

extension CreateProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProductOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.productViewDetail = output.productViewDetail
            self.provisioningArtifactDetail = output.provisioningArtifactDetail
            self.tags = output.tags
        } else {
            self.productViewDetail = nil
            self.provisioningArtifactDetail = nil
            self.tags = nil
        }
    }
}

public struct CreateProductOutputResponse: Equatable {
    /// <p>Information about the product view.</p>
    public let productViewDetail: ProductViewDetail?
    /// <p>Information about the provisioning artifact. </p>
    public let provisioningArtifactDetail: ProvisioningArtifactDetail?
    /// <p>Information about the tags associated with the product.</p>
    public let tags: [Tag]?

    public init (
        productViewDetail: ProductViewDetail? = nil,
        provisioningArtifactDetail: ProvisioningArtifactDetail? = nil,
        tags: [Tag]? = nil
    )
    {
        self.productViewDetail = productViewDetail
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.tags = tags
    }
}

struct CreateProductOutputResponseBody: Equatable {
    public let productViewDetail: ProductViewDetail?
    public let provisioningArtifactDetail: ProvisioningArtifactDetail?
    public let tags: [Tag]?
}

extension CreateProductOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case productViewDetail = "ProductViewDetail"
        case provisioningArtifactDetail = "ProvisioningArtifactDetail"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewDetailDecoded = try containerValues.decodeIfPresent(ProductViewDetail.self, forKey: .productViewDetail)
        productViewDetail = productViewDetailDecoded
        let provisioningArtifactDetailDecoded = try containerValues.decodeIfPresent(ProvisioningArtifactDetail.self, forKey: .provisioningArtifactDetail)
        provisioningArtifactDetail = provisioningArtifactDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateProvisionedProductPlanInputBodyMiddleware: Middleware {
    public let id: String = "CreateProvisionedProductPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisionedProductPlanInput>
    public typealias MOutput = OperationOutput<CreateProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisionedProductPlanOutputError>
}

extension CreateProvisionedProductPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProvisionedProductPlanInput(acceptLanguage: \(String(describing: acceptLanguage)), idempotencyToken: \(String(describing: idempotencyToken)), notificationArns: \(String(describing: notificationArns)), pathId: \(String(describing: pathId)), planName: \(String(describing: planName)), planType: \(String(describing: planType)), productId: \(String(describing: productId)), provisionedProductName: \(String(describing: provisionedProductName)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), provisioningParameters: \(String(describing: provisioningParameters)), tags: \(String(describing: tags)))"}
}

extension CreateProvisionedProductPlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case planName = "PlanName"
        case planType = "PlanType"
        case productId = "ProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningParameters = "ProvisioningParameters"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for notificationarns0 in notificationArns {
                try notificationArnsContainer.encode(notificationarns0)
            }
        }
        if let pathId = pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let planName = planName {
            try encodeContainer.encode(planName, forKey: .planName)
        }
        if let planType = planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningParameters = provisioningParameters {
            var provisioningParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .provisioningParameters)
            for updateprovisioningparameters0 in provisioningParameters {
                try provisioningParametersContainer.encode(updateprovisioningparameters0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateProvisionedProductPlanInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProvisionedProductPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisionedProductPlanInput>
    public typealias MOutput = OperationOutput<CreateProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisionedProductPlanOutputError>
}

public struct CreateProvisionedProductPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProvisionedProductPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisionedProductPlanInput>
    public typealias MOutput = OperationOutput<CreateProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisionedProductPlanOutputError>
}

public struct CreateProvisionedProductPlanInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.</p>
    public var idempotencyToken: String?
    /// <p>Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related
    ///          events.</p>
    public let notificationArns: [String]?
    /// <p>The path identifier of the product. This value is optional if the product
    ///          has a default path, and required if the product has more than one path.
    ///          To list the paths for a product, use <a>ListLaunchPaths</a>.</p>
    public let pathId: String?
    /// <p>The name of the plan.</p>
    public let planName: String?
    /// <p>The plan type.</p>
    public let planType: ProvisionedProductPlanType?
    /// <p>The product identifier.</p>
    public let productId: String?
    /// <p>A user-friendly name for the provisioned product. This value must be
    ///          unique for the AWS account and cannot be updated after the product is provisioned.</p>
    public let provisionedProductName: String?
    /// <p>The identifier of the provisioning artifact.</p>
    public let provisioningArtifactId: String?
    /// <p>Parameters specified by the administrator that are required for provisioning the
    ///          product.</p>
    public let provisioningParameters: [UpdateProvisioningParameter]?
    /// <p>One or more tags.</p>
    ///          <p>If the plan is for an existing provisioned product, the product must have a <code>RESOURCE_UPDATE</code> constraint with <code>TagUpdatesOnProvisionedProduct</code> set to <code>ALLOWED</code> to allow tag updates.</p>
    public let tags: [Tag]?

    public init (
        acceptLanguage: String? = nil,
        idempotencyToken: String? = nil,
        notificationArns: [String]? = nil,
        pathId: String? = nil,
        planName: String? = nil,
        planType: ProvisionedProductPlanType? = nil,
        productId: String? = nil,
        provisionedProductName: String? = nil,
        provisioningArtifactId: String? = nil,
        provisioningParameters: [UpdateProvisioningParameter]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.notificationArns = notificationArns
        self.pathId = pathId
        self.planName = planName
        self.planType = planType
        self.productId = productId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningParameters = provisioningParameters
        self.tags = tags
    }
}

struct CreateProvisionedProductPlanInputBody: Equatable {
    public let acceptLanguage: String?
    public let planName: String?
    public let planType: ProvisionedProductPlanType?
    public let notificationArns: [String]?
    public let pathId: String?
    public let productId: String?
    public let provisionedProductName: String?
    public let provisioningArtifactId: String?
    public let provisioningParameters: [UpdateProvisioningParameter]?
    public let idempotencyToken: String?
    public let tags: [Tag]?
}

extension CreateProvisionedProductPlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case planName = "PlanName"
        case planType = "PlanType"
        case productId = "ProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningParameters = "ProvisioningParameters"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let planNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .planName)
        planName = planNameDecoded
        let planTypeDecoded = try containerValues.decodeIfPresent(ProvisionedProductPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let notificationArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let pathIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningParametersContainer = try containerValues.decodeIfPresent([UpdateProvisioningParameter?].self, forKey: .provisioningParameters)
        var provisioningParametersDecoded0:[UpdateProvisioningParameter]? = nil
        if let provisioningParametersContainer = provisioningParametersContainer {
            provisioningParametersDecoded0 = [UpdateProvisioningParameter]()
            for structure0 in provisioningParametersContainer {
                if let structure0 = structure0 {
                    provisioningParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningParameters = provisioningParametersDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProvisionedProductPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProvisionedProductPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProvisionedProductPlanOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProvisionedProductPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProvisionedProductPlanOutputResponse(planId: \(String(describing: planId)), planName: \(String(describing: planName)), provisionProductId: \(String(describing: provisionProductId)), provisionedProductName: \(String(describing: provisionedProductName)), provisioningArtifactId: \(String(describing: provisioningArtifactId)))"}
}

extension CreateProvisionedProductPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProvisionedProductPlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.planId = output.planId
            self.planName = output.planName
            self.provisionProductId = output.provisionProductId
            self.provisionedProductName = output.provisionedProductName
            self.provisioningArtifactId = output.provisioningArtifactId
        } else {
            self.planId = nil
            self.planName = nil
            self.provisionProductId = nil
            self.provisionedProductName = nil
            self.provisioningArtifactId = nil
        }
    }
}

public struct CreateProvisionedProductPlanOutputResponse: Equatable {
    /// <p>The plan identifier.</p>
    public let planId: String?
    /// <p>The name of the plan.</p>
    public let planName: String?
    /// <p>The product identifier.</p>
    public let provisionProductId: String?
    /// <p>The user-friendly name of the provisioned product.</p>
    public let provisionedProductName: String?
    /// <p>The identifier of the provisioning artifact.</p>
    public let provisioningArtifactId: String?

    public init (
        planId: String? = nil,
        planName: String? = nil,
        provisionProductId: String? = nil,
        provisionedProductName: String? = nil,
        provisioningArtifactId: String? = nil
    )
    {
        self.planId = planId
        self.planName = planName
        self.provisionProductId = provisionProductId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct CreateProvisionedProductPlanOutputResponseBody: Equatable {
    public let planName: String?
    public let planId: String?
    public let provisionProductId: String?
    public let provisionedProductName: String?
    public let provisioningArtifactId: String?
}

extension CreateProvisionedProductPlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case planId = "PlanId"
        case planName = "PlanName"
        case provisionProductId = "ProvisionProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let planNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .planName)
        planName = planNameDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .planId)
        planId = planIdDecoded
        let provisionProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionProductId)
        provisionProductId = provisionProductIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
    }
}

public struct CreateProvisioningArtifactInputBodyMiddleware: Middleware {
    public let id: String = "CreateProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<CreateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisioningArtifactOutputError>
}

extension CreateProvisioningArtifactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProvisioningArtifactInput(acceptLanguage: \(String(describing: acceptLanguage)), idempotencyToken: \(String(describing: idempotencyToken)), parameters: \(String(describing: parameters)), productId: \(String(describing: productId)))"}
}

extension CreateProvisioningArtifactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case parameters = "Parameters"
        case productId = "ProductId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

public struct CreateProvisioningArtifactInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<CreateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisioningArtifactOutputError>
}

public struct CreateProvisioningArtifactInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<CreateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProvisioningArtifactOutputError>
}

public struct CreateProvisioningArtifactInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.</p>
    public var idempotencyToken: String?
    /// <p>The configuration for the provisioning artifact.</p>
    public let parameters: ProvisioningArtifactProperties?
    /// <p>The product identifier.</p>
    public let productId: String?

    public init (
        acceptLanguage: String? = nil,
        idempotencyToken: String? = nil,
        parameters: ProvisioningArtifactProperties? = nil,
        productId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.parameters = parameters
        self.productId = productId
    }
}

struct CreateProvisioningArtifactInputBody: Equatable {
    public let acceptLanguage: String?
    public let productId: String?
    public let parameters: ProvisioningArtifactProperties?
    public let idempotencyToken: String?
}

extension CreateProvisioningArtifactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case parameters = "Parameters"
        case productId = "ProductId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(ProvisioningArtifactProperties.self, forKey: .parameters)
        parameters = parametersDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateProvisioningArtifactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProvisioningArtifactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProvisioningArtifactOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProvisioningArtifactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProvisioningArtifactOutputResponse(info: \(String(describing: info)), provisioningArtifactDetail: \(String(describing: provisioningArtifactDetail)), status: \(String(describing: status)))"}
}

extension CreateProvisioningArtifactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProvisioningArtifactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.info = output.info
            self.provisioningArtifactDetail = output.provisioningArtifactDetail
            self.status = output.status
        } else {
            self.info = nil
            self.provisioningArtifactDetail = nil
            self.status = nil
        }
    }
}

public struct CreateProvisioningArtifactOutputResponse: Equatable {
    /// <p>Specify the template source with one of the following options, but not both. Keys
    ///          accepted: [ <code>LoadTemplateFromURL</code>, <code>ImportFromPhysicalId</code> ].</p>
    ///          <p>The URL of the CloudFormation template in Amazon S3, in JSON format. </p>
    ///          <p>
    ///             <code>LoadTemplateFromURL</code>
    ///          </p>
    ///          <p>Use the URL of the CloudFormation template in Amazon S3 in JSON format.</p>
    ///          <p>
    ///             <code>ImportFromPhysicalId</code>
    ///          </p>
    ///          <p>Use the physical id of the resource that contains the template; currently supports
    ///          CloudFormation stack ARN.</p>
    public let info: [String:String]?
    /// <p>Information about the provisioning artifact.</p>
    public let provisioningArtifactDetail: ProvisioningArtifactDetail?
    /// <p>The status of the current request.</p>
    public let status: Status?

    public init (
        info: [String:String]? = nil,
        provisioningArtifactDetail: ProvisioningArtifactDetail? = nil,
        status: Status? = nil
    )
    {
        self.info = info
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.status = status
    }
}

struct CreateProvisioningArtifactOutputResponseBody: Equatable {
    public let provisioningArtifactDetail: ProvisioningArtifactDetail?
    public let info: [String:String]?
    public let status: Status?
}

extension CreateProvisioningArtifactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case info = "Info"
        case provisioningArtifactDetail = "ProvisioningArtifactDetail"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactDetailDecoded = try containerValues.decodeIfPresent(ProvisioningArtifactDetail.self, forKey: .provisioningArtifactDetail)
        provisioningArtifactDetail = provisioningArtifactDetailDecoded
        let infoContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .info)
        var infoDecoded0: [String:String]? = nil
        if let infoContainer = infoContainer {
            infoDecoded0 = [String:String]()
            for (key0, provisioningartifactinfovalue0) in infoContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    infoDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        info = infoDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateServiceActionInputBodyMiddleware: Middleware {
    public let id: String = "CreateServiceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceActionInput>
    public typealias MOutput = OperationOutput<CreateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceActionOutputError>
}

extension CreateServiceActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceActionInput(acceptLanguage: \(String(describing: acceptLanguage)), definition: \(String(describing: definition)), definitionType: \(String(describing: definitionType)), description: \(String(describing: description)), idempotencyToken: \(String(describing: idempotencyToken)), name: \(String(describing: name)))"}
}

extension CreateServiceActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case definition = "Definition"
        case definitionType = "DefinitionType"
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .definition)
            for (dictKey0, serviceactiondefinitionmap0) in definition {
                try definitionContainer.encode(serviceactiondefinitionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let definitionType = definitionType {
            try encodeContainer.encode(definitionType.rawValue, forKey: .definitionType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateServiceActionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateServiceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceActionInput>
    public typealias MOutput = OperationOutput<CreateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceActionOutputError>
}

public struct CreateServiceActionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateServiceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceActionInput>
    public typealias MOutput = OperationOutput<CreateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceActionOutputError>
}

public struct CreateServiceActionInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The self-service action definition. Can be one of the following:</p>
    ///          <dl>
    ///             <dt>Name</dt>
    ///             <dd>
    ///                <p>The name of the AWS Systems Manager document (SSM document). For example, <code>AWS-RestartEC2Instance</code>.</p>
    ///                <p>If you are using a shared SSM document, you must provide the ARN instead of the name.</p>
    ///             </dd>
    ///             <dt>Version</dt>
    ///             <dd>
    ///                <p>The AWS Systems Manager automation document version. For example, <code>"Version": "1"</code>
    ///                </p>
    ///             </dd>
    ///             <dt>AssumeRole</dt>
    ///             <dd>
    ///                <p>The Amazon Resource Name (ARN) of the role that performs the self-service actions on your behalf. For example, <code>"AssumeRole": "arn:aws:iam::12345678910:role/ActionRole"</code>.</p>
    ///                <p>To reuse the provisioned product launch role, set to <code>"AssumeRole": "LAUNCH_ROLE"</code>.</p>
    ///             </dd>
    ///             <dt>Parameters</dt>
    ///             <dd>
    ///                <p>The list of parameters in JSON format.</p>
    ///                <p>For example: <code>[{\"Name\":\"InstanceId\",\"Type\":\"TARGET\"}]</code> or <code>[{\"Name\":\"InstanceId\",\"Type\":\"TEXT_VALUE\"}]</code>.</p>
    ///             </dd>
    ///          </dl>
    public let definition: [String:String]?
    /// <p>The service action definition type. For example, <code>SSM_AUTOMATION</code>.</p>
    public let definitionType: ServiceActionDefinitionType?
    /// <p>The self-service action description.</p>
    public let description: String?
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.</p>
    public var idempotencyToken: String?
    /// <p>The self-service action name.</p>
    public let name: String?

    public init (
        acceptLanguage: String? = nil,
        definition: [String:String]? = nil,
        definitionType: ServiceActionDefinitionType? = nil,
        description: String? = nil,
        idempotencyToken: String? = nil,
        name: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.definition = definition
        self.definitionType = definitionType
        self.description = description
        self.idempotencyToken = idempotencyToken
        self.name = name
    }
}

struct CreateServiceActionInputBody: Equatable {
    public let name: String?
    public let definitionType: ServiceActionDefinitionType?
    public let definition: [String:String]?
    public let description: String?
    public let acceptLanguage: String?
    public let idempotencyToken: String?
}

extension CreateServiceActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case definition = "Definition"
        case definitionType = "DefinitionType"
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let definitionTypeDecoded = try containerValues.decodeIfPresent(ServiceActionDefinitionType.self, forKey: .definitionType)
        definitionType = definitionTypeDecoded
        let definitionContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .definition)
        var definitionDecoded0: [String:String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [String:String]()
            for (key0, serviceactiondefinitionvalue0) in definitionContainer {
                if let serviceactiondefinitionvalue0 = serviceactiondefinitionvalue0 {
                    definitionDecoded0?[key0] = serviceactiondefinitionvalue0
                }
            }
        }
        definition = definitionDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateServiceActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceActionOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceActionOutputResponse(serviceActionDetail: \(String(describing: serviceActionDetail)))"}
}

extension CreateServiceActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateServiceActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceActionDetail = output.serviceActionDetail
        } else {
            self.serviceActionDetail = nil
        }
    }
}

public struct CreateServiceActionOutputResponse: Equatable {
    /// <p>An object containing information about the self-service action.</p>
    public let serviceActionDetail: ServiceActionDetail?

    public init (
        serviceActionDetail: ServiceActionDetail? = nil
    )
    {
        self.serviceActionDetail = serviceActionDetail
    }
}

struct CreateServiceActionOutputResponseBody: Equatable {
    public let serviceActionDetail: ServiceActionDetail?
}

extension CreateServiceActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceActionDetail = "ServiceActionDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionDetailDecoded = try containerValues.decodeIfPresent(ServiceActionDetail.self, forKey: .serviceActionDetail)
        serviceActionDetail = serviceActionDetailDecoded
    }
}

public struct CreateTagOptionInputBodyMiddleware: Middleware {
    public let id: String = "CreateTagOptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagOptionInput>
    public typealias MOutput = OperationOutput<CreateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagOptionOutputError>
}

extension CreateTagOptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTagOptionInput(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

extension CreateTagOptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

public struct CreateTagOptionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTagOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagOptionInput>
    public typealias MOutput = OperationOutput<CreateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagOptionOutputError>
}

public struct CreateTagOptionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTagOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagOptionInput>
    public typealias MOutput = OperationOutput<CreateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagOptionOutputError>
}

public struct CreateTagOptionInput: Equatable {
    /// <p>The TagOption key.</p>
    public let key: String?
    /// <p>The TagOption value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

struct CreateTagOptionInputBody: Equatable {
    public let key: String?
    public let value: String?
}

extension CreateTagOptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CreateTagOptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTagOptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTagOptionOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case limitExceededException(LimitExceededException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagOptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTagOptionOutputResponse(tagOptionDetail: \(String(describing: tagOptionDetail)))"}
}

extension CreateTagOptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTagOptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagOptionDetail = output.tagOptionDetail
        } else {
            self.tagOptionDetail = nil
        }
    }
}

public struct CreateTagOptionOutputResponse: Equatable {
    /// <p>Information about the TagOption.</p>
    public let tagOptionDetail: TagOptionDetail?

    public init (
        tagOptionDetail: TagOptionDetail? = nil
    )
    {
        self.tagOptionDetail = tagOptionDetail
    }
}

struct CreateTagOptionOutputResponseBody: Equatable {
    public let tagOptionDetail: TagOptionDetail?
}

extension CreateTagOptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagOptionDetail = "TagOptionDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagOptionDetailDecoded = try containerValues.decodeIfPresent(TagOptionDetail.self, forKey: .tagOptionDetail)
        tagOptionDetail = tagOptionDetailDecoded
    }
}

public struct DeleteConstraintInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConstraintInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConstraintInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConstraintInput>
    public typealias MOutput = OperationOutput<DeleteConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConstraintOutputError>
}

extension DeleteConstraintInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConstraintInput(acceptLanguage: \(String(describing: acceptLanguage)), id: \(String(describing: id)))"}
}

extension DeleteConstraintInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteConstraintInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConstraintInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConstraintInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConstraintInput>
    public typealias MOutput = OperationOutput<DeleteConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConstraintOutputError>
}

public struct DeleteConstraintInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConstraintInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConstraintInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConstraintInput>
    public typealias MOutput = OperationOutput<DeleteConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConstraintOutputError>
}

public struct DeleteConstraintInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The identifier of the constraint.</p>
    public let id: String?

    public init (
        acceptLanguage: String? = nil,
        id: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DeleteConstraintInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
}

extension DeleteConstraintInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteConstraintOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConstraintOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConstraintOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConstraintOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConstraintOutputResponse()"}
}

extension DeleteConstraintOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConstraintOutputResponse: Equatable {

    public init() {}
}

struct DeleteConstraintOutputResponseBody: Equatable {
}

extension DeleteConstraintOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePortfolioInputBodyMiddleware: Middleware {
    public let id: String = "DeletePortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePortfolioInput>
    public typealias MOutput = OperationOutput<DeletePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePortfolioOutputError>
}

extension DeletePortfolioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePortfolioInput(acceptLanguage: \(String(describing: acceptLanguage)), id: \(String(describing: id)))"}
}

extension DeletePortfolioInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeletePortfolioInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePortfolioInput>
    public typealias MOutput = OperationOutput<DeletePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePortfolioOutputError>
}

public struct DeletePortfolioInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePortfolioInput>
    public typealias MOutput = OperationOutput<DeletePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePortfolioOutputError>
}

public struct DeletePortfolioInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The portfolio identifier.</p>
    public let id: String?

    public init (
        acceptLanguage: String? = nil,
        id: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DeletePortfolioInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
}

extension DeletePortfolioInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeletePortfolioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePortfolioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePortfolioOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePortfolioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePortfolioOutputResponse()"}
}

extension DeletePortfolioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePortfolioOutputResponse: Equatable {

    public init() {}
}

struct DeletePortfolioOutputResponseBody: Equatable {
}

extension DeletePortfolioOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePortfolioShareInputBodyMiddleware: Middleware {
    public let id: String = "DeletePortfolioShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePortfolioShareInput>
    public typealias MOutput = OperationOutput<DeletePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePortfolioShareOutputError>
}

extension DeletePortfolioShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePortfolioShareInput(acceptLanguage: \(String(describing: acceptLanguage)), accountId: \(String(describing: accountId)), organizationNode: \(String(describing: organizationNode)), portfolioId: \(String(describing: portfolioId)))"}
}

extension DeletePortfolioShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let organizationNode = organizationNode {
            try encodeContainer.encode(organizationNode, forKey: .organizationNode)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
    }
}

public struct DeletePortfolioShareInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePortfolioShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePortfolioShareInput>
    public typealias MOutput = OperationOutput<DeletePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePortfolioShareOutputError>
}

public struct DeletePortfolioShareInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePortfolioShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePortfolioShareInput>
    public typealias MOutput = OperationOutput<DeletePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePortfolioShareOutputError>
}

public struct DeletePortfolioShareInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The AWS account ID.</p>
    public let accountId: String?
    /// <p>The organization node to whom you are going to stop sharing.</p>
    public let organizationNode: OrganizationNode?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?

    public init (
        acceptLanguage: String? = nil,
        accountId: String? = nil,
        organizationNode: OrganizationNode? = nil,
        portfolioId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accountId = accountId
        self.organizationNode = organizationNode
        self.portfolioId = portfolioId
    }
}

struct DeletePortfolioShareInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let accountId: String?
    public let organizationNode: OrganizationNode?
}

extension DeletePortfolioShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationNodeDecoded = try containerValues.decodeIfPresent(OrganizationNode.self, forKey: .organizationNode)
        organizationNode = organizationNodeDecoded
    }
}

extension DeletePortfolioShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePortfolioShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePortfolioShareOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePortfolioShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePortfolioShareOutputResponse(portfolioShareToken: \(String(describing: portfolioShareToken)))"}
}

extension DeletePortfolioShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeletePortfolioShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.portfolioShareToken = output.portfolioShareToken
        } else {
            self.portfolioShareToken = nil
        }
    }
}

public struct DeletePortfolioShareOutputResponse: Equatable {
    /// <p>The portfolio share unique identifier. This will only be returned if delete is made to an organization node.</p>
    public let portfolioShareToken: String?

    public init (
        portfolioShareToken: String? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
    }
}

struct DeletePortfolioShareOutputResponseBody: Equatable {
    public let portfolioShareToken: String?
}

extension DeletePortfolioShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
    }
}

public struct DeleteProductInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProductInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProductInput>
    public typealias MOutput = OperationOutput<DeleteProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProductOutputError>
}

extension DeleteProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProductInput(acceptLanguage: \(String(describing: acceptLanguage)), id: \(String(describing: id)))"}
}

extension DeleteProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteProductInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProductInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProductInput>
    public typealias MOutput = OperationOutput<DeleteProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProductOutputError>
}

public struct DeleteProductInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProductInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProductInput>
    public typealias MOutput = OperationOutput<DeleteProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProductOutputError>
}

public struct DeleteProductInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The product identifier.</p>
    public let id: String?

    public init (
        acceptLanguage: String? = nil,
        id: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DeleteProductInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
}

extension DeleteProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProductOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProductOutputResponse()"}
}

extension DeleteProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProductOutputResponse: Equatable {

    public init() {}
}

struct DeleteProductOutputResponseBody: Equatable {
}

extension DeleteProductOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteProvisionedProductPlanInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProvisionedProductPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProvisionedProductPlanInput>
    public typealias MOutput = OperationOutput<DeleteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProvisionedProductPlanOutputError>
}

extension DeleteProvisionedProductPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProvisionedProductPlanInput(acceptLanguage: \(String(describing: acceptLanguage)), ignoreErrors: \(String(describing: ignoreErrors)), planId: \(String(describing: planId)))"}
}

extension DeleteProvisionedProductPlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case ignoreErrors = "IgnoreErrors"
        case planId = "PlanId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if ignoreErrors != false {
            try encodeContainer.encode(ignoreErrors, forKey: .ignoreErrors)
        }
        if let planId = planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
    }
}

public struct DeleteProvisionedProductPlanInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProvisionedProductPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProvisionedProductPlanInput>
    public typealias MOutput = OperationOutput<DeleteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProvisionedProductPlanOutputError>
}

public struct DeleteProvisionedProductPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProvisionedProductPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProvisionedProductPlanInput>
    public typealias MOutput = OperationOutput<DeleteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProvisionedProductPlanOutputError>
}

public struct DeleteProvisionedProductPlanInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>If set to true, AWS Service Catalog stops managing the specified provisioned product even
    ///          if it cannot delete the underlying resources.</p>
    public let ignoreErrors: Bool
    /// <p>The plan identifier.</p>
    public let planId: String?

    public init (
        acceptLanguage: String? = nil,
        ignoreErrors: Bool = false,
        planId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.ignoreErrors = ignoreErrors
        self.planId = planId
    }
}

struct DeleteProvisionedProductPlanInputBody: Equatable {
    public let acceptLanguage: String?
    public let planId: String?
    public let ignoreErrors: Bool
}

extension DeleteProvisionedProductPlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case ignoreErrors = "IgnoreErrors"
        case planId = "PlanId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .planId)
        planId = planIdDecoded
        let ignoreErrorsDecoded = try containerValues.decode(Bool.self, forKey: .ignoreErrors)
        ignoreErrors = ignoreErrorsDecoded
    }
}

extension DeleteProvisionedProductPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProvisionedProductPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProvisionedProductPlanOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProvisionedProductPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProvisionedProductPlanOutputResponse()"}
}

extension DeleteProvisionedProductPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProvisionedProductPlanOutputResponse: Equatable {

    public init() {}
}

struct DeleteProvisionedProductPlanOutputResponseBody: Equatable {
}

extension DeleteProvisionedProductPlanOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteProvisioningArtifactInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<DeleteProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProvisioningArtifactOutputError>
}

extension DeleteProvisioningArtifactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProvisioningArtifactInput(acceptLanguage: \(String(describing: acceptLanguage)), productId: \(String(describing: productId)), provisioningArtifactId: \(String(describing: provisioningArtifactId)))"}
}

extension DeleteProvisioningArtifactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }
}

public struct DeleteProvisioningArtifactInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<DeleteProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProvisioningArtifactOutputError>
}

public struct DeleteProvisioningArtifactInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<DeleteProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProvisioningArtifactOutputError>
}

public struct DeleteProvisioningArtifactInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The product identifier.</p>
    public let productId: String?
    /// <p>The identifier of the provisioning artifact.</p>
    public let provisioningArtifactId: String?

    public init (
        acceptLanguage: String? = nil,
        productId: String? = nil,
        provisioningArtifactId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct DeleteProvisioningArtifactInputBody: Equatable {
    public let acceptLanguage: String?
    public let productId: String?
    public let provisioningArtifactId: String?
}

extension DeleteProvisioningArtifactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
    }
}

extension DeleteProvisioningArtifactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProvisioningArtifactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProvisioningArtifactOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProvisioningArtifactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProvisioningArtifactOutputResponse()"}
}

extension DeleteProvisioningArtifactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProvisioningArtifactOutputResponse: Equatable {

    public init() {}
}

struct DeleteProvisioningArtifactOutputResponseBody: Equatable {
}

extension DeleteProvisioningArtifactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteServiceActionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteServiceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceActionInput>
    public typealias MOutput = OperationOutput<DeleteServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceActionOutputError>
}

extension DeleteServiceActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceActionInput(acceptLanguage: \(String(describing: acceptLanguage)), id: \(String(describing: id)))"}
}

extension DeleteServiceActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteServiceActionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteServiceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceActionInput>
    public typealias MOutput = OperationOutput<DeleteServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceActionOutputError>
}

public struct DeleteServiceActionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteServiceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceActionInput>
    public typealias MOutput = OperationOutput<DeleteServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceActionOutputError>
}

public struct DeleteServiceActionInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
    public let id: String?

    public init (
        acceptLanguage: String? = nil,
        id: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DeleteServiceActionInputBody: Equatable {
    public let id: String?
    public let acceptLanguage: String?
}

extension DeleteServiceActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension DeleteServiceActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceActionOutputError: Equatable {
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceActionOutputResponse()"}
}

extension DeleteServiceActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceActionOutputResponse: Equatable {

    public init() {}
}

struct DeleteServiceActionOutputResponseBody: Equatable {
}

extension DeleteServiceActionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteTagOptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagOptionInput(id: \(String(describing: id)))"}
}

extension DeleteTagOptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteTagOptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTagOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagOptionInput>
    public typealias MOutput = OperationOutput<DeleteTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagOptionOutputError>
}

public struct DeleteTagOptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTagOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagOptionInput>
    public typealias MOutput = OperationOutput<DeleteTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagOptionOutputError>
}

public struct DeleteTagOptionInput: Equatable {
    /// <p>The TagOption identifier.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteTagOptionInputBody: Equatable {
}

extension DeleteTagOptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteTagOptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagOptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagOptionOutputError: Equatable {
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagOptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagOptionOutputResponse()"}
}

extension DeleteTagOptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagOptionOutputResponse: Equatable {

    public init() {}
}

struct DeleteTagOptionOutputResponseBody: Equatable {
}

extension DeleteTagOptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeConstraintInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConstraintInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConstraintInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConstraintInput>
    public typealias MOutput = OperationOutput<DescribeConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConstraintOutputError>
}

extension DescribeConstraintInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConstraintInput(acceptLanguage: \(String(describing: acceptLanguage)), id: \(String(describing: id)))"}
}

extension DescribeConstraintInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribeConstraintInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConstraintInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConstraintInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConstraintInput>
    public typealias MOutput = OperationOutput<DescribeConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConstraintOutputError>
}

public struct DescribeConstraintInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConstraintInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConstraintInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConstraintInput>
    public typealias MOutput = OperationOutput<DescribeConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConstraintOutputError>
}

public struct DescribeConstraintInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The identifier of the constraint.</p>
    public let id: String?

    public init (
        acceptLanguage: String? = nil,
        id: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DescribeConstraintInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
}

extension DescribeConstraintInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeConstraintOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConstraintOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConstraintOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConstraintOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConstraintOutputResponse(constraintDetail: \(String(describing: constraintDetail)), constraintParameters: \(String(describing: constraintParameters)), status: \(String(describing: status)))"}
}

extension DescribeConstraintOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConstraintOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.constraintDetail = output.constraintDetail
            self.constraintParameters = output.constraintParameters
            self.status = output.status
        } else {
            self.constraintDetail = nil
            self.constraintParameters = nil
            self.status = nil
        }
    }
}

public struct DescribeConstraintOutputResponse: Equatable {
    /// <p>Information about the constraint.</p>
    public let constraintDetail: ConstraintDetail?
    /// <p>The constraint parameters.</p>
    public let constraintParameters: String?
    /// <p>The status of the current request.</p>
    public let status: Status?

    public init (
        constraintDetail: ConstraintDetail? = nil,
        constraintParameters: String? = nil,
        status: Status? = nil
    )
    {
        self.constraintDetail = constraintDetail
        self.constraintParameters = constraintParameters
        self.status = status
    }
}

struct DescribeConstraintOutputResponseBody: Equatable {
    public let constraintDetail: ConstraintDetail?
    public let constraintParameters: String?
    public let status: Status?
}

extension DescribeConstraintOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case constraintDetail = "ConstraintDetail"
        case constraintParameters = "ConstraintParameters"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDetailDecoded = try containerValues.decodeIfPresent(ConstraintDetail.self, forKey: .constraintDetail)
        constraintDetail = constraintDetailDecoded
        let constraintParametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .constraintParameters)
        constraintParameters = constraintParametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DescribeCopyProductStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCopyProductStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCopyProductStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCopyProductStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCopyProductStatusInput>
    public typealias MOutput = OperationOutput<DescribeCopyProductStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCopyProductStatusOutputError>
}

extension DescribeCopyProductStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCopyProductStatusInput(acceptLanguage: \(String(describing: acceptLanguage)), copyProductToken: \(String(describing: copyProductToken)))"}
}

extension DescribeCopyProductStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case copyProductToken = "CopyProductToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let copyProductToken = copyProductToken {
            try encodeContainer.encode(copyProductToken, forKey: .copyProductToken)
        }
    }
}

public struct DescribeCopyProductStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCopyProductStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCopyProductStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCopyProductStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCopyProductStatusInput>
    public typealias MOutput = OperationOutput<DescribeCopyProductStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCopyProductStatusOutputError>
}

public struct DescribeCopyProductStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCopyProductStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCopyProductStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCopyProductStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCopyProductStatusInput>
    public typealias MOutput = OperationOutput<DescribeCopyProductStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCopyProductStatusOutputError>
}

public struct DescribeCopyProductStatusInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The token for the copy product operation. This token is returned by <a>CopyProduct</a>.</p>
    public let copyProductToken: String?

    public init (
        acceptLanguage: String? = nil,
        copyProductToken: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.copyProductToken = copyProductToken
    }
}

struct DescribeCopyProductStatusInputBody: Equatable {
    public let acceptLanguage: String?
    public let copyProductToken: String?
}

extension DescribeCopyProductStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case copyProductToken = "CopyProductToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let copyProductTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .copyProductToken)
        copyProductToken = copyProductTokenDecoded
    }
}

extension DescribeCopyProductStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCopyProductStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCopyProductStatusOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCopyProductStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCopyProductStatusOutputResponse(copyProductStatus: \(String(describing: copyProductStatus)), statusDetail: \(String(describing: statusDetail)), targetProductId: \(String(describing: targetProductId)))"}
}

extension DescribeCopyProductStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCopyProductStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.copyProductStatus = output.copyProductStatus
            self.statusDetail = output.statusDetail
            self.targetProductId = output.targetProductId
        } else {
            self.copyProductStatus = nil
            self.statusDetail = nil
            self.targetProductId = nil
        }
    }
}

public struct DescribeCopyProductStatusOutputResponse: Equatable {
    /// <p>The status of the copy product operation.</p>
    public let copyProductStatus: CopyProductStatus?
    /// <p>The status message.</p>
    public let statusDetail: String?
    /// <p>The identifier of the copied product.</p>
    public let targetProductId: String?

    public init (
        copyProductStatus: CopyProductStatus? = nil,
        statusDetail: String? = nil,
        targetProductId: String? = nil
    )
    {
        self.copyProductStatus = copyProductStatus
        self.statusDetail = statusDetail
        self.targetProductId = targetProductId
    }
}

struct DescribeCopyProductStatusOutputResponseBody: Equatable {
    public let copyProductStatus: CopyProductStatus?
    public let targetProductId: String?
    public let statusDetail: String?
}

extension DescribeCopyProductStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case copyProductStatus = "CopyProductStatus"
        case statusDetail = "StatusDetail"
        case targetProductId = "TargetProductId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyProductStatusDecoded = try containerValues.decodeIfPresent(CopyProductStatus.self, forKey: .copyProductStatus)
        copyProductStatus = copyProductStatusDecoded
        let targetProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetProductId)
        targetProductId = targetProductIdDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
    }
}

public struct DescribePortfolioInputBodyMiddleware: Middleware {
    public let id: String = "DescribePortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePortfolioInput>
    public typealias MOutput = OperationOutput<DescribePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePortfolioOutputError>
}

extension DescribePortfolioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePortfolioInput(acceptLanguage: \(String(describing: acceptLanguage)), id: \(String(describing: id)))"}
}

extension DescribePortfolioInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribePortfolioInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePortfolioInput>
    public typealias MOutput = OperationOutput<DescribePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePortfolioOutputError>
}

public struct DescribePortfolioInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePortfolioInput>
    public typealias MOutput = OperationOutput<DescribePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePortfolioOutputError>
}

public struct DescribePortfolioInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The portfolio identifier.</p>
    public let id: String?

    public init (
        acceptLanguage: String? = nil,
        id: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DescribePortfolioInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
}

extension DescribePortfolioInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribePortfolioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePortfolioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePortfolioOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePortfolioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePortfolioOutputResponse(budgets: \(String(describing: budgets)), portfolioDetail: \(String(describing: portfolioDetail)), tagOptions: \(String(describing: tagOptions)), tags: \(String(describing: tags)))"}
}

extension DescribePortfolioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePortfolioOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.budgets = output.budgets
            self.portfolioDetail = output.portfolioDetail
            self.tagOptions = output.tagOptions
            self.tags = output.tags
        } else {
            self.budgets = nil
            self.portfolioDetail = nil
            self.tagOptions = nil
            self.tags = nil
        }
    }
}

public struct DescribePortfolioOutputResponse: Equatable {
    /// <p>Information about the associated budgets.</p>
    public let budgets: [BudgetDetail]?
    /// <p>Information about the portfolio.</p>
    public let portfolioDetail: PortfolioDetail?
    /// <p>Information about the TagOptions associated with the portfolio.</p>
    public let tagOptions: [TagOptionDetail]?
    /// <p>Information about the tags associated with the portfolio.</p>
    public let tags: [Tag]?

    public init (
        budgets: [BudgetDetail]? = nil,
        portfolioDetail: PortfolioDetail? = nil,
        tagOptions: [TagOptionDetail]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.budgets = budgets
        self.portfolioDetail = portfolioDetail
        self.tagOptions = tagOptions
        self.tags = tags
    }
}

struct DescribePortfolioOutputResponseBody: Equatable {
    public let portfolioDetail: PortfolioDetail?
    public let tags: [Tag]?
    public let tagOptions: [TagOptionDetail]?
    public let budgets: [BudgetDetail]?
}

extension DescribePortfolioOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case budgets = "Budgets"
        case portfolioDetail = "PortfolioDetail"
        case tagOptions = "TagOptions"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailDecoded = try containerValues.decodeIfPresent(PortfolioDetail.self, forKey: .portfolioDetail)
        portfolioDetail = portfolioDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let tagOptionsContainer = try containerValues.decodeIfPresent([TagOptionDetail?].self, forKey: .tagOptions)
        var tagOptionsDecoded0:[TagOptionDetail]? = nil
        if let tagOptionsContainer = tagOptionsContainer {
            tagOptionsDecoded0 = [TagOptionDetail]()
            for structure0 in tagOptionsContainer {
                if let structure0 = structure0 {
                    tagOptionsDecoded0?.append(structure0)
                }
            }
        }
        tagOptions = tagOptionsDecoded0
        let budgetsContainer = try containerValues.decodeIfPresent([BudgetDetail?].self, forKey: .budgets)
        var budgetsDecoded0:[BudgetDetail]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [BudgetDetail]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
    }
}

public struct DescribePortfolioShareStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribePortfolioShareStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePortfolioShareStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePortfolioShareStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePortfolioShareStatusInput>
    public typealias MOutput = OperationOutput<DescribePortfolioShareStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePortfolioShareStatusOutputError>
}

extension DescribePortfolioShareStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePortfolioShareStatusInput(portfolioShareToken: \(String(describing: portfolioShareToken)))"}
}

extension DescribePortfolioShareStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portfolioShareToken = portfolioShareToken {
            try encodeContainer.encode(portfolioShareToken, forKey: .portfolioShareToken)
        }
    }
}

public struct DescribePortfolioShareStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePortfolioShareStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePortfolioShareStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePortfolioShareStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePortfolioShareStatusInput>
    public typealias MOutput = OperationOutput<DescribePortfolioShareStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePortfolioShareStatusOutputError>
}

public struct DescribePortfolioShareStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePortfolioShareStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePortfolioShareStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePortfolioShareStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePortfolioShareStatusInput>
    public typealias MOutput = OperationOutput<DescribePortfolioShareStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePortfolioShareStatusOutputError>
}

public struct DescribePortfolioShareStatusInput: Equatable {
    /// <p>The token for the portfolio share operation. This token is returned either by CreatePortfolioShare or by DeletePortfolioShare.</p>
    public let portfolioShareToken: String?

    public init (
        portfolioShareToken: String? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
    }
}

struct DescribePortfolioShareStatusInputBody: Equatable {
    public let portfolioShareToken: String?
}

extension DescribePortfolioShareStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
    }
}

extension DescribePortfolioShareStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePortfolioShareStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePortfolioShareStatusOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePortfolioShareStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePortfolioShareStatusOutputResponse(organizationNodeValue: \(String(describing: organizationNodeValue)), portfolioId: \(String(describing: portfolioId)), portfolioShareToken: \(String(describing: portfolioShareToken)), shareDetails: \(String(describing: shareDetails)), status: \(String(describing: status)))"}
}

extension DescribePortfolioShareStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePortfolioShareStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.organizationNodeValue = output.organizationNodeValue
            self.portfolioId = output.portfolioId
            self.portfolioShareToken = output.portfolioShareToken
            self.shareDetails = output.shareDetails
            self.status = output.status
        } else {
            self.organizationNodeValue = nil
            self.portfolioId = nil
            self.portfolioShareToken = nil
            self.shareDetails = nil
            self.status = nil
        }
    }
}

public struct DescribePortfolioShareStatusOutputResponse: Equatable {
    /// <p>Organization node identifier. It can be either account id, organizational unit id or organization id.</p>
    public let organizationNodeValue: String?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?
    /// <p>The token for the portfolio share operation. For example, <code>share-6v24abcdefghi</code>.</p>
    public let portfolioShareToken: String?
    /// <p>Information about the portfolio share operation.</p>
    public let shareDetails: ShareDetails?
    /// <p>Status of the portfolio share operation.</p>
    public let status: ShareStatus?

    public init (
        organizationNodeValue: String? = nil,
        portfolioId: String? = nil,
        portfolioShareToken: String? = nil,
        shareDetails: ShareDetails? = nil,
        status: ShareStatus? = nil
    )
    {
        self.organizationNodeValue = organizationNodeValue
        self.portfolioId = portfolioId
        self.portfolioShareToken = portfolioShareToken
        self.shareDetails = shareDetails
        self.status = status
    }
}

struct DescribePortfolioShareStatusOutputResponseBody: Equatable {
    public let portfolioShareToken: String?
    public let portfolioId: String?
    public let organizationNodeValue: String?
    public let status: ShareStatus?
    public let shareDetails: ShareDetails?
}

extension DescribePortfolioShareStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationNodeValue = "OrganizationNodeValue"
        case portfolioId = "PortfolioId"
        case portfolioShareToken = "PortfolioShareToken"
        case shareDetails = "ShareDetails"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let organizationNodeValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationNodeValue)
        organizationNodeValue = organizationNodeValueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ShareStatus.self, forKey: .status)
        status = statusDecoded
        let shareDetailsDecoded = try containerValues.decodeIfPresent(ShareDetails.self, forKey: .shareDetails)
        shareDetails = shareDetailsDecoded
    }
}

public enum DescribePortfolioShareType {
    case account
    case organization
    case organizationalUnit
    case organizationMemberAccount
    case sdkUnknown(String)
}

extension DescribePortfolioShareType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DescribePortfolioShareType] {
        return [
            .account,
            .organization,
            .organizationalUnit,
            .organizationMemberAccount,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .account: return "ACCOUNT"
        case .organization: return "ORGANIZATION"
        case .organizationalUnit: return "ORGANIZATIONAL_UNIT"
        case .organizationMemberAccount: return "ORGANIZATION_MEMBER_ACCOUNT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DescribePortfolioShareType(rawValue: rawValue) ?? DescribePortfolioShareType.sdkUnknown(rawValue)
    }
}

public struct DescribePortfolioSharesInputBodyMiddleware: Middleware {
    public let id: String = "DescribePortfolioSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePortfolioSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePortfolioSharesInput>
    public typealias MOutput = OperationOutput<DescribePortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePortfolioSharesOutputError>
}

extension DescribePortfolioSharesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePortfolioSharesInput(pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), portfolioId: \(String(describing: portfolioId)), type: \(String(describing: type)))"}
}

extension DescribePortfolioSharesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct DescribePortfolioSharesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePortfolioSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePortfolioSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePortfolioSharesInput>
    public typealias MOutput = OperationOutput<DescribePortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePortfolioSharesOutputError>
}

public struct DescribePortfolioSharesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePortfolioSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePortfolioSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePortfolioSharesInput>
    public typealias MOutput = OperationOutput<DescribePortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePortfolioSharesOutputError>
}

public struct DescribePortfolioSharesInput: Equatable {
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The unique identifier of the portfolio for which shares will be retrieved.</p>
    public let portfolioId: String?
    /// <p>The type of portfolio share to summarize. This field acts as a filter on the type of portfolio share, which can be one of the following:</p>
    ///          <p>1. <code>ACCOUNT</code> - Represents an external account to account share.</p>
    ///          <p>2. <code>ORGANIZATION</code> - Represents a share to an organization. This share is available to every account in the organization.</p>
    ///          <p>3. <code>ORGANIZATIONAL_UNIT</code> - Represents a share to an organizational unit.</p>
    ///          <p>4. <code>ORGANIZATION_MEMBER_ACCOUNT</code> - Represents a share to an account in the organization.</p>
    public let type: DescribePortfolioShareType?

    public init (
        pageSize: Int = 0,
        pageToken: String? = nil,
        portfolioId: String? = nil,
        type: DescribePortfolioShareType? = nil
    )
    {
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
        self.type = type
    }
}

struct DescribePortfolioSharesInputBody: Equatable {
    public let portfolioId: String?
    public let type: DescribePortfolioShareType?
    public let pageToken: String?
    public let pageSize: Int
}

extension DescribePortfolioSharesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DescribePortfolioShareType.self, forKey: .type)
        type = typeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension DescribePortfolioSharesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePortfolioSharesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePortfolioSharesOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePortfolioSharesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePortfolioSharesOutputResponse(nextPageToken: \(String(describing: nextPageToken)), portfolioShareDetails: \(String(describing: portfolioShareDetails)))"}
}

extension DescribePortfolioSharesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePortfolioSharesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.portfolioShareDetails = output.portfolioShareDetails
        } else {
            self.nextPageToken = nil
            self.portfolioShareDetails = nil
        }
    }
}

public struct DescribePortfolioSharesOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Summaries about each of the portfolio shares.</p>
    public let portfolioShareDetails: [PortfolioShareDetail]?

    public init (
        nextPageToken: String? = nil,
        portfolioShareDetails: [PortfolioShareDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioShareDetails = portfolioShareDetails
    }
}

struct DescribePortfolioSharesOutputResponseBody: Equatable {
    public let nextPageToken: String?
    public let portfolioShareDetails: [PortfolioShareDetail]?
}

extension DescribePortfolioSharesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case portfolioShareDetails = "PortfolioShareDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let portfolioShareDetailsContainer = try containerValues.decodeIfPresent([PortfolioShareDetail?].self, forKey: .portfolioShareDetails)
        var portfolioShareDetailsDecoded0:[PortfolioShareDetail]? = nil
        if let portfolioShareDetailsContainer = portfolioShareDetailsContainer {
            portfolioShareDetailsDecoded0 = [PortfolioShareDetail]()
            for structure0 in portfolioShareDetailsContainer {
                if let structure0 = structure0 {
                    portfolioShareDetailsDecoded0?.append(structure0)
                }
            }
        }
        portfolioShareDetails = portfolioShareDetailsDecoded0
    }
}

public struct DescribeProductAsAdminInputBodyMiddleware: Middleware {
    public let id: String = "DescribeProductAsAdminInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProductAsAdminInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProductAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProductAsAdminInput>
    public typealias MOutput = OperationOutput<DescribeProductAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProductAsAdminOutputError>
}

extension DescribeProductAsAdminInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProductAsAdminInput(acceptLanguage: \(String(describing: acceptLanguage)), id: \(String(describing: id)), name: \(String(describing: name)), sourcePortfolioId: \(String(describing: sourcePortfolioId)))"}
}

extension DescribeProductAsAdminInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
        case sourcePortfolioId = "SourcePortfolioId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourcePortfolioId = sourcePortfolioId {
            try encodeContainer.encode(sourcePortfolioId, forKey: .sourcePortfolioId)
        }
    }
}

public struct DescribeProductAsAdminInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProductAsAdminInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProductAsAdminInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProductAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProductAsAdminInput>
    public typealias MOutput = OperationOutput<DescribeProductAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProductAsAdminOutputError>
}

public struct DescribeProductAsAdminInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProductAsAdminInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProductAsAdminInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProductAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProductAsAdminInput>
    public typealias MOutput = OperationOutput<DescribeProductAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProductAsAdminOutputError>
}

public struct DescribeProductAsAdminInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The product identifier.</p>
    public let id: String?
    /// <p>The product name.</p>
    public let name: String?
    /// <p>The unique identifier of the shared portfolio that the specified product is associated
    ///          with.</p>
    ///          <p>You can provide this parameter to retrieve the shared TagOptions associated with the
    ///          product. If this parameter is provided and if TagOptions sharing is enabled in the
    ///          portfolio share, the API returns both local and shared TagOptions associated with the
    ///          product. Otherwise only local TagOptions will be returned. </p>
    public let sourcePortfolioId: String?

    public init (
        acceptLanguage: String? = nil,
        id: String? = nil,
        name: String? = nil,
        sourcePortfolioId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.name = name
        self.sourcePortfolioId = sourcePortfolioId
    }
}

struct DescribeProductAsAdminInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
    public let name: String?
    public let sourcePortfolioId: String?
}

extension DescribeProductAsAdminInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
        case sourcePortfolioId = "SourcePortfolioId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sourcePortfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourcePortfolioId)
        sourcePortfolioId = sourcePortfolioIdDecoded
    }
}

extension DescribeProductAsAdminOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProductAsAdminOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProductAsAdminOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProductAsAdminOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProductAsAdminOutputResponse(budgets: \(String(describing: budgets)), productViewDetail: \(String(describing: productViewDetail)), provisioningArtifactSummaries: \(String(describing: provisioningArtifactSummaries)), tagOptions: \(String(describing: tagOptions)), tags: \(String(describing: tags)))"}
}

extension DescribeProductAsAdminOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProductAsAdminOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.budgets = output.budgets
            self.productViewDetail = output.productViewDetail
            self.provisioningArtifactSummaries = output.provisioningArtifactSummaries
            self.tagOptions = output.tagOptions
            self.tags = output.tags
        } else {
            self.budgets = nil
            self.productViewDetail = nil
            self.provisioningArtifactSummaries = nil
            self.tagOptions = nil
            self.tags = nil
        }
    }
}

public struct DescribeProductAsAdminOutputResponse: Equatable {
    /// <p>Information about the associated budgets.</p>
    public let budgets: [BudgetDetail]?
    /// <p>Information about the product view.</p>
    public let productViewDetail: ProductViewDetail?
    /// <p>Information about the provisioning artifacts (also known as versions) for the specified product.</p>
    public let provisioningArtifactSummaries: [ProvisioningArtifactSummary]?
    /// <p>Information about the TagOptions associated with the product.</p>
    public let tagOptions: [TagOptionDetail]?
    /// <p>Information about the tags associated with the product.</p>
    public let tags: [Tag]?

    public init (
        budgets: [BudgetDetail]? = nil,
        productViewDetail: ProductViewDetail? = nil,
        provisioningArtifactSummaries: [ProvisioningArtifactSummary]? = nil,
        tagOptions: [TagOptionDetail]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.budgets = budgets
        self.productViewDetail = productViewDetail
        self.provisioningArtifactSummaries = provisioningArtifactSummaries
        self.tagOptions = tagOptions
        self.tags = tags
    }
}

struct DescribeProductAsAdminOutputResponseBody: Equatable {
    public let productViewDetail: ProductViewDetail?
    public let provisioningArtifactSummaries: [ProvisioningArtifactSummary]?
    public let tags: [Tag]?
    public let tagOptions: [TagOptionDetail]?
    public let budgets: [BudgetDetail]?
}

extension DescribeProductAsAdminOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case budgets = "Budgets"
        case productViewDetail = "ProductViewDetail"
        case provisioningArtifactSummaries = "ProvisioningArtifactSummaries"
        case tagOptions = "TagOptions"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewDetailDecoded = try containerValues.decodeIfPresent(ProductViewDetail.self, forKey: .productViewDetail)
        productViewDetail = productViewDetailDecoded
        let provisioningArtifactSummariesContainer = try containerValues.decodeIfPresent([ProvisioningArtifactSummary?].self, forKey: .provisioningArtifactSummaries)
        var provisioningArtifactSummariesDecoded0:[ProvisioningArtifactSummary]? = nil
        if let provisioningArtifactSummariesContainer = provisioningArtifactSummariesContainer {
            provisioningArtifactSummariesDecoded0 = [ProvisioningArtifactSummary]()
            for structure0 in provisioningArtifactSummariesContainer {
                if let structure0 = structure0 {
                    provisioningArtifactSummariesDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactSummaries = provisioningArtifactSummariesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let tagOptionsContainer = try containerValues.decodeIfPresent([TagOptionDetail?].self, forKey: .tagOptions)
        var tagOptionsDecoded0:[TagOptionDetail]? = nil
        if let tagOptionsContainer = tagOptionsContainer {
            tagOptionsDecoded0 = [TagOptionDetail]()
            for structure0 in tagOptionsContainer {
                if let structure0 = structure0 {
                    tagOptionsDecoded0?.append(structure0)
                }
            }
        }
        tagOptions = tagOptionsDecoded0
        let budgetsContainer = try containerValues.decodeIfPresent([BudgetDetail?].self, forKey: .budgets)
        var budgetsDecoded0:[BudgetDetail]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [BudgetDetail]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
    }
}

public struct DescribeProductInputBodyMiddleware: Middleware {
    public let id: String = "DescribeProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProductInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProductInput>
    public typealias MOutput = OperationOutput<DescribeProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProductOutputError>
}

extension DescribeProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProductInput(acceptLanguage: \(String(describing: acceptLanguage)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

extension DescribeProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeProductInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProductInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProductInput>
    public typealias MOutput = OperationOutput<DescribeProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProductOutputError>
}

public struct DescribeProductInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProductInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProductInput>
    public typealias MOutput = OperationOutput<DescribeProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProductOutputError>
}

public struct DescribeProductInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The product identifier.</p>
    public let id: String?
    /// <p>The product name.</p>
    public let name: String?

    public init (
        acceptLanguage: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.name = name
    }
}

struct DescribeProductInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
    public let name: String?
}

extension DescribeProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProductOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProductOutputResponse(budgets: \(String(describing: budgets)), launchPaths: \(String(describing: launchPaths)), productViewSummary: \(String(describing: productViewSummary)), provisioningArtifacts: \(String(describing: provisioningArtifacts)))"}
}

extension DescribeProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProductOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.budgets = output.budgets
            self.launchPaths = output.launchPaths
            self.productViewSummary = output.productViewSummary
            self.provisioningArtifacts = output.provisioningArtifacts
        } else {
            self.budgets = nil
            self.launchPaths = nil
            self.productViewSummary = nil
            self.provisioningArtifacts = nil
        }
    }
}

public struct DescribeProductOutputResponse: Equatable {
    /// <p>Information about the associated budgets.</p>
    public let budgets: [BudgetDetail]?
    /// <p>Information about the associated launch paths.</p>
    public let launchPaths: [LaunchPath]?
    /// <p>Summary information about the product view.</p>
    public let productViewSummary: ProductViewSummary?
    /// <p>Information about the provisioning artifacts for the specified product.</p>
    public let provisioningArtifacts: [ProvisioningArtifact]?

    public init (
        budgets: [BudgetDetail]? = nil,
        launchPaths: [LaunchPath]? = nil,
        productViewSummary: ProductViewSummary? = nil,
        provisioningArtifacts: [ProvisioningArtifact]? = nil
    )
    {
        self.budgets = budgets
        self.launchPaths = launchPaths
        self.productViewSummary = productViewSummary
        self.provisioningArtifacts = provisioningArtifacts
    }
}

struct DescribeProductOutputResponseBody: Equatable {
    public let productViewSummary: ProductViewSummary?
    public let provisioningArtifacts: [ProvisioningArtifact]?
    public let budgets: [BudgetDetail]?
    public let launchPaths: [LaunchPath]?
}

extension DescribeProductOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case budgets = "Budgets"
        case launchPaths = "LaunchPaths"
        case productViewSummary = "ProductViewSummary"
        case provisioningArtifacts = "ProvisioningArtifacts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummaryDecoded = try containerValues.decodeIfPresent(ProductViewSummary.self, forKey: .productViewSummary)
        productViewSummary = productViewSummaryDecoded
        let provisioningArtifactsContainer = try containerValues.decodeIfPresent([ProvisioningArtifact?].self, forKey: .provisioningArtifacts)
        var provisioningArtifactsDecoded0:[ProvisioningArtifact]? = nil
        if let provisioningArtifactsContainer = provisioningArtifactsContainer {
            provisioningArtifactsDecoded0 = [ProvisioningArtifact]()
            for structure0 in provisioningArtifactsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifacts = provisioningArtifactsDecoded0
        let budgetsContainer = try containerValues.decodeIfPresent([BudgetDetail?].self, forKey: .budgets)
        var budgetsDecoded0:[BudgetDetail]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [BudgetDetail]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
        let launchPathsContainer = try containerValues.decodeIfPresent([LaunchPath?].self, forKey: .launchPaths)
        var launchPathsDecoded0:[LaunchPath]? = nil
        if let launchPathsContainer = launchPathsContainer {
            launchPathsDecoded0 = [LaunchPath]()
            for structure0 in launchPathsContainer {
                if let structure0 = structure0 {
                    launchPathsDecoded0?.append(structure0)
                }
            }
        }
        launchPaths = launchPathsDecoded0
    }
}

public struct DescribeProductViewInputBodyMiddleware: Middleware {
    public let id: String = "DescribeProductViewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProductViewInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProductViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProductViewInput>
    public typealias MOutput = OperationOutput<DescribeProductViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProductViewOutputError>
}

extension DescribeProductViewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProductViewInput(acceptLanguage: \(String(describing: acceptLanguage)), id: \(String(describing: id)))"}
}

extension DescribeProductViewInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribeProductViewInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProductViewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProductViewInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProductViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProductViewInput>
    public typealias MOutput = OperationOutput<DescribeProductViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProductViewOutputError>
}

public struct DescribeProductViewInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProductViewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProductViewInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProductViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProductViewInput>
    public typealias MOutput = OperationOutput<DescribeProductViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProductViewOutputError>
}

public struct DescribeProductViewInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The product view identifier.</p>
    public let id: String?

    public init (
        acceptLanguage: String? = nil,
        id: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DescribeProductViewInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
}

extension DescribeProductViewInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeProductViewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProductViewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProductViewOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProductViewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProductViewOutputResponse(productViewSummary: \(String(describing: productViewSummary)), provisioningArtifacts: \(String(describing: provisioningArtifacts)))"}
}

extension DescribeProductViewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProductViewOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.productViewSummary = output.productViewSummary
            self.provisioningArtifacts = output.provisioningArtifacts
        } else {
            self.productViewSummary = nil
            self.provisioningArtifacts = nil
        }
    }
}

public struct DescribeProductViewOutputResponse: Equatable {
    /// <p>Summary information about the product.</p>
    public let productViewSummary: ProductViewSummary?
    /// <p>Information about the provisioning artifacts for the product.</p>
    public let provisioningArtifacts: [ProvisioningArtifact]?

    public init (
        productViewSummary: ProductViewSummary? = nil,
        provisioningArtifacts: [ProvisioningArtifact]? = nil
    )
    {
        self.productViewSummary = productViewSummary
        self.provisioningArtifacts = provisioningArtifacts
    }
}

struct DescribeProductViewOutputResponseBody: Equatable {
    public let productViewSummary: ProductViewSummary?
    public let provisioningArtifacts: [ProvisioningArtifact]?
}

extension DescribeProductViewOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case productViewSummary = "ProductViewSummary"
        case provisioningArtifacts = "ProvisioningArtifacts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummaryDecoded = try containerValues.decodeIfPresent(ProductViewSummary.self, forKey: .productViewSummary)
        productViewSummary = productViewSummaryDecoded
        let provisioningArtifactsContainer = try containerValues.decodeIfPresent([ProvisioningArtifact?].self, forKey: .provisioningArtifacts)
        var provisioningArtifactsDecoded0:[ProvisioningArtifact]? = nil
        if let provisioningArtifactsContainer = provisioningArtifactsContainer {
            provisioningArtifactsDecoded0 = [ProvisioningArtifact]()
            for structure0 in provisioningArtifactsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifacts = provisioningArtifactsDecoded0
    }
}

public struct DescribeProvisionedProductInputBodyMiddleware: Middleware {
    public let id: String = "DescribeProvisionedProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisionedProductInput>
    public typealias MOutput = OperationOutput<DescribeProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisionedProductOutputError>
}

extension DescribeProvisionedProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProvisionedProductInput(acceptLanguage: \(String(describing: acceptLanguage)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

extension DescribeProvisionedProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeProvisionedProductInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProvisionedProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisionedProductInput>
    public typealias MOutput = OperationOutput<DescribeProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisionedProductOutputError>
}

public struct DescribeProvisionedProductInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProvisionedProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisionedProductInput>
    public typealias MOutput = OperationOutput<DescribeProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisionedProductOutputError>
}

/// DescribeProvisionedProductAPI input structure.
///
///         AcceptLanguage - [Optional]
///         The language code for localization.
///
///         Id - [Optional]
///         The provisioned product identifier.
///
///         Name - [Optional]
///         Another provisioned product identifier. Customers must provide either Id or Name.
public struct DescribeProvisionedProductInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The provisioned product identifier. You must provide the name or ID, but not both.</p>
    ///          <p>If you do not provide a name or ID, or you provide both name and ID, an <code>InvalidParametersException</code> will occur.</p>
    public let id: String?
    /// <p>The name of the provisioned product. You must provide the name or ID, but not both.</p>
    ///          <p>If you do not provide a name or ID, or you provide both name and ID, an <code>InvalidParametersException</code> will occur.</p>
    public let name: String?

    public init (
        acceptLanguage: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.name = name
    }
}

struct DescribeProvisionedProductInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
    public let name: String?
}

extension DescribeProvisionedProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeProvisionedProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProvisionedProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProvisionedProductOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProvisionedProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProvisionedProductOutputResponse(cloudWatchDashboards: \(String(describing: cloudWatchDashboards)), provisionedProductDetail: \(String(describing: provisionedProductDetail)))"}
}

extension DescribeProvisionedProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProvisionedProductOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cloudWatchDashboards = output.cloudWatchDashboards
            self.provisionedProductDetail = output.provisionedProductDetail
        } else {
            self.cloudWatchDashboards = nil
            self.provisionedProductDetail = nil
        }
    }
}

public struct DescribeProvisionedProductOutputResponse: Equatable {
    /// <p>Any CloudWatch dashboards that were created when provisioning the product.</p>
    public let cloudWatchDashboards: [CloudWatchDashboard]?
    /// <p>Information about the provisioned product.</p>
    public let provisionedProductDetail: ProvisionedProductDetail?

    public init (
        cloudWatchDashboards: [CloudWatchDashboard]? = nil,
        provisionedProductDetail: ProvisionedProductDetail? = nil
    )
    {
        self.cloudWatchDashboards = cloudWatchDashboards
        self.provisionedProductDetail = provisionedProductDetail
    }
}

struct DescribeProvisionedProductOutputResponseBody: Equatable {
    public let provisionedProductDetail: ProvisionedProductDetail?
    public let cloudWatchDashboards: [CloudWatchDashboard]?
}

extension DescribeProvisionedProductOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchDashboards = "CloudWatchDashboards"
        case provisionedProductDetail = "ProvisionedProductDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductDetailDecoded = try containerValues.decodeIfPresent(ProvisionedProductDetail.self, forKey: .provisionedProductDetail)
        provisionedProductDetail = provisionedProductDetailDecoded
        let cloudWatchDashboardsContainer = try containerValues.decodeIfPresent([CloudWatchDashboard?].self, forKey: .cloudWatchDashboards)
        var cloudWatchDashboardsDecoded0:[CloudWatchDashboard]? = nil
        if let cloudWatchDashboardsContainer = cloudWatchDashboardsContainer {
            cloudWatchDashboardsDecoded0 = [CloudWatchDashboard]()
            for structure0 in cloudWatchDashboardsContainer {
                if let structure0 = structure0 {
                    cloudWatchDashboardsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchDashboards = cloudWatchDashboardsDecoded0
    }
}

public struct DescribeProvisionedProductPlanInputBodyMiddleware: Middleware {
    public let id: String = "DescribeProvisionedProductPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisionedProductPlanInput>
    public typealias MOutput = OperationOutput<DescribeProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisionedProductPlanOutputError>
}

extension DescribeProvisionedProductPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProvisionedProductPlanInput(acceptLanguage: \(String(describing: acceptLanguage)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), planId: \(String(describing: planId)))"}
}

extension DescribeProvisionedProductPlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case planId = "PlanId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let planId = planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
    }
}

public struct DescribeProvisionedProductPlanInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProvisionedProductPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisionedProductPlanInput>
    public typealias MOutput = OperationOutput<DescribeProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisionedProductPlanOutputError>
}

public struct DescribeProvisionedProductPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProvisionedProductPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisionedProductPlanInput>
    public typealias MOutput = OperationOutput<DescribeProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisionedProductPlanOutputError>
}

public struct DescribeProvisionedProductPlanInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The plan identifier.</p>
    public let planId: String?

    public init (
        acceptLanguage: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        planId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.planId = planId
    }
}

struct DescribeProvisionedProductPlanInputBody: Equatable {
    public let acceptLanguage: String?
    public let planId: String?
    public let pageSize: Int
    public let pageToken: String?
}

extension DescribeProvisionedProductPlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case planId = "PlanId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .planId)
        planId = planIdDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension DescribeProvisionedProductPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProvisionedProductPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProvisionedProductPlanOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProvisionedProductPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProvisionedProductPlanOutputResponse(nextPageToken: \(String(describing: nextPageToken)), provisionedProductPlanDetails: \(String(describing: provisionedProductPlanDetails)), resourceChanges: \(String(describing: resourceChanges)))"}
}

extension DescribeProvisionedProductPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProvisionedProductPlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.provisionedProductPlanDetails = output.provisionedProductPlanDetails
            self.resourceChanges = output.resourceChanges
        } else {
            self.nextPageToken = nil
            self.provisionedProductPlanDetails = nil
            self.resourceChanges = nil
        }
    }
}

public struct DescribeProvisionedProductPlanOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Information about the plan.</p>
    public let provisionedProductPlanDetails: ProvisionedProductPlanDetails?
    /// <p>Information about the resource changes that will occur when the plan is executed.</p>
    public let resourceChanges: [ResourceChange]?

    public init (
        nextPageToken: String? = nil,
        provisionedProductPlanDetails: ProvisionedProductPlanDetails? = nil,
        resourceChanges: [ResourceChange]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProductPlanDetails = provisionedProductPlanDetails
        self.resourceChanges = resourceChanges
    }
}

struct DescribeProvisionedProductPlanOutputResponseBody: Equatable {
    public let provisionedProductPlanDetails: ProvisionedProductPlanDetails?
    public let resourceChanges: [ResourceChange]?
    public let nextPageToken: String?
}

extension DescribeProvisionedProductPlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case provisionedProductPlanDetails = "ProvisionedProductPlanDetails"
        case resourceChanges = "ResourceChanges"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductPlanDetailsDecoded = try containerValues.decodeIfPresent(ProvisionedProductPlanDetails.self, forKey: .provisionedProductPlanDetails)
        provisionedProductPlanDetails = provisionedProductPlanDetailsDecoded
        let resourceChangesContainer = try containerValues.decodeIfPresent([ResourceChange?].self, forKey: .resourceChanges)
        var resourceChangesDecoded0:[ResourceChange]? = nil
        if let resourceChangesContainer = resourceChangesContainer {
            resourceChangesDecoded0 = [ResourceChange]()
            for structure0 in resourceChangesContainer {
                if let structure0 = structure0 {
                    resourceChangesDecoded0?.append(structure0)
                }
            }
        }
        resourceChanges = resourceChangesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct DescribeProvisioningArtifactInputBodyMiddleware: Middleware {
    public let id: String = "DescribeProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<DescribeProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisioningArtifactOutputError>
}

extension DescribeProvisioningArtifactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProvisioningArtifactInput(acceptLanguage: \(String(describing: acceptLanguage)), productId: \(String(describing: productId)), productName: \(String(describing: productName)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), provisioningArtifactName: \(String(describing: provisioningArtifactName)), verbose: \(String(describing: verbose)))"}
}

extension DescribeProvisioningArtifactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case verbose = "Verbose"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
        if verbose != false {
            try encodeContainer.encode(verbose, forKey: .verbose)
        }
    }
}

public struct DescribeProvisioningArtifactInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<DescribeProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisioningArtifactOutputError>
}

public struct DescribeProvisioningArtifactInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<DescribeProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisioningArtifactOutputError>
}

public struct DescribeProvisioningArtifactInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The product identifier.</p>
    public let productId: String?
    /// <p>The product name.</p>
    public let productName: String?
    /// <p>The identifier of the provisioning artifact.</p>
    public let provisioningArtifactId: String?
    /// <p>The provisioning artifact name.</p>
    public let provisioningArtifactName: String?
    /// <p>Indicates whether a verbose level of detail is enabled.</p>
    public let verbose: Bool

    public init (
        acceptLanguage: String? = nil,
        productId: String? = nil,
        productName: String? = nil,
        provisioningArtifactId: String? = nil,
        provisioningArtifactName: String? = nil,
        verbose: Bool = false
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
        self.productName = productName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.verbose = verbose
    }
}

struct DescribeProvisioningArtifactInputBody: Equatable {
    public let acceptLanguage: String?
    public let provisioningArtifactId: String?
    public let productId: String?
    public let provisioningArtifactName: String?
    public let productName: String?
    public let verbose: Bool
}

extension DescribeProvisioningArtifactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case verbose = "Verbose"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productName)
        productName = productNameDecoded
        let verboseDecoded = try containerValues.decode(Bool.self, forKey: .verbose)
        verbose = verboseDecoded
    }
}

extension DescribeProvisioningArtifactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProvisioningArtifactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProvisioningArtifactOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProvisioningArtifactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProvisioningArtifactOutputResponse(info: \(String(describing: info)), provisioningArtifactDetail: \(String(describing: provisioningArtifactDetail)), status: \(String(describing: status)))"}
}

extension DescribeProvisioningArtifactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProvisioningArtifactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.info = output.info
            self.provisioningArtifactDetail = output.provisioningArtifactDetail
            self.status = output.status
        } else {
            self.info = nil
            self.provisioningArtifactDetail = nil
            self.status = nil
        }
    }
}

public struct DescribeProvisioningArtifactOutputResponse: Equatable {
    /// <p>The URL of the CloudFormation template in Amazon S3.</p>
    public let info: [String:String]?
    /// <p>Information about the provisioning artifact.</p>
    public let provisioningArtifactDetail: ProvisioningArtifactDetail?
    /// <p>The status of the current request.</p>
    public let status: Status?

    public init (
        info: [String:String]? = nil,
        provisioningArtifactDetail: ProvisioningArtifactDetail? = nil,
        status: Status? = nil
    )
    {
        self.info = info
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.status = status
    }
}

struct DescribeProvisioningArtifactOutputResponseBody: Equatable {
    public let provisioningArtifactDetail: ProvisioningArtifactDetail?
    public let info: [String:String]?
    public let status: Status?
}

extension DescribeProvisioningArtifactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case info = "Info"
        case provisioningArtifactDetail = "ProvisioningArtifactDetail"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactDetailDecoded = try containerValues.decodeIfPresent(ProvisioningArtifactDetail.self, forKey: .provisioningArtifactDetail)
        provisioningArtifactDetail = provisioningArtifactDetailDecoded
        let infoContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .info)
        var infoDecoded0: [String:String]? = nil
        if let infoContainer = infoContainer {
            infoDecoded0 = [String:String]()
            for (key0, provisioningartifactinfovalue0) in infoContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    infoDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        info = infoDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DescribeProvisioningParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeProvisioningParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisioningParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisioningParametersInput>
    public typealias MOutput = OperationOutput<DescribeProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisioningParametersOutputError>
}

extension DescribeProvisioningParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProvisioningParametersInput(acceptLanguage: \(String(describing: acceptLanguage)), pathId: \(String(describing: pathId)), pathName: \(String(describing: pathName)), productId: \(String(describing: productId)), productName: \(String(describing: productName)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), provisioningArtifactName: \(String(describing: provisioningArtifactName)))"}
}

extension DescribeProvisioningParametersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pathId = pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let pathName = pathName {
            try encodeContainer.encode(pathName, forKey: .pathName)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
    }
}

public struct DescribeProvisioningParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProvisioningParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisioningParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisioningParametersInput>
    public typealias MOutput = OperationOutput<DescribeProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisioningParametersOutputError>
}

public struct DescribeProvisioningParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProvisioningParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProvisioningParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProvisioningParametersInput>
    public typealias MOutput = OperationOutput<DescribeProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProvisioningParametersOutputError>
}

public struct DescribeProvisioningParametersInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The path identifier of the product. This value is optional if the product
    ///          has a default path, and required if the product has more than one path.
    ///          To list the paths for a product, use <a>ListLaunchPaths</a>. You must provide the name or ID, but not both.</p>
    public let pathId: String?
    /// <p>The name of the path. You must provide the name or ID, but not both.</p>
    public let pathName: String?
    /// <p>The product identifier. You must provide the product name or ID, but not both.</p>
    public let productId: String?
    /// <p>The name of the product. You must provide the name or ID, but not both.</p>
    public let productName: String?
    /// <p>The identifier of the provisioning artifact. You must provide the name or ID, but not both.</p>
    public let provisioningArtifactId: String?
    /// <p>The name of the provisioning artifact. You must provide the name or ID, but not both.</p>
    public let provisioningArtifactName: String?

    public init (
        acceptLanguage: String? = nil,
        pathId: String? = nil,
        pathName: String? = nil,
        productId: String? = nil,
        productName: String? = nil,
        provisioningArtifactId: String? = nil,
        provisioningArtifactName: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pathId = pathId
        self.pathName = pathName
        self.productId = productId
        self.productName = productName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
    }
}

struct DescribeProvisioningParametersInputBody: Equatable {
    public let acceptLanguage: String?
    public let productId: String?
    public let productName: String?
    public let provisioningArtifactId: String?
    public let provisioningArtifactName: String?
    public let pathId: String?
    public let pathName: String?
}

extension DescribeProvisioningParametersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productName)
        productName = productNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let pathNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathName)
        pathName = pathNameDecoded
    }
}

extension DescribeProvisioningParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProvisioningParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProvisioningParametersOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProvisioningParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProvisioningParametersOutputResponse(constraintSummaries: \(String(describing: constraintSummaries)), provisioningArtifactOutputs: \(String(describing: provisioningArtifactOutputs)), provisioningArtifactParameters: \(String(describing: provisioningArtifactParameters)), provisioningArtifactPreferences: \(String(describing: provisioningArtifactPreferences)), tagOptions: \(String(describing: tagOptions)), usageInstructions: \(String(describing: usageInstructions)))"}
}

extension DescribeProvisioningParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProvisioningParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.constraintSummaries = output.constraintSummaries
            self.provisioningArtifactOutputs = output.provisioningArtifactOutputs
            self.provisioningArtifactParameters = output.provisioningArtifactParameters
            self.provisioningArtifactPreferences = output.provisioningArtifactPreferences
            self.tagOptions = output.tagOptions
            self.usageInstructions = output.usageInstructions
        } else {
            self.constraintSummaries = nil
            self.provisioningArtifactOutputs = nil
            self.provisioningArtifactParameters = nil
            self.provisioningArtifactPreferences = nil
            self.tagOptions = nil
            self.usageInstructions = nil
        }
    }
}

public struct DescribeProvisioningParametersOutputResponse: Equatable {
    /// <p>Information about the constraints used to provision the product.</p>
    public let constraintSummaries: [ConstraintSummary]?
    /// <p>The output of the provisioning artifact.</p>
    public let provisioningArtifactOutputs: [ProvisioningArtifactOutput]?
    /// <p>Information about the parameters used to provision the product.</p>
    public let provisioningArtifactParameters: [ProvisioningArtifactParameter]?
    /// <p>An object that contains information about preferences, such as regions and accounts, for the provisioning artifact.</p>
    public let provisioningArtifactPreferences: ProvisioningArtifactPreferences?
    /// <p>Information about the TagOptions associated with the resource.</p>
    public let tagOptions: [TagOptionSummary]?
    /// <p>Any additional metadata specifically related to the provisioning of the product. For
    ///          example, see the <code>Version</code> field of the CloudFormation template.</p>
    public let usageInstructions: [UsageInstruction]?

    public init (
        constraintSummaries: [ConstraintSummary]? = nil,
        provisioningArtifactOutputs: [ProvisioningArtifactOutput]? = nil,
        provisioningArtifactParameters: [ProvisioningArtifactParameter]? = nil,
        provisioningArtifactPreferences: ProvisioningArtifactPreferences? = nil,
        tagOptions: [TagOptionSummary]? = nil,
        usageInstructions: [UsageInstruction]? = nil
    )
    {
        self.constraintSummaries = constraintSummaries
        self.provisioningArtifactOutputs = provisioningArtifactOutputs
        self.provisioningArtifactParameters = provisioningArtifactParameters
        self.provisioningArtifactPreferences = provisioningArtifactPreferences
        self.tagOptions = tagOptions
        self.usageInstructions = usageInstructions
    }
}

struct DescribeProvisioningParametersOutputResponseBody: Equatable {
    public let provisioningArtifactParameters: [ProvisioningArtifactParameter]?
    public let constraintSummaries: [ConstraintSummary]?
    public let usageInstructions: [UsageInstruction]?
    public let tagOptions: [TagOptionSummary]?
    public let provisioningArtifactPreferences: ProvisioningArtifactPreferences?
    public let provisioningArtifactOutputs: [ProvisioningArtifactOutput]?
}

extension DescribeProvisioningParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case constraintSummaries = "ConstraintSummaries"
        case provisioningArtifactOutputs = "ProvisioningArtifactOutputs"
        case provisioningArtifactParameters = "ProvisioningArtifactParameters"
        case provisioningArtifactPreferences = "ProvisioningArtifactPreferences"
        case tagOptions = "TagOptions"
        case usageInstructions = "UsageInstructions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactParametersContainer = try containerValues.decodeIfPresent([ProvisioningArtifactParameter?].self, forKey: .provisioningArtifactParameters)
        var provisioningArtifactParametersDecoded0:[ProvisioningArtifactParameter]? = nil
        if let provisioningArtifactParametersContainer = provisioningArtifactParametersContainer {
            provisioningArtifactParametersDecoded0 = [ProvisioningArtifactParameter]()
            for structure0 in provisioningArtifactParametersContainer {
                if let structure0 = structure0 {
                    provisioningArtifactParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactParameters = provisioningArtifactParametersDecoded0
        let constraintSummariesContainer = try containerValues.decodeIfPresent([ConstraintSummary?].self, forKey: .constraintSummaries)
        var constraintSummariesDecoded0:[ConstraintSummary]? = nil
        if let constraintSummariesContainer = constraintSummariesContainer {
            constraintSummariesDecoded0 = [ConstraintSummary]()
            for structure0 in constraintSummariesContainer {
                if let structure0 = structure0 {
                    constraintSummariesDecoded0?.append(structure0)
                }
            }
        }
        constraintSummaries = constraintSummariesDecoded0
        let usageInstructionsContainer = try containerValues.decodeIfPresent([UsageInstruction?].self, forKey: .usageInstructions)
        var usageInstructionsDecoded0:[UsageInstruction]? = nil
        if let usageInstructionsContainer = usageInstructionsContainer {
            usageInstructionsDecoded0 = [UsageInstruction]()
            for structure0 in usageInstructionsContainer {
                if let structure0 = structure0 {
                    usageInstructionsDecoded0?.append(structure0)
                }
            }
        }
        usageInstructions = usageInstructionsDecoded0
        let tagOptionsContainer = try containerValues.decodeIfPresent([TagOptionSummary?].self, forKey: .tagOptions)
        var tagOptionsDecoded0:[TagOptionSummary]? = nil
        if let tagOptionsContainer = tagOptionsContainer {
            tagOptionsDecoded0 = [TagOptionSummary]()
            for structure0 in tagOptionsContainer {
                if let structure0 = structure0 {
                    tagOptionsDecoded0?.append(structure0)
                }
            }
        }
        tagOptions = tagOptionsDecoded0
        let provisioningArtifactPreferencesDecoded = try containerValues.decodeIfPresent(ProvisioningArtifactPreferences.self, forKey: .provisioningArtifactPreferences)
        provisioningArtifactPreferences = provisioningArtifactPreferencesDecoded
        let provisioningArtifactOutputsContainer = try containerValues.decodeIfPresent([ProvisioningArtifactOutput?].self, forKey: .provisioningArtifactOutputs)
        var provisioningArtifactOutputsDecoded0:[ProvisioningArtifactOutput]? = nil
        if let provisioningArtifactOutputsContainer = provisioningArtifactOutputsContainer {
            provisioningArtifactOutputsDecoded0 = [ProvisioningArtifactOutput]()
            for structure0 in provisioningArtifactOutputsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactOutputsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactOutputs = provisioningArtifactOutputsDecoded0
    }
}

public struct DescribeRecordInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRecordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecordInput>
    public typealias MOutput = OperationOutput<DescribeRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecordOutputError>
}

extension DescribeRecordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRecordInput(acceptLanguage: \(String(describing: acceptLanguage)), id: \(String(describing: id)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)))"}
}

extension DescribeRecordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

public struct DescribeRecordInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecordInput>
    public typealias MOutput = OperationOutput<DescribeRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecordOutputError>
}

public struct DescribeRecordInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecordInput>
    public typealias MOutput = OperationOutput<DescribeRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecordOutputError>
}

public struct DescribeRecordInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The record identifier of the provisioned product. This identifier is returned by the
    ///          request operation.</p>
    public let id: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?

    public init (
        acceptLanguage: String? = nil,
        id: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct DescribeRecordInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
    public let pageToken: String?
    public let pageSize: Int
}

extension DescribeRecordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension DescribeRecordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRecordOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRecordOutputResponse(nextPageToken: \(String(describing: nextPageToken)), recordDetail: \(String(describing: recordDetail)), recordOutputs: \(String(describing: recordOutputs)))"}
}

extension DescribeRecordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRecordOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.recordDetail = output.recordDetail
            self.recordOutputs = output.recordOutputs
        } else {
            self.nextPageToken = nil
            self.recordDetail = nil
            self.recordOutputs = nil
        }
    }
}

public struct DescribeRecordOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Information about the product.</p>
    public let recordDetail: RecordDetail?
    /// <p>Information about the product created as the result of a request. For example, the output for
    ///          a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.</p>
    public let recordOutputs: [RecordOutput]?

    public init (
        nextPageToken: String? = nil,
        recordDetail: RecordDetail? = nil,
        recordOutputs: [RecordOutput]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.recordDetail = recordDetail
        self.recordOutputs = recordOutputs
    }
}

struct DescribeRecordOutputResponseBody: Equatable {
    public let recordDetail: RecordDetail?
    public let recordOutputs: [RecordOutput]?
    public let nextPageToken: String?
}

extension DescribeRecordOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case recordDetail = "RecordDetail"
        case recordOutputs = "RecordOutputs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
        let recordOutputsContainer = try containerValues.decodeIfPresent([RecordOutput?].self, forKey: .recordOutputs)
        var recordOutputsDecoded0:[RecordOutput]? = nil
        if let recordOutputsContainer = recordOutputsContainer {
            recordOutputsDecoded0 = [RecordOutput]()
            for structure0 in recordOutputsContainer {
                if let structure0 = structure0 {
                    recordOutputsDecoded0?.append(structure0)
                }
            }
        }
        recordOutputs = recordOutputsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct DescribeServiceActionExecutionParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeServiceActionExecutionParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceActionExecutionParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceActionExecutionParametersInput>
    public typealias MOutput = OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceActionExecutionParametersOutputError>
}

extension DescribeServiceActionExecutionParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServiceActionExecutionParametersInput(acceptLanguage: \(String(describing: acceptLanguage)), provisionedProductId: \(String(describing: provisionedProductId)), serviceActionId: \(String(describing: serviceActionId)))"}
}

extension DescribeServiceActionExecutionParametersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case provisionedProductId = "ProvisionedProductId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

public struct DescribeServiceActionExecutionParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeServiceActionExecutionParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceActionExecutionParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceActionExecutionParametersInput>
    public typealias MOutput = OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceActionExecutionParametersOutputError>
}

public struct DescribeServiceActionExecutionParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeServiceActionExecutionParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceActionExecutionParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceActionExecutionParametersInput>
    public typealias MOutput = OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceActionExecutionParametersOutputError>
}

public struct DescribeServiceActionExecutionParametersInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The identifier of the provisioned product.</p>
    public let provisionedProductId: String?
    /// <p>The self-service action identifier.</p>
    public let serviceActionId: String?

    public init (
        acceptLanguage: String? = nil,
        provisionedProductId: String? = nil,
        serviceActionId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.provisionedProductId = provisionedProductId
        self.serviceActionId = serviceActionId
    }
}

struct DescribeServiceActionExecutionParametersInputBody: Equatable {
    public let provisionedProductId: String?
    public let serviceActionId: String?
    public let acceptLanguage: String?
}

extension DescribeServiceActionExecutionParametersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case provisionedProductId = "ProvisionedProductId"
        case serviceActionId = "ServiceActionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension DescribeServiceActionExecutionParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServiceActionExecutionParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceActionExecutionParametersOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceActionExecutionParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServiceActionExecutionParametersOutputResponse(serviceActionParameters: \(String(describing: serviceActionParameters)))"}
}

extension DescribeServiceActionExecutionParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeServiceActionExecutionParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceActionParameters = output.serviceActionParameters
        } else {
            self.serviceActionParameters = nil
        }
    }
}

public struct DescribeServiceActionExecutionParametersOutputResponse: Equatable {
    /// <p>The parameters of the self-service action.</p>
    public let serviceActionParameters: [ExecutionParameter]?

    public init (
        serviceActionParameters: [ExecutionParameter]? = nil
    )
    {
        self.serviceActionParameters = serviceActionParameters
    }
}

struct DescribeServiceActionExecutionParametersOutputResponseBody: Equatable {
    public let serviceActionParameters: [ExecutionParameter]?
}

extension DescribeServiceActionExecutionParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceActionParameters = "ServiceActionParameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionParametersContainer = try containerValues.decodeIfPresent([ExecutionParameter?].self, forKey: .serviceActionParameters)
        var serviceActionParametersDecoded0:[ExecutionParameter]? = nil
        if let serviceActionParametersContainer = serviceActionParametersContainer {
            serviceActionParametersDecoded0 = [ExecutionParameter]()
            for structure0 in serviceActionParametersContainer {
                if let structure0 = structure0 {
                    serviceActionParametersDecoded0?.append(structure0)
                }
            }
        }
        serviceActionParameters = serviceActionParametersDecoded0
    }
}

public struct DescribeServiceActionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeServiceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceActionInput>
    public typealias MOutput = OperationOutput<DescribeServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceActionOutputError>
}

extension DescribeServiceActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServiceActionInput(acceptLanguage: \(String(describing: acceptLanguage)), id: \(String(describing: id)))"}
}

extension DescribeServiceActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribeServiceActionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeServiceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceActionInput>
    public typealias MOutput = OperationOutput<DescribeServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceActionOutputError>
}

public struct DescribeServiceActionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeServiceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceActionInput>
    public typealias MOutput = OperationOutput<DescribeServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceActionOutputError>
}

public struct DescribeServiceActionInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The self-service action identifier.</p>
    public let id: String?

    public init (
        acceptLanguage: String? = nil,
        id: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DescribeServiceActionInputBody: Equatable {
    public let id: String?
    public let acceptLanguage: String?
}

extension DescribeServiceActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension DescribeServiceActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServiceActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceActionOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServiceActionOutputResponse(serviceActionDetail: \(String(describing: serviceActionDetail)))"}
}

extension DescribeServiceActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeServiceActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceActionDetail = output.serviceActionDetail
        } else {
            self.serviceActionDetail = nil
        }
    }
}

public struct DescribeServiceActionOutputResponse: Equatable {
    /// <p>Detailed information about the self-service action.</p>
    public let serviceActionDetail: ServiceActionDetail?

    public init (
        serviceActionDetail: ServiceActionDetail? = nil
    )
    {
        self.serviceActionDetail = serviceActionDetail
    }
}

struct DescribeServiceActionOutputResponseBody: Equatable {
    public let serviceActionDetail: ServiceActionDetail?
}

extension DescribeServiceActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceActionDetail = "ServiceActionDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionDetailDecoded = try containerValues.decodeIfPresent(ServiceActionDetail.self, forKey: .serviceActionDetail)
        serviceActionDetail = serviceActionDetailDecoded
    }
}

extension DescribeTagOptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagOptionInput(id: \(String(describing: id)))"}
}

extension DescribeTagOptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeTagOptionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTagOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagOptionInput>
    public typealias MOutput = OperationOutput<DescribeTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagOptionOutputError>
}

public struct DescribeTagOptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTagOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagOptionInput>
    public typealias MOutput = OperationOutput<DescribeTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagOptionOutputError>
}

public struct DescribeTagOptionInput: Equatable {
    /// <p>The TagOption identifier.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeTagOptionInputBody: Equatable {
}

extension DescribeTagOptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeTagOptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTagOptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagOptionOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagOptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagOptionOutputResponse(tagOptionDetail: \(String(describing: tagOptionDetail)))"}
}

extension DescribeTagOptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTagOptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagOptionDetail = output.tagOptionDetail
        } else {
            self.tagOptionDetail = nil
        }
    }
}

public struct DescribeTagOptionOutputResponse: Equatable {
    /// <p>Information about the TagOption.</p>
    public let tagOptionDetail: TagOptionDetail?

    public init (
        tagOptionDetail: TagOptionDetail? = nil
    )
    {
        self.tagOptionDetail = tagOptionDetail
    }
}

struct DescribeTagOptionOutputResponseBody: Equatable {
    public let tagOptionDetail: TagOptionDetail?
}

extension DescribeTagOptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagOptionDetail = "TagOptionDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagOptionDetailDecoded = try containerValues.decodeIfPresent(TagOptionDetail.self, forKey: .tagOptionDetail)
        tagOptionDetail = tagOptionDetailDecoded
    }
}

extension DisableAWSOrganizationsAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableAWSOrganizationsAccessInput()"}
}

extension DisableAWSOrganizationsAccessInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisableAWSOrganizationsAccessInputHeadersMiddleware: Middleware {
    public let id: String = "DisableAWSOrganizationsAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableAWSOrganizationsAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableAWSOrganizationsAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableAWSOrganizationsAccessInput>
    public typealias MOutput = OperationOutput<DisableAWSOrganizationsAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableAWSOrganizationsAccessOutputError>
}

public struct DisableAWSOrganizationsAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableAWSOrganizationsAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableAWSOrganizationsAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableAWSOrganizationsAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableAWSOrganizationsAccessInput>
    public typealias MOutput = OperationOutput<DisableAWSOrganizationsAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableAWSOrganizationsAccessOutputError>
}

public struct DisableAWSOrganizationsAccessInput: Equatable {

    public init() {}
}

struct DisableAWSOrganizationsAccessInputBody: Equatable {
}

extension DisableAWSOrganizationsAccessInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisableAWSOrganizationsAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableAWSOrganizationsAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableAWSOrganizationsAccessOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableAWSOrganizationsAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableAWSOrganizationsAccessOutputResponse()"}
}

extension DisableAWSOrganizationsAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableAWSOrganizationsAccessOutputResponse: Equatable {

    public init() {}
}

struct DisableAWSOrganizationsAccessOutputResponseBody: Equatable {
}

extension DisableAWSOrganizationsAccessOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateBudgetFromResourceInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateBudgetFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateBudgetFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateBudgetFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateBudgetFromResourceInput>
    public typealias MOutput = OperationOutput<DisassociateBudgetFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateBudgetFromResourceOutputError>
}

extension DisassociateBudgetFromResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateBudgetFromResourceInput(budgetName: \(String(describing: budgetName)), resourceId: \(String(describing: resourceId)))"}
}

extension DisassociateBudgetFromResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case budgetName = "BudgetName"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct DisassociateBudgetFromResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateBudgetFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateBudgetFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateBudgetFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateBudgetFromResourceInput>
    public typealias MOutput = OperationOutput<DisassociateBudgetFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateBudgetFromResourceOutputError>
}

public struct DisassociateBudgetFromResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateBudgetFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateBudgetFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateBudgetFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateBudgetFromResourceInput>
    public typealias MOutput = OperationOutput<DisassociateBudgetFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateBudgetFromResourceOutputError>
}

public struct DisassociateBudgetFromResourceInput: Equatable {
    /// <p>The name of the budget you want to disassociate.</p>
    public let budgetName: String?
    /// <p>The resource identifier you want to disassociate from. Either a portfolio-id or a product-id.</p>
    public let resourceId: String?

    public init (
        budgetName: String? = nil,
        resourceId: String? = nil
    )
    {
        self.budgetName = budgetName
        self.resourceId = resourceId
    }
}

struct DisassociateBudgetFromResourceInputBody: Equatable {
    public let budgetName: String?
    public let resourceId: String?
}

extension DisassociateBudgetFromResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case budgetName = "BudgetName"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DisassociateBudgetFromResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateBudgetFromResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateBudgetFromResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateBudgetFromResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateBudgetFromResourceOutputResponse()"}
}

extension DisassociateBudgetFromResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateBudgetFromResourceOutputResponse: Equatable {

    public init() {}
}

struct DisassociateBudgetFromResourceOutputResponseBody: Equatable {
}

extension DisassociateBudgetFromResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociatePrincipalFromPortfolioInputBodyMiddleware: Middleware {
    public let id: String = "DisassociatePrincipalFromPortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociatePrincipalFromPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociatePrincipalFromPortfolioInput>
    public typealias MOutput = OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociatePrincipalFromPortfolioOutputError>
}

extension DisassociatePrincipalFromPortfolioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociatePrincipalFromPortfolioInput(acceptLanguage: \(String(describing: acceptLanguage)), portfolioId: \(String(describing: portfolioId)), principalARN: \(String(describing: principalARN)))"}
}

extension DisassociatePrincipalFromPortfolioInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case principalARN = "PrincipalARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let principalARN = principalARN {
            try encodeContainer.encode(principalARN, forKey: .principalARN)
        }
    }
}

public struct DisassociatePrincipalFromPortfolioInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociatePrincipalFromPortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociatePrincipalFromPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociatePrincipalFromPortfolioInput>
    public typealias MOutput = OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociatePrincipalFromPortfolioOutputError>
}

public struct DisassociatePrincipalFromPortfolioInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociatePrincipalFromPortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociatePrincipalFromPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociatePrincipalFromPortfolioInput>
    public typealias MOutput = OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociatePrincipalFromPortfolioOutputError>
}

public struct DisassociatePrincipalFromPortfolioInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?
    /// <p>The ARN of the principal (IAM user, role, or group).</p>
    public let principalARN: String?

    public init (
        acceptLanguage: String? = nil,
        portfolioId: String? = nil,
        principalARN: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.principalARN = principalARN
    }
}

struct DisassociatePrincipalFromPortfolioInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let principalARN: String?
}

extension DisassociatePrincipalFromPortfolioInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case principalARN = "PrincipalARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let principalARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalARN)
        principalARN = principalARNDecoded
    }
}

extension DisassociatePrincipalFromPortfolioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociatePrincipalFromPortfolioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociatePrincipalFromPortfolioOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociatePrincipalFromPortfolioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociatePrincipalFromPortfolioOutputResponse()"}
}

extension DisassociatePrincipalFromPortfolioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociatePrincipalFromPortfolioOutputResponse: Equatable {

    public init() {}
}

struct DisassociatePrincipalFromPortfolioOutputResponseBody: Equatable {
}

extension DisassociatePrincipalFromPortfolioOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateProductFromPortfolioInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateProductFromPortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateProductFromPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateProductFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateProductFromPortfolioInput>
    public typealias MOutput = OperationOutput<DisassociateProductFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateProductFromPortfolioOutputError>
}

extension DisassociateProductFromPortfolioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateProductFromPortfolioInput(acceptLanguage: \(String(describing: acceptLanguage)), portfolioId: \(String(describing: portfolioId)), productId: \(String(describing: productId)))"}
}

extension DisassociateProductFromPortfolioInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

public struct DisassociateProductFromPortfolioInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateProductFromPortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateProductFromPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateProductFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateProductFromPortfolioInput>
    public typealias MOutput = OperationOutput<DisassociateProductFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateProductFromPortfolioOutputError>
}

public struct DisassociateProductFromPortfolioInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateProductFromPortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateProductFromPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateProductFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateProductFromPortfolioInput>
    public typealias MOutput = OperationOutput<DisassociateProductFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateProductFromPortfolioOutputError>
}

public struct DisassociateProductFromPortfolioInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?
    /// <p>The product identifier.</p>
    public let productId: String?

    public init (
        acceptLanguage: String? = nil,
        portfolioId: String? = nil,
        productId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.productId = productId
    }
}

struct DisassociateProductFromPortfolioInputBody: Equatable {
    public let acceptLanguage: String?
    public let productId: String?
    public let portfolioId: String?
}

extension DisassociateProductFromPortfolioInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
    }
}

extension DisassociateProductFromPortfolioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateProductFromPortfolioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateProductFromPortfolioOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateProductFromPortfolioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateProductFromPortfolioOutputResponse()"}
}

extension DisassociateProductFromPortfolioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateProductFromPortfolioOutputResponse: Equatable {

    public init() {}
}

struct DisassociateProductFromPortfolioOutputResponseBody: Equatable {
}

extension DisassociateProductFromPortfolioOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateServiceActionFromProvisioningArtifactInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateServiceActionFromProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateServiceActionFromProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateServiceActionFromProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateServiceActionFromProvisioningArtifactOutputError>
}

extension DisassociateServiceActionFromProvisioningArtifactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateServiceActionFromProvisioningArtifactInput(acceptLanguage: \(String(describing: acceptLanguage)), productId: \(String(describing: productId)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), serviceActionId: \(String(describing: serviceActionId)))"}
}

extension DisassociateServiceActionFromProvisioningArtifactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

public struct DisassociateServiceActionFromProvisioningArtifactInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateServiceActionFromProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateServiceActionFromProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateServiceActionFromProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateServiceActionFromProvisioningArtifactOutputError>
}

public struct DisassociateServiceActionFromProvisioningArtifactInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateServiceActionFromProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateServiceActionFromProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateServiceActionFromProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateServiceActionFromProvisioningArtifactOutputError>
}

public struct DisassociateServiceActionFromProvisioningArtifactInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
    public let productId: String?
    /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
    public let provisioningArtifactId: String?
    /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
    public let serviceActionId: String?

    public init (
        acceptLanguage: String? = nil,
        productId: String? = nil,
        provisioningArtifactId: String? = nil,
        serviceActionId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
        self.serviceActionId = serviceActionId
    }
}

struct DisassociateServiceActionFromProvisioningArtifactInputBody: Equatable {
    public let productId: String?
    public let provisioningArtifactId: String?
    public let serviceActionId: String?
    public let acceptLanguage: String?
}

extension DisassociateServiceActionFromProvisioningArtifactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension DisassociateServiceActionFromProvisioningArtifactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateServiceActionFromProvisioningArtifactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateServiceActionFromProvisioningArtifactOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateServiceActionFromProvisioningArtifactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateServiceActionFromProvisioningArtifactOutputResponse()"}
}

extension DisassociateServiceActionFromProvisioningArtifactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateServiceActionFromProvisioningArtifactOutputResponse: Equatable {

    public init() {}
}

struct DisassociateServiceActionFromProvisioningArtifactOutputResponseBody: Equatable {
}

extension DisassociateServiceActionFromProvisioningArtifactOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateTagOptionFromResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateTagOptionFromResourceInput(resourceId: \(String(describing: resourceId)), tagOptionId: \(String(describing: tagOptionId)))"}
}

extension DisassociateTagOptionFromResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateTagOptionFromResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateTagOptionFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateTagOptionFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateTagOptionFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateTagOptionFromResourceInput>
    public typealias MOutput = OperationOutput<DisassociateTagOptionFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateTagOptionFromResourceOutputError>
}

public struct DisassociateTagOptionFromResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateTagOptionFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateTagOptionFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateTagOptionFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateTagOptionFromResourceInput>
    public typealias MOutput = OperationOutput<DisassociateTagOptionFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateTagOptionFromResourceOutputError>
}

public struct DisassociateTagOptionFromResourceInput: Equatable {
    /// <p>The resource identifier.</p>
    public let resourceId: String?
    /// <p>The TagOption identifier.</p>
    public let tagOptionId: String?

    public init (
        resourceId: String? = nil,
        tagOptionId: String? = nil
    )
    {
        self.resourceId = resourceId
        self.tagOptionId = tagOptionId
    }
}

struct DisassociateTagOptionFromResourceInputBody: Equatable {
}

extension DisassociateTagOptionFromResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateTagOptionFromResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTagOptionFromResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateTagOptionFromResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTagOptionFromResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateTagOptionFromResourceOutputResponse()"}
}

extension DisassociateTagOptionFromResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateTagOptionFromResourceOutputResponse: Equatable {

    public init() {}
}

struct DisassociateTagOptionFromResourceOutputResponseBody: Equatable {
}

extension DisassociateTagOptionFromResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DuplicateResourceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateResourceException(message: \(String(describing: message)))"}
}

extension DuplicateResourceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DuplicateResourceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource is a duplicate.</p>
public struct DuplicateResourceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateResourceExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateResourceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EnableAWSOrganizationsAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableAWSOrganizationsAccessInput()"}
}

extension EnableAWSOrganizationsAccessInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct EnableAWSOrganizationsAccessInputHeadersMiddleware: Middleware {
    public let id: String = "EnableAWSOrganizationsAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableAWSOrganizationsAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableAWSOrganizationsAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableAWSOrganizationsAccessInput>
    public typealias MOutput = OperationOutput<EnableAWSOrganizationsAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableAWSOrganizationsAccessOutputError>
}

public struct EnableAWSOrganizationsAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableAWSOrganizationsAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableAWSOrganizationsAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableAWSOrganizationsAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableAWSOrganizationsAccessInput>
    public typealias MOutput = OperationOutput<EnableAWSOrganizationsAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableAWSOrganizationsAccessOutputError>
}

public struct EnableAWSOrganizationsAccessInput: Equatable {

    public init() {}
}

struct EnableAWSOrganizationsAccessInputBody: Equatable {
}

extension EnableAWSOrganizationsAccessInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EnableAWSOrganizationsAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableAWSOrganizationsAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableAWSOrganizationsAccessOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableAWSOrganizationsAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableAWSOrganizationsAccessOutputResponse()"}
}

extension EnableAWSOrganizationsAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableAWSOrganizationsAccessOutputResponse: Equatable {

    public init() {}
}

struct EnableAWSOrganizationsAccessOutputResponseBody: Equatable {
}

extension EnableAWSOrganizationsAccessOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum EvaluationType {
    case `dynamic`
    case `static`
    case sdkUnknown(String)
}

extension EvaluationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EvaluationType] {
        return [
            .dynamic,
            .static,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dynamic: return "DYNAMIC"
        case .static: return "STATIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EvaluationType(rawValue: rawValue) ?? EvaluationType.sdkUnknown(rawValue)
    }
}

public struct ExecuteProvisionedProductPlanInputBodyMiddleware: Middleware {
    public let id: String = "ExecuteProvisionedProductPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteProvisionedProductPlanInput>
    public typealias MOutput = OperationOutput<ExecuteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteProvisionedProductPlanOutputError>
}

extension ExecuteProvisionedProductPlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteProvisionedProductPlanInput(acceptLanguage: \(String(describing: acceptLanguage)), idempotencyToken: \(String(describing: idempotencyToken)), planId: \(String(describing: planId)))"}
}

extension ExecuteProvisionedProductPlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case planId = "PlanId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let planId = planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
    }
}

public struct ExecuteProvisionedProductPlanInputHeadersMiddleware: Middleware {
    public let id: String = "ExecuteProvisionedProductPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteProvisionedProductPlanInput>
    public typealias MOutput = OperationOutput<ExecuteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteProvisionedProductPlanOutputError>
}

public struct ExecuteProvisionedProductPlanInputQueryItemMiddleware: Middleware {
    public let id: String = "ExecuteProvisionedProductPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteProvisionedProductPlanInput>
    public typealias MOutput = OperationOutput<ExecuteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteProvisionedProductPlanOutputError>
}

public struct ExecuteProvisionedProductPlanInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.</p>
    public var idempotencyToken: String?
    /// <p>The plan identifier.</p>
    public let planId: String?

    public init (
        acceptLanguage: String? = nil,
        idempotencyToken: String? = nil,
        planId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.planId = planId
    }
}

struct ExecuteProvisionedProductPlanInputBody: Equatable {
    public let acceptLanguage: String?
    public let planId: String?
    public let idempotencyToken: String?
}

extension ExecuteProvisionedProductPlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case planId = "PlanId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .planId)
        planId = planIdDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension ExecuteProvisionedProductPlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteProvisionedProductPlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteProvisionedProductPlanOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteProvisionedProductPlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteProvisionedProductPlanOutputResponse(recordDetail: \(String(describing: recordDetail)))"}
}

extension ExecuteProvisionedProductPlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExecuteProvisionedProductPlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct ExecuteProvisionedProductPlanOutputResponse: Equatable {
    /// <p>Information about the result of provisioning the product.</p>
    public let recordDetail: RecordDetail?

    public init (
        recordDetail: RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct ExecuteProvisionedProductPlanOutputResponseBody: Equatable {
    public let recordDetail: RecordDetail?
}

extension ExecuteProvisionedProductPlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

public struct ExecuteProvisionedProductServiceActionInputBodyMiddleware: Middleware {
    public let id: String = "ExecuteProvisionedProductServiceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteProvisionedProductServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteProvisionedProductServiceActionInput>
    public typealias MOutput = OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteProvisionedProductServiceActionOutputError>
}

extension ExecuteProvisionedProductServiceActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteProvisionedProductServiceActionInput(acceptLanguage: \(String(describing: acceptLanguage)), executeToken: \(String(describing: executeToken)), parameters: \(String(describing: parameters)), provisionedProductId: \(String(describing: provisionedProductId)), serviceActionId: \(String(describing: serviceActionId)))"}
}

extension ExecuteProvisionedProductServiceActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case executeToken = "ExecuteToken"
        case parameters = "Parameters"
        case provisionedProductId = "ProvisionedProductId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let executeToken = executeToken {
            try encodeContainer.encode(executeToken, forKey: .executeToken)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, executionparametermap0) in parameters {
                try parametersContainer.encode(executionparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

public struct ExecuteProvisionedProductServiceActionInputHeadersMiddleware: Middleware {
    public let id: String = "ExecuteProvisionedProductServiceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteProvisionedProductServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteProvisionedProductServiceActionInput>
    public typealias MOutput = OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteProvisionedProductServiceActionOutputError>
}

public struct ExecuteProvisionedProductServiceActionInputQueryItemMiddleware: Middleware {
    public let id: String = "ExecuteProvisionedProductServiceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteProvisionedProductServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteProvisionedProductServiceActionInput>
    public typealias MOutput = OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteProvisionedProductServiceActionOutputError>
}

public struct ExecuteProvisionedProductServiceActionInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>An idempotency token that uniquely identifies the execute request.</p>
    public var executeToken: String?
    /// <p>A map of all self-service action parameters and their values. If a provided parameter is of a special type, such as <code>TARGET</code>, the provided value will
    ///             override the default value generated by AWS Service Catalog. If the parameters field is not provided, no additional parameters are passed and default values will be used for
    ///             any special parameters such as <code>TARGET</code>.</p>
    public let parameters: [String:[String]]?
    /// <p>The identifier of the provisioned product.</p>
    public let provisionedProductId: String?
    /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
    public let serviceActionId: String?

    public init (
        acceptLanguage: String? = nil,
        executeToken: String? = nil,
        parameters: [String:[String]]? = nil,
        provisionedProductId: String? = nil,
        serviceActionId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.executeToken = executeToken
        self.parameters = parameters
        self.provisionedProductId = provisionedProductId
        self.serviceActionId = serviceActionId
    }
}

struct ExecuteProvisionedProductServiceActionInputBody: Equatable {
    public let provisionedProductId: String?
    public let serviceActionId: String?
    public let executeToken: String?
    public let acceptLanguage: String?
    public let parameters: [String:[String]]?
}

extension ExecuteProvisionedProductServiceActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case executeToken = "ExecuteToken"
        case parameters = "Parameters"
        case provisionedProductId = "ProvisionedProductId"
        case serviceActionId = "ServiceActionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let executeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executeToken)
        executeToken = executeTokenDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, executionparametervaluelist0) in parametersContainer {
                var executionparametervaluelist0Decoded0: [String]? = nil
                if let executionparametervaluelist0 = executionparametervaluelist0 {
                    executionparametervaluelist0Decoded0 = [String]()
                    for string1 in executionparametervaluelist0 {
                        if let string1 = string1 {
                            executionparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = executionparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension ExecuteProvisionedProductServiceActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteProvisionedProductServiceActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteProvisionedProductServiceActionOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteProvisionedProductServiceActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteProvisionedProductServiceActionOutputResponse(recordDetail: \(String(describing: recordDetail)))"}
}

extension ExecuteProvisionedProductServiceActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExecuteProvisionedProductServiceActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct ExecuteProvisionedProductServiceActionOutputResponse: Equatable {
    /// <p>An object containing detailed information about the result of provisioning the product.</p>
    public let recordDetail: RecordDetail?

    public init (
        recordDetail: RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct ExecuteProvisionedProductServiceActionOutputResponseBody: Equatable {
    public let recordDetail: RecordDetail?
}

extension ExecuteProvisionedProductServiceActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

extension ExecutionParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValues = "DefaultValues"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValues = defaultValues {
            var defaultValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultValues)
            for executionparametervaluelist0 in defaultValues {
                try defaultValuesContainer.encode(executionparametervaluelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let defaultValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .defaultValues)
        var defaultValuesDecoded0:[String]? = nil
        if let defaultValuesContainer = defaultValuesContainer {
            defaultValuesDecoded0 = [String]()
            for string0 in defaultValuesContainer {
                if let string0 = string0 {
                    defaultValuesDecoded0?.append(string0)
                }
            }
        }
        defaultValues = defaultValuesDecoded0
    }
}

extension ExecutionParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionParameter(defaultValues: \(String(describing: defaultValues)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Details of an execution parameter value that is passed to a self-service action when executed on a provisioned product.</p>
public struct ExecutionParameter: Equatable {
    /// <p>The default values for the execution parameter.</p>
    public let defaultValues: [String]?
    /// <p>The name of the execution parameter.</p>
    public let name: String?
    /// <p>The execution parameter type.</p>
    public let type: String?

    public init (
        defaultValues: [String]? = nil,
        name: String? = nil,
        type: String? = nil
    )
    {
        self.defaultValues = defaultValues
        self.name = name
        self.type = type
    }
}

extension FailedServiceActionAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ServiceActionAssociationErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension FailedServiceActionAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedServiceActionAssociation(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), productId: \(String(describing: productId)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), serviceActionId: \(String(describing: serviceActionId)))"}
}

/// <p>An object containing information about the error, along with identifying information about the self-service action and its associations.</p>
public struct FailedServiceActionAssociation: Equatable {
    /// <p>The error code. Valid values are listed below.</p>
    public let errorCode: ServiceActionAssociationErrorCode?
    /// <p>A text description of the error.</p>
    public let errorMessage: String?
    /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
    public let productId: String?
    /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
    public let provisioningArtifactId: String?
    /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
    public let serviceActionId: String?

    public init (
        errorCode: ServiceActionAssociationErrorCode? = nil,
        errorMessage: String? = nil,
        productId: String? = nil,
        provisioningArtifactId: String? = nil,
        serviceActionId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
        self.serviceActionId = serviceActionId
    }
}

extension GetAWSOrganizationsAccessStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAWSOrganizationsAccessStatusInput()"}
}

extension GetAWSOrganizationsAccessStatusInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAWSOrganizationsAccessStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetAWSOrganizationsAccessStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAWSOrganizationsAccessStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAWSOrganizationsAccessStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAWSOrganizationsAccessStatusInput>
    public typealias MOutput = OperationOutput<GetAWSOrganizationsAccessStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAWSOrganizationsAccessStatusOutputError>
}

public struct GetAWSOrganizationsAccessStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAWSOrganizationsAccessStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAWSOrganizationsAccessStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAWSOrganizationsAccessStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAWSOrganizationsAccessStatusInput>
    public typealias MOutput = OperationOutput<GetAWSOrganizationsAccessStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAWSOrganizationsAccessStatusOutputError>
}

public struct GetAWSOrganizationsAccessStatusInput: Equatable {

    public init() {}
}

struct GetAWSOrganizationsAccessStatusInputBody: Equatable {
}

extension GetAWSOrganizationsAccessStatusInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAWSOrganizationsAccessStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAWSOrganizationsAccessStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAWSOrganizationsAccessStatusOutputError: Equatable {
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAWSOrganizationsAccessStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAWSOrganizationsAccessStatusOutputResponse(accessStatus: \(String(describing: accessStatus)))"}
}

extension GetAWSOrganizationsAccessStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAWSOrganizationsAccessStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessStatus = output.accessStatus
        } else {
            self.accessStatus = nil
        }
    }
}

public struct GetAWSOrganizationsAccessStatusOutputResponse: Equatable {
    /// <p>The status of the portfolio share feature.</p>
    public let accessStatus: AccessStatus?

    public init (
        accessStatus: AccessStatus? = nil
    )
    {
        self.accessStatus = accessStatus
    }
}

struct GetAWSOrganizationsAccessStatusOutputResponseBody: Equatable {
    public let accessStatus: AccessStatus?
}

extension GetAWSOrganizationsAccessStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessStatus = "AccessStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessStatusDecoded = try containerValues.decodeIfPresent(AccessStatus.self, forKey: .accessStatus)
        accessStatus = accessStatusDecoded
    }
}

public struct GetProvisionedProductOutputsInputBodyMiddleware: Middleware {
    public let id: String = "GetProvisionedProductOutputsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProvisionedProductOutputsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProvisionedProductOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProvisionedProductOutputsInput>
    public typealias MOutput = OperationOutput<GetProvisionedProductOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProvisionedProductOutputsOutputError>
}

extension GetProvisionedProductOutputsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProvisionedProductOutputsInput(acceptLanguage: \(String(describing: acceptLanguage)), outputKeys: \(String(describing: outputKeys)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), provisionedProductId: \(String(describing: provisionedProductId)), provisionedProductName: \(String(describing: provisionedProductName)))"}
}

extension GetProvisionedProductOutputsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case outputKeys = "OutputKeys"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let outputKeys = outputKeys {
            var outputKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputKeys)
            for outputkeys0 in outputKeys {
                try outputKeysContainer.encode(outputkeys0)
            }
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
    }
}

public struct GetProvisionedProductOutputsInputHeadersMiddleware: Middleware {
    public let id: String = "GetProvisionedProductOutputsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProvisionedProductOutputsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProvisionedProductOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProvisionedProductOutputsInput>
    public typealias MOutput = OperationOutput<GetProvisionedProductOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProvisionedProductOutputsOutputError>
}

public struct GetProvisionedProductOutputsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetProvisionedProductOutputsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProvisionedProductOutputsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProvisionedProductOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProvisionedProductOutputsInput>
    public typealias MOutput = OperationOutput<GetProvisionedProductOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProvisionedProductOutputsOutputError>
}

public struct GetProvisionedProductOutputsInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The list of keys that the API should return with their values. If none are provided, the API will return all outputs of the provisioned product.</p>
    public let outputKeys: [String]?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The identifier of the provisioned product that you want the outputs from.</p>
    public let provisionedProductId: String?
    /// <p>The name of the provisioned product that you want the outputs from.</p>
    public let provisionedProductName: String?

    public init (
        acceptLanguage: String? = nil,
        outputKeys: [String]? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        provisionedProductId: String? = nil,
        provisionedProductName: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.outputKeys = outputKeys
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
    }
}

struct GetProvisionedProductOutputsInputBody: Equatable {
    public let acceptLanguage: String?
    public let provisionedProductId: String?
    public let provisionedProductName: String?
    public let outputKeys: [String]?
    public let pageSize: Int
    public let pageToken: String?
}

extension GetProvisionedProductOutputsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case outputKeys = "OutputKeys"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let outputKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .outputKeys)
        var outputKeysDecoded0:[String]? = nil
        if let outputKeysContainer = outputKeysContainer {
            outputKeysDecoded0 = [String]()
            for string0 in outputKeysContainer {
                if let string0 = string0 {
                    outputKeysDecoded0?.append(string0)
                }
            }
        }
        outputKeys = outputKeysDecoded0
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension GetProvisionedProductOutputsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProvisionedProductOutputsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProvisionedProductOutputsOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProvisionedProductOutputsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProvisionedProductOutputsOutputResponse(nextPageToken: \(String(describing: nextPageToken)), outputs: \(String(describing: outputs)))"}
}

extension GetProvisionedProductOutputsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetProvisionedProductOutputsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.outputs = output.outputs
        } else {
            self.nextPageToken = nil
            self.outputs = nil
        }
    }
}

public struct GetProvisionedProductOutputsOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Information about the product created as the result of a request. For example, the output for a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.
    ///       </p>
    public let outputs: [RecordOutput]?

    public init (
        nextPageToken: String? = nil,
        outputs: [RecordOutput]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.outputs = outputs
    }
}

struct GetProvisionedProductOutputsOutputResponseBody: Equatable {
    public let outputs: [RecordOutput]?
    public let nextPageToken: String?
}

extension GetProvisionedProductOutputsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case outputs = "Outputs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputsContainer = try containerValues.decodeIfPresent([RecordOutput?].self, forKey: .outputs)
        var outputsDecoded0:[RecordOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [RecordOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ImportAsProvisionedProductInputBodyMiddleware: Middleware {
    public let id: String = "ImportAsProvisionedProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportAsProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportAsProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportAsProvisionedProductInput>
    public typealias MOutput = OperationOutput<ImportAsProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportAsProvisionedProductOutputError>
}

extension ImportAsProvisionedProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportAsProvisionedProductInput(acceptLanguage: \(String(describing: acceptLanguage)), idempotencyToken: \(String(describing: idempotencyToken)), physicalId: \(String(describing: physicalId)), productId: \(String(describing: productId)), provisionedProductName: \(String(describing: provisionedProductName)), provisioningArtifactId: \(String(describing: provisioningArtifactId)))"}
}

extension ImportAsProvisionedProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case physicalId = "PhysicalId"
        case productId = "ProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let physicalId = physicalId {
            try encodeContainer.encode(physicalId, forKey: .physicalId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }
}

public struct ImportAsProvisionedProductInputHeadersMiddleware: Middleware {
    public let id: String = "ImportAsProvisionedProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportAsProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportAsProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportAsProvisionedProductInput>
    public typealias MOutput = OperationOutput<ImportAsProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportAsProvisionedProductOutputError>
}

public struct ImportAsProvisionedProductInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportAsProvisionedProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportAsProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportAsProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportAsProvisionedProductInput>
    public typealias MOutput = OperationOutput<ImportAsProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportAsProvisionedProductOutputError>
}

public struct ImportAsProvisionedProductInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.</p>
    public var idempotencyToken: String?
    /// <p>The unique identifier of the resource to be imported. It only currently supports
    ///          CloudFormation stack IDs.</p>
    public let physicalId: String?
    /// <p>The product identifier.</p>
    public let productId: String?
    /// <p>The user-friendly name of the provisioned product. The value must be unique for the AWS
    ///          account. The name cannot be updated after the product is provisioned. </p>
    public let provisionedProductName: String?
    /// <p>The identifier of the provisioning artifact.</p>
    public let provisioningArtifactId: String?

    public init (
        acceptLanguage: String? = nil,
        idempotencyToken: String? = nil,
        physicalId: String? = nil,
        productId: String? = nil,
        provisionedProductName: String? = nil,
        provisioningArtifactId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.physicalId = physicalId
        self.productId = productId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct ImportAsProvisionedProductInputBody: Equatable {
    public let acceptLanguage: String?
    public let productId: String?
    public let provisioningArtifactId: String?
    public let provisionedProductName: String?
    public let physicalId: String?
    public let idempotencyToken: String?
}

extension ImportAsProvisionedProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case physicalId = "PhysicalId"
        case productId = "ProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let physicalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .physicalId)
        physicalId = physicalIdDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension ImportAsProvisionedProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportAsProvisionedProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportAsProvisionedProductOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportAsProvisionedProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportAsProvisionedProductOutputResponse(recordDetail: \(String(describing: recordDetail)))"}
}

extension ImportAsProvisionedProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportAsProvisionedProductOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct ImportAsProvisionedProductOutputResponse: Equatable {
    /// <p>Information about a request operation.</p>
    public let recordDetail: RecordDetail?

    public init (
        recordDetail: RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct ImportAsProvisionedProductOutputResponseBody: Equatable {
    public let recordDetail: RecordDetail?
}

extension ImportAsProvisionedProductOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

extension InvalidParametersException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParametersException(message: \(String(describing: message)))"}
}

extension InvalidParametersException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParametersExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters provided to the operation are not valid.</p>
public struct InvalidParametersException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParametersExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParametersExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidStateException(message: \(String(describing: message)))"}
}

extension InvalidStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An attempt was made to modify a resource that is in a state that is not valid.
///          Check your resources to ensure that they are in valid states before retrying the operation.</p>
public struct InvalidStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LaunchPath: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension LaunchPath: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchPath(id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>A launch path object.</p>
public struct LaunchPath: Equatable {
    /// <p>The identifier of the launch path.</p>
    public let id: String?
    /// <p>The name of the launch path.</p>
    public let name: String?

    public init (
        id: String? = nil,
        name: String? = nil
    )
    {
        self.id = id
        self.name = name
    }
}

extension LaunchPathSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case constraintSummaries = "ConstraintSummaries"
        case id = "Id"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraintSummaries = constraintSummaries {
            var constraintSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .constraintSummaries)
            for constraintsummaries0 in constraintSummaries {
                try constraintSummariesContainer.encode(constraintsummaries0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let constraintSummariesContainer = try containerValues.decodeIfPresent([ConstraintSummary?].self, forKey: .constraintSummaries)
        var constraintSummariesDecoded0:[ConstraintSummary]? = nil
        if let constraintSummariesContainer = constraintSummariesContainer {
            constraintSummariesDecoded0 = [ConstraintSummary]()
            for structure0 in constraintSummariesContainer {
                if let structure0 = structure0 {
                    constraintSummariesDecoded0?.append(structure0)
                }
            }
        }
        constraintSummaries = constraintSummariesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension LaunchPathSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchPathSummary(constraintSummaries: \(String(describing: constraintSummaries)), id: \(String(describing: id)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

/// <p>Summary information about a product path for a user.</p>
public struct LaunchPathSummary: Equatable {
    /// <p>The constraints on the portfolio-product relationship.</p>
    public let constraintSummaries: [ConstraintSummary]?
    /// <p>The identifier of the product path.</p>
    public let id: String?
    /// <p>The name of the portfolio to which the user was assigned.</p>
    public let name: String?
    /// <p>The tags associated with this product path.</p>
    public let tags: [Tag]?

    public init (
        constraintSummaries: [ConstraintSummary]? = nil,
        id: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.constraintSummaries = constraintSummaries
        self.id = id
        self.name = name
        self.tags = tags
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The current limits of the service would have been exceeded by this operation. Decrease your
///          resource use or increase your service limits and retry the operation.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAcceptedPortfolioSharesInputBodyMiddleware: Middleware {
    public let id: String = "ListAcceptedPortfolioSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAcceptedPortfolioSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAcceptedPortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAcceptedPortfolioSharesInput>
    public typealias MOutput = OperationOutput<ListAcceptedPortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAcceptedPortfolioSharesOutputError>
}

extension ListAcceptedPortfolioSharesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAcceptedPortfolioSharesInput(acceptLanguage: \(String(describing: acceptLanguage)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), portfolioShareType: \(String(describing: portfolioShareType)))"}
}

extension ListAcceptedPortfolioSharesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioShareType = "PortfolioShareType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioShareType = portfolioShareType {
            try encodeContainer.encode(portfolioShareType.rawValue, forKey: .portfolioShareType)
        }
    }
}

public struct ListAcceptedPortfolioSharesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAcceptedPortfolioSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAcceptedPortfolioSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAcceptedPortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAcceptedPortfolioSharesInput>
    public typealias MOutput = OperationOutput<ListAcceptedPortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAcceptedPortfolioSharesOutputError>
}

public struct ListAcceptedPortfolioSharesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAcceptedPortfolioSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAcceptedPortfolioSharesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAcceptedPortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAcceptedPortfolioSharesInput>
    public typealias MOutput = OperationOutput<ListAcceptedPortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAcceptedPortfolioSharesOutputError>
}

public struct ListAcceptedPortfolioSharesInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The type of shared portfolios to list. The default is to list imported portfolios.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AWS_ORGANIZATIONS</code> - List portfolios shared by the management
    ///                account of your organization</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AWS_SERVICECATALOG</code> - List default portfolios</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IMPORTED</code> - List imported portfolios</p>
    ///             </li>
    ///          </ul>
    public let portfolioShareType: PortfolioShareType?

    public init (
        acceptLanguage: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        portfolioShareType: PortfolioShareType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioShareType = portfolioShareType
    }
}

struct ListAcceptedPortfolioSharesInputBody: Equatable {
    public let acceptLanguage: String?
    public let pageToken: String?
    public let pageSize: Int
    public let portfolioShareType: PortfolioShareType?
}

extension ListAcceptedPortfolioSharesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioShareType = "PortfolioShareType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let portfolioShareTypeDecoded = try containerValues.decodeIfPresent(PortfolioShareType.self, forKey: .portfolioShareType)
        portfolioShareType = portfolioShareTypeDecoded
    }
}

extension ListAcceptedPortfolioSharesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAcceptedPortfolioSharesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAcceptedPortfolioSharesOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case operationNotSupportedException(OperationNotSupportedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAcceptedPortfolioSharesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAcceptedPortfolioSharesOutputResponse(nextPageToken: \(String(describing: nextPageToken)), portfolioDetails: \(String(describing: portfolioDetails)))"}
}

extension ListAcceptedPortfolioSharesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAcceptedPortfolioSharesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.portfolioDetails = output.portfolioDetails
        } else {
            self.nextPageToken = nil
            self.portfolioDetails = nil
        }
    }
}

public struct ListAcceptedPortfolioSharesOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Information about the portfolios.</p>
    public let portfolioDetails: [PortfolioDetail]?

    public init (
        nextPageToken: String? = nil,
        portfolioDetails: [PortfolioDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioDetails = portfolioDetails
    }
}

struct ListAcceptedPortfolioSharesOutputResponseBody: Equatable {
    public let portfolioDetails: [PortfolioDetail]?
    public let nextPageToken: String?
}

extension ListAcceptedPortfolioSharesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case portfolioDetails = "PortfolioDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailsContainer = try containerValues.decodeIfPresent([PortfolioDetail?].self, forKey: .portfolioDetails)
        var portfolioDetailsDecoded0:[PortfolioDetail]? = nil
        if let portfolioDetailsContainer = portfolioDetailsContainer {
            portfolioDetailsDecoded0 = [PortfolioDetail]()
            for structure0 in portfolioDetailsContainer {
                if let structure0 = structure0 {
                    portfolioDetailsDecoded0?.append(structure0)
                }
            }
        }
        portfolioDetails = portfolioDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListBudgetsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListBudgetsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBudgetsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBudgetsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBudgetsForResourceInput>
    public typealias MOutput = OperationOutput<ListBudgetsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBudgetsForResourceOutputError>
}

extension ListBudgetsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBudgetsForResourceInput(acceptLanguage: \(String(describing: acceptLanguage)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), resourceId: \(String(describing: resourceId)))"}
}

extension ListBudgetsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct ListBudgetsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListBudgetsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBudgetsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBudgetsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBudgetsForResourceInput>
    public typealias MOutput = OperationOutput<ListBudgetsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBudgetsForResourceOutputError>
}

public struct ListBudgetsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBudgetsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBudgetsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBudgetsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBudgetsForResourceInput>
    public typealias MOutput = OperationOutput<ListBudgetsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBudgetsForResourceOutputError>
}

public struct ListBudgetsForResourceInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The resource identifier.</p>
    public let resourceId: String?

    public init (
        acceptLanguage: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        resourceId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.resourceId = resourceId
    }
}

struct ListBudgetsForResourceInputBody: Equatable {
    public let acceptLanguage: String?
    public let resourceId: String?
    public let pageSize: Int
    public let pageToken: String?
}

extension ListBudgetsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListBudgetsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBudgetsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBudgetsForResourceOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBudgetsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBudgetsForResourceOutputResponse(budgets: \(String(describing: budgets)), nextPageToken: \(String(describing: nextPageToken)))"}
}

extension ListBudgetsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBudgetsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.budgets = output.budgets
            self.nextPageToken = output.nextPageToken
        } else {
            self.budgets = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListBudgetsForResourceOutputResponse: Equatable {
    /// <p>Information about the associated budgets.</p>
    public let budgets: [BudgetDetail]?
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?

    public init (
        budgets: [BudgetDetail]? = nil,
        nextPageToken: String? = nil
    )
    {
        self.budgets = budgets
        self.nextPageToken = nextPageToken
    }
}

struct ListBudgetsForResourceOutputResponseBody: Equatable {
    public let budgets: [BudgetDetail]?
    public let nextPageToken: String?
}

extension ListBudgetsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case budgets = "Budgets"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetsContainer = try containerValues.decodeIfPresent([BudgetDetail?].self, forKey: .budgets)
        var budgetsDecoded0:[BudgetDetail]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [BudgetDetail]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListConstraintsForPortfolioInputBodyMiddleware: Middleware {
    public let id: String = "ListConstraintsForPortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConstraintsForPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConstraintsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConstraintsForPortfolioInput>
    public typealias MOutput = OperationOutput<ListConstraintsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConstraintsForPortfolioOutputError>
}

extension ListConstraintsForPortfolioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConstraintsForPortfolioInput(acceptLanguage: \(String(describing: acceptLanguage)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), portfolioId: \(String(describing: portfolioId)), productId: \(String(describing: productId)))"}
}

extension ListConstraintsForPortfolioInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

public struct ListConstraintsForPortfolioInputHeadersMiddleware: Middleware {
    public let id: String = "ListConstraintsForPortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConstraintsForPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConstraintsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConstraintsForPortfolioInput>
    public typealias MOutput = OperationOutput<ListConstraintsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConstraintsForPortfolioOutputError>
}

public struct ListConstraintsForPortfolioInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConstraintsForPortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConstraintsForPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConstraintsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConstraintsForPortfolioInput>
    public typealias MOutput = OperationOutput<ListConstraintsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConstraintsForPortfolioOutputError>
}

public struct ListConstraintsForPortfolioInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?
    /// <p>The product identifier.</p>
    public let productId: String?

    public init (
        acceptLanguage: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        portfolioId: String? = nil,
        productId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
        self.productId = productId
    }
}

struct ListConstraintsForPortfolioInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let productId: String?
    public let pageSize: Int
    public let pageToken: String?
}

extension ListConstraintsForPortfolioInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListConstraintsForPortfolioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConstraintsForPortfolioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConstraintsForPortfolioOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConstraintsForPortfolioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConstraintsForPortfolioOutputResponse(constraintDetails: \(String(describing: constraintDetails)), nextPageToken: \(String(describing: nextPageToken)))"}
}

extension ListConstraintsForPortfolioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConstraintsForPortfolioOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.constraintDetails = output.constraintDetails
            self.nextPageToken = output.nextPageToken
        } else {
            self.constraintDetails = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListConstraintsForPortfolioOutputResponse: Equatable {
    /// <p>Information about the constraints.</p>
    public let constraintDetails: [ConstraintDetail]?
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?

    public init (
        constraintDetails: [ConstraintDetail]? = nil,
        nextPageToken: String? = nil
    )
    {
        self.constraintDetails = constraintDetails
        self.nextPageToken = nextPageToken
    }
}

struct ListConstraintsForPortfolioOutputResponseBody: Equatable {
    public let constraintDetails: [ConstraintDetail]?
    public let nextPageToken: String?
}

extension ListConstraintsForPortfolioOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case constraintDetails = "ConstraintDetails"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDetailsContainer = try containerValues.decodeIfPresent([ConstraintDetail?].self, forKey: .constraintDetails)
        var constraintDetailsDecoded0:[ConstraintDetail]? = nil
        if let constraintDetailsContainer = constraintDetailsContainer {
            constraintDetailsDecoded0 = [ConstraintDetail]()
            for structure0 in constraintDetailsContainer {
                if let structure0 = structure0 {
                    constraintDetailsDecoded0?.append(structure0)
                }
            }
        }
        constraintDetails = constraintDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListLaunchPathsInputBodyMiddleware: Middleware {
    public let id: String = "ListLaunchPathsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLaunchPathsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLaunchPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLaunchPathsInput>
    public typealias MOutput = OperationOutput<ListLaunchPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLaunchPathsOutputError>
}

extension ListLaunchPathsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLaunchPathsInput(acceptLanguage: \(String(describing: acceptLanguage)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), productId: \(String(describing: productId)))"}
}

extension ListLaunchPathsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

public struct ListLaunchPathsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLaunchPathsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLaunchPathsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLaunchPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLaunchPathsInput>
    public typealias MOutput = OperationOutput<ListLaunchPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLaunchPathsOutputError>
}

public struct ListLaunchPathsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLaunchPathsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLaunchPathsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLaunchPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLaunchPathsInput>
    public typealias MOutput = OperationOutput<ListLaunchPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLaunchPathsOutputError>
}

public struct ListLaunchPathsInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The product identifier.</p>
    public let productId: String?

    public init (
        acceptLanguage: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        productId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.productId = productId
    }
}

struct ListLaunchPathsInputBody: Equatable {
    public let acceptLanguage: String?
    public let productId: String?
    public let pageSize: Int
    public let pageToken: String?
}

extension ListLaunchPathsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListLaunchPathsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLaunchPathsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLaunchPathsOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLaunchPathsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLaunchPathsOutputResponse(launchPathSummaries: \(String(describing: launchPathSummaries)), nextPageToken: \(String(describing: nextPageToken)))"}
}

extension ListLaunchPathsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLaunchPathsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.launchPathSummaries = output.launchPathSummaries
            self.nextPageToken = output.nextPageToken
        } else {
            self.launchPathSummaries = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListLaunchPathsOutputResponse: Equatable {
    /// <p>Information about the launch path.</p>
    public let launchPathSummaries: [LaunchPathSummary]?
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?

    public init (
        launchPathSummaries: [LaunchPathSummary]? = nil,
        nextPageToken: String? = nil
    )
    {
        self.launchPathSummaries = launchPathSummaries
        self.nextPageToken = nextPageToken
    }
}

struct ListLaunchPathsOutputResponseBody: Equatable {
    public let launchPathSummaries: [LaunchPathSummary]?
    public let nextPageToken: String?
}

extension ListLaunchPathsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case launchPathSummaries = "LaunchPathSummaries"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchPathSummariesContainer = try containerValues.decodeIfPresent([LaunchPathSummary?].self, forKey: .launchPathSummaries)
        var launchPathSummariesDecoded0:[LaunchPathSummary]? = nil
        if let launchPathSummariesContainer = launchPathSummariesContainer {
            launchPathSummariesDecoded0 = [LaunchPathSummary]()
            for structure0 in launchPathSummariesContainer {
                if let structure0 = structure0 {
                    launchPathSummariesDecoded0?.append(structure0)
                }
            }
        }
        launchPathSummaries = launchPathSummariesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListOrganizationPortfolioAccessInputBodyMiddleware: Middleware {
    public let id: String = "ListOrganizationPortfolioAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOrganizationPortfolioAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOrganizationPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOrganizationPortfolioAccessInput>
    public typealias MOutput = OperationOutput<ListOrganizationPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOrganizationPortfolioAccessOutputError>
}

extension ListOrganizationPortfolioAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOrganizationPortfolioAccessInput(acceptLanguage: \(String(describing: acceptLanguage)), organizationNodeType: \(String(describing: organizationNodeType)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), portfolioId: \(String(describing: portfolioId)))"}
}

extension ListOrganizationPortfolioAccessInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case organizationNodeType = "OrganizationNodeType"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let organizationNodeType = organizationNodeType {
            try encodeContainer.encode(organizationNodeType.rawValue, forKey: .organizationNodeType)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
    }
}

public struct ListOrganizationPortfolioAccessInputHeadersMiddleware: Middleware {
    public let id: String = "ListOrganizationPortfolioAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOrganizationPortfolioAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOrganizationPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOrganizationPortfolioAccessInput>
    public typealias MOutput = OperationOutput<ListOrganizationPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOrganizationPortfolioAccessOutputError>
}

public struct ListOrganizationPortfolioAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOrganizationPortfolioAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOrganizationPortfolioAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOrganizationPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOrganizationPortfolioAccessInput>
    public typealias MOutput = OperationOutput<ListOrganizationPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOrganizationPortfolioAccessOutputError>
}

public struct ListOrganizationPortfolioAccessInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The organization node type that will be returned in the output.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ORGANIZATION</code> - Organization that has access to the portfolio. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ORGANIZATIONAL_UNIT</code> - Organizational unit that has access to the portfolio within your organization.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACCOUNT</code> - Account that has access to the portfolio within your organization.</p>
    ///             </li>
    ///          </ul>
    public let organizationNodeType: OrganizationNodeType?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The portfolio identifier. For example, <code>port-2abcdext3y5fk</code>.</p>
    public let portfolioId: String?

    public init (
        acceptLanguage: String? = nil,
        organizationNodeType: OrganizationNodeType? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        portfolioId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.organizationNodeType = organizationNodeType
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
    }
}

struct ListOrganizationPortfolioAccessInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let organizationNodeType: OrganizationNodeType?
    public let pageToken: String?
    public let pageSize: Int
}

extension ListOrganizationPortfolioAccessInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case organizationNodeType = "OrganizationNodeType"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let organizationNodeTypeDecoded = try containerValues.decodeIfPresent(OrganizationNodeType.self, forKey: .organizationNodeType)
        organizationNodeType = organizationNodeTypeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListOrganizationPortfolioAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationPortfolioAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOrganizationPortfolioAccessOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationPortfolioAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOrganizationPortfolioAccessOutputResponse(nextPageToken: \(String(describing: nextPageToken)), organizationNodes: \(String(describing: organizationNodes)))"}
}

extension ListOrganizationPortfolioAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOrganizationPortfolioAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.organizationNodes = output.organizationNodes
        } else {
            self.nextPageToken = nil
            self.organizationNodes = nil
        }
    }
}

public struct ListOrganizationPortfolioAccessOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Displays information about the organization nodes.</p>
    public let organizationNodes: [OrganizationNode]?

    public init (
        nextPageToken: String? = nil,
        organizationNodes: [OrganizationNode]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.organizationNodes = organizationNodes
    }
}

struct ListOrganizationPortfolioAccessOutputResponseBody: Equatable {
    public let organizationNodes: [OrganizationNode]?
    public let nextPageToken: String?
}

extension ListOrganizationPortfolioAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case organizationNodes = "OrganizationNodes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationNodesContainer = try containerValues.decodeIfPresent([OrganizationNode?].self, forKey: .organizationNodes)
        var organizationNodesDecoded0:[OrganizationNode]? = nil
        if let organizationNodesContainer = organizationNodesContainer {
            organizationNodesDecoded0 = [OrganizationNode]()
            for structure0 in organizationNodesContainer {
                if let structure0 = structure0 {
                    organizationNodesDecoded0?.append(structure0)
                }
            }
        }
        organizationNodes = organizationNodesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListPortfolioAccessInputBodyMiddleware: Middleware {
    public let id: String = "ListPortfolioAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPortfolioAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPortfolioAccessInput>
    public typealias MOutput = OperationOutput<ListPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPortfolioAccessOutputError>
}

extension ListPortfolioAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPortfolioAccessInput(acceptLanguage: \(String(describing: acceptLanguage)), organizationParentId: \(String(describing: organizationParentId)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), portfolioId: \(String(describing: portfolioId)))"}
}

extension ListPortfolioAccessInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case organizationParentId = "OrganizationParentId"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let organizationParentId = organizationParentId {
            try encodeContainer.encode(organizationParentId, forKey: .organizationParentId)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
    }
}

public struct ListPortfolioAccessInputHeadersMiddleware: Middleware {
    public let id: String = "ListPortfolioAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPortfolioAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPortfolioAccessInput>
    public typealias MOutput = OperationOutput<ListPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPortfolioAccessOutputError>
}

public struct ListPortfolioAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPortfolioAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPortfolioAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPortfolioAccessInput>
    public typealias MOutput = OperationOutput<ListPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPortfolioAccessOutputError>
}

public struct ListPortfolioAccessInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The ID of an organization node the portfolio is shared with. All children of this node with an inherited portfolio share will be returned.</p>
    public let organizationParentId: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?

    public init (
        acceptLanguage: String? = nil,
        organizationParentId: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        portfolioId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.organizationParentId = organizationParentId
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
    }
}

struct ListPortfolioAccessInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let organizationParentId: String?
    public let pageToken: String?
    public let pageSize: Int
}

extension ListPortfolioAccessInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case organizationParentId = "OrganizationParentId"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let organizationParentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationParentId)
        organizationParentId = organizationParentIdDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListPortfolioAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPortfolioAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPortfolioAccessOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPortfolioAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPortfolioAccessOutputResponse(accountIds: \(String(describing: accountIds)), nextPageToken: \(String(describing: nextPageToken)))"}
}

extension ListPortfolioAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPortfolioAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountIds = output.accountIds
            self.nextPageToken = output.nextPageToken
        } else {
            self.accountIds = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListPortfolioAccessOutputResponse: Equatable {
    /// <p>Information about the AWS accounts with access to the portfolio.</p>
    public let accountIds: [String]?
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?

    public init (
        accountIds: [String]? = nil,
        nextPageToken: String? = nil
    )
    {
        self.accountIds = accountIds
        self.nextPageToken = nextPageToken
    }
}

struct ListPortfolioAccessOutputResponseBody: Equatable {
    public let accountIds: [String]?
    public let nextPageToken: String?
}

extension ListPortfolioAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListPortfoliosForProductInputBodyMiddleware: Middleware {
    public let id: String = "ListPortfoliosForProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPortfoliosForProductInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPortfoliosForProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPortfoliosForProductInput>
    public typealias MOutput = OperationOutput<ListPortfoliosForProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPortfoliosForProductOutputError>
}

extension ListPortfoliosForProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPortfoliosForProductInput(acceptLanguage: \(String(describing: acceptLanguage)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), productId: \(String(describing: productId)))"}
}

extension ListPortfoliosForProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

public struct ListPortfoliosForProductInputHeadersMiddleware: Middleware {
    public let id: String = "ListPortfoliosForProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPortfoliosForProductInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPortfoliosForProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPortfoliosForProductInput>
    public typealias MOutput = OperationOutput<ListPortfoliosForProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPortfoliosForProductOutputError>
}

public struct ListPortfoliosForProductInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPortfoliosForProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPortfoliosForProductInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPortfoliosForProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPortfoliosForProductInput>
    public typealias MOutput = OperationOutput<ListPortfoliosForProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPortfoliosForProductOutputError>
}

public struct ListPortfoliosForProductInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The product identifier.</p>
    public let productId: String?

    public init (
        acceptLanguage: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        productId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.productId = productId
    }
}

struct ListPortfoliosForProductInputBody: Equatable {
    public let acceptLanguage: String?
    public let productId: String?
    public let pageToken: String?
    public let pageSize: Int
}

extension ListPortfoliosForProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListPortfoliosForProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPortfoliosForProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPortfoliosForProductOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPortfoliosForProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPortfoliosForProductOutputResponse(nextPageToken: \(String(describing: nextPageToken)), portfolioDetails: \(String(describing: portfolioDetails)))"}
}

extension ListPortfoliosForProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPortfoliosForProductOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.portfolioDetails = output.portfolioDetails
        } else {
            self.nextPageToken = nil
            self.portfolioDetails = nil
        }
    }
}

public struct ListPortfoliosForProductOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Information about the portfolios.</p>
    public let portfolioDetails: [PortfolioDetail]?

    public init (
        nextPageToken: String? = nil,
        portfolioDetails: [PortfolioDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioDetails = portfolioDetails
    }
}

struct ListPortfoliosForProductOutputResponseBody: Equatable {
    public let portfolioDetails: [PortfolioDetail]?
    public let nextPageToken: String?
}

extension ListPortfoliosForProductOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case portfolioDetails = "PortfolioDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailsContainer = try containerValues.decodeIfPresent([PortfolioDetail?].self, forKey: .portfolioDetails)
        var portfolioDetailsDecoded0:[PortfolioDetail]? = nil
        if let portfolioDetailsContainer = portfolioDetailsContainer {
            portfolioDetailsDecoded0 = [PortfolioDetail]()
            for structure0 in portfolioDetailsContainer {
                if let structure0 = structure0 {
                    portfolioDetailsDecoded0?.append(structure0)
                }
            }
        }
        portfolioDetails = portfolioDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListPortfoliosInputBodyMiddleware: Middleware {
    public let id: String = "ListPortfoliosInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPortfoliosInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPortfoliosOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPortfoliosInput>
    public typealias MOutput = OperationOutput<ListPortfoliosOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPortfoliosOutputError>
}

extension ListPortfoliosInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPortfoliosInput(acceptLanguage: \(String(describing: acceptLanguage)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)))"}
}

extension ListPortfoliosInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

public struct ListPortfoliosInputHeadersMiddleware: Middleware {
    public let id: String = "ListPortfoliosInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPortfoliosInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPortfoliosOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPortfoliosInput>
    public typealias MOutput = OperationOutput<ListPortfoliosOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPortfoliosOutputError>
}

public struct ListPortfoliosInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPortfoliosInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPortfoliosInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPortfoliosOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPortfoliosInput>
    public typealias MOutput = OperationOutput<ListPortfoliosOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPortfoliosOutputError>
}

public struct ListPortfoliosInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?

    public init (
        acceptLanguage: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct ListPortfoliosInputBody: Equatable {
    public let acceptLanguage: String?
    public let pageToken: String?
    public let pageSize: Int
}

extension ListPortfoliosInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListPortfoliosOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPortfoliosOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPortfoliosOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPortfoliosOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPortfoliosOutputResponse(nextPageToken: \(String(describing: nextPageToken)), portfolioDetails: \(String(describing: portfolioDetails)))"}
}

extension ListPortfoliosOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPortfoliosOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.portfolioDetails = output.portfolioDetails
        } else {
            self.nextPageToken = nil
            self.portfolioDetails = nil
        }
    }
}

public struct ListPortfoliosOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Information about the portfolios.</p>
    public let portfolioDetails: [PortfolioDetail]?

    public init (
        nextPageToken: String? = nil,
        portfolioDetails: [PortfolioDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioDetails = portfolioDetails
    }
}

struct ListPortfoliosOutputResponseBody: Equatable {
    public let portfolioDetails: [PortfolioDetail]?
    public let nextPageToken: String?
}

extension ListPortfoliosOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case portfolioDetails = "PortfolioDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailsContainer = try containerValues.decodeIfPresent([PortfolioDetail?].self, forKey: .portfolioDetails)
        var portfolioDetailsDecoded0:[PortfolioDetail]? = nil
        if let portfolioDetailsContainer = portfolioDetailsContainer {
            portfolioDetailsDecoded0 = [PortfolioDetail]()
            for structure0 in portfolioDetailsContainer {
                if let structure0 = structure0 {
                    portfolioDetailsDecoded0?.append(structure0)
                }
            }
        }
        portfolioDetails = portfolioDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListPrincipalsForPortfolioInputBodyMiddleware: Middleware {
    public let id: String = "ListPrincipalsForPortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPrincipalsForPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPrincipalsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPrincipalsForPortfolioInput>
    public typealias MOutput = OperationOutput<ListPrincipalsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPrincipalsForPortfolioOutputError>
}

extension ListPrincipalsForPortfolioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPrincipalsForPortfolioInput(acceptLanguage: \(String(describing: acceptLanguage)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), portfolioId: \(String(describing: portfolioId)))"}
}

extension ListPrincipalsForPortfolioInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
    }
}

public struct ListPrincipalsForPortfolioInputHeadersMiddleware: Middleware {
    public let id: String = "ListPrincipalsForPortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPrincipalsForPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPrincipalsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPrincipalsForPortfolioInput>
    public typealias MOutput = OperationOutput<ListPrincipalsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPrincipalsForPortfolioOutputError>
}

public struct ListPrincipalsForPortfolioInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPrincipalsForPortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPrincipalsForPortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPrincipalsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPrincipalsForPortfolioInput>
    public typealias MOutput = OperationOutput<ListPrincipalsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPrincipalsForPortfolioOutputError>
}

public struct ListPrincipalsForPortfolioInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?

    public init (
        acceptLanguage: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        portfolioId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
    }
}

struct ListPrincipalsForPortfolioInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let pageSize: Int
    public let pageToken: String?
}

extension ListPrincipalsForPortfolioInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListPrincipalsForPortfolioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPrincipalsForPortfolioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPrincipalsForPortfolioOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPrincipalsForPortfolioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPrincipalsForPortfolioOutputResponse(nextPageToken: \(String(describing: nextPageToken)), principals: \(String(describing: principals)))"}
}

extension ListPrincipalsForPortfolioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPrincipalsForPortfolioOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.principals = output.principals
        } else {
            self.nextPageToken = nil
            self.principals = nil
        }
    }
}

public struct ListPrincipalsForPortfolioOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>The IAM principals (users or roles) associated with the portfolio.</p>
    public let principals: [Principal]?

    public init (
        nextPageToken: String? = nil,
        principals: [Principal]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.principals = principals
    }
}

struct ListPrincipalsForPortfolioOutputResponseBody: Equatable {
    public let principals: [Principal]?
    public let nextPageToken: String?
}

extension ListPrincipalsForPortfolioOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case principals = "Principals"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([Principal?].self, forKey: .principals)
        var principalsDecoded0:[Principal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Principal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListProvisionedProductPlansInputBodyMiddleware: Middleware {
    public let id: String = "ListProvisionedProductPlansInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisionedProductPlansInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisionedProductPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisionedProductPlansInput>
    public typealias MOutput = OperationOutput<ListProvisionedProductPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisionedProductPlansOutputError>
}

extension ListProvisionedProductPlansInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisionedProductPlansInput(acceptLanguage: \(String(describing: acceptLanguage)), accessLevelFilter: \(String(describing: accessLevelFilter)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), provisionProductId: \(String(describing: provisionProductId)))"}
}

extension ListProvisionedProductPlansInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionProductId = "ProvisionProductId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accessLevelFilter = accessLevelFilter {
            try encodeContainer.encode(accessLevelFilter, forKey: .accessLevelFilter)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let provisionProductId = provisionProductId {
            try encodeContainer.encode(provisionProductId, forKey: .provisionProductId)
        }
    }
}

public struct ListProvisionedProductPlansInputHeadersMiddleware: Middleware {
    public let id: String = "ListProvisionedProductPlansInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisionedProductPlansInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisionedProductPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisionedProductPlansInput>
    public typealias MOutput = OperationOutput<ListProvisionedProductPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisionedProductPlansOutputError>
}

public struct ListProvisionedProductPlansInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProvisionedProductPlansInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisionedProductPlansInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisionedProductPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisionedProductPlansInput>
    public typealias MOutput = OperationOutput<ListProvisionedProductPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisionedProductPlansOutputError>
}

public struct ListProvisionedProductPlansInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The access level to use to obtain results. The default is <code>User</code>.</p>
    public let accessLevelFilter: AccessLevelFilter?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The product identifier.</p>
    public let provisionProductId: String?

    public init (
        acceptLanguage: String? = nil,
        accessLevelFilter: AccessLevelFilter? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        provisionProductId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.provisionProductId = provisionProductId
    }
}

struct ListProvisionedProductPlansInputBody: Equatable {
    public let acceptLanguage: String?
    public let provisionProductId: String?
    public let pageSize: Int
    public let pageToken: String?
    public let accessLevelFilter: AccessLevelFilter?
}

extension ListProvisionedProductPlansInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionProductId = "ProvisionProductId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionProductId)
        provisionProductId = provisionProductIdDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let accessLevelFilterDecoded = try containerValues.decodeIfPresent(AccessLevelFilter.self, forKey: .accessLevelFilter)
        accessLevelFilter = accessLevelFilterDecoded
    }
}

extension ListProvisionedProductPlansOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisionedProductPlansOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisionedProductPlansOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisionedProductPlansOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisionedProductPlansOutputResponse(nextPageToken: \(String(describing: nextPageToken)), provisionedProductPlans: \(String(describing: provisionedProductPlans)))"}
}

extension ListProvisionedProductPlansOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProvisionedProductPlansOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.provisionedProductPlans = output.provisionedProductPlans
        } else {
            self.nextPageToken = nil
            self.provisionedProductPlans = nil
        }
    }
}

public struct ListProvisionedProductPlansOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Information about the plans.</p>
    public let provisionedProductPlans: [ProvisionedProductPlanSummary]?

    public init (
        nextPageToken: String? = nil,
        provisionedProductPlans: [ProvisionedProductPlanSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProductPlans = provisionedProductPlans
    }
}

struct ListProvisionedProductPlansOutputResponseBody: Equatable {
    public let provisionedProductPlans: [ProvisionedProductPlanSummary]?
    public let nextPageToken: String?
}

extension ListProvisionedProductPlansOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case provisionedProductPlans = "ProvisionedProductPlans"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductPlansContainer = try containerValues.decodeIfPresent([ProvisionedProductPlanSummary?].self, forKey: .provisionedProductPlans)
        var provisionedProductPlansDecoded0:[ProvisionedProductPlanSummary]? = nil
        if let provisionedProductPlansContainer = provisionedProductPlansContainer {
            provisionedProductPlansDecoded0 = [ProvisionedProductPlanSummary]()
            for structure0 in provisionedProductPlansContainer {
                if let structure0 = structure0 {
                    provisionedProductPlansDecoded0?.append(structure0)
                }
            }
        }
        provisionedProductPlans = provisionedProductPlansDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListProvisioningArtifactsForServiceActionInputBodyMiddleware: Middleware {
    public let id: String = "ListProvisioningArtifactsForServiceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisioningArtifactsForServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisioningArtifactsForServiceActionInput>
    public typealias MOutput = OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisioningArtifactsForServiceActionOutputError>
}

extension ListProvisioningArtifactsForServiceActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisioningArtifactsForServiceActionInput(acceptLanguage: \(String(describing: acceptLanguage)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), serviceActionId: \(String(describing: serviceActionId)))"}
}

extension ListProvisioningArtifactsForServiceActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

public struct ListProvisioningArtifactsForServiceActionInputHeadersMiddleware: Middleware {
    public let id: String = "ListProvisioningArtifactsForServiceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisioningArtifactsForServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisioningArtifactsForServiceActionInput>
    public typealias MOutput = OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisioningArtifactsForServiceActionOutputError>
}

public struct ListProvisioningArtifactsForServiceActionInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProvisioningArtifactsForServiceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisioningArtifactsForServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisioningArtifactsForServiceActionInput>
    public typealias MOutput = OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisioningArtifactsForServiceActionOutputError>
}

public struct ListProvisioningArtifactsForServiceActionInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
    public let serviceActionId: String?

    public init (
        acceptLanguage: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        serviceActionId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.serviceActionId = serviceActionId
    }
}

struct ListProvisioningArtifactsForServiceActionInputBody: Equatable {
    public let serviceActionId: String?
    public let pageSize: Int
    public let pageToken: String?
    public let acceptLanguage: String?
}

extension ListProvisioningArtifactsForServiceActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case serviceActionId = "ServiceActionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension ListProvisioningArtifactsForServiceActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisioningArtifactsForServiceActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisioningArtifactsForServiceActionOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisioningArtifactsForServiceActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisioningArtifactsForServiceActionOutputResponse(nextPageToken: \(String(describing: nextPageToken)), provisioningArtifactViews: \(String(describing: provisioningArtifactViews)))"}
}

extension ListProvisioningArtifactsForServiceActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProvisioningArtifactsForServiceActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.provisioningArtifactViews = output.provisioningArtifactViews
        } else {
            self.nextPageToken = nil
            self.provisioningArtifactViews = nil
        }
    }
}

public struct ListProvisioningArtifactsForServiceActionOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>An array of objects with information about product views and provisioning artifacts.</p>
    public let provisioningArtifactViews: [ProvisioningArtifactView]?

    public init (
        nextPageToken: String? = nil,
        provisioningArtifactViews: [ProvisioningArtifactView]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisioningArtifactViews = provisioningArtifactViews
    }
}

struct ListProvisioningArtifactsForServiceActionOutputResponseBody: Equatable {
    public let provisioningArtifactViews: [ProvisioningArtifactView]?
    public let nextPageToken: String?
}

extension ListProvisioningArtifactsForServiceActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case provisioningArtifactViews = "ProvisioningArtifactViews"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactViewsContainer = try containerValues.decodeIfPresent([ProvisioningArtifactView?].self, forKey: .provisioningArtifactViews)
        var provisioningArtifactViewsDecoded0:[ProvisioningArtifactView]? = nil
        if let provisioningArtifactViewsContainer = provisioningArtifactViewsContainer {
            provisioningArtifactViewsDecoded0 = [ProvisioningArtifactView]()
            for structure0 in provisioningArtifactViewsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactViewsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactViews = provisioningArtifactViewsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListProvisioningArtifactsInputBodyMiddleware: Middleware {
    public let id: String = "ListProvisioningArtifactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisioningArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisioningArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisioningArtifactsInput>
    public typealias MOutput = OperationOutput<ListProvisioningArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisioningArtifactsOutputError>
}

extension ListProvisioningArtifactsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisioningArtifactsInput(acceptLanguage: \(String(describing: acceptLanguage)), productId: \(String(describing: productId)))"}
}

extension ListProvisioningArtifactsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

public struct ListProvisioningArtifactsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProvisioningArtifactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisioningArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisioningArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisioningArtifactsInput>
    public typealias MOutput = OperationOutput<ListProvisioningArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisioningArtifactsOutputError>
}

public struct ListProvisioningArtifactsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProvisioningArtifactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisioningArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisioningArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisioningArtifactsInput>
    public typealias MOutput = OperationOutput<ListProvisioningArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisioningArtifactsOutputError>
}

public struct ListProvisioningArtifactsInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The product identifier.</p>
    public let productId: String?

    public init (
        acceptLanguage: String? = nil,
        productId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
    }
}

struct ListProvisioningArtifactsInputBody: Equatable {
    public let acceptLanguage: String?
    public let productId: String?
}

extension ListProvisioningArtifactsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
    }
}

extension ListProvisioningArtifactsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisioningArtifactsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisioningArtifactsOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisioningArtifactsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisioningArtifactsOutputResponse(nextPageToken: \(String(describing: nextPageToken)), provisioningArtifactDetails: \(String(describing: provisioningArtifactDetails)))"}
}

extension ListProvisioningArtifactsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProvisioningArtifactsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.provisioningArtifactDetails = output.provisioningArtifactDetails
        } else {
            self.nextPageToken = nil
            self.provisioningArtifactDetails = nil
        }
    }
}

public struct ListProvisioningArtifactsOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Information about the provisioning artifacts.</p>
    public let provisioningArtifactDetails: [ProvisioningArtifactDetail]?

    public init (
        nextPageToken: String? = nil,
        provisioningArtifactDetails: [ProvisioningArtifactDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisioningArtifactDetails = provisioningArtifactDetails
    }
}

struct ListProvisioningArtifactsOutputResponseBody: Equatable {
    public let provisioningArtifactDetails: [ProvisioningArtifactDetail]?
    public let nextPageToken: String?
}

extension ListProvisioningArtifactsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case provisioningArtifactDetails = "ProvisioningArtifactDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactDetailsContainer = try containerValues.decodeIfPresent([ProvisioningArtifactDetail?].self, forKey: .provisioningArtifactDetails)
        var provisioningArtifactDetailsDecoded0:[ProvisioningArtifactDetail]? = nil
        if let provisioningArtifactDetailsContainer = provisioningArtifactDetailsContainer {
            provisioningArtifactDetailsDecoded0 = [ProvisioningArtifactDetail]()
            for structure0 in provisioningArtifactDetailsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactDetailsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactDetails = provisioningArtifactDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListRecordHistoryInputBodyMiddleware: Middleware {
    public let id: String = "ListRecordHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecordHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecordHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecordHistoryInput>
    public typealias MOutput = OperationOutput<ListRecordHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecordHistoryOutputError>
}

extension ListRecordHistoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecordHistoryInput(acceptLanguage: \(String(describing: acceptLanguage)), accessLevelFilter: \(String(describing: accessLevelFilter)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), searchFilter: \(String(describing: searchFilter)))"}
}

extension ListRecordHistoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case searchFilter = "SearchFilter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accessLevelFilter = accessLevelFilter {
            try encodeContainer.encode(accessLevelFilter, forKey: .accessLevelFilter)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let searchFilter = searchFilter {
            try encodeContainer.encode(searchFilter, forKey: .searchFilter)
        }
    }
}

public struct ListRecordHistoryInputHeadersMiddleware: Middleware {
    public let id: String = "ListRecordHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecordHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecordHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecordHistoryInput>
    public typealias MOutput = OperationOutput<ListRecordHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecordHistoryOutputError>
}

public struct ListRecordHistoryInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRecordHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecordHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecordHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecordHistoryInput>
    public typealias MOutput = OperationOutput<ListRecordHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecordHistoryOutputError>
}

public struct ListRecordHistoryInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The access level to use to obtain results. The default is <code>User</code>.</p>
    public let accessLevelFilter: AccessLevelFilter?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The search filter to scope the results.</p>
    public let searchFilter: ListRecordHistorySearchFilter?

    public init (
        acceptLanguage: String? = nil,
        accessLevelFilter: AccessLevelFilter? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        searchFilter: ListRecordHistorySearchFilter? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.searchFilter = searchFilter
    }
}

struct ListRecordHistoryInputBody: Equatable {
    public let acceptLanguage: String?
    public let accessLevelFilter: AccessLevelFilter?
    public let searchFilter: ListRecordHistorySearchFilter?
    public let pageSize: Int
    public let pageToken: String?
}

extension ListRecordHistoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case searchFilter = "SearchFilter"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let accessLevelFilterDecoded = try containerValues.decodeIfPresent(AccessLevelFilter.self, forKey: .accessLevelFilter)
        accessLevelFilter = accessLevelFilterDecoded
        let searchFilterDecoded = try containerValues.decodeIfPresent(ListRecordHistorySearchFilter.self, forKey: .searchFilter)
        searchFilter = searchFilterDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListRecordHistoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecordHistoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecordHistoryOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecordHistoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecordHistoryOutputResponse(nextPageToken: \(String(describing: nextPageToken)), recordDetails: \(String(describing: recordDetails)))"}
}

extension ListRecordHistoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRecordHistoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.recordDetails = output.recordDetails
        } else {
            self.nextPageToken = nil
            self.recordDetails = nil
        }
    }
}

public struct ListRecordHistoryOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>The records, in reverse chronological order.</p>
    public let recordDetails: [RecordDetail]?

    public init (
        nextPageToken: String? = nil,
        recordDetails: [RecordDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.recordDetails = recordDetails
    }
}

struct ListRecordHistoryOutputResponseBody: Equatable {
    public let recordDetails: [RecordDetail]?
    public let nextPageToken: String?
}

extension ListRecordHistoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case recordDetails = "RecordDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailsContainer = try containerValues.decodeIfPresent([RecordDetail?].self, forKey: .recordDetails)
        var recordDetailsDecoded0:[RecordDetail]? = nil
        if let recordDetailsContainer = recordDetailsContainer {
            recordDetailsDecoded0 = [RecordDetail]()
            for structure0 in recordDetailsContainer {
                if let structure0 = structure0 {
                    recordDetailsDecoded0?.append(structure0)
                }
            }
        }
        recordDetails = recordDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ListRecordHistorySearchFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ListRecordHistorySearchFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecordHistorySearchFilter(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The search filter to use when listing history records.</p>
public struct ListRecordHistorySearchFilter: Equatable {
    /// <p>The filter key.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>product</code> - Filter results based on the specified product identifier.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>provisionedproduct</code> - Filter results based on the provisioned product identifier.</p>
    ///             </li>
    ///          </ul>
    public let key: String?
    /// <p>The filter value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension ListResourcesForTagOptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesForTagOptionInput(pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), resourceType: \(String(describing: resourceType)), tagOptionId: \(String(describing: tagOptionId)))"}
}

extension ListResourcesForTagOptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListResourcesForTagOptionInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourcesForTagOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesForTagOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesForTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesForTagOptionInput>
    public typealias MOutput = OperationOutput<ListResourcesForTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesForTagOptionOutputError>
}

public struct ListResourcesForTagOptionInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourcesForTagOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesForTagOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesForTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesForTagOptionInput>
    public typealias MOutput = OperationOutput<ListResourcesForTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesForTagOptionOutputError>
}

public struct ListResourcesForTagOptionInput: Equatable {
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The resource type.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Portfolio</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Product</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let resourceType: String?
    /// <p>The TagOption identifier.</p>
    public let tagOptionId: String?

    public init (
        pageSize: Int = 0,
        pageToken: String? = nil,
        resourceType: String? = nil,
        tagOptionId: String? = nil
    )
    {
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.resourceType = resourceType
        self.tagOptionId = tagOptionId
    }
}

struct ListResourcesForTagOptionInputBody: Equatable {
}

extension ListResourcesForTagOptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListResourcesForTagOptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesForTagOptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesForTagOptionOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesForTagOptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesForTagOptionOutputResponse(pageToken: \(String(describing: pageToken)), resourceDetails: \(String(describing: resourceDetails)))"}
}

extension ListResourcesForTagOptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourcesForTagOptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pageToken = output.pageToken
            self.resourceDetails = output.resourceDetails
        } else {
            self.pageToken = nil
            self.resourceDetails = nil
        }
    }
}

public struct ListResourcesForTagOptionOutputResponse: Equatable {
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>Information about the resources.</p>
    public let resourceDetails: [ResourceDetail]?

    public init (
        pageToken: String? = nil,
        resourceDetails: [ResourceDetail]? = nil
    )
    {
        self.pageToken = pageToken
        self.resourceDetails = resourceDetails
    }
}

struct ListResourcesForTagOptionOutputResponseBody: Equatable {
    public let resourceDetails: [ResourceDetail]?
    public let pageToken: String?
}

extension ListResourcesForTagOptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pageToken = "PageToken"
        case resourceDetails = "ResourceDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDetailsContainer = try containerValues.decodeIfPresent([ResourceDetail?].self, forKey: .resourceDetails)
        var resourceDetailsDecoded0:[ResourceDetail]? = nil
        if let resourceDetailsContainer = resourceDetailsContainer {
            resourceDetailsDecoded0 = [ResourceDetail]()
            for structure0 in resourceDetailsContainer {
                if let structure0 = structure0 {
                    resourceDetailsDecoded0?.append(structure0)
                }
            }
        }
        resourceDetails = resourceDetailsDecoded0
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

public struct ListServiceActionsForProvisioningArtifactInputBodyMiddleware: Middleware {
    public let id: String = "ListServiceActionsForProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceActionsForProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceActionsForProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceActionsForProvisioningArtifactOutputError>
}

extension ListServiceActionsForProvisioningArtifactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServiceActionsForProvisioningArtifactInput(acceptLanguage: \(String(describing: acceptLanguage)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), productId: \(String(describing: productId)), provisioningArtifactId: \(String(describing: provisioningArtifactId)))"}
}

extension ListServiceActionsForProvisioningArtifactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }
}

public struct ListServiceActionsForProvisioningArtifactInputHeadersMiddleware: Middleware {
    public let id: String = "ListServiceActionsForProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceActionsForProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceActionsForProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceActionsForProvisioningArtifactOutputError>
}

public struct ListServiceActionsForProvisioningArtifactInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServiceActionsForProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceActionsForProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceActionsForProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceActionsForProvisioningArtifactOutputError>
}

public struct ListServiceActionsForProvisioningArtifactInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
    public let productId: String?
    /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
    public let provisioningArtifactId: String?

    public init (
        acceptLanguage: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        productId: String? = nil,
        provisioningArtifactId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct ListServiceActionsForProvisioningArtifactInputBody: Equatable {
    public let productId: String?
    public let provisioningArtifactId: String?
    public let pageSize: Int
    public let pageToken: String?
    public let acceptLanguage: String?
}

extension ListServiceActionsForProvisioningArtifactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension ListServiceActionsForProvisioningArtifactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceActionsForProvisioningArtifactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceActionsForProvisioningArtifactOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceActionsForProvisioningArtifactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServiceActionsForProvisioningArtifactOutputResponse(nextPageToken: \(String(describing: nextPageToken)), serviceActionSummaries: \(String(describing: serviceActionSummaries)))"}
}

extension ListServiceActionsForProvisioningArtifactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServiceActionsForProvisioningArtifactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.serviceActionSummaries = output.serviceActionSummaries
        } else {
            self.nextPageToken = nil
            self.serviceActionSummaries = nil
        }
    }
}

public struct ListServiceActionsForProvisioningArtifactOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>An object containing information about the self-service actions associated with the provisioning artifact.</p>
    public let serviceActionSummaries: [ServiceActionSummary]?

    public init (
        nextPageToken: String? = nil,
        serviceActionSummaries: [ServiceActionSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.serviceActionSummaries = serviceActionSummaries
    }
}

struct ListServiceActionsForProvisioningArtifactOutputResponseBody: Equatable {
    public let serviceActionSummaries: [ServiceActionSummary]?
    public let nextPageToken: String?
}

extension ListServiceActionsForProvisioningArtifactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case serviceActionSummaries = "ServiceActionSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionSummariesContainer = try containerValues.decodeIfPresent([ServiceActionSummary?].self, forKey: .serviceActionSummaries)
        var serviceActionSummariesDecoded0:[ServiceActionSummary]? = nil
        if let serviceActionSummariesContainer = serviceActionSummariesContainer {
            serviceActionSummariesDecoded0 = [ServiceActionSummary]()
            for structure0 in serviceActionSummariesContainer {
                if let structure0 = structure0 {
                    serviceActionSummariesDecoded0?.append(structure0)
                }
            }
        }
        serviceActionSummaries = serviceActionSummariesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListServiceActionsInputBodyMiddleware: Middleware {
    public let id: String = "ListServiceActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceActionsInput>
    public typealias MOutput = OperationOutput<ListServiceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceActionsOutputError>
}

extension ListServiceActionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServiceActionsInput(acceptLanguage: \(String(describing: acceptLanguage)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)))"}
}

extension ListServiceActionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

public struct ListServiceActionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListServiceActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceActionsInput>
    public typealias MOutput = OperationOutput<ListServiceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceActionsOutputError>
}

public struct ListServiceActionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServiceActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceActionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceActionsInput>
    public typealias MOutput = OperationOutput<ListServiceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceActionsOutputError>
}

public struct ListServiceActionsInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?

    public init (
        acceptLanguage: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct ListServiceActionsInputBody: Equatable {
    public let acceptLanguage: String?
    public let pageSize: Int
    public let pageToken: String?
}

extension ListServiceActionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListServiceActionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceActionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceActionsOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceActionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServiceActionsOutputResponse(nextPageToken: \(String(describing: nextPageToken)), serviceActionSummaries: \(String(describing: serviceActionSummaries)))"}
}

extension ListServiceActionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServiceActionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.serviceActionSummaries = output.serviceActionSummaries
        } else {
            self.nextPageToken = nil
            self.serviceActionSummaries = nil
        }
    }
}

public struct ListServiceActionsOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>An object containing information about the service actions associated with the provisioning artifact.</p>
    public let serviceActionSummaries: [ServiceActionSummary]?

    public init (
        nextPageToken: String? = nil,
        serviceActionSummaries: [ServiceActionSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.serviceActionSummaries = serviceActionSummaries
    }
}

struct ListServiceActionsOutputResponseBody: Equatable {
    public let serviceActionSummaries: [ServiceActionSummary]?
    public let nextPageToken: String?
}

extension ListServiceActionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case serviceActionSummaries = "ServiceActionSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionSummariesContainer = try containerValues.decodeIfPresent([ServiceActionSummary?].self, forKey: .serviceActionSummaries)
        var serviceActionSummariesDecoded0:[ServiceActionSummary]? = nil
        if let serviceActionSummariesContainer = serviceActionSummariesContainer {
            serviceActionSummariesDecoded0 = [ServiceActionSummary]()
            for structure0 in serviceActionSummariesContainer {
                if let structure0 = structure0 {
                    serviceActionSummariesDecoded0?.append(structure0)
                }
            }
        }
        serviceActionSummaries = serviceActionSummariesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListStackInstancesForProvisionedProductInputBodyMiddleware: Middleware {
    public let id: String = "ListStackInstancesForProvisionedProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackInstancesForProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackInstancesForProvisionedProductInput>
    public typealias MOutput = OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackInstancesForProvisionedProductOutputError>
}

extension ListStackInstancesForProvisionedProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStackInstancesForProvisionedProductInput(acceptLanguage: \(String(describing: acceptLanguage)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), provisionedProductId: \(String(describing: provisionedProductId)))"}
}

extension ListStackInstancesForProvisionedProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionedProductId = "ProvisionedProductId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
    }
}

public struct ListStackInstancesForProvisionedProductInputHeadersMiddleware: Middleware {
    public let id: String = "ListStackInstancesForProvisionedProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackInstancesForProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackInstancesForProvisionedProductInput>
    public typealias MOutput = OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackInstancesForProvisionedProductOutputError>
}

public struct ListStackInstancesForProvisionedProductInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStackInstancesForProvisionedProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStackInstancesForProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStackInstancesForProvisionedProductInput>
    public typealias MOutput = OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStackInstancesForProvisionedProductOutputError>
}

public struct ListStackInstancesForProvisionedProductInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The identifier of the provisioned product.</p>
    public let provisionedProductId: String?

    public init (
        acceptLanguage: String? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        provisionedProductId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.provisionedProductId = provisionedProductId
    }
}

struct ListStackInstancesForProvisionedProductInputBody: Equatable {
    public let acceptLanguage: String?
    public let provisionedProductId: String?
    public let pageToken: String?
    public let pageSize: Int
}

extension ListStackInstancesForProvisionedProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionedProductId = "ProvisionedProductId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListStackInstancesForProvisionedProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStackInstancesForProvisionedProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStackInstancesForProvisionedProductOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStackInstancesForProvisionedProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStackInstancesForProvisionedProductOutputResponse(nextPageToken: \(String(describing: nextPageToken)), stackInstances: \(String(describing: stackInstances)))"}
}

extension ListStackInstancesForProvisionedProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStackInstancesForProvisionedProductOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.stackInstances = output.stackInstances
        } else {
            self.nextPageToken = nil
            self.stackInstances = nil
        }
    }
}

public struct ListStackInstancesForProvisionedProductOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>List of stack instances.</p>
    public let stackInstances: [StackInstance]?

    public init (
        nextPageToken: String? = nil,
        stackInstances: [StackInstance]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.stackInstances = stackInstances
    }
}

struct ListStackInstancesForProvisionedProductOutputResponseBody: Equatable {
    public let stackInstances: [StackInstance]?
    public let nextPageToken: String?
}

extension ListStackInstancesForProvisionedProductOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case stackInstances = "StackInstances"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackInstancesContainer = try containerValues.decodeIfPresent([StackInstance?].self, forKey: .stackInstances)
        var stackInstancesDecoded0:[StackInstance]? = nil
        if let stackInstancesContainer = stackInstancesContainer {
            stackInstancesDecoded0 = [StackInstance]()
            for structure0 in stackInstancesContainer {
                if let structure0 = structure0 {
                    stackInstancesDecoded0?.append(structure0)
                }
            }
        }
        stackInstances = stackInstancesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ListTagOptionsFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case active = "Active"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .active)
        active = activeDecoded
    }
}

extension ListTagOptionsFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagOptionsFilters(active: \(String(describing: active)), key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Filters to use when listing TagOptions.</p>
public struct ListTagOptionsFilters: Equatable {
    /// <p>The active state.</p>
    public let active: Bool?
    /// <p>The TagOption key.</p>
    public let key: String?
    /// <p>The TagOption value.</p>
    public let value: String?

    public init (
        active: Bool? = nil,
        key: String? = nil,
        value: String? = nil
    )
    {
        self.active = active
        self.key = key
        self.value = value
    }
}

public struct ListTagOptionsInputBodyMiddleware: Middleware {
    public let id: String = "ListTagOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagOptionsInput>
    public typealias MOutput = OperationOutput<ListTagOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagOptionsOutputError>
}

extension ListTagOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagOptionsInput(filters: \(String(describing: filters)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)))"}
}

extension ListTagOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

public struct ListTagOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagOptionsInput>
    public typealias MOutput = OperationOutput<ListTagOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagOptionsOutputError>
}

public struct ListTagOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagOptionsInput>
    public typealias MOutput = OperationOutput<ListTagOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagOptionsOutputError>
}

public struct ListTagOptionsInput: Equatable {
    /// <p>The search filters. If no search filters are specified, the output includes all TagOptions.</p>
    public let filters: ListTagOptionsFilters?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?

    public init (
        filters: ListTagOptionsFilters? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil
    )
    {
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct ListTagOptionsInputBody: Equatable {
    public let filters: ListTagOptionsFilters?
    public let pageSize: Int
    public let pageToken: String?
}

extension ListTagOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(ListTagOptionsFilters.self, forKey: .filters)
        filters = filtersDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListTagOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagOptionsOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagOptionsOutputResponse(pageToken: \(String(describing: pageToken)), tagOptionDetails: \(String(describing: tagOptionDetails)))"}
}

extension ListTagOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pageToken = output.pageToken
            self.tagOptionDetails = output.tagOptionDetails
        } else {
            self.pageToken = nil
            self.tagOptionDetails = nil
        }
    }
}

public struct ListTagOptionsOutputResponse: Equatable {
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>Information about the TagOptions.</p>
    public let tagOptionDetails: [TagOptionDetail]?

    public init (
        pageToken: String? = nil,
        tagOptionDetails: [TagOptionDetail]? = nil
    )
    {
        self.pageToken = pageToken
        self.tagOptionDetails = tagOptionDetails
    }
}

struct ListTagOptionsOutputResponseBody: Equatable {
    public let tagOptionDetails: [TagOptionDetail]?
    public let pageToken: String?
}

extension ListTagOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pageToken = "PageToken"
        case tagOptionDetails = "TagOptionDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagOptionDetailsContainer = try containerValues.decodeIfPresent([TagOptionDetail?].self, forKey: .tagOptionDetails)
        var tagOptionDetailsDecoded0:[TagOptionDetail]? = nil
        if let tagOptionDetailsContainer = tagOptionDetailsContainer {
            tagOptionDetailsDecoded0 = [TagOptionDetail]()
            for structure0 in tagOptionDetailsContainer {
                if let structure0 = structure0 {
                    tagOptionDetailsDecoded0?.append(structure0)
                }
            }
        }
        tagOptionDetails = tagOptionDetailsDecoded0
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension OperationNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationNotSupportedException(message: \(String(describing: message)))"}
}

extension OperationNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OperationNotSupportedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation is not supported.</p>
public struct OperationNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotSupportedExceptionBody: Equatable {
    public let message: String?
}

extension OperationNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNode: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OrganizationNodeType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension OrganizationNode: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationNode(type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Information about the organization node.</p>
public struct OrganizationNode: Equatable {
    /// <p>The organization node type.</p>
    public let type: OrganizationNodeType?
    /// <p>The identifier of the organization node.</p>
    public let value: String?

    public init (
        type: OrganizationNodeType? = nil,
        value: String? = nil
    )
    {
        self.type = type
        self.value = value
    }
}

public enum OrganizationNodeType {
    case account
    case organization
    case organizationalUnit
    case sdkUnknown(String)
}

extension OrganizationNodeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrganizationNodeType] {
        return [
            .account,
            .organization,
            .organizationalUnit,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .account: return "ACCOUNT"
        case .organization: return "ORGANIZATION"
        case .organizationalUnit: return "ORGANIZATIONAL_UNIT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrganizationNodeType(rawValue: rawValue) ?? OrganizationNodeType.sdkUnknown(rawValue)
    }
}

extension ParameterConstraints: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedPattern = "AllowedPattern"
        case allowedValues = "AllowedValues"
        case constraintDescription = "ConstraintDescription"
        case maxLength = "MaxLength"
        case maxValue = "MaxValue"
        case minLength = "MinLength"
        case minValue = "MinValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for allowedvalues0 in allowedValues {
                try allowedValuesContainer.encode(allowedvalues0)
            }
        }
        if let constraintDescription = constraintDescription {
            try encodeContainer.encode(constraintDescription, forKey: .constraintDescription)
        }
        if let maxLength = maxLength {
            try encodeContainer.encode(maxLength, forKey: .maxLength)
        }
        if let maxValue = maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minLength = minLength {
            try encodeContainer.encode(minLength, forKey: .minLength)
        }
        if let minValue = minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[String]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [String]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let allowedPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let constraintDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .constraintDescription)
        constraintDescription = constraintDescriptionDecoded
        let maxLengthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxLength)
        maxLength = maxLengthDecoded
        let minLengthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minLength)
        minLength = minLengthDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minValue)
        minValue = minValueDecoded
    }
}

extension ParameterConstraints: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterConstraints(allowedPattern: \(String(describing: allowedPattern)), allowedValues: \(String(describing: allowedValues)), constraintDescription: \(String(describing: constraintDescription)), maxLength: \(String(describing: maxLength)), maxValue: \(String(describing: maxValue)), minLength: \(String(describing: minLength)), minValue: \(String(describing: minValue)))"}
}

/// <p>The constraints that the administrator has put on the parameter.</p>
public struct ParameterConstraints: Equatable {
    /// <p>A regular expression that represents the patterns that allow for <code>String</code> types. The pattern must match the entire parameter value provided.</p>
    public let allowedPattern: String?
    /// <p>The values that the administrator has allowed for the parameter.</p>
    public let allowedValues: [String]?
    /// <p>A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of <code>[A-Za-z0-9]+</code> displays the following error message when the user specifies an invalid value:</p>
    ///
    ///          <p>
    ///             <code>Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+</code>
    ///          </p>
    ///
    ///          <p>By adding a constraint description, such as must only contain letters (uppercase and lowercase) and numbers, you can display the following customized error message:</p>
    ///
    ///          <p>
    ///             <code>Malformed input-Parameter MyParameter must only contain uppercase and lowercase letters and numbers.</code>
    ///          </p>
    public let constraintDescription: String?
    /// <p>An integer value that determines the largest number of characters you want to allow for <code>String</code> types. </p>
    public let maxLength: String?
    /// <p>A numeric value that determines the largest numeric value you want to allow for <code>Number</code> types.</p>
    public let maxValue: String?
    /// <p>An integer value that determines the smallest number of characters you want to allow for <code>String</code> types.</p>
    public let minLength: String?
    /// <p>A numeric value that determines the smallest numeric value you want to allow for <code>Number</code> types. </p>
    public let minValue: String?

    public init (
        allowedPattern: String? = nil,
        allowedValues: [String]? = nil,
        constraintDescription: String? = nil,
        maxLength: String? = nil,
        maxValue: String? = nil,
        minLength: String? = nil,
        minValue: String? = nil
    )
    {
        self.allowedPattern = allowedPattern
        self.allowedValues = allowedValues
        self.constraintDescription = constraintDescription
        self.maxLength = maxLength
        self.maxValue = maxValue
        self.minLength = minLength
        self.minValue = minValue
    }
}

extension PortfolioDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case id = "Id"
        case providerName = "ProviderName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
    }
}

extension PortfolioDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortfolioDetail(aRN: \(String(describing: aRN)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), id: \(String(describing: id)), providerName: \(String(describing: providerName)))"}
}

/// <p>Information about a portfolio.</p>
public struct PortfolioDetail: Equatable {
    /// <p>The ARN assigned to the portfolio.</p>
    public let aRN: String?
    /// <p>The UTC time stamp of the creation time.</p>
    public let createdTime: Date?
    /// <p>The description of the portfolio.</p>
    public let description: String?
    /// <p>The name to use for display purposes.</p>
    public let displayName: String?
    /// <p>The portfolio identifier.</p>
    public let id: String?
    /// <p>The name of the portfolio provider.</p>
    public let providerName: String?

    public init (
        aRN: String? = nil,
        createdTime: Date? = nil,
        description: String? = nil,
        displayName: String? = nil,
        id: String? = nil,
        providerName: String? = nil
    )
    {
        self.aRN = aRN
        self.createdTime = createdTime
        self.description = description
        self.displayName = displayName
        self.id = id
        self.providerName = providerName
    }
}

extension PortfolioShareDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accepted = "Accepted"
        case principalId = "PrincipalId"
        case shareTagOptions = "ShareTagOptions"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if accepted != false {
            try encodeContainer.encode(accepted, forKey: .accepted)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if shareTagOptions != false {
            try encodeContainer.encode(shareTagOptions, forKey: .shareTagOptions)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DescribePortfolioShareType.self, forKey: .type)
        type = typeDecoded
        let acceptedDecoded = try containerValues.decode(Bool.self, forKey: .accepted)
        accepted = acceptedDecoded
        let shareTagOptionsDecoded = try containerValues.decode(Bool.self, forKey: .shareTagOptions)
        shareTagOptions = shareTagOptionsDecoded
    }
}

extension PortfolioShareDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortfolioShareDetail(accepted: \(String(describing: accepted)), principalId: \(String(describing: principalId)), shareTagOptions: \(String(describing: shareTagOptions)), type: \(String(describing: type)))"}
}

/// <p>Information about the portfolio share.</p>
public struct PortfolioShareDetail: Equatable {
    /// <p>Indicates whether the shared portfolio is imported by the recipient account. If the recipient is in an organization node, the share is automatically imported, and the field is always set to true.</p>
    public let accepted: Bool
    /// <p>The identifier of the recipient entity that received the portfolio share.
    ///          The recipient entities can be one of the following:
    ///       </p>
    ///          <p>1. An external account.</p>
    ///          <p>2. An organziation member account.</p>
    ///          <p>3. An organzational unit (OU).</p>
    ///          <p>4. The organization itself. (This shares with every account in the organization).</p>
    public let principalId: String?
    /// <p>Indicates whether TagOptions sharing is enabled or disabled for the portfolio share.</p>
    public let shareTagOptions: Bool
    /// <p>The type of the portfolio share.</p>
    public let type: DescribePortfolioShareType?

    public init (
        accepted: Bool = false,
        principalId: String? = nil,
        shareTagOptions: Bool = false,
        type: DescribePortfolioShareType? = nil
    )
    {
        self.accepted = accepted
        self.principalId = principalId
        self.shareTagOptions = shareTagOptions
        self.type = type
    }
}

public enum PortfolioShareType {
    case awsOrganizations
    case awsServicecatalog
    case imported
    case sdkUnknown(String)
}

extension PortfolioShareType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PortfolioShareType] {
        return [
            .awsOrganizations,
            .awsServicecatalog,
            .imported,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsOrganizations: return "AWS_ORGANIZATIONS"
        case .awsServicecatalog: return "AWS_SERVICECATALOG"
        case .imported: return "IMPORTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PortfolioShareType(rawValue: rawValue) ?? PortfolioShareType.sdkUnknown(rawValue)
    }
}

extension Principal: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case principalARN = "PrincipalARN"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principalARN = principalARN {
            try encodeContainer.encode(principalARN, forKey: .principalARN)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalARN)
        principalARN = principalARNDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension Principal: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Principal(principalARN: \(String(describing: principalARN)), principalType: \(String(describing: principalType)))"}
}

/// <p>Information about a principal.</p>
public struct Principal: Equatable {
    /// <p>The ARN of the principal (IAM user, role, or group).</p>
    public let principalARN: String?
    /// <p>The principal type. The supported value is <code>IAM</code>.</p>
    public let principalType: PrincipalType?

    public init (
        principalARN: String? = nil,
        principalType: PrincipalType? = nil
    )
    {
        self.principalARN = principalARN
        self.principalType = principalType
    }
}

public enum PrincipalType {
    case iam
    case sdkUnknown(String)
}

extension PrincipalType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PrincipalType] {
        return [
            .iam,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .iam: return "IAM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
    }
}

public enum ProductSource {
    case account
    case sdkUnknown(String)
}

extension ProductSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProductSource] {
        return [
            .account,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .account: return "ACCOUNT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProductSource(rawValue: rawValue) ?? ProductSource.sdkUnknown(rawValue)
    }
}

public enum ProductType {
    case cloudFormationTemplate
    case marketplace
    case sdkUnknown(String)
}

extension ProductType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProductType] {
        return [
            .cloudFormationTemplate,
            .marketplace,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloudFormationTemplate: return "CLOUD_FORMATION_TEMPLATE"
        case .marketplace: return "MARKETPLACE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProductType(rawValue: rawValue) ?? ProductType.sdkUnknown(rawValue)
    }
}

extension ProductViewAggregationValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approximateCount = "ApproximateCount"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if approximateCount != 0 {
            try encodeContainer.encode(approximateCount, forKey: .approximateCount)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let approximateCountDecoded = try containerValues.decode(Int.self, forKey: .approximateCount)
        approximateCount = approximateCountDecoded
    }
}

extension ProductViewAggregationValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProductViewAggregationValue(approximateCount: \(String(describing: approximateCount)), value: \(String(describing: value)))"}
}

/// <p>A single product view aggregation value/count pair, containing metadata about each
///          product to which the calling user has access.</p>
public struct ProductViewAggregationValue: Equatable {
    /// <p>An approximate count of the products that match the value.</p>
    public let approximateCount: Int
    /// <p>The value of the product view aggregation.</p>
    public let value: String?

    public init (
        approximateCount: Int = 0,
        value: String? = nil
    )
    {
        self.approximateCount = approximateCount
        self.value = value
    }
}

extension ProductViewDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case productARN = "ProductARN"
        case productViewSummary = "ProductViewSummary"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let productARN = productARN {
            try encodeContainer.encode(productARN, forKey: .productARN)
        }
        if let productViewSummary = productViewSummary {
            try encodeContainer.encode(productViewSummary, forKey: .productViewSummary)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummaryDecoded = try containerValues.decodeIfPresent(ProductViewSummary.self, forKey: .productViewSummary)
        productViewSummary = productViewSummaryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let productARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productARN)
        productARN = productARNDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension ProductViewDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProductViewDetail(createdTime: \(String(describing: createdTime)), productARN: \(String(describing: productARN)), productViewSummary: \(String(describing: productViewSummary)), status: \(String(describing: status)))"}
}

/// <p>Information about a product view.</p>
public struct ProductViewDetail: Equatable {
    /// <p>The UTC time stamp of the creation time.</p>
    public let createdTime: Date?
    /// <p>The ARN of the product.</p>
    public let productARN: String?
    /// <p>Summary information about the product view.</p>
    public let productViewSummary: ProductViewSummary?
    /// <p>The status of the product.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AVAILABLE</code> - The product is ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATING</code> - Product creation has started; the product is not ready for use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - An action failed.</p>
    ///             </li>
    ///          </ul>
    public let status: Status?

    public init (
        createdTime: Date? = nil,
        productARN: String? = nil,
        productViewSummary: ProductViewSummary? = nil,
        status: Status? = nil
    )
    {
        self.createdTime = createdTime
        self.productARN = productARN
        self.productViewSummary = productViewSummary
        self.status = status
    }
}

public enum ProductViewFilterBy {
    case fulltextsearch
    case owner
    case producttype
    case sourceproductid
    case sdkUnknown(String)
}

extension ProductViewFilterBy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProductViewFilterBy] {
        return [
            .fulltextsearch,
            .owner,
            .producttype,
            .sourceproductid,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fulltextsearch: return "FullTextSearch"
        case .owner: return "Owner"
        case .producttype: return "ProductType"
        case .sourceproductid: return "SourceProductId"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProductViewFilterBy(rawValue: rawValue) ?? ProductViewFilterBy.sdkUnknown(rawValue)
    }
}

public enum ProductViewSortBy {
    case creationdate
    case title
    case versioncount
    case sdkUnknown(String)
}

extension ProductViewSortBy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProductViewSortBy] {
        return [
            .creationdate,
            .title,
            .versioncount,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creationdate: return "CreationDate"
        case .title: return "Title"
        case .versioncount: return "VersionCount"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProductViewSortBy(rawValue: rawValue) ?? ProductViewSortBy.sdkUnknown(rawValue)
    }
}

extension ProductViewSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case distributor = "Distributor"
        case hasDefaultPath = "HasDefaultPath"
        case id = "Id"
        case name = "Name"
        case owner = "Owner"
        case productId = "ProductId"
        case shortDescription = "ShortDescription"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distributor = distributor {
            try encodeContainer.encode(distributor, forKey: .distributor)
        }
        if hasDefaultPath != false {
            try encodeContainer.encode(hasDefaultPath, forKey: .hasDefaultPath)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let shortDescription = shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
        if let supportDescription = supportDescription {
            try encodeContainer.encode(supportDescription, forKey: .supportDescription)
        }
        if let supportEmail = supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportUrl = supportUrl {
            try encodeContainer.encode(supportUrl, forKey: .supportUrl)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ProductType.self, forKey: .type)
        type = typeDecoded
        let distributorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributor)
        distributor = distributorDecoded
        let hasDefaultPathDecoded = try containerValues.decode(Bool.self, forKey: .hasDefaultPath)
        hasDefaultPath = hasDefaultPathDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportDescription)
        supportDescription = supportDescriptionDecoded
        let supportUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportUrl)
        supportUrl = supportUrlDecoded
    }
}

extension ProductViewSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProductViewSummary(distributor: \(String(describing: distributor)), hasDefaultPath: \(String(describing: hasDefaultPath)), id: \(String(describing: id)), name: \(String(describing: name)), owner: \(String(describing: owner)), productId: \(String(describing: productId)), shortDescription: \(String(describing: shortDescription)), supportDescription: \(String(describing: supportDescription)), supportEmail: \(String(describing: supportEmail)), supportUrl: \(String(describing: supportUrl)), type: \(String(describing: type)))"}
}

/// <p>Summary information about a product view.</p>
public struct ProductViewSummary: Equatable {
    /// <p>The distributor of the product. Contact the product administrator for the
    ///          significance of this value.</p>
    public let distributor: String?
    /// <p>Indicates whether the product has a default path.
    ///          If the product does not have a default path, call <a>ListLaunchPaths</a>
    ///          to disambiguate between paths. Otherwise, <a>ListLaunchPaths</a> is not
    ///          required, and the output of <a>ProductViewSummary</a> can be used directly with
    ///          <a>DescribeProvisioningParameters</a>.</p>
    public let hasDefaultPath: Bool
    /// <p>The product view identifier.</p>
    public let id: String?
    /// <p>The name of the product.</p>
    public let name: String?
    /// <p>The owner of the product. Contact the product administrator for the significance of
    ///          this value.</p>
    public let owner: String?
    /// <p>The product identifier.</p>
    public let productId: String?
    /// <p>Short description of the product.</p>
    public let shortDescription: String?
    /// <p>The description of the support for this Product.</p>
    public let supportDescription: String?
    /// <p>The email contact information to obtain support for this Product.</p>
    public let supportEmail: String?
    /// <p>The URL information to obtain support for this Product.</p>
    public let supportUrl: String?
    /// <p>The product type. Contact the product administrator for the significance of this
    ///          value. If this value is <code>MARKETPLACE</code>, the product was created by AWS
    ///          Marketplace.</p>
    public let type: ProductType?

    public init (
        distributor: String? = nil,
        hasDefaultPath: Bool = false,
        id: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        productId: String? = nil,
        shortDescription: String? = nil,
        supportDescription: String? = nil,
        supportEmail: String? = nil,
        supportUrl: String? = nil,
        type: ProductType? = nil
    )
    {
        self.distributor = distributor
        self.hasDefaultPath = hasDefaultPath
        self.id = id
        self.name = name
        self.owner = owner
        self.productId = productId
        self.shortDescription = shortDescription
        self.supportDescription = supportDescription
        self.supportEmail = supportEmail
        self.supportUrl = supportUrl
        self.type = type
    }
}

public enum PropertyKey {
    case launchrole
    case owner
    case sdkUnknown(String)
}

extension PropertyKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PropertyKey] {
        return [
            .launchrole,
            .owner,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .launchrole: return "LAUNCH_ROLE"
        case .owner: return "OWNER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PropertyKey(rawValue: rawValue) ?? PropertyKey.sdkUnknown(rawValue)
    }
}

public struct ProvisionProductInputBodyMiddleware: Middleware {
    public let id: String = "ProvisionProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ProvisionProductInput>,
                  next: H) -> Swift.Result<OperationOutput<ProvisionProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ProvisionProductInput>
    public typealias MOutput = OperationOutput<ProvisionProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ProvisionProductOutputError>
}

extension ProvisionProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionProductInput(acceptLanguage: \(String(describing: acceptLanguage)), notificationArns: \(String(describing: notificationArns)), pathId: \(String(describing: pathId)), pathName: \(String(describing: pathName)), productId: \(String(describing: productId)), productName: \(String(describing: productName)), provisionToken: \(String(describing: provisionToken)), provisionedProductName: \(String(describing: provisionedProductName)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), provisioningArtifactName: \(String(describing: provisioningArtifactName)), provisioningParameters: \(String(describing: provisioningParameters)), provisioningPreferences: \(String(describing: provisioningPreferences)), tags: \(String(describing: tags)))"}
}

extension ProvisionProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisionToken = "ProvisionToken"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case provisioningParameters = "ProvisioningParameters"
        case provisioningPreferences = "ProvisioningPreferences"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for notificationarns0 in notificationArns {
                try notificationArnsContainer.encode(notificationarns0)
            }
        }
        if let pathId = pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let pathName = pathName {
            try encodeContainer.encode(pathName, forKey: .pathName)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisionToken = provisionToken {
            try encodeContainer.encode(provisionToken, forKey: .provisionToken)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
        if let provisioningParameters = provisioningParameters {
            var provisioningParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .provisioningParameters)
            for provisioningparameters0 in provisioningParameters {
                try provisioningParametersContainer.encode(provisioningparameters0)
            }
        }
        if let provisioningPreferences = provisioningPreferences {
            try encodeContainer.encode(provisioningPreferences, forKey: .provisioningPreferences)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct ProvisionProductInputHeadersMiddleware: Middleware {
    public let id: String = "ProvisionProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ProvisionProductInput>,
                  next: H) -> Swift.Result<OperationOutput<ProvisionProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ProvisionProductInput>
    public typealias MOutput = OperationOutput<ProvisionProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ProvisionProductOutputError>
}

public struct ProvisionProductInputQueryItemMiddleware: Middleware {
    public let id: String = "ProvisionProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ProvisionProductInput>,
                  next: H) -> Swift.Result<OperationOutput<ProvisionProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ProvisionProductInput>
    public typealias MOutput = OperationOutput<ProvisionProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ProvisionProductOutputError>
}

public struct ProvisionProductInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related
    ///          events.</p>
    public let notificationArns: [String]?
    /// <p>The path identifier of the product. This value is optional if the product
    ///          has a default path, and required if the product has more than one path.
    ///          To list the paths for a product, use <a>ListLaunchPaths</a>. You must provide the name or ID, but not both.</p>
    public let pathId: String?
    /// <p>The name of the path. You must provide the name or ID, but not both.</p>
    public let pathName: String?
    /// <p>The product identifier. You must provide the name or ID, but not both.</p>
    public let productId: String?
    /// <p>The name of the product. You must provide the name or ID, but not both.</p>
    public let productName: String?
    /// <p>An idempotency token that uniquely identifies the provisioning request.</p>
    public var provisionToken: String?
    /// <p>A user-friendly name for the provisioned product. This value must be
    ///          unique for the AWS account and cannot be updated after the product is provisioned.</p>
    public let provisionedProductName: String?
    /// <p>The identifier of the provisioning artifact. You must provide the name or ID, but not both.</p>
    public let provisioningArtifactId: String?
    /// <p>The name of the provisioning artifact. You must provide the name or ID, but not both.</p>
    public let provisioningArtifactName: String?
    /// <p>Parameters specified by the administrator that are required for provisioning the
    ///          product.</p>
    public let provisioningParameters: [ProvisioningParameter]?
    /// <p>An object that contains information about the provisioning preferences for a stack set.</p>
    public let provisioningPreferences: ProvisioningPreferences?
    /// <p>One or more tags.</p>
    public let tags: [Tag]?

    public init (
        acceptLanguage: String? = nil,
        notificationArns: [String]? = nil,
        pathId: String? = nil,
        pathName: String? = nil,
        productId: String? = nil,
        productName: String? = nil,
        provisionToken: String? = nil,
        provisionedProductName: String? = nil,
        provisioningArtifactId: String? = nil,
        provisioningArtifactName: String? = nil,
        provisioningParameters: [ProvisioningParameter]? = nil,
        provisioningPreferences: ProvisioningPreferences? = nil,
        tags: [Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.notificationArns = notificationArns
        self.pathId = pathId
        self.pathName = pathName
        self.productId = productId
        self.productName = productName
        self.provisionToken = provisionToken
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.provisioningParameters = provisioningParameters
        self.provisioningPreferences = provisioningPreferences
        self.tags = tags
    }
}

struct ProvisionProductInputBody: Equatable {
    public let acceptLanguage: String?
    public let productId: String?
    public let productName: String?
    public let provisioningArtifactId: String?
    public let provisioningArtifactName: String?
    public let pathId: String?
    public let pathName: String?
    public let provisionedProductName: String?
    public let provisioningParameters: [ProvisioningParameter]?
    public let provisioningPreferences: ProvisioningPreferences?
    public let tags: [Tag]?
    public let notificationArns: [String]?
    public let provisionToken: String?
}

extension ProvisionProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisionToken = "ProvisionToken"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case provisioningParameters = "ProvisioningParameters"
        case provisioningPreferences = "ProvisioningPreferences"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productName)
        productName = productNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let pathNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathName)
        pathName = pathNameDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisioningParametersContainer = try containerValues.decodeIfPresent([ProvisioningParameter?].self, forKey: .provisioningParameters)
        var provisioningParametersDecoded0:[ProvisioningParameter]? = nil
        if let provisioningParametersContainer = provisioningParametersContainer {
            provisioningParametersDecoded0 = [ProvisioningParameter]()
            for structure0 in provisioningParametersContainer {
                if let structure0 = structure0 {
                    provisioningParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningParameters = provisioningParametersDecoded0
        let provisioningPreferencesDecoded = try containerValues.decodeIfPresent(ProvisioningPreferences.self, forKey: .provisioningPreferences)
        provisioningPreferences = provisioningPreferencesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let notificationArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let provisionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionToken)
        provisionToken = provisionTokenDecoded
    }
}

extension ProvisionProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ProvisionProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ProvisionProductOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ProvisionProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionProductOutputResponse(recordDetail: \(String(describing: recordDetail)))"}
}

extension ProvisionProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ProvisionProductOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct ProvisionProductOutputResponse: Equatable {
    /// <p>Information about the result of provisioning the product.</p>
    public let recordDetail: RecordDetail?

    public init (
        recordDetail: RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct ProvisionProductOutputResponseBody: Equatable {
    public let recordDetail: RecordDetail?
}

extension ProvisionProductOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

extension ProvisionedProductAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case idempotencyToken = "IdempotencyToken"
        case lastProvisioningRecordId = "LastProvisioningRecordId"
        case lastRecordId = "LastRecordId"
        case lastSuccessfulProvisioningRecordId = "LastSuccessfulProvisioningRecordId"
        case name = "Name"
        case physicalId = "PhysicalId"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case tags = "Tags"
        case type = "Type"
        case userArn = "UserArn"
        case userArnSession = "UserArnSession"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lastProvisioningRecordId = lastProvisioningRecordId {
            try encodeContainer.encode(lastProvisioningRecordId, forKey: .lastProvisioningRecordId)
        }
        if let lastRecordId = lastRecordId {
            try encodeContainer.encode(lastRecordId, forKey: .lastRecordId)
        }
        if let lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId {
            try encodeContainer.encode(lastSuccessfulProvisioningRecordId, forKey: .lastSuccessfulProvisioningRecordId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let physicalId = physicalId {
            try encodeContainer.encode(physicalId, forKey: .physicalId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
        if let userArnSession = userArnSession {
            try encodeContainer.encode(userArnSession, forKey: .userArnSession)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProvisionedProductStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let lastRecordIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastRecordId)
        lastRecordId = lastRecordIdDecoded
        let lastProvisioningRecordIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastProvisioningRecordId)
        lastProvisioningRecordId = lastProvisioningRecordIdDecoded
        let lastSuccessfulProvisioningRecordIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastSuccessfulProvisioningRecordId)
        lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let physicalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .physicalId)
        physicalId = physicalIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productName)
        productName = productNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let userArnSessionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArnSession)
        userArnSession = userArnSessionDecoded
    }
}

extension ProvisionedProductAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionedProductAttribute(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), id: \(String(describing: id)), idempotencyToken: \(String(describing: idempotencyToken)), lastProvisioningRecordId: \(String(describing: lastProvisioningRecordId)), lastRecordId: \(String(describing: lastRecordId)), lastSuccessfulProvisioningRecordId: \(String(describing: lastSuccessfulProvisioningRecordId)), name: \(String(describing: name)), physicalId: \(String(describing: physicalId)), productId: \(String(describing: productId)), productName: \(String(describing: productName)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), provisioningArtifactName: \(String(describing: provisioningArtifactName)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), tags: \(String(describing: tags)), type: \(String(describing: type)), userArn: \(String(describing: userArn)), userArnSession: \(String(describing: userArnSession)))"}
}

/// <p>Information about a provisioned product.</p>
public struct ProvisionedProductAttribute: Equatable {
    /// <p>The ARN of the provisioned product.</p>
    public let arn: String?
    /// <p>The UTC time stamp of the creation time.</p>
    public let createdTime: Date?
    /// <p>The identifier of the provisioned product.</p>
    public let id: String?
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.</p>
    public let idempotencyToken: String?
    /// <p>The record identifier of the last request performed on this provisioned product of the following types:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                ProvisionedProduct
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                UpdateProvisionedProduct
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                ExecuteProvisionedProductPlan
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                TerminateProvisionedProduct
    ///             </p>
    ///             </li>
    ///          </ul>
    public let lastProvisioningRecordId: String?
    /// <p>The record identifier of the last request performed on this provisioned product.</p>
    public let lastRecordId: String?
    /// <p>The record identifier of the last successful request performed on this provisioned product of the following types:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                ProvisionedProduct
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                UpdateProvisionedProduct
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                ExecuteProvisionedProductPlan
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                TerminateProvisionedProduct
    ///             </p>
    ///             </li>
    ///          </ul>
    public let lastSuccessfulProvisioningRecordId: String?
    /// <p>The user-friendly name of the provisioned product.</p>
    public let name: String?
    /// <p>The assigned identifier for the resource, such as an EC2 instance ID or an S3 bucket name.</p>
    public let physicalId: String?
    /// <p>The product identifier.</p>
    public let productId: String?
    /// <p>The name of the product.</p>
    public let productName: String?
    /// <p>The identifier of the provisioning artifact.</p>
    public let provisioningArtifactId: String?
    /// <p>The name of the provisioning artifact.</p>
    public let provisioningArtifactName: String?
    /// <p>The current status of the provisioned product.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most
    ///                recent operation succeeded and completed.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results.
    ///                Wait for an <code>AVAILABLE</code> status before performing operations.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has
    ///                completed the requested operation but is not exactly what was requested. For example, a
    ///                request to update to a new version failed and the stack rolled back to the current version.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running.
    ///                For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product,
    ///                 but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an <code>AVAILABLE</code> status before performing operations.</p>
    ///             </li>
    ///          </ul>
    public let status: ProvisionedProductStatus?
    /// <p>The current status message of the provisioned product.</p>
    public let statusMessage: String?
    /// <p>One or more tags.</p>
    public let tags: [Tag]?
    /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
    public let type: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM user.</p>
    public let userArn: String?
    /// <p>The ARN of the IAM user in the session. This ARN might contain a session ID.</p>
    public let userArnSession: String?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        id: String? = nil,
        idempotencyToken: String? = nil,
        lastProvisioningRecordId: String? = nil,
        lastRecordId: String? = nil,
        lastSuccessfulProvisioningRecordId: String? = nil,
        name: String? = nil,
        physicalId: String? = nil,
        productId: String? = nil,
        productName: String? = nil,
        provisioningArtifactId: String? = nil,
        provisioningArtifactName: String? = nil,
        status: ProvisionedProductStatus? = nil,
        statusMessage: String? = nil,
        tags: [Tag]? = nil,
        type: String? = nil,
        userArn: String? = nil,
        userArnSession: String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.id = id
        self.idempotencyToken = idempotencyToken
        self.lastProvisioningRecordId = lastProvisioningRecordId
        self.lastRecordId = lastRecordId
        self.lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId
        self.name = name
        self.physicalId = physicalId
        self.productId = productId
        self.productName = productName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.type = type
        self.userArn = userArn
        self.userArnSession = userArnSession
    }
}

extension ProvisionedProductDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case idempotencyToken = "IdempotencyToken"
        case lastProvisioningRecordId = "LastProvisioningRecordId"
        case lastRecordId = "LastRecordId"
        case lastSuccessfulProvisioningRecordId = "LastSuccessfulProvisioningRecordId"
        case launchRoleArn = "LaunchRoleArn"
        case name = "Name"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lastProvisioningRecordId = lastProvisioningRecordId {
            try encodeContainer.encode(lastProvisioningRecordId, forKey: .lastProvisioningRecordId)
        }
        if let lastRecordId = lastRecordId {
            try encodeContainer.encode(lastRecordId, forKey: .lastRecordId)
        }
        if let lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId {
            try encodeContainer.encode(lastSuccessfulProvisioningRecordId, forKey: .lastSuccessfulProvisioningRecordId)
        }
        if let launchRoleArn = launchRoleArn {
            try encodeContainer.encode(launchRoleArn, forKey: .launchRoleArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProvisionedProductStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let lastRecordIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastRecordId)
        lastRecordId = lastRecordIdDecoded
        let lastProvisioningRecordIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastProvisioningRecordId)
        lastProvisioningRecordId = lastProvisioningRecordIdDecoded
        let lastSuccessfulProvisioningRecordIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastSuccessfulProvisioningRecordId)
        lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let launchRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchRoleArn)
        launchRoleArn = launchRoleArnDecoded
    }
}

extension ProvisionedProductDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionedProductDetail(arn: \(String(describing: arn)), createdTime: \(String(describing: createdTime)), id: \(String(describing: id)), idempotencyToken: \(String(describing: idempotencyToken)), lastProvisioningRecordId: \(String(describing: lastProvisioningRecordId)), lastRecordId: \(String(describing: lastRecordId)), lastSuccessfulProvisioningRecordId: \(String(describing: lastSuccessfulProvisioningRecordId)), launchRoleArn: \(String(describing: launchRoleArn)), name: \(String(describing: name)), productId: \(String(describing: productId)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), type: \(String(describing: type)))"}
}

/// <p>Information about a provisioned product.</p>
public struct ProvisionedProductDetail: Equatable {
    /// <p>The ARN of the provisioned product.</p>
    public let arn: String?
    /// <p>The UTC time stamp of the creation time.</p>
    public let createdTime: Date?
    /// <p>The identifier of the provisioned product.</p>
    public let id: String?
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.</p>
    public let idempotencyToken: String?
    /// <p>The record identifier of the last request performed on this provisioned product of the following types:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                ProvisionedProduct
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                UpdateProvisionedProduct
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                ExecuteProvisionedProductPlan
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                TerminateProvisionedProduct
    ///             </p>
    ///             </li>
    ///          </ul>
    public let lastProvisioningRecordId: String?
    /// <p>The record identifier of the last request performed on this provisioned product.</p>
    public let lastRecordId: String?
    /// <p>The record identifier of the last successful request performed on this provisioned product of the following types:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                ProvisionedProduct
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                UpdateProvisionedProduct
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                ExecuteProvisionedProductPlan
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                TerminateProvisionedProduct
    ///             </p>
    ///             </li>
    ///          </ul>
    public let lastSuccessfulProvisioningRecordId: String?
    /// <p>The ARN of the launch role associated with the provisioned product.</p>
    public let launchRoleArn: String?
    /// <p>The user-friendly name of the provisioned product.</p>
    public let name: String?
    /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
    public let productId: String?
    /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
    public let provisioningArtifactId: String?
    /// <p>The current status of the provisioned product.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most
    ///                recent operation succeeded and completed.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results.
    ///                Wait for an <code>AVAILABLE</code> status before performing operations.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has
    ///                completed the requested operation but is not exactly what was requested. For example, a
    ///                request to update to a new version failed and the stack rolled back to the current version.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running.
    ///                For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product,
    ///                but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an <code>AVAILABLE</code> status before performing operations.</p>
    ///             </li>
    ///          </ul>
    public let status: ProvisionedProductStatus?
    /// <p>The current status message of the provisioned product.</p>
    public let statusMessage: String?
    /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
    public let type: String?

    public init (
        arn: String? = nil,
        createdTime: Date? = nil,
        id: String? = nil,
        idempotencyToken: String? = nil,
        lastProvisioningRecordId: String? = nil,
        lastRecordId: String? = nil,
        lastSuccessfulProvisioningRecordId: String? = nil,
        launchRoleArn: String? = nil,
        name: String? = nil,
        productId: String? = nil,
        provisioningArtifactId: String? = nil,
        status: ProvisionedProductStatus? = nil,
        statusMessage: String? = nil,
        type: String? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.id = id
        self.idempotencyToken = idempotencyToken
        self.lastProvisioningRecordId = lastProvisioningRecordId
        self.lastRecordId = lastRecordId
        self.lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId
        self.launchRoleArn = launchRoleArn
        self.name = name
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
        self.status = status
        self.statusMessage = statusMessage
        self.type = type
    }
}

extension ProvisionedProductPlanDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case planId = "PlanId"
        case planName = "PlanName"
        case planType = "PlanType"
        case productId = "ProductId"
        case provisionProductId = "ProvisionProductId"
        case provisionProductName = "ProvisionProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningParameters = "ProvisioningParameters"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case tags = "Tags"
        case updatedTime = "UpdatedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for notificationarns0 in notificationArns {
                try notificationArnsContainer.encode(notificationarns0)
            }
        }
        if let pathId = pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let planId = planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
        if let planName = planName {
            try encodeContainer.encode(planName, forKey: .planName)
        }
        if let planType = planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisionProductId = provisionProductId {
            try encodeContainer.encode(provisionProductId, forKey: .provisionProductId)
        }
        if let provisionProductName = provisionProductName {
            try encodeContainer.encode(provisionProductName, forKey: .provisionProductName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningParameters = provisioningParameters {
            var provisioningParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .provisioningParameters)
            for updateprovisioningparameters0 in provisioningParameters {
                try provisioningParametersContainer.encode(updateprovisioningparameters0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let updatedTime = updatedTime {
            try encodeContainer.encode(updatedTime.timeIntervalSince1970, forKey: .updatedTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let planNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .planName)
        planName = planNameDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .planId)
        planId = planIdDecoded
        let provisionProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionProductId)
        provisionProductId = provisionProductIdDecoded
        let provisionProductNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionProductName)
        provisionProductName = provisionProductNameDecoded
        let planTypeDecoded = try containerValues.decodeIfPresent(ProvisionedProductPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProvisionedProductPlanStatus.self, forKey: .status)
        status = statusDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let notificationArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let provisioningParametersContainer = try containerValues.decodeIfPresent([UpdateProvisioningParameter?].self, forKey: .provisioningParameters)
        var provisioningParametersDecoded0:[UpdateProvisioningParameter]? = nil
        if let provisioningParametersContainer = provisioningParametersContainer {
            provisioningParametersDecoded0 = [UpdateProvisioningParameter]()
            for structure0 in provisioningParametersContainer {
                if let structure0 = structure0 {
                    provisioningParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningParameters = provisioningParametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ProvisionedProductPlanDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionedProductPlanDetails(createdTime: \(String(describing: createdTime)), notificationArns: \(String(describing: notificationArns)), pathId: \(String(describing: pathId)), planId: \(String(describing: planId)), planName: \(String(describing: planName)), planType: \(String(describing: planType)), productId: \(String(describing: productId)), provisionProductId: \(String(describing: provisionProductId)), provisionProductName: \(String(describing: provisionProductName)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), provisioningParameters: \(String(describing: provisioningParameters)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), tags: \(String(describing: tags)), updatedTime: \(String(describing: updatedTime)))"}
}

/// <p>Information about a plan.</p>
public struct ProvisionedProductPlanDetails: Equatable {
    /// <p>The UTC time stamp of the creation time.</p>
    public let createdTime: Date?
    /// <p>Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related
    ///          events.</p>
    public let notificationArns: [String]?
    /// <p>The path identifier of the product. This value is optional if the product
    ///          has a default path, and required if the product has more than one path.
    ///          To list the paths for a product, use <a>ListLaunchPaths</a>.</p>
    public let pathId: String?
    /// <p>The plan identifier.</p>
    public let planId: String?
    /// <p>The name of the plan.</p>
    public let planName: String?
    /// <p>The plan type.</p>
    public let planType: ProvisionedProductPlanType?
    /// <p>The product identifier.</p>
    public let productId: String?
    /// <p>The product identifier.</p>
    public let provisionProductId: String?
    /// <p>The user-friendly name of the provisioned product.</p>
    public let provisionProductName: String?
    /// <p>The identifier of the provisioning artifact.</p>
    public let provisioningArtifactId: String?
    /// <p>Parameters specified by the administrator that are required for provisioning the
    ///          product.</p>
    public let provisioningParameters: [UpdateProvisioningParameter]?
    /// <p>The status.</p>
    public let status: ProvisionedProductPlanStatus?
    /// <p>The status message.</p>
    public let statusMessage: String?
    /// <p>One or more tags.</p>
    public let tags: [Tag]?
    /// <p>The time when the plan was last updated.</p>
    public let updatedTime: Date?

    public init (
        createdTime: Date? = nil,
        notificationArns: [String]? = nil,
        pathId: String? = nil,
        planId: String? = nil,
        planName: String? = nil,
        planType: ProvisionedProductPlanType? = nil,
        productId: String? = nil,
        provisionProductId: String? = nil,
        provisionProductName: String? = nil,
        provisioningArtifactId: String? = nil,
        provisioningParameters: [UpdateProvisioningParameter]? = nil,
        status: ProvisionedProductPlanStatus? = nil,
        statusMessage: String? = nil,
        tags: [Tag]? = nil,
        updatedTime: Date? = nil
    )
    {
        self.createdTime = createdTime
        self.notificationArns = notificationArns
        self.pathId = pathId
        self.planId = planId
        self.planName = planName
        self.planType = planType
        self.productId = productId
        self.provisionProductId = provisionProductId
        self.provisionProductName = provisionProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningParameters = provisioningParameters
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.updatedTime = updatedTime
    }
}

public enum ProvisionedProductPlanStatus {
    case createFailed
    case createInProgress
    case createSuccess
    case executeFailed
    case executeInProgress
    case executeSuccess
    case sdkUnknown(String)
}

extension ProvisionedProductPlanStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProvisionedProductPlanStatus] {
        return [
            .createFailed,
            .createInProgress,
            .createSuccess,
            .executeFailed,
            .executeInProgress,
            .executeSuccess,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .createSuccess: return "CREATE_SUCCESS"
        case .executeFailed: return "EXECUTE_FAILED"
        case .executeInProgress: return "EXECUTE_IN_PROGRESS"
        case .executeSuccess: return "EXECUTE_SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProvisionedProductPlanStatus(rawValue: rawValue) ?? ProvisionedProductPlanStatus.sdkUnknown(rawValue)
    }
}

extension ProvisionedProductPlanSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case planId = "PlanId"
        case planName = "PlanName"
        case planType = "PlanType"
        case provisionProductId = "ProvisionProductId"
        case provisionProductName = "ProvisionProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let planId = planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
        if let planName = planName {
            try encodeContainer.encode(planName, forKey: .planName)
        }
        if let planType = planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
        if let provisionProductId = provisionProductId {
            try encodeContainer.encode(provisionProductId, forKey: .provisionProductId)
        }
        if let provisionProductName = provisionProductName {
            try encodeContainer.encode(provisionProductName, forKey: .provisionProductName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let planNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .planName)
        planName = planNameDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .planId)
        planId = planIdDecoded
        let provisionProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionProductId)
        provisionProductId = provisionProductIdDecoded
        let provisionProductNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionProductName)
        provisionProductName = provisionProductNameDecoded
        let planTypeDecoded = try containerValues.decodeIfPresent(ProvisionedProductPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
    }
}

extension ProvisionedProductPlanSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionedProductPlanSummary(planId: \(String(describing: planId)), planName: \(String(describing: planName)), planType: \(String(describing: planType)), provisionProductId: \(String(describing: provisionProductId)), provisionProductName: \(String(describing: provisionProductName)), provisioningArtifactId: \(String(describing: provisioningArtifactId)))"}
}

/// <p>Summary information about a plan.</p>
public struct ProvisionedProductPlanSummary: Equatable {
    /// <p>The plan identifier.</p>
    public let planId: String?
    /// <p>The name of the plan.</p>
    public let planName: String?
    /// <p>The plan type.</p>
    public let planType: ProvisionedProductPlanType?
    /// <p>The product identifier.</p>
    public let provisionProductId: String?
    /// <p>The user-friendly name of the provisioned product.</p>
    public let provisionProductName: String?
    /// <p>The identifier of the provisioning artifact.</p>
    public let provisioningArtifactId: String?

    public init (
        planId: String? = nil,
        planName: String? = nil,
        planType: ProvisionedProductPlanType? = nil,
        provisionProductId: String? = nil,
        provisionProductName: String? = nil,
        provisioningArtifactId: String? = nil
    )
    {
        self.planId = planId
        self.planName = planName
        self.planType = planType
        self.provisionProductId = provisionProductId
        self.provisionProductName = provisionProductName
        self.provisioningArtifactId = provisioningArtifactId
    }
}

public enum ProvisionedProductPlanType {
    case cloudformation
    case sdkUnknown(String)
}

extension ProvisionedProductPlanType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProvisionedProductPlanType] {
        return [
            .cloudformation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloudformation: return "CLOUDFORMATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProvisionedProductPlanType(rawValue: rawValue) ?? ProvisionedProductPlanType.sdkUnknown(rawValue)
    }
}

public enum ProvisionedProductStatus {
    case available
    case error
    case planInProgress
    case tainted
    case underChange
    case sdkUnknown(String)
}

extension ProvisionedProductStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProvisionedProductStatus] {
        return [
            .available,
            .error,
            .planInProgress,
            .tainted,
            .underChange,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .error: return "ERROR"
        case .planInProgress: return "PLAN_IN_PROGRESS"
        case .tainted: return "TAINTED"
        case .underChange: return "UNDER_CHANGE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProvisionedProductStatus(rawValue: rawValue) ?? ProvisionedProductStatus.sdkUnknown(rawValue)
    }
}

public enum ProvisionedProductViewFilterBy {
    case searchquery
    case sdkUnknown(String)
}

extension ProvisionedProductViewFilterBy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProvisionedProductViewFilterBy] {
        return [
            .searchquery,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .searchquery: return "SearchQuery"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProvisionedProductViewFilterBy(rawValue: rawValue) ?? ProvisionedProductViewFilterBy.sdkUnknown(rawValue)
    }
}

extension ProvisioningArtifact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case description = "Description"
        case guidance = "Guidance"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let guidance = guidance {
            try encodeContainer.encode(guidance.rawValue, forKey: .guidance)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let guidanceDecoded = try containerValues.decodeIfPresent(ProvisioningArtifactGuidance.self, forKey: .guidance)
        guidance = guidanceDecoded
    }
}

extension ProvisioningArtifact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningArtifact(createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), guidance: \(String(describing: guidance)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Information about a provisioning artifact. A provisioning artifact is also known as a product version.</p>
public struct ProvisioningArtifact: Equatable {
    /// <p>The UTC time stamp of the creation time.</p>
    public let createdTime: Date?
    /// <p>The description of the provisioning artifact.</p>
    public let description: String?
    /// <p>Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.</p>
    public let guidance: ProvisioningArtifactGuidance?
    /// <p>The identifier of the provisioning artifact.</p>
    public let id: String?
    /// <p>The name of the provisioning artifact.</p>
    public let name: String?

    public init (
        createdTime: Date? = nil,
        description: String? = nil,
        guidance: ProvisioningArtifactGuidance? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.createdTime = createdTime
        self.description = description
        self.guidance = guidance
        self.id = id
        self.name = name
    }
}

extension ProvisioningArtifactDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case active = "Active"
        case createdTime = "CreatedTime"
        case description = "Description"
        case guidance = "Guidance"
        case id = "Id"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let guidance = guidance {
            try encodeContainer.encode(guidance.rawValue, forKey: .guidance)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ProvisioningArtifactType.self, forKey: .type)
        type = typeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .active)
        active = activeDecoded
        let guidanceDecoded = try containerValues.decodeIfPresent(ProvisioningArtifactGuidance.self, forKey: .guidance)
        guidance = guidanceDecoded
    }
}

extension ProvisioningArtifactDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningArtifactDetail(active: \(String(describing: active)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), guidance: \(String(describing: guidance)), id: \(String(describing: id)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Information about a provisioning artifact (also known as a version) for a product.</p>
public struct ProvisioningArtifactDetail: Equatable {
    /// <p>Indicates whether the product version is active.</p>
    public let active: Bool?
    /// <p>The UTC time stamp of the creation time.</p>
    public let createdTime: Date?
    /// <p>The description of the provisioning artifact.</p>
    public let description: String?
    /// <p>Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.</p>
    public let guidance: ProvisioningArtifactGuidance?
    /// <p>The identifier of the provisioning artifact.</p>
    public let id: String?
    /// <p>The name of the provisioning artifact.</p>
    public let name: String?
    /// <p>The type of provisioning artifact.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CLOUD_FORMATION_TEMPLATE</code> - AWS CloudFormation template</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MARKETPLACE_AMI</code> - AWS Marketplace AMI</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MARKETPLACE_CAR</code> - AWS Marketplace Clusters and AWS Resources</p>
    ///             </li>
    ///          </ul>
    public let type: ProvisioningArtifactType?

    public init (
        active: Bool? = nil,
        createdTime: Date? = nil,
        description: String? = nil,
        guidance: ProvisioningArtifactGuidance? = nil,
        id: String? = nil,
        name: String? = nil,
        type: ProvisioningArtifactType? = nil
    )
    {
        self.active = active
        self.createdTime = createdTime
        self.description = description
        self.guidance = guidance
        self.id = id
        self.name = name
        self.type = type
    }
}

public enum ProvisioningArtifactGuidance {
    case `default`
    case deprecated
    case sdkUnknown(String)
}

extension ProvisioningArtifactGuidance : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProvisioningArtifactGuidance] {
        return [
            .default,
            .deprecated,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .default: return "DEFAULT"
        case .deprecated: return "DEPRECATED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProvisioningArtifactGuidance(rawValue: rawValue) ?? ProvisioningArtifactGuidance.sdkUnknown(rawValue)
    }
}

extension ProvisioningArtifactOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ProvisioningArtifactOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningArtifactOutput(description: \(String(describing: description)), key: \(String(describing: key)))"}
}

/// <p>Provisioning artifact output.</p>
public struct ProvisioningArtifactOutput: Equatable {
    /// <p>Description of the provisioning artifact output key.</p>
    public let description: String?
    /// <p>The provisioning artifact output key.</p>
    public let key: String?

    public init (
        description: String? = nil,
        key: String? = nil
    )
    {
        self.description = description
        self.key = key
    }
}

extension ProvisioningArtifactParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case description = "Description"
        case isNoEcho = "IsNoEcho"
        case parameterConstraints = "ParameterConstraints"
        case parameterKey = "ParameterKey"
        case parameterType = "ParameterType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isNoEcho != false {
            try encodeContainer.encode(isNoEcho, forKey: .isNoEcho)
        }
        if let parameterConstraints = parameterConstraints {
            try encodeContainer.encode(parameterConstraints, forKey: .parameterConstraints)
        }
        if let parameterKey = parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let parameterType = parameterType {
            try encodeContainer.encode(parameterType, forKey: .parameterType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let parameterTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterType)
        parameterType = parameterTypeDecoded
        let isNoEchoDecoded = try containerValues.decode(Bool.self, forKey: .isNoEcho)
        isNoEcho = isNoEchoDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parameterConstraintsDecoded = try containerValues.decodeIfPresent(ParameterConstraints.self, forKey: .parameterConstraints)
        parameterConstraints = parameterConstraintsDecoded
    }
}

extension ProvisioningArtifactParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningArtifactParameter(defaultValue: \(String(describing: defaultValue)), description: \(String(describing: description)), isNoEcho: \(String(describing: isNoEcho)), parameterConstraints: \(String(describing: parameterConstraints)), parameterKey: \(String(describing: parameterKey)), parameterType: \(String(describing: parameterType)))"}
}

/// <p>Information about a parameter used to provision a product.</p>
public struct ProvisioningArtifactParameter: Equatable {
    /// <p>The default value.</p>
    public let defaultValue: String?
    /// <p>The description of the parameter.</p>
    public let description: String?
    /// <p>If this value is true, the value for this parameter is obfuscated from view when the
    ///          parameter is retrieved. This parameter is used to hide sensitive information.</p>
    public let isNoEcho: Bool
    /// <p>Constraints that the administrator has put on a parameter.</p>
    public let parameterConstraints: ParameterConstraints?
    /// <p>The parameter key.</p>
    public let parameterKey: String?
    /// <p>The parameter type.</p>
    public let parameterType: String?

    public init (
        defaultValue: String? = nil,
        description: String? = nil,
        isNoEcho: Bool = false,
        parameterConstraints: ParameterConstraints? = nil,
        parameterKey: String? = nil,
        parameterType: String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.description = description
        self.isNoEcho = isNoEcho
        self.parameterConstraints = parameterConstraints
        self.parameterKey = parameterKey
        self.parameterType = parameterType
    }
}

extension ProvisioningArtifactPreferences: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackSetAccounts = "StackSetAccounts"
        case stackSetRegions = "StackSetRegions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackSetAccounts = stackSetAccounts {
            var stackSetAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetAccounts)
            for stacksetaccounts0 in stackSetAccounts {
                try stackSetAccountsContainer.encode(stacksetaccounts0)
            }
        }
        if let stackSetRegions = stackSetRegions {
            var stackSetRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetRegions)
            for stacksetregions0 in stackSetRegions {
                try stackSetRegionsContainer.encode(stacksetregions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stackSetAccounts)
        var stackSetAccountsDecoded0:[String]? = nil
        if let stackSetAccountsContainer = stackSetAccountsContainer {
            stackSetAccountsDecoded0 = [String]()
            for string0 in stackSetAccountsContainer {
                if let string0 = string0 {
                    stackSetAccountsDecoded0?.append(string0)
                }
            }
        }
        stackSetAccounts = stackSetAccountsDecoded0
        let stackSetRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stackSetRegions)
        var stackSetRegionsDecoded0:[String]? = nil
        if let stackSetRegionsContainer = stackSetRegionsContainer {
            stackSetRegionsDecoded0 = [String]()
            for string0 in stackSetRegionsContainer {
                if let string0 = string0 {
                    stackSetRegionsDecoded0?.append(string0)
                }
            }
        }
        stackSetRegions = stackSetRegionsDecoded0
    }
}

extension ProvisioningArtifactPreferences: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningArtifactPreferences(stackSetAccounts: \(String(describing: stackSetAccounts)), stackSetRegions: \(String(describing: stackSetRegions)))"}
}

/// <p>The user-defined preferences that will be applied during product provisioning, unless overridden by <code>ProvisioningPreferences</code> or <code>UpdateProvisioningPreferences</code>.</p>
///          <p>For more information on maximum concurrent accounts and failure tolerance, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-ops-options">Stack set operation options</a> in the <i>AWS CloudFormation User Guide</i>.</p>
public struct ProvisioningArtifactPreferences: Equatable {
    /// <p>One or more AWS accounts where stack instances are deployed from the stack set. These accounts can be scoped in <code>ProvisioningPreferences$StackSetAccounts</code> and <code>UpdateProvisioningPreferences$StackSetAccounts</code>.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    public let stackSetAccounts: [String]?
    /// <p>One or more AWS Regions where stack instances are deployed from the stack set. These regions can be scoped in <code>ProvisioningPreferences$StackSetRegions</code> and <code>UpdateProvisioningPreferences$StackSetRegions</code>.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    public let stackSetRegions: [String]?

    public init (
        stackSetAccounts: [String]? = nil,
        stackSetRegions: [String]? = nil
    )
    {
        self.stackSetAccounts = stackSetAccounts
        self.stackSetRegions = stackSetRegions
    }
}

extension ProvisioningArtifactProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case disableTemplateValidation = "DisableTemplateValidation"
        case info = "Info"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if disableTemplateValidation != false {
            try encodeContainer.encode(disableTemplateValidation, forKey: .disableTemplateValidation)
        }
        if let info = info {
            var infoContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .info)
            for (dictKey0, provisioningartifactinfo0) in info {
                try infoContainer.encode(provisioningartifactinfo0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let infoContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .info)
        var infoDecoded0: [String:String]? = nil
        if let infoContainer = infoContainer {
            infoDecoded0 = [String:String]()
            for (key0, provisioningartifactinfovalue0) in infoContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    infoDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        info = infoDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ProvisioningArtifactType.self, forKey: .type)
        type = typeDecoded
        let disableTemplateValidationDecoded = try containerValues.decode(Bool.self, forKey: .disableTemplateValidation)
        disableTemplateValidation = disableTemplateValidationDecoded
    }
}

extension ProvisioningArtifactProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningArtifactProperties(description: \(String(describing: description)), disableTemplateValidation: \(String(describing: disableTemplateValidation)), info: \(String(describing: info)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Information about a provisioning artifact (also known as a version) for a product.</p>
public struct ProvisioningArtifactProperties: Equatable {
    /// <p>The description of the provisioning artifact, including how it differs from the previous provisioning artifact.</p>
    public let description: String?
    /// <p>If set to true, AWS Service Catalog stops validating the specified provisioning artifact even if it is invalid.</p>
    public let disableTemplateValidation: Bool
    /// <p>Specify the template source with one of the following options, but not both.
    ///          Keys accepted: [ <code>LoadTemplateFromURL</code>, <code>ImportFromPhysicalId</code> ]</p>
    ///          <p>The URL of the CloudFormation template in Amazon S3. Specify the URL in JSON format as follows:</p>
    ///          <p>
    ///             <code>"LoadTemplateFromURL": "https://s3.amazonaws.com/cf-templates-ozkq9d3hgiq2-us-east-1/..."</code>
    ///          </p>
    ///          <p>
    ///             <code>ImportFromPhysicalId</code>: The physical id of the resource that contains the
    ///          template. Currently only supports CloudFormation stack arn. Specify the physical id in JSON
    ///          format as follows: <code>ImportFromPhysicalId: arn:aws:cloudformation:[us-east-1]:[accountId]:stack/[StackName]/[resourceId]</code>
    ///          </p>
    public let info: [String:String]?
    /// <p>The name of the provisioning artifact (for example, v1 v2beta). No spaces are allowed.</p>
    public let name: String?
    /// <p>The type of provisioning artifact.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CLOUD_FORMATION_TEMPLATE</code> - AWS CloudFormation template</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MARKETPLACE_AMI</code> - AWS Marketplace AMI</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MARKETPLACE_CAR</code> - AWS Marketplace Clusters and AWS Resources</p>
    ///             </li>
    ///          </ul>
    public let type: ProvisioningArtifactType?

    public init (
        description: String? = nil,
        disableTemplateValidation: Bool = false,
        info: [String:String]? = nil,
        name: String? = nil,
        type: ProvisioningArtifactType? = nil
    )
    {
        self.description = description
        self.disableTemplateValidation = disableTemplateValidation
        self.info = info
        self.name = name
        self.type = type
    }
}

public enum ProvisioningArtifactPropertyName {
    case id
    case sdkUnknown(String)
}

extension ProvisioningArtifactPropertyName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProvisioningArtifactPropertyName] {
        return [
            .id,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .id: return "Id"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProvisioningArtifactPropertyName(rawValue: rawValue) ?? ProvisioningArtifactPropertyName.sdkUnknown(rawValue)
    }
}

extension ProvisioningArtifactSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case provisioningArtifactMetadata = "ProvisioningArtifactMetadata"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioningArtifactMetadata = provisioningArtifactMetadata {
            var provisioningArtifactMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .provisioningArtifactMetadata)
            for (dictKey0, provisioningartifactinfo0) in provisioningArtifactMetadata {
                try provisioningArtifactMetadataContainer.encode(provisioningartifactinfo0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let provisioningArtifactMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .provisioningArtifactMetadata)
        var provisioningArtifactMetadataDecoded0: [String:String]? = nil
        if let provisioningArtifactMetadataContainer = provisioningArtifactMetadataContainer {
            provisioningArtifactMetadataDecoded0 = [String:String]()
            for (key0, provisioningartifactinfovalue0) in provisioningArtifactMetadataContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    provisioningArtifactMetadataDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        provisioningArtifactMetadata = provisioningArtifactMetadataDecoded0
    }
}

extension ProvisioningArtifactSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningArtifactSummary(createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), provisioningArtifactMetadata: \(String(describing: provisioningArtifactMetadata)))"}
}

/// <p>Summary information about a provisioning artifact (also known as a version) for a product.</p>
public struct ProvisioningArtifactSummary: Equatable {
    /// <p>The UTC time stamp of the creation time.</p>
    public let createdTime: Date?
    /// <p>The description of the provisioning artifact.</p>
    public let description: String?
    /// <p>The identifier of the provisioning artifact.</p>
    public let id: String?
    /// <p>The name of the provisioning artifact.</p>
    public let name: String?
    /// <p>The metadata for the provisioning artifact. This is used with AWS Marketplace products.</p>
    public let provisioningArtifactMetadata: [String:String]?

    public init (
        createdTime: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        provisioningArtifactMetadata: [String:String]? = nil
    )
    {
        self.createdTime = createdTime
        self.description = description
        self.id = id
        self.name = name
        self.provisioningArtifactMetadata = provisioningArtifactMetadata
    }
}

public enum ProvisioningArtifactType {
    case cloudFormationTemplate
    case marketplaceAmi
    case marketplaceCar
    case sdkUnknown(String)
}

extension ProvisioningArtifactType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProvisioningArtifactType] {
        return [
            .cloudFormationTemplate,
            .marketplaceAmi,
            .marketplaceCar,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloudFormationTemplate: return "CLOUD_FORMATION_TEMPLATE"
        case .marketplaceAmi: return "MARKETPLACE_AMI"
        case .marketplaceCar: return "MARKETPLACE_CAR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProvisioningArtifactType(rawValue: rawValue) ?? ProvisioningArtifactType.sdkUnknown(rawValue)
    }
}

extension ProvisioningArtifactView: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case productViewSummary = "ProductViewSummary"
        case provisioningArtifact = "ProvisioningArtifact"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productViewSummary = productViewSummary {
            try encodeContainer.encode(productViewSummary, forKey: .productViewSummary)
        }
        if let provisioningArtifact = provisioningArtifact {
            try encodeContainer.encode(provisioningArtifact, forKey: .provisioningArtifact)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummaryDecoded = try containerValues.decodeIfPresent(ProductViewSummary.self, forKey: .productViewSummary)
        productViewSummary = productViewSummaryDecoded
        let provisioningArtifactDecoded = try containerValues.decodeIfPresent(ProvisioningArtifact.self, forKey: .provisioningArtifact)
        provisioningArtifact = provisioningArtifactDecoded
    }
}

extension ProvisioningArtifactView: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningArtifactView(productViewSummary: \(String(describing: productViewSummary)), provisioningArtifact: \(String(describing: provisioningArtifact)))"}
}

/// <p>An object that contains summary information about a product view and a provisioning artifact.</p>
public struct ProvisioningArtifactView: Equatable {
    /// <p>Summary information about a product view.</p>
    public let productViewSummary: ProductViewSummary?
    /// <p>Information about a provisioning artifact. A provisioning artifact is also known as a product version.</p>
    public let provisioningArtifact: ProvisioningArtifact?

    public init (
        productViewSummary: ProductViewSummary? = nil,
        provisioningArtifact: ProvisioningArtifact? = nil
    )
    {
        self.productViewSummary = productViewSummary
        self.provisioningArtifact = provisioningArtifact
    }
}

extension ProvisioningParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ProvisioningParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningParameter(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Information about a parameter used to provision a product.</p>
public struct ProvisioningParameter: Equatable {
    /// <p>The parameter key.</p>
    public let key: String?
    /// <p>The parameter value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension ProvisioningPreferences: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackSetAccounts = "StackSetAccounts"
        case stackSetFailureToleranceCount = "StackSetFailureToleranceCount"
        case stackSetFailureTolerancePercentage = "StackSetFailureTolerancePercentage"
        case stackSetMaxConcurrencyCount = "StackSetMaxConcurrencyCount"
        case stackSetMaxConcurrencyPercentage = "StackSetMaxConcurrencyPercentage"
        case stackSetRegions = "StackSetRegions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackSetAccounts = stackSetAccounts {
            var stackSetAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetAccounts)
            for stacksetaccounts0 in stackSetAccounts {
                try stackSetAccountsContainer.encode(stacksetaccounts0)
            }
        }
        if let stackSetFailureToleranceCount = stackSetFailureToleranceCount {
            try encodeContainer.encode(stackSetFailureToleranceCount, forKey: .stackSetFailureToleranceCount)
        }
        if let stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage {
            try encodeContainer.encode(stackSetFailureTolerancePercentage, forKey: .stackSetFailureTolerancePercentage)
        }
        if let stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount {
            try encodeContainer.encode(stackSetMaxConcurrencyCount, forKey: .stackSetMaxConcurrencyCount)
        }
        if let stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage {
            try encodeContainer.encode(stackSetMaxConcurrencyPercentage, forKey: .stackSetMaxConcurrencyPercentage)
        }
        if let stackSetRegions = stackSetRegions {
            var stackSetRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetRegions)
            for stacksetregions0 in stackSetRegions {
                try stackSetRegionsContainer.encode(stacksetregions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stackSetAccounts)
        var stackSetAccountsDecoded0:[String]? = nil
        if let stackSetAccountsContainer = stackSetAccountsContainer {
            stackSetAccountsDecoded0 = [String]()
            for string0 in stackSetAccountsContainer {
                if let string0 = string0 {
                    stackSetAccountsDecoded0?.append(string0)
                }
            }
        }
        stackSetAccounts = stackSetAccountsDecoded0
        let stackSetRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stackSetRegions)
        var stackSetRegionsDecoded0:[String]? = nil
        if let stackSetRegionsContainer = stackSetRegionsContainer {
            stackSetRegionsDecoded0 = [String]()
            for string0 in stackSetRegionsContainer {
                if let string0 = string0 {
                    stackSetRegionsDecoded0?.append(string0)
                }
            }
        }
        stackSetRegions = stackSetRegionsDecoded0
        let stackSetFailureToleranceCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stackSetFailureToleranceCount)
        stackSetFailureToleranceCount = stackSetFailureToleranceCountDecoded
        let stackSetFailureTolerancePercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stackSetFailureTolerancePercentage)
        stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentageDecoded
        let stackSetMaxConcurrencyCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stackSetMaxConcurrencyCount)
        stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCountDecoded
        let stackSetMaxConcurrencyPercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stackSetMaxConcurrencyPercentage)
        stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentageDecoded
    }
}

extension ProvisioningPreferences: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisioningPreferences(stackSetAccounts: \(String(describing: stackSetAccounts)), stackSetFailureToleranceCount: \(String(describing: stackSetFailureToleranceCount)), stackSetFailureTolerancePercentage: \(String(describing: stackSetFailureTolerancePercentage)), stackSetMaxConcurrencyCount: \(String(describing: stackSetMaxConcurrencyCount)), stackSetMaxConcurrencyPercentage: \(String(describing: stackSetMaxConcurrencyPercentage)), stackSetRegions: \(String(describing: stackSetRegions)))"}
}

/// <p>The user-defined preferences that will be applied when updating a provisioned
///          product. Not all preferences are applicable to all provisioned product type</p>
///          <p>One or more AWS accounts that will have access to the provisioned product.</p>
///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
///          <p>The AWS accounts specified should be within the list of accounts in the
///             <code>STACKSET</code> constraint. To get the list of accounts in the
///             <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code>
///          operation.</p>
///          <p>If no values are specified, the default value is all accounts from the
///             <code>STACKSET</code> constraint.</p>
public struct ProvisioningPreferences: Equatable {
    /// <p>One or more AWS accounts where the provisioned product will be available.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <p>The specified accounts should be within the list of accounts from the <code>STACKSET</code> constraint. To get the list of accounts in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
    ///          <p>If no values are specified, the default value is all acounts from the <code>STACKSET</code> constraint.</p>
    public let stackSetAccounts: [String]?
    /// <p>The number of accounts, per region, for which this operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
    ///          <p>The default value is <code>0</code> if no value is specified.</p>
    public let stackSetFailureToleranceCount: Int?
    /// <p>The percentage of accounts, per region, for which this stack operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions.</p>
    ///          <p>When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
    public let stackSetFailureTolerancePercentage: Int?
    /// <p>The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of <code>StackSetFailureToleranceCount</code>. <code>StackSetMaxConcurrentCount</code> is at most one more than the <code>StackSetFailureToleranceCount</code>.</p>
    ///          <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
    public let stackSetMaxConcurrencyCount: Int?
    /// <p>The maximum percentage of accounts in which to perform this operation at one time.</p>
    ///          <p>When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, AWS Service Catalog sets the number as <code>1</code> instead.</p>
    ///          <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
    public let stackSetMaxConcurrencyPercentage: Int?
    /// <p>One or more AWS Regions where the provisioned product will be available.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <p>The specified regions should be within the list of regions from the <code>STACKSET</code> constraint. To get the list of regions in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
    ///          <p>If no values are specified, the default value is all regions from the <code>STACKSET</code> constraint.</p>
    public let stackSetRegions: [String]?

    public init (
        stackSetAccounts: [String]? = nil,
        stackSetFailureToleranceCount: Int? = nil,
        stackSetFailureTolerancePercentage: Int? = nil,
        stackSetMaxConcurrencyCount: Int? = nil,
        stackSetMaxConcurrencyPercentage: Int? = nil,
        stackSetRegions: [String]? = nil
    )
    {
        self.stackSetAccounts = stackSetAccounts
        self.stackSetFailureToleranceCount = stackSetFailureToleranceCount
        self.stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage
        self.stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount
        self.stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage
        self.stackSetRegions = stackSetRegions
    }
}

extension RecordDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case launchRoleArn = "LaunchRoleArn"
        case pathId = "PathId"
        case productId = "ProductId"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisionedProductType = "ProvisionedProductType"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case recordErrors = "RecordErrors"
        case recordId = "RecordId"
        case recordTags = "RecordTags"
        case recordType = "RecordType"
        case status = "Status"
        case updatedTime = "UpdatedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let launchRoleArn = launchRoleArn {
            try encodeContainer.encode(launchRoleArn, forKey: .launchRoleArn)
        }
        if let pathId = pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisionedProductType = provisionedProductType {
            try encodeContainer.encode(provisionedProductType, forKey: .provisionedProductType)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let recordErrors = recordErrors {
            var recordErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordErrors)
            for recorderrors0 in recordErrors {
                try recordErrorsContainer.encode(recorderrors0)
            }
        }
        if let recordId = recordId {
            try encodeContainer.encode(recordId, forKey: .recordId)
        }
        if let recordTags = recordTags {
            var recordTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordTags)
            for recordtags0 in recordTags {
                try recordTagsContainer.encode(recordtags0)
            }
        }
        if let recordType = recordType {
            try encodeContainer.encode(recordType, forKey: .recordType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTime = updatedTime {
            try encodeContainer.encode(updatedTime.timeIntervalSince1970, forKey: .updatedTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordId)
        recordId = recordIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RecordStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let provisionedProductTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductType)
        provisionedProductType = provisionedProductTypeDecoded
        let recordTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordType)
        recordType = recordTypeDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let recordErrorsContainer = try containerValues.decodeIfPresent([RecordError?].self, forKey: .recordErrors)
        var recordErrorsDecoded0:[RecordError]? = nil
        if let recordErrorsContainer = recordErrorsContainer {
            recordErrorsDecoded0 = [RecordError]()
            for structure0 in recordErrorsContainer {
                if let structure0 = structure0 {
                    recordErrorsDecoded0?.append(structure0)
                }
            }
        }
        recordErrors = recordErrorsDecoded0
        let recordTagsContainer = try containerValues.decodeIfPresent([RecordTag?].self, forKey: .recordTags)
        var recordTagsDecoded0:[RecordTag]? = nil
        if let recordTagsContainer = recordTagsContainer {
            recordTagsDecoded0 = [RecordTag]()
            for structure0 in recordTagsContainer {
                if let structure0 = structure0 {
                    recordTagsDecoded0?.append(structure0)
                }
            }
        }
        recordTags = recordTagsDecoded0
        let launchRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchRoleArn)
        launchRoleArn = launchRoleArnDecoded
    }
}

extension RecordDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordDetail(createdTime: \(String(describing: createdTime)), launchRoleArn: \(String(describing: launchRoleArn)), pathId: \(String(describing: pathId)), productId: \(String(describing: productId)), provisionedProductId: \(String(describing: provisionedProductId)), provisionedProductName: \(String(describing: provisionedProductName)), provisionedProductType: \(String(describing: provisionedProductType)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), recordErrors: \(String(describing: recordErrors)), recordId: \(String(describing: recordId)), recordTags: \(String(describing: recordTags)), recordType: \(String(describing: recordType)), status: \(String(describing: status)), updatedTime: \(String(describing: updatedTime)))"}
}

/// <p>Information about a request operation.</p>
public struct RecordDetail: Equatable {
    /// <p>The UTC time stamp of the creation time.</p>
    public let createdTime: Date?
    /// <p>The ARN of the launch role associated with the provisioned product.</p>
    public let launchRoleArn: String?
    /// <p>The path identifier.</p>
    public let pathId: String?
    /// <p>The product identifier.</p>
    public let productId: String?
    /// <p>The identifier of the provisioned product.</p>
    public let provisionedProductId: String?
    /// <p>The user-friendly name of the provisioned product.</p>
    public let provisionedProductName: String?
    /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
    public let provisionedProductType: String?
    /// <p>The identifier of the provisioning artifact.</p>
    public let provisioningArtifactId: String?
    /// <p>The errors that occurred.</p>
    public let recordErrors: [RecordError]?
    /// <p>The identifier of the record.</p>
    public let recordId: String?
    /// <p>One or more tags.</p>
    public let recordTags: [RecordTag]?
    /// <p>The record type.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PROVISION_PRODUCT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_PROVISIONED_PRODUCT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TERMINATE_PROVISIONED_PRODUCT</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let recordType: String?
    /// <p>The status of the provisioned product.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATED</code> - The request was created but the operation has not started.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_PROGRESS</code> - The requested operation is in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_PROGRESS_IN_ERROR</code> - The provisioned product is under change but the
    ///             requested operation failed and some remediation is occurring. For example, a rollback.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUCCEEDED</code> - The requested operation has successfully completed.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - The requested operation has unsuccessfully completed.
    ///             Investigate using the error messages returned.</p>
    ///             </li>
    ///          </ul>
    public let status: RecordStatus?
    /// <p>The time when the record was last updated.</p>
    public let updatedTime: Date?

    public init (
        createdTime: Date? = nil,
        launchRoleArn: String? = nil,
        pathId: String? = nil,
        productId: String? = nil,
        provisionedProductId: String? = nil,
        provisionedProductName: String? = nil,
        provisionedProductType: String? = nil,
        provisioningArtifactId: String? = nil,
        recordErrors: [RecordError]? = nil,
        recordId: String? = nil,
        recordTags: [RecordTag]? = nil,
        recordType: String? = nil,
        status: RecordStatus? = nil,
        updatedTime: Date? = nil
    )
    {
        self.createdTime = createdTime
        self.launchRoleArn = launchRoleArn
        self.pathId = pathId
        self.productId = productId
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
        self.provisionedProductType = provisionedProductType
        self.provisioningArtifactId = provisioningArtifactId
        self.recordErrors = recordErrors
        self.recordId = recordId
        self.recordTags = recordTags
        self.recordType = recordType
        self.status = status
        self.updatedTime = updatedTime
    }
}

extension RecordError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension RecordError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordError(code: \(String(describing: code)), description: \(String(describing: description)))"}
}

/// <p>The error code and description resulting from an operation.</p>
public struct RecordError: Equatable {
    /// <p>The numeric value of the error.</p>
    public let code: String?
    /// <p>The description of the error.</p>
    public let description: String?

    public init (
        code: String? = nil,
        description: String? = nil
    )
    {
        self.code = code
        self.description = description
    }
}

extension RecordOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case outputKey = "OutputKey"
        case outputValue = "OutputValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let outputKey = outputKey {
            try encodeContainer.encode(outputKey, forKey: .outputKey)
        }
        if let outputValue = outputValue {
            try encodeContainer.encode(outputValue, forKey: .outputValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputKey)
        outputKey = outputKeyDecoded
        let outputValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputValue)
        outputValue = outputValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension RecordOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordOutput(description: \(String(describing: description)), outputKey: \(String(describing: outputKey)), outputValue: \(String(describing: outputValue)))"}
}

/// <p>The output for the product created as the result of a request. For example, the output for
///          a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.</p>
public struct RecordOutput: Equatable {
    /// <p>The description of the output.</p>
    public let description: String?
    /// <p>The output key.</p>
    public let outputKey: String?
    /// <p>The output value.</p>
    public let outputValue: String?

    public init (
        description: String? = nil,
        outputKey: String? = nil,
        outputValue: String? = nil
    )
    {
        self.description = description
        self.outputKey = outputKey
        self.outputValue = outputValue
    }
}

public enum RecordStatus {
    case created
    case failed
    case inProgress
    case inProgressInError
    case succeeded
    case sdkUnknown(String)
}

extension RecordStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecordStatus] {
        return [
            .created,
            .failed,
            .inProgress,
            .inProgressInError,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .created: return "CREATED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .inProgressInError: return "IN_PROGRESS_IN_ERROR"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecordStatus(rawValue: rawValue) ?? RecordStatus.sdkUnknown(rawValue)
    }
}

extension RecordTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RecordTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordTag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Information about a tag, which is a key-value pair.</p>
public struct RecordTag: Equatable {
    /// <p>The key for this tag.</p>
    public let key: String?
    /// <p>The value for this tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct RejectPortfolioShareInputBodyMiddleware: Middleware {
    public let id: String = "RejectPortfolioShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectPortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectPortfolioShareInput>
    public typealias MOutput = OperationOutput<RejectPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectPortfolioShareOutputError>
}

extension RejectPortfolioShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectPortfolioShareInput(acceptLanguage: \(String(describing: acceptLanguage)), portfolioId: \(String(describing: portfolioId)), portfolioShareType: \(String(describing: portfolioShareType)))"}
}

extension RejectPortfolioShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case portfolioShareType = "PortfolioShareType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let portfolioShareType = portfolioShareType {
            try encodeContainer.encode(portfolioShareType.rawValue, forKey: .portfolioShareType)
        }
    }
}

public struct RejectPortfolioShareInputHeadersMiddleware: Middleware {
    public let id: String = "RejectPortfolioShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectPortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectPortfolioShareInput>
    public typealias MOutput = OperationOutput<RejectPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectPortfolioShareOutputError>
}

public struct RejectPortfolioShareInputQueryItemMiddleware: Middleware {
    public let id: String = "RejectPortfolioShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RejectPortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<RejectPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RejectPortfolioShareInput>
    public typealias MOutput = OperationOutput<RejectPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RejectPortfolioShareOutputError>
}

public struct RejectPortfolioShareInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?
    /// <p>The type of shared portfolios to reject. The default is to reject imported portfolios.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AWS_ORGANIZATIONS</code> - Reject portfolios shared by the management account of your
    ///                organization.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IMPORTED</code> - Reject imported portfolios.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AWS_SERVICECATALOG</code> - Not supported. (Throws ResourceNotFoundException.)</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, <code>aws servicecatalog reject-portfolio-share --portfolio-id "port-2qwzkwxt3y5fk" --portfolio-share-type AWS_ORGANIZATIONS</code>
    ///          </p>
    public let portfolioShareType: PortfolioShareType?

    public init (
        acceptLanguage: String? = nil,
        portfolioId: String? = nil,
        portfolioShareType: PortfolioShareType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.portfolioShareType = portfolioShareType
    }
}

struct RejectPortfolioShareInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let portfolioShareType: PortfolioShareType?
}

extension RejectPortfolioShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case portfolioShareType = "PortfolioShareType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let portfolioShareTypeDecoded = try containerValues.decodeIfPresent(PortfolioShareType.self, forKey: .portfolioShareType)
        portfolioShareType = portfolioShareTypeDecoded
    }
}

extension RejectPortfolioShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectPortfolioShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectPortfolioShareOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectPortfolioShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectPortfolioShareOutputResponse()"}
}

extension RejectPortfolioShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RejectPortfolioShareOutputResponse: Equatable {

    public init() {}
}

struct RejectPortfolioShareOutputResponseBody: Equatable {
}

extension RejectPortfolioShareOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum Replacement {
    case conditional
    case `false`
    case `true`
    case sdkUnknown(String)
}

extension Replacement : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Replacement] {
        return [
            .conditional,
            .false,
            .true,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .conditional: return "CONDITIONAL"
        case .false: return "FALSE"
        case .true: return "TRUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Replacement(rawValue: rawValue) ?? Replacement.sdkUnknown(rawValue)
    }
}

public enum RequiresRecreation {
    case always
    case conditionally
    case never
    case sdkUnknown(String)
}

extension RequiresRecreation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RequiresRecreation] {
        return [
            .always,
            .conditionally,
            .never,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .always: return "ALWAYS"
        case .conditionally: return "CONDITIONALLY"
        case .never: return "NEVER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RequiresRecreation(rawValue: rawValue) ?? RequiresRecreation.sdkUnknown(rawValue)
    }
}

public enum ResourceAttribute {
    case creationpolicy
    case deletionpolicy
    case metadata
    case properties
    case tags
    case updatepolicy
    case sdkUnknown(String)
}

extension ResourceAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceAttribute] {
        return [
            .creationpolicy,
            .deletionpolicy,
            .metadata,
            .properties,
            .tags,
            .updatepolicy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creationpolicy: return "CREATIONPOLICY"
        case .deletionpolicy: return "DELETIONPOLICY"
        case .metadata: return "METADATA"
        case .properties: return "PROPERTIES"
        case .tags: return "TAGS"
        case .updatepolicy: return "UPDATEPOLICY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceAttribute(rawValue: rawValue) ?? ResourceAttribute.sdkUnknown(rawValue)
    }
}

extension ResourceChange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case details = "Details"
        case logicalResourceId = "LogicalResourceId"
        case physicalResourceId = "PhysicalResourceId"
        case replacement = "Replacement"
        case resourceType = "ResourceType"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let details = details {
            var detailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .details)
            for resourcechangedetails0 in details {
                try detailsContainer.encode(resourcechangedetails0)
            }
        }
        if let logicalResourceId = logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let replacement = replacement {
            try encodeContainer.encode(replacement.rawValue, forKey: .replacement)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let scope = scope {
            var scopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scope)
            for scope0 in scope {
                try scopeContainer.encode(scope0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let replacementDecoded = try containerValues.decodeIfPresent(Replacement.self, forKey: .replacement)
        replacement = replacementDecoded
        let scopeContainer = try containerValues.decodeIfPresent([ResourceAttribute?].self, forKey: .scope)
        var scopeDecoded0:[ResourceAttribute]? = nil
        if let scopeContainer = scopeContainer {
            scopeDecoded0 = [ResourceAttribute]()
            for string0 in scopeContainer {
                if let string0 = string0 {
                    scopeDecoded0?.append(string0)
                }
            }
        }
        scope = scopeDecoded0
        let detailsContainer = try containerValues.decodeIfPresent([ResourceChangeDetail?].self, forKey: .details)
        var detailsDecoded0:[ResourceChangeDetail]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [ResourceChangeDetail]()
            for structure0 in detailsContainer {
                if let structure0 = structure0 {
                    detailsDecoded0?.append(structure0)
                }
            }
        }
        details = detailsDecoded0
    }
}

extension ResourceChange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceChange(action: \(String(describing: action)), details: \(String(describing: details)), logicalResourceId: \(String(describing: logicalResourceId)), physicalResourceId: \(String(describing: physicalResourceId)), replacement: \(String(describing: replacement)), resourceType: \(String(describing: resourceType)), scope: \(String(describing: scope)))"}
}

/// <p>Information about a resource change that will occur when a plan is executed.</p>
public struct ResourceChange: Equatable {
    /// <p>The change action.</p>
    public let action: ChangeAction?
    /// <p>Information about the resource changes.</p>
    public let details: [ResourceChangeDetail]?
    /// <p>The ID of the resource, as defined in the CloudFormation template.</p>
    public let logicalResourceId: String?
    /// <p>The ID of the resource, if it was already created.</p>
    public let physicalResourceId: String?
    /// <p>If the change type is <code>Modify</code>, indicates whether the existing resource
    ///          is deleted and replaced with a new one.</p>
    public let replacement: Replacement?
    /// <p>The type of resource.</p>
    public let resourceType: String?
    /// <p>The change scope.</p>
    public let scope: [ResourceAttribute]?

    public init (
        action: ChangeAction? = nil,
        details: [ResourceChangeDetail]? = nil,
        logicalResourceId: String? = nil,
        physicalResourceId: String? = nil,
        replacement: Replacement? = nil,
        resourceType: String? = nil,
        scope: [ResourceAttribute]? = nil
    )
    {
        self.action = action
        self.details = details
        self.logicalResourceId = logicalResourceId
        self.physicalResourceId = physicalResourceId
        self.replacement = replacement
        self.resourceType = resourceType
        self.scope = scope
    }
}

extension ResourceChangeDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case causingEntity = "CausingEntity"
        case evaluation = "Evaluation"
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let causingEntity = causingEntity {
            try encodeContainer.encode(causingEntity, forKey: .causingEntity)
        }
        if let evaluation = evaluation {
            try encodeContainer.encode(evaluation.rawValue, forKey: .evaluation)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(ResourceTargetDefinition.self, forKey: .target)
        target = targetDecoded
        let evaluationDecoded = try containerValues.decodeIfPresent(EvaluationType.self, forKey: .evaluation)
        evaluation = evaluationDecoded
        let causingEntityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .causingEntity)
        causingEntity = causingEntityDecoded
    }
}

extension ResourceChangeDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceChangeDetail(causingEntity: \(String(describing: causingEntity)), evaluation: \(String(describing: evaluation)), target: \(String(describing: target)))"}
}

/// <p>Information about a change to a resource attribute.</p>
public struct ResourceChangeDetail: Equatable {
    /// <p>The ID of the entity that caused the change.</p>
    public let causingEntity: String?
    /// <p>For static evaluations, the value of the resource attribute will change and the new value is known.
    ///          For dynamic evaluations, the value might change, and any new value will be determined when the plan is updated.</p>
    public let evaluation: EvaluationType?
    /// <p>Information about the resource attribute to be modified.</p>
    public let target: ResourceTargetDefinition?

    public init (
        causingEntity: String? = nil,
        evaluation: EvaluationType? = nil,
        target: ResourceTargetDefinition? = nil
    )
    {
        self.causingEntity = causingEntity
        self.evaluation = evaluation
        self.target = target
    }
}

extension ResourceDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case createdTime = "CreatedTime"
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension ResourceDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDetail(aRN: \(String(describing: aRN)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Information about a resource.</p>
public struct ResourceDetail: Equatable {
    /// <p>The ARN of the resource.</p>
    public let aRN: String?
    /// <p>The creation time of the resource.</p>
    public let createdTime: Date?
    /// <p>The description of the resource.</p>
    public let description: String?
    /// <p>The identifier of the resource.</p>
    public let id: String?
    /// <p>The name of the resource.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        createdTime: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.createdTime = createdTime
        self.description = description
        self.id = id
        self.name = name
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource that is currently in use. Ensure that the resource is not in use and retry the operation.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceTargetDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute = "Attribute"
        case name = "Name"
        case requiresRecreation = "RequiresRecreation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiresRecreation = requiresRecreation {
            try encodeContainer.encode(requiresRecreation.rawValue, forKey: .requiresRecreation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(ResourceAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let requiresRecreationDecoded = try containerValues.decodeIfPresent(RequiresRecreation.self, forKey: .requiresRecreation)
        requiresRecreation = requiresRecreationDecoded
    }
}

extension ResourceTargetDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceTargetDefinition(attribute: \(String(describing: attribute)), name: \(String(describing: name)), requiresRecreation: \(String(describing: requiresRecreation)))"}
}

/// <p>Information about a change to a resource attribute.</p>
public struct ResourceTargetDefinition: Equatable {
    /// <p>The attribute to be changed.</p>
    public let attribute: ResourceAttribute?
    /// <p>If the attribute is <code>Properties</code>, the value is the name of the property.
    ///          Otherwise, the value is null.</p>
    public let name: String?
    /// <p>If the attribute is <code>Properties</code>, indicates whether a change to this property
    ///          causes the resource to be re-created.</p>
    public let requiresRecreation: RequiresRecreation?

    public init (
        attribute: ResourceAttribute? = nil,
        name: String? = nil,
        requiresRecreation: RequiresRecreation? = nil
    )
    {
        self.attribute = attribute
        self.name = name
        self.requiresRecreation = requiresRecreation
    }
}

public struct ScanProvisionedProductsInputBodyMiddleware: Middleware {
    public let id: String = "ScanProvisionedProductsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ScanProvisionedProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<ScanProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ScanProvisionedProductsInput>
    public typealias MOutput = OperationOutput<ScanProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ScanProvisionedProductsOutputError>
}

extension ScanProvisionedProductsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScanProvisionedProductsInput(acceptLanguage: \(String(describing: acceptLanguage)), accessLevelFilter: \(String(describing: accessLevelFilter)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)))"}
}

extension ScanProvisionedProductsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accessLevelFilter = accessLevelFilter {
            try encodeContainer.encode(accessLevelFilter, forKey: .accessLevelFilter)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

public struct ScanProvisionedProductsInputHeadersMiddleware: Middleware {
    public let id: String = "ScanProvisionedProductsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ScanProvisionedProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<ScanProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ScanProvisionedProductsInput>
    public typealias MOutput = OperationOutput<ScanProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ScanProvisionedProductsOutputError>
}

public struct ScanProvisionedProductsInputQueryItemMiddleware: Middleware {
    public let id: String = "ScanProvisionedProductsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ScanProvisionedProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<ScanProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ScanProvisionedProductsInput>
    public typealias MOutput = OperationOutput<ScanProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ScanProvisionedProductsOutputError>
}

public struct ScanProvisionedProductsInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The access level to use to obtain results. The default is <code>User</code>.</p>
    public let accessLevelFilter: AccessLevelFilter?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?

    public init (
        acceptLanguage: String? = nil,
        accessLevelFilter: AccessLevelFilter? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct ScanProvisionedProductsInputBody: Equatable {
    public let acceptLanguage: String?
    public let accessLevelFilter: AccessLevelFilter?
    public let pageSize: Int
    public let pageToken: String?
}

extension ScanProvisionedProductsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let accessLevelFilterDecoded = try containerValues.decodeIfPresent(AccessLevelFilter.self, forKey: .accessLevelFilter)
        accessLevelFilter = accessLevelFilterDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ScanProvisionedProductsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ScanProvisionedProductsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ScanProvisionedProductsOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ScanProvisionedProductsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScanProvisionedProductsOutputResponse(nextPageToken: \(String(describing: nextPageToken)), provisionedProducts: \(String(describing: provisionedProducts)))"}
}

extension ScanProvisionedProductsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ScanProvisionedProductsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.provisionedProducts = output.provisionedProducts
        } else {
            self.nextPageToken = nil
            self.provisionedProducts = nil
        }
    }
}

public struct ScanProvisionedProductsOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Information about the provisioned products.</p>
    public let provisionedProducts: [ProvisionedProductDetail]?

    public init (
        nextPageToken: String? = nil,
        provisionedProducts: [ProvisionedProductDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProducts = provisionedProducts
    }
}

struct ScanProvisionedProductsOutputResponseBody: Equatable {
    public let provisionedProducts: [ProvisionedProductDetail]?
    public let nextPageToken: String?
}

extension ScanProvisionedProductsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case provisionedProducts = "ProvisionedProducts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductsContainer = try containerValues.decodeIfPresent([ProvisionedProductDetail?].self, forKey: .provisionedProducts)
        var provisionedProductsDecoded0:[ProvisionedProductDetail]? = nil
        if let provisionedProductsContainer = provisionedProductsContainer {
            provisionedProductsDecoded0 = [ProvisionedProductDetail]()
            for structure0 in provisionedProductsContainer {
                if let structure0 = structure0 {
                    provisionedProductsDecoded0?.append(structure0)
                }
            }
        }
        provisionedProducts = provisionedProductsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct SearchProductsAsAdminInputBodyMiddleware: Middleware {
    public let id: String = "SearchProductsAsAdminInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProductsAsAdminInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProductsAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProductsAsAdminInput>
    public typealias MOutput = OperationOutput<SearchProductsAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProductsAsAdminOutputError>
}

extension SearchProductsAsAdminInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchProductsAsAdminInput(acceptLanguage: \(String(describing: acceptLanguage)), filters: \(String(describing: filters)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), portfolioId: \(String(describing: portfolioId)), productSource: \(String(describing: productSource)), sortBy: \(String(describing: sortBy)), sortOrder: \(String(describing: sortOrder)))"}
}

extension SearchProductsAsAdminInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case productSource = "ProductSource"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filters)
            for (dictKey0, productviewfilters0) in filters {
                try filtersContainer.encode(productviewfilters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productSource = productSource {
            try encodeContainer.encode(productSource.rawValue, forKey: .productSource)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct SearchProductsAsAdminInputHeadersMiddleware: Middleware {
    public let id: String = "SearchProductsAsAdminInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProductsAsAdminInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProductsAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProductsAsAdminInput>
    public typealias MOutput = OperationOutput<SearchProductsAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProductsAsAdminOutputError>
}

public struct SearchProductsAsAdminInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchProductsAsAdminInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProductsAsAdminInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProductsAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProductsAsAdminInput>
    public typealias MOutput = OperationOutput<SearchProductsAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProductsAsAdminOutputError>
}

public struct SearchProductsAsAdminInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The search filters. If no search filters are specified, the output includes all products
    ///          to which the administrator has access.</p>
    public let filters: [String:[String]]?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The portfolio identifier.</p>
    public let portfolioId: String?
    /// <p>Access level of the source of the product.</p>
    public let productSource: ProductSource?
    /// <p>The sort field. If no value is specified, the results are not sorted.</p>
    public let sortBy: ProductViewSortBy?
    /// <p>The sort order. If no value is specified, the results are not sorted.</p>
    public let sortOrder: SortOrder?

    public init (
        acceptLanguage: String? = nil,
        filters: [String:[String]]? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        portfolioId: String? = nil,
        productSource: ProductSource? = nil,
        sortBy: ProductViewSortBy? = nil,
        sortOrder: SortOrder? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
        self.productSource = productSource
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct SearchProductsAsAdminInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let filters: [String:[String]]?
    public let sortBy: ProductViewSortBy?
    public let sortOrder: SortOrder?
    public let pageToken: String?
    public let pageSize: Int
    public let productSource: ProductSource?
}

extension SearchProductsAsAdminInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case productSource = "ProductSource"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .filters)
        var filtersDecoded0: [String:[String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [String:[String]]()
            for (key0, productviewfiltervalues0) in filtersContainer {
                var productviewfiltervalues0Decoded0: [String]? = nil
                if let productviewfiltervalues0 = productviewfiltervalues0 {
                    productviewfiltervalues0Decoded0 = [String]()
                    for string1 in productviewfiltervalues0 {
                        if let string1 = string1 {
                            productviewfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = productviewfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(ProductViewSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let productSourceDecoded = try containerValues.decodeIfPresent(ProductSource.self, forKey: .productSource)
        productSource = productSourceDecoded
    }
}

extension SearchProductsAsAdminOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchProductsAsAdminOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchProductsAsAdminOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchProductsAsAdminOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchProductsAsAdminOutputResponse(nextPageToken: \(String(describing: nextPageToken)), productViewDetails: \(String(describing: productViewDetails)))"}
}

extension SearchProductsAsAdminOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchProductsAsAdminOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.productViewDetails = output.productViewDetails
        } else {
            self.nextPageToken = nil
            self.productViewDetails = nil
        }
    }
}

public struct SearchProductsAsAdminOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Information about the product views.</p>
    public let productViewDetails: [ProductViewDetail]?

    public init (
        nextPageToken: String? = nil,
        productViewDetails: [ProductViewDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.productViewDetails = productViewDetails
    }
}

struct SearchProductsAsAdminOutputResponseBody: Equatable {
    public let productViewDetails: [ProductViewDetail]?
    public let nextPageToken: String?
}

extension SearchProductsAsAdminOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case productViewDetails = "ProductViewDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewDetailsContainer = try containerValues.decodeIfPresent([ProductViewDetail?].self, forKey: .productViewDetails)
        var productViewDetailsDecoded0:[ProductViewDetail]? = nil
        if let productViewDetailsContainer = productViewDetailsContainer {
            productViewDetailsDecoded0 = [ProductViewDetail]()
            for structure0 in productViewDetailsContainer {
                if let structure0 = structure0 {
                    productViewDetailsDecoded0?.append(structure0)
                }
            }
        }
        productViewDetails = productViewDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct SearchProductsInputBodyMiddleware: Middleware {
    public let id: String = "SearchProductsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProductsInput>
    public typealias MOutput = OperationOutput<SearchProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProductsOutputError>
}

extension SearchProductsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchProductsInput(acceptLanguage: \(String(describing: acceptLanguage)), filters: \(String(describing: filters)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), sortBy: \(String(describing: sortBy)), sortOrder: \(String(describing: sortOrder)))"}
}

extension SearchProductsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filters)
            for (dictKey0, productviewfilters0) in filters {
                try filtersContainer.encode(productviewfilters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct SearchProductsInputHeadersMiddleware: Middleware {
    public let id: String = "SearchProductsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProductsInput>
    public typealias MOutput = OperationOutput<SearchProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProductsOutputError>
}

public struct SearchProductsInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchProductsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProductsInput>
    public typealias MOutput = OperationOutput<SearchProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProductsOutputError>
}

public struct SearchProductsInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The search filters. If no search filters are specified, the output includes
    ///          all products to which the caller has access.</p>
    public let filters: [String:[String]]?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The sort field. If no value is specified, the results are not sorted.</p>
    public let sortBy: ProductViewSortBy?
    /// <p>The sort order. If no value is specified, the results are not sorted.</p>
    public let sortOrder: SortOrder?

    public init (
        acceptLanguage: String? = nil,
        filters: [String:[String]]? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        sortBy: ProductViewSortBy? = nil,
        sortOrder: SortOrder? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct SearchProductsInputBody: Equatable {
    public let acceptLanguage: String?
    public let filters: [String:[String]]?
    public let pageSize: Int
    public let sortBy: ProductViewSortBy?
    public let sortOrder: SortOrder?
    public let pageToken: String?
}

extension SearchProductsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let filtersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .filters)
        var filtersDecoded0: [String:[String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [String:[String]]()
            for (key0, productviewfiltervalues0) in filtersContainer {
                var productviewfiltervalues0Decoded0: [String]? = nil
                if let productviewfiltervalues0 = productviewfiltervalues0 {
                    productviewfiltervalues0Decoded0 = [String]()
                    for string1 in productviewfiltervalues0 {
                        if let string1 = string1 {
                            productviewfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = productviewfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(ProductViewSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension SearchProductsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchProductsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchProductsOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchProductsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchProductsOutputResponse(nextPageToken: \(String(describing: nextPageToken)), productViewAggregations: \(String(describing: productViewAggregations)), productViewSummaries: \(String(describing: productViewSummaries)))"}
}

extension SearchProductsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchProductsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.productViewAggregations = output.productViewAggregations
            self.productViewSummaries = output.productViewSummaries
        } else {
            self.nextPageToken = nil
            self.productViewAggregations = nil
            self.productViewSummaries = nil
        }
    }
}

public struct SearchProductsOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>The product view aggregations.</p>
    public let productViewAggregations: [String:[ProductViewAggregationValue]]?
    /// <p>Information about the product views.</p>
    public let productViewSummaries: [ProductViewSummary]?

    public init (
        nextPageToken: String? = nil,
        productViewAggregations: [String:[ProductViewAggregationValue]]? = nil,
        productViewSummaries: [ProductViewSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.productViewAggregations = productViewAggregations
        self.productViewSummaries = productViewSummaries
    }
}

struct SearchProductsOutputResponseBody: Equatable {
    public let productViewSummaries: [ProductViewSummary]?
    public let productViewAggregations: [String:[ProductViewAggregationValue]]?
    public let nextPageToken: String?
}

extension SearchProductsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case productViewAggregations = "ProductViewAggregations"
        case productViewSummaries = "ProductViewSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummariesContainer = try containerValues.decodeIfPresent([ProductViewSummary?].self, forKey: .productViewSummaries)
        var productViewSummariesDecoded0:[ProductViewSummary]? = nil
        if let productViewSummariesContainer = productViewSummariesContainer {
            productViewSummariesDecoded0 = [ProductViewSummary]()
            for structure0 in productViewSummariesContainer {
                if let structure0 = structure0 {
                    productViewSummariesDecoded0?.append(structure0)
                }
            }
        }
        productViewSummaries = productViewSummariesDecoded0
        let productViewAggregationsContainer = try containerValues.decodeIfPresent([String: [ProductViewAggregationValue?]?].self, forKey: .productViewAggregations)
        var productViewAggregationsDecoded0: [String:[ProductViewAggregationValue]]? = nil
        if let productViewAggregationsContainer = productViewAggregationsContainer {
            productViewAggregationsDecoded0 = [String:[ProductViewAggregationValue]]()
            for (key0, productviewaggregationvalues0) in productViewAggregationsContainer {
                var productviewaggregationvalues0Decoded0: [ProductViewAggregationValue]? = nil
                if let productviewaggregationvalues0 = productviewaggregationvalues0 {
                    productviewaggregationvalues0Decoded0 = [ProductViewAggregationValue]()
                    for structure1 in productviewaggregationvalues0 {
                        if let structure1 = structure1 {
                            productviewaggregationvalues0Decoded0?.append(structure1)
                        }
                    }
                }
                productViewAggregationsDecoded0?[key0] = productviewaggregationvalues0Decoded0
            }
        }
        productViewAggregations = productViewAggregationsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct SearchProvisionedProductsInputBodyMiddleware: Middleware {
    public let id: String = "SearchProvisionedProductsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProvisionedProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProvisionedProductsInput>
    public typealias MOutput = OperationOutput<SearchProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProvisionedProductsOutputError>
}

extension SearchProvisionedProductsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchProvisionedProductsInput(acceptLanguage: \(String(describing: acceptLanguage)), accessLevelFilter: \(String(describing: accessLevelFilter)), filters: \(String(describing: filters)), pageSize: \(String(describing: pageSize)), pageToken: \(String(describing: pageToken)), sortBy: \(String(describing: sortBy)), sortOrder: \(String(describing: sortOrder)))"}
}

extension SearchProvisionedProductsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accessLevelFilter = accessLevelFilter {
            try encodeContainer.encode(accessLevelFilter, forKey: .accessLevelFilter)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filters)
            for (dictKey0, provisionedproductfilters0) in filters {
                try filtersContainer.encode(provisionedproductfilters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct SearchProvisionedProductsInputHeadersMiddleware: Middleware {
    public let id: String = "SearchProvisionedProductsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProvisionedProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProvisionedProductsInput>
    public typealias MOutput = OperationOutput<SearchProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProvisionedProductsOutputError>
}

public struct SearchProvisionedProductsInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchProvisionedProductsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchProvisionedProductsInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchProvisionedProductsInput>
    public typealias MOutput = OperationOutput<SearchProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchProvisionedProductsOutputError>
}

public struct SearchProvisionedProductsInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The access level to use to obtain results. The default is <code>User</code>.</p>
    public let accessLevelFilter: AccessLevelFilter?
    /// <p>The search filters.</p>
    ///          <p>When the key is <code>SearchQuery</code>, the searchable fields are <code>arn</code>,
    ///          <code>createdTime</code>, <code>id</code>, <code>lastRecordId</code>,
    ///          <code>idempotencyToken</code>, <code>name</code>, <code>physicalId</code>, <code>productId</code>,
    ///          <code>provisioningArtifact</code>, <code>type</code>, <code>status</code>,
    ///          <code>tags</code>, <code>userArn</code>, <code>userArnSession</code>, <code>lastProvisioningRecordId</code>, <code>lastSuccessfulProvisioningRecordId</code>,
    ///          <code>productName</code>, and <code>provisioningArtifactName</code>.</p>
    ///          <p>Example: <code>"SearchQuery":["status:AVAILABLE"]</code>
    ///          </p>
    public let filters: [String:[String]]?
    /// <p>The maximum number of items to return with this call.</p>
    public let pageSize: Int
    /// <p>The page token for the next set of results. To retrieve the first set of results, use null.</p>
    public let pageToken: String?
    /// <p>The sort field. If no value is specified, the results are not sorted. The valid values are <code>arn</code>, <code>id</code>, <code>name</code>,
    ///          and <code>lastRecordId</code>.</p>
    public let sortBy: String?
    /// <p>The sort order. If no value is specified, the results are not sorted.</p>
    public let sortOrder: SortOrder?

    public init (
        acceptLanguage: String? = nil,
        accessLevelFilter: AccessLevelFilter? = nil,
        filters: [String:[String]]? = nil,
        pageSize: Int = 0,
        pageToken: String? = nil,
        sortBy: String? = nil,
        sortOrder: SortOrder? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct SearchProvisionedProductsInputBody: Equatable {
    public let acceptLanguage: String?
    public let accessLevelFilter: AccessLevelFilter?
    public let filters: [String:[String]]?
    public let sortBy: String?
    public let sortOrder: SortOrder?
    public let pageSize: Int
    public let pageToken: String?
}

extension SearchProvisionedProductsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let accessLevelFilterDecoded = try containerValues.decodeIfPresent(AccessLevelFilter.self, forKey: .accessLevelFilter)
        accessLevelFilter = accessLevelFilterDecoded
        let filtersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .filters)
        var filtersDecoded0: [String:[String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [String:[String]]()
            for (key0, provisionedproductviewfiltervalues0) in filtersContainer {
                var provisionedproductviewfiltervalues0Decoded0: [String]? = nil
                if let provisionedproductviewfiltervalues0 = provisionedproductviewfiltervalues0 {
                    provisionedproductviewfiltervalues0Decoded0 = [String]()
                    for string1 in provisionedproductviewfiltervalues0 {
                        if let string1 = string1 {
                            provisionedproductviewfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = provisionedproductviewfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension SearchProvisionedProductsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchProvisionedProductsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchProvisionedProductsOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchProvisionedProductsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchProvisionedProductsOutputResponse(nextPageToken: \(String(describing: nextPageToken)), provisionedProducts: \(String(describing: provisionedProducts)), totalResultsCount: \(String(describing: totalResultsCount)))"}
}

extension SearchProvisionedProductsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchProvisionedProductsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.provisionedProducts = output.provisionedProducts
            self.totalResultsCount = output.totalResultsCount
        } else {
            self.nextPageToken = nil
            self.provisionedProducts = nil
            self.totalResultsCount = 0
        }
    }
}

public struct SearchProvisionedProductsOutputResponse: Equatable {
    /// <p>The page token to use to retrieve the next set of results. If there are no additional results, this value is null.</p>
    public let nextPageToken: String?
    /// <p>Information about the provisioned products.</p>
    public let provisionedProducts: [ProvisionedProductAttribute]?
    /// <p>The number of provisioned products found.</p>
    public let totalResultsCount: Int

    public init (
        nextPageToken: String? = nil,
        provisionedProducts: [ProvisionedProductAttribute]? = nil,
        totalResultsCount: Int = 0
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProducts = provisionedProducts
        self.totalResultsCount = totalResultsCount
    }
}

struct SearchProvisionedProductsOutputResponseBody: Equatable {
    public let provisionedProducts: [ProvisionedProductAttribute]?
    public let totalResultsCount: Int
    public let nextPageToken: String?
}

extension SearchProvisionedProductsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case provisionedProducts = "ProvisionedProducts"
        case totalResultsCount = "TotalResultsCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductsContainer = try containerValues.decodeIfPresent([ProvisionedProductAttribute?].self, forKey: .provisionedProducts)
        var provisionedProductsDecoded0:[ProvisionedProductAttribute]? = nil
        if let provisionedProductsContainer = provisionedProductsContainer {
            provisionedProductsDecoded0 = [ProvisionedProductAttribute]()
            for structure0 in provisionedProductsContainer {
                if let structure0 = structure0 {
                    provisionedProductsDecoded0?.append(structure0)
                }
            }
        }
        provisionedProducts = provisionedProductsDecoded0
        let totalResultsCountDecoded = try containerValues.decode(Int.self, forKey: .totalResultsCount)
        totalResultsCount = totalResultsCountDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ServiceActionAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
    }
}

extension ServiceActionAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceActionAssociation(productId: \(String(describing: productId)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), serviceActionId: \(String(describing: serviceActionId)))"}
}

/// <p>A self-service action association consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.</p>
public struct ServiceActionAssociation: Equatable {
    /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
    public let productId: String?
    /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
    public let provisioningArtifactId: String?
    /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
    public let serviceActionId: String?

    public init (
        productId: String? = nil,
        provisioningArtifactId: String? = nil,
        serviceActionId: String? = nil
    )
    {
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
        self.serviceActionId = serviceActionId
    }
}

public enum ServiceActionAssociationErrorCode {
    case duplicateresourceexception
    case internalfailure
    case limitexceededexception
    case resourcenotfoundexception
    case throttlingexception
    case sdkUnknown(String)
}

extension ServiceActionAssociationErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceActionAssociationErrorCode] {
        return [
            .duplicateresourceexception,
            .internalfailure,
            .limitexceededexception,
            .resourcenotfoundexception,
            .throttlingexception,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .duplicateresourceexception: return "DUPLICATE_RESOURCE"
        case .internalfailure: return "INTERNAL_FAILURE"
        case .limitexceededexception: return "LIMIT_EXCEEDED"
        case .resourcenotfoundexception: return "RESOURCE_NOT_FOUND"
        case .throttlingexception: return "THROTTLING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceActionAssociationErrorCode(rawValue: rawValue) ?? ServiceActionAssociationErrorCode.sdkUnknown(rawValue)
    }
}

public enum ServiceActionDefinitionKey {
    case assumerole
    case name
    case parameters
    case version
    case sdkUnknown(String)
}

extension ServiceActionDefinitionKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceActionDefinitionKey] {
        return [
            .assumerole,
            .name,
            .parameters,
            .version,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assumerole: return "AssumeRole"
        case .name: return "Name"
        case .parameters: return "Parameters"
        case .version: return "Version"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceActionDefinitionKey(rawValue: rawValue) ?? ServiceActionDefinitionKey.sdkUnknown(rawValue)
    }
}

public enum ServiceActionDefinitionType {
    case ssmautomation
    case sdkUnknown(String)
}

extension ServiceActionDefinitionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceActionDefinitionType] {
        return [
            .ssmautomation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ssmautomation: return "SSM_AUTOMATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceActionDefinitionType(rawValue: rawValue) ?? ServiceActionDefinitionType.sdkUnknown(rawValue)
    }
}

extension ServiceActionDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definition = "Definition"
        case serviceActionSummary = "ServiceActionSummary"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .definition)
            for (dictKey0, serviceactiondefinitionmap0) in definition {
                try definitionContainer.encode(serviceactiondefinitionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let serviceActionSummary = serviceActionSummary {
            try encodeContainer.encode(serviceActionSummary, forKey: .serviceActionSummary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionSummaryDecoded = try containerValues.decodeIfPresent(ServiceActionSummary.self, forKey: .serviceActionSummary)
        serviceActionSummary = serviceActionSummaryDecoded
        let definitionContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .definition)
        var definitionDecoded0: [String:String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [String:String]()
            for (key0, serviceactiondefinitionvalue0) in definitionContainer {
                if let serviceactiondefinitionvalue0 = serviceactiondefinitionvalue0 {
                    definitionDecoded0?[key0] = serviceactiondefinitionvalue0
                }
            }
        }
        definition = definitionDecoded0
    }
}

extension ServiceActionDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceActionDetail(definition: \(String(describing: definition)), serviceActionSummary: \(String(describing: serviceActionSummary)))"}
}

/// <p>An object containing detailed information about the self-service action.</p>
public struct ServiceActionDetail: Equatable {
    /// <p>A map that defines the self-service action.</p>
    public let definition: [String:String]?
    /// <p>Summary information about the self-service action.</p>
    public let serviceActionSummary: ServiceActionSummary?

    public init (
        definition: [String:String]? = nil,
        serviceActionSummary: ServiceActionSummary? = nil
    )
    {
        self.definition = definition
        self.serviceActionSummary = serviceActionSummary
    }
}

extension ServiceActionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definitionType = "DefinitionType"
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definitionType = definitionType {
            try encodeContainer.encode(definitionType.rawValue, forKey: .definitionType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let definitionTypeDecoded = try containerValues.decodeIfPresent(ServiceActionDefinitionType.self, forKey: .definitionType)
        definitionType = definitionTypeDecoded
    }
}

extension ServiceActionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceActionSummary(definitionType: \(String(describing: definitionType)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Detailed information about the self-service action.</p>
public struct ServiceActionSummary: Equatable {
    /// <p>The self-service action definition type. For example, <code>SSM_AUTOMATION</code>.</p>
    public let definitionType: ServiceActionDefinitionType?
    /// <p>The self-service action description.</p>
    public let description: String?
    /// <p>The self-service action identifier.</p>
    public let id: String?
    /// <p>The self-service action name.</p>
    public let name: String?

    public init (
        definitionType: ServiceActionDefinitionType? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.definitionType = definitionType
        self.description = description
        self.id = id
        self.name = name
    }
}

extension ShareDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case shareErrors = "ShareErrors"
        case successfulShares = "SuccessfulShares"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareErrors = shareErrors {
            var shareErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shareErrors)
            for shareerrors0 in shareErrors {
                try shareErrorsContainer.encode(shareerrors0)
            }
        }
        if let successfulShares = successfulShares {
            var successfulSharesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .successfulShares)
            for successfulshares0 in successfulShares {
                try successfulSharesContainer.encode(successfulshares0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulSharesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .successfulShares)
        var successfulSharesDecoded0:[String]? = nil
        if let successfulSharesContainer = successfulSharesContainer {
            successfulSharesDecoded0 = [String]()
            for string0 in successfulSharesContainer {
                if let string0 = string0 {
                    successfulSharesDecoded0?.append(string0)
                }
            }
        }
        successfulShares = successfulSharesDecoded0
        let shareErrorsContainer = try containerValues.decodeIfPresent([ShareError?].self, forKey: .shareErrors)
        var shareErrorsDecoded0:[ShareError]? = nil
        if let shareErrorsContainer = shareErrorsContainer {
            shareErrorsDecoded0 = [ShareError]()
            for structure0 in shareErrorsContainer {
                if let structure0 = structure0 {
                    shareErrorsDecoded0?.append(structure0)
                }
            }
        }
        shareErrors = shareErrorsDecoded0
    }
}

extension ShareDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShareDetails(shareErrors: \(String(describing: shareErrors)), successfulShares: \(String(describing: successfulShares)))"}
}

/// <p>Information about the portfolio share operation.</p>
public struct ShareDetails: Equatable {
    /// <p>List of errors.</p>
    public let shareErrors: [ShareError]?
    /// <p>List of accounts for whom the operation succeeded.</p>
    public let successfulShares: [String]?

    public init (
        shareErrors: [ShareError]? = nil,
        successfulShares: [String]? = nil
    )
    {
        self.shareErrors = shareErrors
        self.successfulShares = successfulShares
    }
}

extension ShareError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accounts = "Accounts"
        case error = "Error"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for namespaces0 in accounts {
                try accountsContainer.encode(namespaces0)
            }
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accounts)
        var accountsDecoded0:[String]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [String]()
            for string0 in accountsContainer {
                if let string0 = string0 {
                    accountsDecoded0?.append(string0)
                }
            }
        }
        accounts = accountsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
    }
}

extension ShareError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShareError(accounts: \(String(describing: accounts)), error: \(String(describing: error)), message: \(String(describing: message)))"}
}

/// <p>Errors that occurred during the portfolio share operation.</p>
public struct ShareError: Equatable {
    /// <p>List of accounts impacted by the error.</p>
    public let accounts: [String]?
    /// <p>Error type that happened when processing the operation.</p>
    public let error: String?
    /// <p>Information about the error.</p>
    public let message: String?

    public init (
        accounts: [String]? = nil,
        error: String? = nil,
        message: String? = nil
    )
    {
        self.accounts = accounts
        self.error = error
        self.message = message
    }
}

public enum ShareStatus {
    case completed
    case completedWithErrors
    case error
    case inProgress
    case notStarted
    case sdkUnknown(String)
}

extension ShareStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShareStatus] {
        return [
            .completed,
            .completedWithErrors,
            .error,
            .inProgress,
            .notStarted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
        case .error: return "ERROR"
        case .inProgress: return "IN_PROGRESS"
        case .notStarted: return "NOT_STARTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
    }
}

public enum SortOrder {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension SortOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortOrder] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASCENDING"
        case .descending: return "DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
    }
}

extension StackInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case account = "Account"
        case region = "Region"
        case stackInstanceStatus = "StackInstanceStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stackInstanceStatus = stackInstanceStatus {
            try encodeContainer.encode(stackInstanceStatus.rawValue, forKey: .stackInstanceStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .account)
        account = accountDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let stackInstanceStatusDecoded = try containerValues.decodeIfPresent(StackInstanceStatus.self, forKey: .stackInstanceStatus)
        stackInstanceStatus = stackInstanceStatusDecoded
    }
}

extension StackInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackInstance(account: \(String(describing: account)), region: \(String(describing: region)), stackInstanceStatus: \(String(describing: stackInstanceStatus)))"}
}

/// <p>An AWS CloudFormation stack, in a specific account and region, that's part of a stack set operation. A stack instance is a reference to an attempted or actual stack in a given account within a given region. A stack instance can exist without a stackfor example, if the stack couldn't be created for some reason. A stack instance is associated with only one stack set. Each stack instance contains the ID of its associated stack set, as well as the ID of the actual stack and the stack status. </p>
public struct StackInstance: Equatable {
    /// <p>The name of the AWS account that the stack instance is associated with.</p>
    public let account: String?
    /// <p>The name of the AWS region that the stack instance is associated with.</p>
    public let region: String?
    /// <p>The status of the stack instance, in terms of its synchronization with its associated stack set. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has failed and left the stack in an unstable state. Stacks in this state are excluded from further <code>UpdateStackSet</code> operations. You might need to perform a <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to true, to delete the stack instance, and then delete the stack manually. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OUTDATED</code>: The stack isn't currently up to date with the stack set because either
    ///             the associated stack failed during a <code>CreateStackSet</code> or <code>UpdateStackSet</code> operation,
    ///             or the stack was part of a <code>CreateStackSet</code> or <code>UpdateStackSet</code> operation that failed or was stopped before the stack was created or updated.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CURRENT</code>: The stack is currently up to date with the stack set.</p>
    ///             </li>
    ///          </ul>
    public let stackInstanceStatus: StackInstanceStatus?

    public init (
        account: String? = nil,
        region: String? = nil,
        stackInstanceStatus: StackInstanceStatus? = nil
    )
    {
        self.account = account
        self.region = region
        self.stackInstanceStatus = stackInstanceStatus
    }
}

public enum StackInstanceStatus {
    case current
    case inoperable
    case outdated
    case sdkUnknown(String)
}

extension StackInstanceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackInstanceStatus] {
        return [
            .current,
            .inoperable,
            .outdated,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .current: return "CURRENT"
        case .inoperable: return "INOPERABLE"
        case .outdated: return "OUTDATED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackInstanceStatus(rawValue: rawValue) ?? StackInstanceStatus.sdkUnknown(rawValue)
    }
}

public enum StackSetOperationType {
    case create
    case delete
    case update
    case sdkUnknown(String)
}

extension StackSetOperationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackSetOperationType] {
        return [
            .create,
            .delete,
            .update,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .create: return "CREATE"
        case .delete: return "DELETE"
        case .update: return "UPDATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackSetOperationType(rawValue: rawValue) ?? StackSetOperationType.sdkUnknown(rawValue)
    }
}

public enum Status {
    case available
    case creating
    case failed
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .available,
            .creating,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .creating: return "CREATING"
        case .failed: return "FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Information about a tag. A tag is a key-value pair. Tags are propagated
///          to the resources created when provisioning a product.</p>
public struct Tag: Equatable {
    /// <p>The tag key.</p>
    public let key: String?
    /// <p>The value for this key.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagOptionDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case active = "Active"
        case id = "Id"
        case key = "Key"
        case owner = "Owner"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .active)
        active = activeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension TagOptionDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagOptionDetail(active: \(String(describing: active)), id: \(String(describing: id)), key: \(String(describing: key)), owner: \(String(describing: owner)), value: \(String(describing: value)))"}
}

/// <p>Information about a TagOption.</p>
public struct TagOptionDetail: Equatable {
    /// <p>The TagOption active state.</p>
    public let active: Bool?
    /// <p>The TagOption identifier.</p>
    public let id: String?
    /// <p>The TagOption key.</p>
    public let key: String?
    /// <p>The AWS account Id of the owner account that created the TagOption.</p>
    public let owner: String?
    /// <p>The TagOption value.</p>
    public let value: String?

    public init (
        active: Bool? = nil,
        id: String? = nil,
        key: String? = nil,
        owner: String? = nil,
        value: String? = nil
    )
    {
        self.active = active
        self.id = id
        self.key = key
        self.owner = owner
        self.value = value
    }
}

extension TagOptionNotMigratedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagOptionNotMigratedException(message: \(String(describing: message)))"}
}

extension TagOptionNotMigratedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagOptionNotMigratedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An operation requiring TagOptions failed because the TagOptions migration process has
///          not been performed for this account. Please use the AWS console to perform the migration
///          process before retrying the operation.</p>
public struct TagOptionNotMigratedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagOptionNotMigratedExceptionBody: Equatable {
    public let message: String?
}

extension TagOptionNotMigratedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagOptionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for tagoptionvalues0 in values {
                try valuesContainer.encode(tagoptionvalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension TagOptionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagOptionSummary(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>Summary information about a TagOption.</p>
public struct TagOptionSummary: Equatable {
    /// <p>The TagOption key.</p>
    public let key: String?
    /// <p>The TagOption value.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

public struct TerminateProvisionedProductInputBodyMiddleware: Middleware {
    public let id: String = "TerminateProvisionedProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateProvisionedProductInput>
    public typealias MOutput = OperationOutput<TerminateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateProvisionedProductOutputError>
}

extension TerminateProvisionedProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateProvisionedProductInput(acceptLanguage: \(String(describing: acceptLanguage)), ignoreErrors: \(String(describing: ignoreErrors)), provisionedProductId: \(String(describing: provisionedProductId)), provisionedProductName: \(String(describing: provisionedProductName)), retainPhysicalResources: \(String(describing: retainPhysicalResources)), terminateToken: \(String(describing: terminateToken)))"}
}

extension TerminateProvisionedProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case ignoreErrors = "IgnoreErrors"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case retainPhysicalResources = "RetainPhysicalResources"
        case terminateToken = "TerminateToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if ignoreErrors != false {
            try encodeContainer.encode(ignoreErrors, forKey: .ignoreErrors)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if retainPhysicalResources != false {
            try encodeContainer.encode(retainPhysicalResources, forKey: .retainPhysicalResources)
        }
        if let terminateToken = terminateToken {
            try encodeContainer.encode(terminateToken, forKey: .terminateToken)
        }
    }
}

public struct TerminateProvisionedProductInputHeadersMiddleware: Middleware {
    public let id: String = "TerminateProvisionedProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateProvisionedProductInput>
    public typealias MOutput = OperationOutput<TerminateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateProvisionedProductOutputError>
}

public struct TerminateProvisionedProductInputQueryItemMiddleware: Middleware {
    public let id: String = "TerminateProvisionedProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateProvisionedProductInput>
    public typealias MOutput = OperationOutput<TerminateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateProvisionedProductOutputError>
}

public struct TerminateProvisionedProductInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>If set to true, AWS Service Catalog stops managing the specified provisioned product even
    ///          if it cannot delete the underlying resources.</p>
    public let ignoreErrors: Bool
    /// <p>The identifier of the provisioned product. You cannot specify both
    ///          <code>ProvisionedProductName</code> and <code>ProvisionedProductId</code>.</p>
    public let provisionedProductId: String?
    /// <p>The name of the provisioned product. You cannot specify both
    ///          <code>ProvisionedProductName</code> and <code>ProvisionedProductId</code>.</p>
    public let provisionedProductName: String?
    /// <p>When this boolean parameter is set to true, the <code>TerminateProvisionedProduct</code> API deletes
    ///          the Service Catalog provisioned product. However, it does not remove the CloudFormation
    ///          stack, stack set, or the underlying resources of the deleted provisioned product. The
    ///          default value is false.</p>
    public let retainPhysicalResources: Bool
    /// <p>An idempotency token that uniquely identifies the termination request. This token is
    ///          only valid during the termination process. After the provisioned product is terminated,
    ///          subsequent requests to terminate the same provisioned product always return
    ///          <b>ResourceNotFound</b>.</p>
    public var terminateToken: String?

    public init (
        acceptLanguage: String? = nil,
        ignoreErrors: Bool = false,
        provisionedProductId: String? = nil,
        provisionedProductName: String? = nil,
        retainPhysicalResources: Bool = false,
        terminateToken: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.ignoreErrors = ignoreErrors
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
        self.retainPhysicalResources = retainPhysicalResources
        self.terminateToken = terminateToken
    }
}

struct TerminateProvisionedProductInputBody: Equatable {
    public let provisionedProductName: String?
    public let provisionedProductId: String?
    public let terminateToken: String?
    public let ignoreErrors: Bool
    public let acceptLanguage: String?
    public let retainPhysicalResources: Bool
}

extension TerminateProvisionedProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case ignoreErrors = "IgnoreErrors"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case retainPhysicalResources = "RetainPhysicalResources"
        case terminateToken = "TerminateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let terminateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .terminateToken)
        terminateToken = terminateTokenDecoded
        let ignoreErrorsDecoded = try containerValues.decode(Bool.self, forKey: .ignoreErrors)
        ignoreErrors = ignoreErrorsDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let retainPhysicalResourcesDecoded = try containerValues.decode(Bool.self, forKey: .retainPhysicalResources)
        retainPhysicalResources = retainPhysicalResourcesDecoded
    }
}

extension TerminateProvisionedProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateProvisionedProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TerminateProvisionedProductOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateProvisionedProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateProvisionedProductOutputResponse(recordDetail: \(String(describing: recordDetail)))"}
}

extension TerminateProvisionedProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TerminateProvisionedProductOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct TerminateProvisionedProductOutputResponse: Equatable {
    /// <p>Information about the result of this request.</p>
    public let recordDetail: RecordDetail?

    public init (
        recordDetail: RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct TerminateProvisionedProductOutputResponseBody: Equatable {
    public let recordDetail: RecordDetail?
}

extension TerminateProvisionedProductOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

public struct UpdateConstraintInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConstraintInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConstraintInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConstraintInput>
    public typealias MOutput = OperationOutput<UpdateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConstraintOutputError>
}

extension UpdateConstraintInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConstraintInput(acceptLanguage: \(String(describing: acceptLanguage)), description: \(String(describing: description)), id: \(String(describing: id)), parameters: \(String(describing: parameters)))"}
}

extension UpdateConstraintInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case id = "Id"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
    }
}

public struct UpdateConstraintInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConstraintInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConstraintInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConstraintInput>
    public typealias MOutput = OperationOutput<UpdateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConstraintOutputError>
}

public struct UpdateConstraintInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConstraintInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConstraintInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConstraintInput>
    public typealias MOutput = OperationOutput<UpdateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConstraintOutputError>
}

public struct UpdateConstraintInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The updated description of the constraint.</p>
    public let description: String?
    /// <p>The identifier of the constraint.</p>
    public let id: String?
    /// <p>The constraint parameters, in JSON format. The syntax depends on the constraint type as follows:</p>
    ///          <dl>
    ///             <dt>LAUNCH</dt>
    ///             <dd>
    ///                <p>You are required to specify either the <code>RoleArn</code> or the <code>LocalRoleName</code> but can't use both.</p>
    ///                <p>Specify the <code>RoleArn</code> property as follows:</p>
    ///                <p>
    ///                   <code>{"RoleArn" : "arn:aws:iam::123456789012:role/LaunchRole"}</code>
    ///                </p>
    ///                <p>Specify the <code>LocalRoleName</code> property as follows:</p>
    ///                <p>
    ///                   <code>{"LocalRoleName": "SCBasicLaunchRole"}</code>
    ///                </p>
    ///                <p>If you specify the <code>LocalRoleName</code> property, when an account uses the launch constraint, the IAM role with that name in the account will be used. This allows launch-role constraints to be
    ///                   account-agnostic so the administrator can create fewer resources per shared account.</p>
    ///                <note>
    ///                   <p>The given role name must exist in the account used to create the launch constraint and the account of the user who launches a product with this launch constraint.</p>
    ///                </note>
    ///                <p>You cannot have both a <code>LAUNCH</code> and a <code>STACKSET</code> constraint.</p>
    ///                <p>You also cannot have more than one <code>LAUNCH</code> constraint on a product and portfolio.</p>
    ///             </dd>
    ///             <dt>NOTIFICATION</dt>
    ///             <dd>
    ///                <p>Specify the <code>NotificationArns</code> property as follows:</p>
    ///                <p>
    ///                   <code>{"NotificationArns" : ["arn:aws:sns:us-east-1:123456789012:Topic"]}</code>
    ///                </p>
    ///             </dd>
    ///             <dt>RESOURCE_UPDATE</dt>
    ///             <dd>
    ///                <p>Specify the <code>TagUpdatesOnProvisionedProduct</code> property as follows:</p>
    ///                <p>
    ///                   <code>{"Version":"2.0","Properties":{"TagUpdateOnProvisionedProduct":"String"}}</code>
    ///                </p>
    ///                <p>The <code>TagUpdatesOnProvisionedProduct</code> property accepts a string value of <code>ALLOWED</code> or <code>NOT_ALLOWED</code>.</p>
    ///             </dd>
    ///             <dt>STACKSET</dt>
    ///             <dd>
    ///                <p>Specify the <code>Parameters</code> property as follows:</p>
    ///                <p>
    ///                   <code>{"Version": "String", "Properties": {"AccountList": [ "String" ], "RegionList": [ "String" ], "AdminRole": "String", "ExecutionRole": "String"}}</code>
    ///                </p>
    ///                <p>You cannot have both a <code>LAUNCH</code> and a <code>STACKSET</code> constraint.</p>
    ///                <p>You also cannot have more than one <code>STACKSET</code> constraint on a product and portfolio.</p>
    ///                <p>Products with a <code>STACKSET</code> constraint will launch an AWS CloudFormation stack set.</p>
    ///             </dd>
    ///             <dt>TEMPLATE</dt>
    ///             <dd>
    ///                <p>Specify the <code>Rules</code> property. For more information, see
    ///                   <a href="http://docs.aws.amazon.com/servicecatalog/latest/adminguide/reference-template_constraint_rules.html">Template Constraint Rules</a>.</p>
    ///             </dd>
    ///          </dl>
    public let parameters: String?

    public init (
        acceptLanguage: String? = nil,
        description: String? = nil,
        id: String? = nil,
        parameters: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.id = id
        self.parameters = parameters
    }
}

struct UpdateConstraintInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
    public let description: String?
    public let parameters: String?
}

extension UpdateConstraintInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case id = "Id"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension UpdateConstraintOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConstraintOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConstraintOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConstraintOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConstraintOutputResponse(constraintDetail: \(String(describing: constraintDetail)), constraintParameters: \(String(describing: constraintParameters)), status: \(String(describing: status)))"}
}

extension UpdateConstraintOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateConstraintOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.constraintDetail = output.constraintDetail
            self.constraintParameters = output.constraintParameters
            self.status = output.status
        } else {
            self.constraintDetail = nil
            self.constraintParameters = nil
            self.status = nil
        }
    }
}

public struct UpdateConstraintOutputResponse: Equatable {
    /// <p>Information about the constraint.</p>
    public let constraintDetail: ConstraintDetail?
    /// <p>The constraint parameters.</p>
    public let constraintParameters: String?
    /// <p>The status of the current request.</p>
    public let status: Status?

    public init (
        constraintDetail: ConstraintDetail? = nil,
        constraintParameters: String? = nil,
        status: Status? = nil
    )
    {
        self.constraintDetail = constraintDetail
        self.constraintParameters = constraintParameters
        self.status = status
    }
}

struct UpdateConstraintOutputResponseBody: Equatable {
    public let constraintDetail: ConstraintDetail?
    public let constraintParameters: String?
    public let status: Status?
}

extension UpdateConstraintOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case constraintDetail = "ConstraintDetail"
        case constraintParameters = "ConstraintParameters"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDetailDecoded = try containerValues.decodeIfPresent(ConstraintDetail.self, forKey: .constraintDetail)
        constraintDetail = constraintDetailDecoded
        let constraintParametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .constraintParameters)
        constraintParameters = constraintParametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdatePortfolioInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePortfolioInput>
    public typealias MOutput = OperationOutput<UpdatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePortfolioOutputError>
}

extension UpdatePortfolioInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePortfolioInput(acceptLanguage: \(String(describing: acceptLanguage)), addTags: \(String(describing: addTags)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), id: \(String(describing: id)), providerName: \(String(describing: providerName)), removeTags: \(String(describing: removeTags)))"}
}

extension UpdatePortfolioInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case addTags = "AddTags"
        case description = "Description"
        case displayName = "DisplayName"
        case id = "Id"
        case providerName = "ProviderName"
        case removeTags = "RemoveTags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let addTags = addTags {
            var addTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addTags)
            for addtags0 in addTags {
                try addTagsContainer.encode(addtags0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let removeTags = removeTags {
            var removeTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeTags)
            for tagkeys0 in removeTags {
                try removeTagsContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UpdatePortfolioInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePortfolioInput>
    public typealias MOutput = OperationOutput<UpdatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePortfolioOutputError>
}

public struct UpdatePortfolioInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePortfolioInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePortfolioInput>
    public typealias MOutput = OperationOutput<UpdatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePortfolioOutputError>
}

public struct UpdatePortfolioInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The tags to add.</p>
    public let addTags: [Tag]?
    /// <p>The updated description of the portfolio.</p>
    public let description: String?
    /// <p>The name to use for display purposes.</p>
    public let displayName: String?
    /// <p>The portfolio identifier.</p>
    public let id: String?
    /// <p>The updated name of the portfolio provider.</p>
    public let providerName: String?
    /// <p>The tags to remove.</p>
    public let removeTags: [String]?

    public init (
        acceptLanguage: String? = nil,
        addTags: [Tag]? = nil,
        description: String? = nil,
        displayName: String? = nil,
        id: String? = nil,
        providerName: String? = nil,
        removeTags: [String]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.addTags = addTags
        self.description = description
        self.displayName = displayName
        self.id = id
        self.providerName = providerName
        self.removeTags = removeTags
    }
}

struct UpdatePortfolioInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
    public let displayName: String?
    public let description: String?
    public let providerName: String?
    public let addTags: [Tag]?
    public let removeTags: [String]?
}

extension UpdatePortfolioInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case addTags = "AddTags"
        case description = "Description"
        case displayName = "DisplayName"
        case id = "Id"
        case providerName = "ProviderName"
        case removeTags = "RemoveTags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let addTagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .addTags)
        var addTagsDecoded0:[Tag]? = nil
        if let addTagsContainer = addTagsContainer {
            addTagsDecoded0 = [Tag]()
            for structure0 in addTagsContainer {
                if let structure0 = structure0 {
                    addTagsDecoded0?.append(structure0)
                }
            }
        }
        addTags = addTagsDecoded0
        let removeTagsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .removeTags)
        var removeTagsDecoded0:[String]? = nil
        if let removeTagsContainer = removeTagsContainer {
            removeTagsDecoded0 = [String]()
            for string0 in removeTagsContainer {
                if let string0 = string0 {
                    removeTagsDecoded0?.append(string0)
                }
            }
        }
        removeTags = removeTagsDecoded0
    }
}

extension UpdatePortfolioOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePortfolioOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePortfolioOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePortfolioOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePortfolioOutputResponse(portfolioDetail: \(String(describing: portfolioDetail)), tags: \(String(describing: tags)))"}
}

extension UpdatePortfolioOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePortfolioOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.portfolioDetail = output.portfolioDetail
            self.tags = output.tags
        } else {
            self.portfolioDetail = nil
            self.tags = nil
        }
    }
}

public struct UpdatePortfolioOutputResponse: Equatable {
    /// <p>Information about the portfolio.</p>
    public let portfolioDetail: PortfolioDetail?
    /// <p>Information about the tags associated with the portfolio.</p>
    public let tags: [Tag]?

    public init (
        portfolioDetail: PortfolioDetail? = nil,
        tags: [Tag]? = nil
    )
    {
        self.portfolioDetail = portfolioDetail
        self.tags = tags
    }
}

struct UpdatePortfolioOutputResponseBody: Equatable {
    public let portfolioDetail: PortfolioDetail?
    public let tags: [Tag]?
}

extension UpdatePortfolioOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case portfolioDetail = "PortfolioDetail"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailDecoded = try containerValues.decodeIfPresent(PortfolioDetail.self, forKey: .portfolioDetail)
        portfolioDetail = portfolioDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdatePortfolioShareInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePortfolioShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePortfolioShareInput>
    public typealias MOutput = OperationOutput<UpdatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePortfolioShareOutputError>
}

extension UpdatePortfolioShareInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePortfolioShareInput(acceptLanguage: \(String(describing: acceptLanguage)), accountId: \(String(describing: accountId)), organizationNode: \(String(describing: organizationNode)), portfolioId: \(String(describing: portfolioId)), shareTagOptions: \(String(describing: shareTagOptions)))"}
}

extension UpdatePortfolioShareInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
        case shareTagOptions = "ShareTagOptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let organizationNode = organizationNode {
            try encodeContainer.encode(organizationNode, forKey: .organizationNode)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let shareTagOptions = shareTagOptions {
            try encodeContainer.encode(shareTagOptions, forKey: .shareTagOptions)
        }
    }
}

public struct UpdatePortfolioShareInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePortfolioShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePortfolioShareInput>
    public typealias MOutput = OperationOutput<UpdatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePortfolioShareOutputError>
}

public struct UpdatePortfolioShareInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePortfolioShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePortfolioShareInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePortfolioShareInput>
    public typealias MOutput = OperationOutput<UpdatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePortfolioShareOutputError>
}

public struct UpdatePortfolioShareInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The AWS Account Id of the recipient account. This field is required when updating an external account to account type share.</p>
    public let accountId: String?
    /// <p>Information about the organization node.</p>
    public let organizationNode: OrganizationNode?
    /// <p>The unique identifier of the portfolio for which the share will be updated.</p>
    public let portfolioId: String?
    /// <p>A flag to enable or disable TagOptions sharing for the portfolio share. If this field is not provided, the current state of TagOptions sharing on the portfolio share will not be modified.</p>
    public let shareTagOptions: Bool?

    public init (
        acceptLanguage: String? = nil,
        accountId: String? = nil,
        organizationNode: OrganizationNode? = nil,
        portfolioId: String? = nil,
        shareTagOptions: Bool? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accountId = accountId
        self.organizationNode = organizationNode
        self.portfolioId = portfolioId
        self.shareTagOptions = shareTagOptions
    }
}

struct UpdatePortfolioShareInputBody: Equatable {
    public let acceptLanguage: String?
    public let portfolioId: String?
    public let accountId: String?
    public let organizationNode: OrganizationNode?
    public let shareTagOptions: Bool?
}

extension UpdatePortfolioShareInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
        case shareTagOptions = "ShareTagOptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationNodeDecoded = try containerValues.decodeIfPresent(OrganizationNode.self, forKey: .organizationNode)
        organizationNode = organizationNodeDecoded
        let shareTagOptionsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .shareTagOptions)
        shareTagOptions = shareTagOptionsDecoded
    }
}

extension UpdatePortfolioShareOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePortfolioShareOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePortfolioShareOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePortfolioShareOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePortfolioShareOutputResponse(portfolioShareToken: \(String(describing: portfolioShareToken)), status: \(String(describing: status)))"}
}

extension UpdatePortfolioShareOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePortfolioShareOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.portfolioShareToken = output.portfolioShareToken
            self.status = output.status
        } else {
            self.portfolioShareToken = nil
            self.status = nil
        }
    }
}

public struct UpdatePortfolioShareOutputResponse: Equatable {
    /// <p>The token that tracks the status of the <code>UpdatePortfolioShare</code> operation for external account to account or  organizational type sharing.</p>
    public let portfolioShareToken: String?
    /// <p>The status of <code>UpdatePortfolioShare</code> operation.
    ///          You can also obtain the operation status using <code>DescribePortfolioShareStatus</code> API.
    ///       </p>
    public let status: ShareStatus?

    public init (
        portfolioShareToken: String? = nil,
        status: ShareStatus? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
        self.status = status
    }
}

struct UpdatePortfolioShareOutputResponseBody: Equatable {
    public let portfolioShareToken: String?
    public let status: ShareStatus?
}

extension UpdatePortfolioShareOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ShareStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateProductInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProductInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProductInput>
    public typealias MOutput = OperationOutput<UpdateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProductOutputError>
}

extension UpdateProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProductInput(acceptLanguage: \(String(describing: acceptLanguage)), addTags: \(String(describing: addTags)), description: \(String(describing: description)), distributor: \(String(describing: distributor)), id: \(String(describing: id)), name: \(String(describing: name)), owner: \(String(describing: owner)), removeTags: \(String(describing: removeTags)), supportDescription: \(String(describing: supportDescription)), supportEmail: \(String(describing: supportEmail)), supportUrl: \(String(describing: supportUrl)))"}
}

extension UpdateProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case addTags = "AddTags"
        case description = "Description"
        case distributor = "Distributor"
        case id = "Id"
        case name = "Name"
        case owner = "Owner"
        case removeTags = "RemoveTags"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let addTags = addTags {
            var addTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addTags)
            for addtags0 in addTags {
                try addTagsContainer.encode(addtags0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributor = distributor {
            try encodeContainer.encode(distributor, forKey: .distributor)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let removeTags = removeTags {
            var removeTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeTags)
            for tagkeys0 in removeTags {
                try removeTagsContainer.encode(tagkeys0)
            }
        }
        if let supportDescription = supportDescription {
            try encodeContainer.encode(supportDescription, forKey: .supportDescription)
        }
        if let supportEmail = supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportUrl = supportUrl {
            try encodeContainer.encode(supportUrl, forKey: .supportUrl)
        }
    }
}

public struct UpdateProductInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProductInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProductInput>
    public typealias MOutput = OperationOutput<UpdateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProductOutputError>
}

public struct UpdateProductInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProductInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProductInput>
    public typealias MOutput = OperationOutput<UpdateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProductOutputError>
}

public struct UpdateProductInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The tags to add to the product.</p>
    public let addTags: [Tag]?
    /// <p>The updated description of the product.</p>
    public let description: String?
    /// <p>The updated distributor of the product.</p>
    public let distributor: String?
    /// <p>The product identifier.</p>
    public let id: String?
    /// <p>The updated product name.</p>
    public let name: String?
    /// <p>The updated owner of the product.</p>
    public let owner: String?
    /// <p>The tags to remove from the product.</p>
    public let removeTags: [String]?
    /// <p>The updated support description for the product.</p>
    public let supportDescription: String?
    /// <p>The updated support email for the product.</p>
    public let supportEmail: String?
    /// <p>The updated support URL for the product.</p>
    public let supportUrl: String?

    public init (
        acceptLanguage: String? = nil,
        addTags: [Tag]? = nil,
        description: String? = nil,
        distributor: String? = nil,
        id: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        removeTags: [String]? = nil,
        supportDescription: String? = nil,
        supportEmail: String? = nil,
        supportUrl: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.addTags = addTags
        self.description = description
        self.distributor = distributor
        self.id = id
        self.name = name
        self.owner = owner
        self.removeTags = removeTags
        self.supportDescription = supportDescription
        self.supportEmail = supportEmail
        self.supportUrl = supportUrl
    }
}

struct UpdateProductInputBody: Equatable {
    public let acceptLanguage: String?
    public let id: String?
    public let name: String?
    public let owner: String?
    public let description: String?
    public let distributor: String?
    public let supportDescription: String?
    public let supportEmail: String?
    public let supportUrl: String?
    public let addTags: [Tag]?
    public let removeTags: [String]?
}

extension UpdateProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case addTags = "AddTags"
        case description = "Description"
        case distributor = "Distributor"
        case id = "Id"
        case name = "Name"
        case owner = "Owner"
        case removeTags = "RemoveTags"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let distributorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributor)
        distributor = distributorDecoded
        let supportDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportDescription)
        supportDescription = supportDescriptionDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .supportUrl)
        supportUrl = supportUrlDecoded
        let addTagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .addTags)
        var addTagsDecoded0:[Tag]? = nil
        if let addTagsContainer = addTagsContainer {
            addTagsDecoded0 = [Tag]()
            for structure0 in addTagsContainer {
                if let structure0 = structure0 {
                    addTagsDecoded0?.append(structure0)
                }
            }
        }
        addTags = addTagsDecoded0
        let removeTagsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .removeTags)
        var removeTagsDecoded0:[String]? = nil
        if let removeTagsContainer = removeTagsContainer {
            removeTagsDecoded0 = [String]()
            for string0 in removeTagsContainer {
                if let string0 = string0 {
                    removeTagsDecoded0?.append(string0)
                }
            }
        }
        removeTags = removeTagsDecoded0
    }
}

extension UpdateProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProductOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProductOutputResponse(productViewDetail: \(String(describing: productViewDetail)), tags: \(String(describing: tags)))"}
}

extension UpdateProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateProductOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.productViewDetail = output.productViewDetail
            self.tags = output.tags
        } else {
            self.productViewDetail = nil
            self.tags = nil
        }
    }
}

public struct UpdateProductOutputResponse: Equatable {
    /// <p>Information about the product view.</p>
    public let productViewDetail: ProductViewDetail?
    /// <p>Information about the tags associated with the product.</p>
    public let tags: [Tag]?

    public init (
        productViewDetail: ProductViewDetail? = nil,
        tags: [Tag]? = nil
    )
    {
        self.productViewDetail = productViewDetail
        self.tags = tags
    }
}

struct UpdateProductOutputResponseBody: Equatable {
    public let productViewDetail: ProductViewDetail?
    public let tags: [Tag]?
}

extension UpdateProductOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case productViewDetail = "ProductViewDetail"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewDetailDecoded = try containerValues.decodeIfPresent(ProductViewDetail.self, forKey: .productViewDetail)
        productViewDetail = productViewDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateProvisionedProductInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProvisionedProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProvisionedProductInput>
    public typealias MOutput = OperationOutput<UpdateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProvisionedProductOutputError>
}

extension UpdateProvisionedProductInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProvisionedProductInput(acceptLanguage: \(String(describing: acceptLanguage)), pathId: \(String(describing: pathId)), pathName: \(String(describing: pathName)), productId: \(String(describing: productId)), productName: \(String(describing: productName)), provisionedProductId: \(String(describing: provisionedProductId)), provisionedProductName: \(String(describing: provisionedProductName)), provisioningArtifactId: \(String(describing: provisioningArtifactId)), provisioningArtifactName: \(String(describing: provisioningArtifactName)), provisioningParameters: \(String(describing: provisioningParameters)), provisioningPreferences: \(String(describing: provisioningPreferences)), tags: \(String(describing: tags)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateProvisionedProductInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case provisioningParameters = "ProvisioningParameters"
        case provisioningPreferences = "ProvisioningPreferences"
        case tags = "Tags"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pathId = pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let pathName = pathName {
            try encodeContainer.encode(pathName, forKey: .pathName)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
        if let provisioningParameters = provisioningParameters {
            var provisioningParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .provisioningParameters)
            for updateprovisioningparameters0 in provisioningParameters {
                try provisioningParametersContainer.encode(updateprovisioningparameters0)
            }
        }
        if let provisioningPreferences = provisioningPreferences {
            try encodeContainer.encode(provisioningPreferences, forKey: .provisioningPreferences)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let updateToken = updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }
}

public struct UpdateProvisionedProductInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProvisionedProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProvisionedProductInput>
    public typealias MOutput = OperationOutput<UpdateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProvisionedProductOutputError>
}

public struct UpdateProvisionedProductInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProvisionedProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProvisionedProductInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProvisionedProductInput>
    public typealias MOutput = OperationOutput<UpdateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProvisionedProductOutputError>
}

public struct UpdateProvisionedProductInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The path identifier. This value is optional if the product
    ///          has a default path, and required if the product has more than one path. You must provide the name or ID, but not both.</p>
    public let pathId: String?
    /// <p>The name of the path. You must provide the name or ID, but not both.</p>
    public let pathName: String?
    /// <p>The identifier of the product. You must provide the name or ID, but not both.</p>
    public let productId: String?
    /// <p>The name of the product. You must provide the name or ID, but not both.</p>
    public let productName: String?
    /// <p>The identifier of the provisioned product. You must provide the name or ID, but not both.</p>
    public let provisionedProductId: String?
    /// <p>The name of the provisioned product. You cannot specify both
    ///          <code>ProvisionedProductName</code> and <code>ProvisionedProductId</code>.</p>
    public let provisionedProductName: String?
    /// <p>The identifier of the provisioning artifact.</p>
    public let provisioningArtifactId: String?
    /// <p>The name of the provisioning artifact. You must provide the name or ID, but not both.</p>
    public let provisioningArtifactName: String?
    /// <p>The new parameters.</p>
    public let provisioningParameters: [UpdateProvisioningParameter]?
    /// <p>An object that contains information about the provisioning preferences for a stack set.</p>
    public let provisioningPreferences: UpdateProvisioningPreferences?
    /// <p>One or more tags. Requires the product to have <code>RESOURCE_UPDATE</code> constraint with <code>TagUpdatesOnProvisionedProduct</code> set to <code>ALLOWED</code> to allow tag updates.</p>
    public let tags: [Tag]?
    /// <p>The idempotency token that uniquely identifies the provisioning update request.</p>
    public var updateToken: String?

    public init (
        acceptLanguage: String? = nil,
        pathId: String? = nil,
        pathName: String? = nil,
        productId: String? = nil,
        productName: String? = nil,
        provisionedProductId: String? = nil,
        provisionedProductName: String? = nil,
        provisioningArtifactId: String? = nil,
        provisioningArtifactName: String? = nil,
        provisioningParameters: [UpdateProvisioningParameter]? = nil,
        provisioningPreferences: UpdateProvisioningPreferences? = nil,
        tags: [Tag]? = nil,
        updateToken: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pathId = pathId
        self.pathName = pathName
        self.productId = productId
        self.productName = productName
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.provisioningParameters = provisioningParameters
        self.provisioningPreferences = provisioningPreferences
        self.tags = tags
        self.updateToken = updateToken
    }
}

struct UpdateProvisionedProductInputBody: Equatable {
    public let acceptLanguage: String?
    public let provisionedProductName: String?
    public let provisionedProductId: String?
    public let productId: String?
    public let productName: String?
    public let provisioningArtifactId: String?
    public let provisioningArtifactName: String?
    public let pathId: String?
    public let pathName: String?
    public let provisioningParameters: [UpdateProvisioningParameter]?
    public let provisioningPreferences: UpdateProvisioningPreferences?
    public let tags: [Tag]?
    public let updateToken: String?
}

extension UpdateProvisionedProductInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case provisioningParameters = "ProvisioningParameters"
        case provisioningPreferences = "ProvisioningPreferences"
        case tags = "Tags"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productName)
        productName = productNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let pathNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathName)
        pathName = pathNameDecoded
        let provisioningParametersContainer = try containerValues.decodeIfPresent([UpdateProvisioningParameter?].self, forKey: .provisioningParameters)
        var provisioningParametersDecoded0:[UpdateProvisioningParameter]? = nil
        if let provisioningParametersContainer = provisioningParametersContainer {
            provisioningParametersDecoded0 = [UpdateProvisioningParameter]()
            for structure0 in provisioningParametersContainer {
                if let structure0 = structure0 {
                    provisioningParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningParameters = provisioningParametersDecoded0
        let provisioningPreferencesDecoded = try containerValues.decodeIfPresent(UpdateProvisioningPreferences.self, forKey: .provisioningPreferences)
        provisioningPreferences = provisioningPreferencesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
    }
}

extension UpdateProvisionedProductOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProvisionedProductOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProvisionedProductOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProvisionedProductOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProvisionedProductOutputResponse(recordDetail: \(String(describing: recordDetail)))"}
}

extension UpdateProvisionedProductOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateProvisionedProductOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct UpdateProvisionedProductOutputResponse: Equatable {
    /// <p>Information about the result of the request.</p>
    public let recordDetail: RecordDetail?

    public init (
        recordDetail: RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct UpdateProvisionedProductOutputResponseBody: Equatable {
    public let recordDetail: RecordDetail?
}

extension UpdateProvisionedProductOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

public struct UpdateProvisionedProductPropertiesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProvisionedProductPropertiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProvisionedProductPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProvisionedProductPropertiesInput>
    public typealias MOutput = OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProvisionedProductPropertiesOutputError>
}

extension UpdateProvisionedProductPropertiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProvisionedProductPropertiesInput(acceptLanguage: \(String(describing: acceptLanguage)), idempotencyToken: \(String(describing: idempotencyToken)), provisionedProductId: \(String(describing: provisionedProductId)), provisionedProductProperties: \(String(describing: provisionedProductProperties)))"}
}

extension UpdateProvisionedProductPropertiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductProperties = "ProvisionedProductProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductProperties = provisionedProductProperties {
            var provisionedProductPropertiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .provisionedProductProperties)
            for (dictKey0, provisionedproductproperties0) in provisionedProductProperties {
                try provisionedProductPropertiesContainer.encode(provisionedproductproperties0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateProvisionedProductPropertiesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProvisionedProductPropertiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProvisionedProductPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProvisionedProductPropertiesInput>
    public typealias MOutput = OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProvisionedProductPropertiesOutputError>
}

public struct UpdateProvisionedProductPropertiesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProvisionedProductPropertiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProvisionedProductPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProvisionedProductPropertiesInput>
    public typealias MOutput = OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProvisionedProductPropertiesOutputError>
}

public struct UpdateProvisionedProductPropertiesInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>The idempotency token that uniquely identifies the provisioning product update request.</p>
    public var idempotencyToken: String?
    /// <p>The identifier of the provisioned product.</p>
    public let provisionedProductId: String?
    /// <p>A map that contains the provisioned product properties to be updated.</p>
    ///          <p>The <code>LAUNCH_ROLE</code> key accepts role ARNs. This key allows an
    ///          administrator to call <code>UpdateProvisionedProductProperties</code> to update the launch
    ///          role that is associated with a provisioned product. This role is used when an end user
    ///          calls a provisioning operation such as <code>UpdateProvisionedProduct</code>,
    ///             <code>TerminateProvisionedProduct</code>, or
    ///             <code>ExecuteProvisionedProductServiceAction</code>. Only a role ARN is valid. A user ARN is invalid. </p>
    ///
    ///          <p>The <code>OWNER</code> key accepts user ARNs and role ARNs. The owner is the user
    ///          that has permission to see, update, terminate, and execute service actions in the
    ///          provisioned product.</p>
    ///          <p>The administrator can change the owner of a provisioned product to another IAM user within the same account. Both end user owners and
    ///          administrators can see ownership history of the provisioned product using the <code>ListRecordHistory</code> API. The new owner can
    ///       describe all past records for the provisioned product using the <code>DescribeRecord</code> API. The previous owner can no longer use <code>DescribeRecord</code>,
    ///       but can still see the product's history from when he was an owner using <code>ListRecordHistory</code>.</p>
    ///          <p>If a provisioned product ownership is assigned to an end user, they can see and perform any action through the API or
    ///          Service Catalog console such as update, terminate, and execute service actions.
    ///          If an end user provisions a product and the owner is updated to someone else, they will no longer be able to see or perform any actions through
    ///          API or the Service Catalog console on that provisioned product.</p>
    public let provisionedProductProperties: [String:String]?

    public init (
        acceptLanguage: String? = nil,
        idempotencyToken: String? = nil,
        provisionedProductId: String? = nil,
        provisionedProductProperties: [String:String]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.provisionedProductId = provisionedProductId
        self.provisionedProductProperties = provisionedProductProperties
    }
}

struct UpdateProvisionedProductPropertiesInputBody: Equatable {
    public let acceptLanguage: String?
    public let provisionedProductId: String?
    public let provisionedProductProperties: [String:String]?
    public let idempotencyToken: String?
}

extension UpdateProvisionedProductPropertiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductProperties = "ProvisionedProductProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let provisionedProductPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .provisionedProductProperties)
        var provisionedProductPropertiesDecoded0: [String:String]? = nil
        if let provisionedProductPropertiesContainer = provisionedProductPropertiesContainer {
            provisionedProductPropertiesDecoded0 = [String:String]()
            for (key0, propertyvalue0) in provisionedProductPropertiesContainer {
                if let propertyvalue0 = propertyvalue0 {
                    provisionedProductPropertiesDecoded0?[key0] = propertyvalue0
                }
            }
        }
        provisionedProductProperties = provisionedProductPropertiesDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension UpdateProvisionedProductPropertiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProvisionedProductPropertiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProvisionedProductPropertiesOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProvisionedProductPropertiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProvisionedProductPropertiesOutputResponse(provisionedProductId: \(String(describing: provisionedProductId)), provisionedProductProperties: \(String(describing: provisionedProductProperties)), recordId: \(String(describing: recordId)), status: \(String(describing: status)))"}
}

extension UpdateProvisionedProductPropertiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateProvisionedProductPropertiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.provisionedProductId = output.provisionedProductId
            self.provisionedProductProperties = output.provisionedProductProperties
            self.recordId = output.recordId
            self.status = output.status
        } else {
            self.provisionedProductId = nil
            self.provisionedProductProperties = nil
            self.recordId = nil
            self.status = nil
        }
    }
}

public struct UpdateProvisionedProductPropertiesOutputResponse: Equatable {
    /// <p>The provisioned product identifier.</p>
    public let provisionedProductId: String?
    /// <p>A map that contains the properties updated.</p>
    public let provisionedProductProperties: [String:String]?
    /// <p>The identifier of the record.</p>
    public let recordId: String?
    /// <p>The status of the request.</p>
    public let status: RecordStatus?

    public init (
        provisionedProductId: String? = nil,
        provisionedProductProperties: [String:String]? = nil,
        recordId: String? = nil,
        status: RecordStatus? = nil
    )
    {
        self.provisionedProductId = provisionedProductId
        self.provisionedProductProperties = provisionedProductProperties
        self.recordId = recordId
        self.status = status
    }
}

struct UpdateProvisionedProductPropertiesOutputResponseBody: Equatable {
    public let provisionedProductId: String?
    public let provisionedProductProperties: [String:String]?
    public let recordId: String?
    public let status: RecordStatus?
}

extension UpdateProvisionedProductPropertiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductProperties = "ProvisionedProductProperties"
        case recordId = "RecordId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let provisionedProductPropertiesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .provisionedProductProperties)
        var provisionedProductPropertiesDecoded0: [String:String]? = nil
        if let provisionedProductPropertiesContainer = provisionedProductPropertiesContainer {
            provisionedProductPropertiesDecoded0 = [String:String]()
            for (key0, propertyvalue0) in provisionedProductPropertiesContainer {
                if let propertyvalue0 = propertyvalue0 {
                    provisionedProductPropertiesDecoded0?[key0] = propertyvalue0
                }
            }
        }
        provisionedProductProperties = provisionedProductPropertiesDecoded0
        let recordIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordId)
        recordId = recordIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RecordStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateProvisioningArtifactInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<UpdateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProvisioningArtifactOutputError>
}

extension UpdateProvisioningArtifactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProvisioningArtifactInput(acceptLanguage: \(String(describing: acceptLanguage)), active: \(String(describing: active)), description: \(String(describing: description)), guidance: \(String(describing: guidance)), name: \(String(describing: name)), productId: \(String(describing: productId)), provisioningArtifactId: \(String(describing: provisioningArtifactId)))"}
}

extension UpdateProvisioningArtifactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case active = "Active"
        case description = "Description"
        case guidance = "Guidance"
        case name = "Name"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let active = active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let guidance = guidance {
            try encodeContainer.encode(guidance.rawValue, forKey: .guidance)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }
}

public struct UpdateProvisioningArtifactInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<UpdateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProvisioningArtifactOutputError>
}

public struct UpdateProvisioningArtifactInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProvisioningArtifactInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProvisioningArtifactInput>
    public typealias MOutput = OperationOutput<UpdateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProvisioningArtifactOutputError>
}

public struct UpdateProvisioningArtifactInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>Indicates whether the product version is active.</p>
    ///          <p>Inactive provisioning artifacts are invisible to end users. End users cannot launch or update a provisioned product from an inactive provisioning artifact.</p>
    public let active: Bool?
    /// <p>The updated description of the provisioning artifact.</p>
    public let description: String?
    /// <p>Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.</p>
    ///          <p>The <code>DEFAULT</code> value indicates that the product version is active.</p>
    ///          <p>The administrator can set the guidance to <code>DEPRECATED</code> to inform
    ///           users that the product version is deprecated. Users are able to make updates to a provisioned product
    ///           of a deprecated version but cannot launch new provisioned products using a deprecated version.</p>
    public let guidance: ProvisioningArtifactGuidance?
    /// <p>The updated name of the provisioning artifact.</p>
    public let name: String?
    /// <p>The product identifier.</p>
    public let productId: String?
    /// <p>The identifier of the provisioning artifact.</p>
    public let provisioningArtifactId: String?

    public init (
        acceptLanguage: String? = nil,
        active: Bool? = nil,
        description: String? = nil,
        guidance: ProvisioningArtifactGuidance? = nil,
        name: String? = nil,
        productId: String? = nil,
        provisioningArtifactId: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.active = active
        self.description = description
        self.guidance = guidance
        self.name = name
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct UpdateProvisioningArtifactInputBody: Equatable {
    public let acceptLanguage: String?
    public let productId: String?
    public let provisioningArtifactId: String?
    public let name: String?
    public let description: String?
    public let active: Bool?
    public let guidance: ProvisioningArtifactGuidance?
}

extension UpdateProvisioningArtifactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case active = "Active"
        case description = "Description"
        case guidance = "Guidance"
        case name = "Name"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .active)
        active = activeDecoded
        let guidanceDecoded = try containerValues.decodeIfPresent(ProvisioningArtifactGuidance.self, forKey: .guidance)
        guidance = guidanceDecoded
    }
}

extension UpdateProvisioningArtifactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProvisioningArtifactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProvisioningArtifactOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProvisioningArtifactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProvisioningArtifactOutputResponse(info: \(String(describing: info)), provisioningArtifactDetail: \(String(describing: provisioningArtifactDetail)), status: \(String(describing: status)))"}
}

extension UpdateProvisioningArtifactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateProvisioningArtifactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.info = output.info
            self.provisioningArtifactDetail = output.provisioningArtifactDetail
            self.status = output.status
        } else {
            self.info = nil
            self.provisioningArtifactDetail = nil
            self.status = nil
        }
    }
}

public struct UpdateProvisioningArtifactOutputResponse: Equatable {
    /// <p>The URL of the CloudFormation template in Amazon S3.</p>
    public let info: [String:String]?
    /// <p>Information about the provisioning artifact.</p>
    public let provisioningArtifactDetail: ProvisioningArtifactDetail?
    /// <p>The status of the current request.</p>
    public let status: Status?

    public init (
        info: [String:String]? = nil,
        provisioningArtifactDetail: ProvisioningArtifactDetail? = nil,
        status: Status? = nil
    )
    {
        self.info = info
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.status = status
    }
}

struct UpdateProvisioningArtifactOutputResponseBody: Equatable {
    public let provisioningArtifactDetail: ProvisioningArtifactDetail?
    public let info: [String:String]?
    public let status: Status?
}

extension UpdateProvisioningArtifactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case info = "Info"
        case provisioningArtifactDetail = "ProvisioningArtifactDetail"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactDetailDecoded = try containerValues.decodeIfPresent(ProvisioningArtifactDetail.self, forKey: .provisioningArtifactDetail)
        provisioningArtifactDetail = provisioningArtifactDetailDecoded
        let infoContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .info)
        var infoDecoded0: [String:String]? = nil
        if let infoContainer = infoContainer {
            infoDecoded0 = [String:String]()
            for (key0, provisioningartifactinfovalue0) in infoContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    infoDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        info = infoDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateProvisioningParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case usePreviousValue = "UsePreviousValue"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if usePreviousValue != false {
            try encodeContainer.encode(usePreviousValue, forKey: .usePreviousValue)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let usePreviousValueDecoded = try containerValues.decode(Bool.self, forKey: .usePreviousValue)
        usePreviousValue = usePreviousValueDecoded
    }
}

extension UpdateProvisioningParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProvisioningParameter(key: \(String(describing: key)), usePreviousValue: \(String(describing: usePreviousValue)), value: \(String(describing: value)))"}
}

/// <p>The parameter key-value pair used to update a provisioned product.</p>
public struct UpdateProvisioningParameter: Equatable {
    /// <p>The parameter key.</p>
    public let key: String?
    /// <p>If set to true, <code>Value</code> is ignored and the previous parameter value is kept.</p>
    public let usePreviousValue: Bool
    /// <p>The parameter value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        usePreviousValue: Bool = false,
        value: String? = nil
    )
    {
        self.key = key
        self.usePreviousValue = usePreviousValue
        self.value = value
    }
}

extension UpdateProvisioningPreferences: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackSetAccounts = "StackSetAccounts"
        case stackSetFailureToleranceCount = "StackSetFailureToleranceCount"
        case stackSetFailureTolerancePercentage = "StackSetFailureTolerancePercentage"
        case stackSetMaxConcurrencyCount = "StackSetMaxConcurrencyCount"
        case stackSetMaxConcurrencyPercentage = "StackSetMaxConcurrencyPercentage"
        case stackSetOperationType = "StackSetOperationType"
        case stackSetRegions = "StackSetRegions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackSetAccounts = stackSetAccounts {
            var stackSetAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetAccounts)
            for stacksetaccounts0 in stackSetAccounts {
                try stackSetAccountsContainer.encode(stacksetaccounts0)
            }
        }
        if let stackSetFailureToleranceCount = stackSetFailureToleranceCount {
            try encodeContainer.encode(stackSetFailureToleranceCount, forKey: .stackSetFailureToleranceCount)
        }
        if let stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage {
            try encodeContainer.encode(stackSetFailureTolerancePercentage, forKey: .stackSetFailureTolerancePercentage)
        }
        if let stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount {
            try encodeContainer.encode(stackSetMaxConcurrencyCount, forKey: .stackSetMaxConcurrencyCount)
        }
        if let stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage {
            try encodeContainer.encode(stackSetMaxConcurrencyPercentage, forKey: .stackSetMaxConcurrencyPercentage)
        }
        if let stackSetOperationType = stackSetOperationType {
            try encodeContainer.encode(stackSetOperationType.rawValue, forKey: .stackSetOperationType)
        }
        if let stackSetRegions = stackSetRegions {
            var stackSetRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetRegions)
            for stacksetregions0 in stackSetRegions {
                try stackSetRegionsContainer.encode(stacksetregions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stackSetAccounts)
        var stackSetAccountsDecoded0:[String]? = nil
        if let stackSetAccountsContainer = stackSetAccountsContainer {
            stackSetAccountsDecoded0 = [String]()
            for string0 in stackSetAccountsContainer {
                if let string0 = string0 {
                    stackSetAccountsDecoded0?.append(string0)
                }
            }
        }
        stackSetAccounts = stackSetAccountsDecoded0
        let stackSetRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stackSetRegions)
        var stackSetRegionsDecoded0:[String]? = nil
        if let stackSetRegionsContainer = stackSetRegionsContainer {
            stackSetRegionsDecoded0 = [String]()
            for string0 in stackSetRegionsContainer {
                if let string0 = string0 {
                    stackSetRegionsDecoded0?.append(string0)
                }
            }
        }
        stackSetRegions = stackSetRegionsDecoded0
        let stackSetFailureToleranceCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stackSetFailureToleranceCount)
        stackSetFailureToleranceCount = stackSetFailureToleranceCountDecoded
        let stackSetFailureTolerancePercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stackSetFailureTolerancePercentage)
        stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentageDecoded
        let stackSetMaxConcurrencyCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stackSetMaxConcurrencyCount)
        stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCountDecoded
        let stackSetMaxConcurrencyPercentageDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stackSetMaxConcurrencyPercentage)
        stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentageDecoded
        let stackSetOperationTypeDecoded = try containerValues.decodeIfPresent(StackSetOperationType.self, forKey: .stackSetOperationType)
        stackSetOperationType = stackSetOperationTypeDecoded
    }
}

extension UpdateProvisioningPreferences: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProvisioningPreferences(stackSetAccounts: \(String(describing: stackSetAccounts)), stackSetFailureToleranceCount: \(String(describing: stackSetFailureToleranceCount)), stackSetFailureTolerancePercentage: \(String(describing: stackSetFailureTolerancePercentage)), stackSetMaxConcurrencyCount: \(String(describing: stackSetMaxConcurrencyCount)), stackSetMaxConcurrencyPercentage: \(String(describing: stackSetMaxConcurrencyPercentage)), stackSetOperationType: \(String(describing: stackSetOperationType)), stackSetRegions: \(String(describing: stackSetRegions)))"}
}

/// <p>The user-defined preferences that will be applied when updating a provisioned product. Not all preferences are applicable to all provisioned product types.</p>
public struct UpdateProvisioningPreferences: Equatable {
    /// <p>One or more AWS accounts that will have access to the provisioned product.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <p>The AWS accounts specified should be within the list of accounts in the <code>STACKSET</code> constraint. To get the list of accounts in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
    ///          <p>If no values are specified, the default value is all accounts from the <code>STACKSET</code> constraint.</p>
    public let stackSetAccounts: [String]?
    /// <p>The number of accounts, per region, for which this operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
    ///          <p>The default value is <code>0</code> if no value is specified.</p>
    public let stackSetFailureToleranceCount: Int?
    /// <p>The percentage of accounts, per region, for which this stack operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions.</p>
    ///          <p>When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
    public let stackSetFailureTolerancePercentage: Int?
    /// <p>The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of <code>StackSetFailureToleranceCount</code>. <code>StackSetMaxConcurrentCount</code> is at most one more than the <code>StackSetFailureToleranceCount</code>.</p>
    ///          <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
    public let stackSetMaxConcurrencyCount: Int?
    /// <p>The maximum percentage of accounts in which to perform this operation at one time.</p>
    ///          <p>When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, AWS Service Catalog sets the number as <code>1</code> instead.</p>
    ///          <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
    public let stackSetMaxConcurrencyPercentage: Int?
    /// <p>Determines what action AWS Service Catalog performs to a stack set or a stack instance represented by the provisioned product. The default value is <code>UPDATE</code> if nothing is specified.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <dl>
    ///             <dt>CREATE</dt>
    ///             <dd>
    ///                <p>Creates a new stack instance in the stack set represented by the provisioned product. In this case, only new stack instances are created based on accounts and regions; if new ProductId or ProvisioningArtifactID are passed, they will be ignored.</p>
    ///             </dd>
    ///             <dt>UPDATE</dt>
    ///             <dd>
    ///                <p>Updates the stack set represented by the provisioned product and also its stack instances.</p>
    ///             </dd>
    ///             <dt>DELETE</dt>
    ///             <dd>
    ///                <p>Deletes a stack instance in the stack set represented by the provisioned product.</p>
    ///             </dd>
    ///          </dl>
    public let stackSetOperationType: StackSetOperationType?
    /// <p>One or more AWS Regions where the provisioned product will be available.</p>
    ///          <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    ///          <p>The specified regions should be within the list of regions from the <code>STACKSET</code> constraint. To get the list of regions in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
    ///          <p>If no values are specified, the default value is all regions from the <code>STACKSET</code> constraint.</p>
    public let stackSetRegions: [String]?

    public init (
        stackSetAccounts: [String]? = nil,
        stackSetFailureToleranceCount: Int? = nil,
        stackSetFailureTolerancePercentage: Int? = nil,
        stackSetMaxConcurrencyCount: Int? = nil,
        stackSetMaxConcurrencyPercentage: Int? = nil,
        stackSetOperationType: StackSetOperationType? = nil,
        stackSetRegions: [String]? = nil
    )
    {
        self.stackSetAccounts = stackSetAccounts
        self.stackSetFailureToleranceCount = stackSetFailureToleranceCount
        self.stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage
        self.stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount
        self.stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage
        self.stackSetOperationType = stackSetOperationType
        self.stackSetRegions = stackSetRegions
    }
}

public struct UpdateServiceActionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateServiceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceActionInput>
    public typealias MOutput = OperationOutput<UpdateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceActionOutputError>
}

extension UpdateServiceActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceActionInput(acceptLanguage: \(String(describing: acceptLanguage)), definition: \(String(describing: definition)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

extension UpdateServiceActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case definition = "Definition"
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .definition)
            for (dictKey0, serviceactiondefinitionmap0) in definition {
                try definitionContainer.encode(serviceactiondefinitionmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateServiceActionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateServiceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceActionInput>
    public typealias MOutput = OperationOutput<UpdateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceActionOutputError>
}

public struct UpdateServiceActionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateServiceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceActionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceActionInput>
    public typealias MOutput = OperationOutput<UpdateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceActionOutputError>
}

public struct UpdateServiceActionInput: Equatable {
    /// <p>The language code.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>en</code> - English (default)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>jp</code> - Japanese</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>zh</code> - Chinese</p>
    ///             </li>
    ///          </ul>
    public let acceptLanguage: String?
    /// <p>A map that defines the self-service action.</p>
    public let definition: [String:String]?
    /// <p>The self-service action description.</p>
    public let description: String?
    /// <p>The self-service action identifier.</p>
    public let id: String?
    /// <p>The self-service action name.</p>
    public let name: String?

    public init (
        acceptLanguage: String? = nil,
        definition: [String:String]? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.definition = definition
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateServiceActionInputBody: Equatable {
    public let id: String?
    public let name: String?
    public let definition: [String:String]?
    public let description: String?
    public let acceptLanguage: String?
}

extension UpdateServiceActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case definition = "Definition"
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let definitionContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .definition)
        var definitionDecoded0: [String:String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [String:String]()
            for (key0, serviceactiondefinitionvalue0) in definitionContainer {
                if let serviceactiondefinitionvalue0 = serviceactiondefinitionvalue0 {
                    definitionDecoded0?[key0] = serviceactiondefinitionvalue0
                }
            }
        }
        definition = definitionDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension UpdateServiceActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceActionOutputError: Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceActionOutputResponse(serviceActionDetail: \(String(describing: serviceActionDetail)))"}
}

extension UpdateServiceActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateServiceActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceActionDetail = output.serviceActionDetail
        } else {
            self.serviceActionDetail = nil
        }
    }
}

public struct UpdateServiceActionOutputResponse: Equatable {
    /// <p>Detailed information about the self-service action.</p>
    public let serviceActionDetail: ServiceActionDetail?

    public init (
        serviceActionDetail: ServiceActionDetail? = nil
    )
    {
        self.serviceActionDetail = serviceActionDetail
    }
}

struct UpdateServiceActionOutputResponseBody: Equatable {
    public let serviceActionDetail: ServiceActionDetail?
}

extension UpdateServiceActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceActionDetail = "ServiceActionDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionDetailDecoded = try containerValues.decodeIfPresent(ServiceActionDetail.self, forKey: .serviceActionDetail)
        serviceActionDetail = serviceActionDetailDecoded
    }
}

public struct UpdateTagOptionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTagOptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTagOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTagOptionInput>
    public typealias MOutput = OperationOutput<UpdateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTagOptionOutputError>
}

extension UpdateTagOptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTagOptionInput(active: \(String(describing: active)), id: \(String(describing: id)), value: \(String(describing: value)))"}
}

extension UpdateTagOptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case active = "Active"
        case id = "Id"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

public struct UpdateTagOptionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTagOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTagOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTagOptionInput>
    public typealias MOutput = OperationOutput<UpdateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTagOptionOutputError>
}

public struct UpdateTagOptionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTagOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTagOptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTagOptionInput>
    public typealias MOutput = OperationOutput<UpdateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTagOptionOutputError>
}

public struct UpdateTagOptionInput: Equatable {
    /// <p>The updated active state.</p>
    public let active: Bool?
    /// <p>The TagOption identifier.</p>
    public let id: String?
    /// <p>The updated value.</p>
    public let value: String?

    public init (
        active: Bool? = nil,
        id: String? = nil,
        value: String? = nil
    )
    {
        self.active = active
        self.id = id
        self.value = value
    }
}

struct UpdateTagOptionInputBody: Equatable {
    public let id: String?
    public let value: String?
    public let active: Bool?
}

extension UpdateTagOptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case active = "Active"
        case id = "Id"
        case value = "Value"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .active)
        active = activeDecoded
    }
}

extension UpdateTagOptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTagOptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTagOptionOutputError: Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTagOptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTagOptionOutputResponse(tagOptionDetail: \(String(describing: tagOptionDetail)))"}
}

extension UpdateTagOptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateTagOptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagOptionDetail = output.tagOptionDetail
        } else {
            self.tagOptionDetail = nil
        }
    }
}

public struct UpdateTagOptionOutputResponse: Equatable {
    /// <p>Information about the TagOption.</p>
    public let tagOptionDetail: TagOptionDetail?

    public init (
        tagOptionDetail: TagOptionDetail? = nil
    )
    {
        self.tagOptionDetail = tagOptionDetail
    }
}

struct UpdateTagOptionOutputResponseBody: Equatable {
    public let tagOptionDetail: TagOptionDetail?
}

extension UpdateTagOptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagOptionDetail = "TagOptionDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagOptionDetailDecoded = try containerValues.decodeIfPresent(TagOptionDetail.self, forKey: .tagOptionDetail)
        tagOptionDetail = tagOptionDetailDecoded
    }
}

extension UsageInstruction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension UsageInstruction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageInstruction(type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Additional information provided by the administrator.</p>
public struct UsageInstruction: Equatable {
    /// <p>The usage instruction type for the value.</p>
    public let type: String?
    /// <p>The usage instruction value for this type.</p>
    public let value: String?

    public init (
        type: String? = nil,
        value: String? = nil
    )
    {
        self.type = type
        self.value = value
    }
}
