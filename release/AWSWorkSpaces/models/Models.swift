// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user is not authorized to access a resource.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesClientTypes {
    public enum AccessPropertyValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPropertyValue] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessPropertyValue(rawValue: rawValue) ?? AccessPropertyValue.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.AccountModification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case modificationState = "ModificationState"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange {
            try encodeContainer.encode(dedicatedTenancyManagementCidrRange, forKey: .dedicatedTenancyManagementCidrRange)
        }
        if let dedicatedTenancySupport = dedicatedTenancySupport {
            try encodeContainer.encode(dedicatedTenancySupport.rawValue, forKey: .dedicatedTenancySupport)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let modificationState = modificationState {
            try encodeContainer.encode(modificationState.rawValue, forKey: .modificationState)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modificationStateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DedicatedTenancyModificationStateEnum.self, forKey: .modificationState)
        modificationState = modificationStateDecoded
        let dedicatedTenancySupportDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DedicatedTenancySupportResultEnum.self, forKey: .dedicatedTenancySupport)
        dedicatedTenancySupport = dedicatedTenancySupportDecoded
        let dedicatedTenancyManagementCidrRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedTenancyManagementCidrRange)
        dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRangeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a modification to the configuration of Bring Your Own License (BYOL) for the specified account.
    public struct AccountModification: Swift.Equatable {
        /// The IP address range, specified as an IPv4 CIDR block, for the management network interface used for the account.
        public var dedicatedTenancyManagementCidrRange: Swift.String?
        /// The status of BYOL (whether BYOL is being enabled or disabled).
        public var dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum?
        /// The error code that is returned if the configuration of BYOL cannot be modified.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the configuration of BYOL cannot be modified.
        public var errorMessage: Swift.String?
        /// The state of the modification to the configuration of BYOL.
        public var modificationState: WorkSpacesClientTypes.DedicatedTenancyModificationStateEnum?
        /// The timestamp when the modification of the BYOL configuration was started.
        public var startTime: ClientRuntime.Date?

        public init (
            dedicatedTenancyManagementCidrRange: Swift.String? = nil,
            dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            modificationState: WorkSpacesClientTypes.DedicatedTenancyModificationStateEnum? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
            self.dedicatedTenancySupport = dedicatedTenancySupport
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.modificationState = modificationState
            self.startTime = startTime
        }
    }

}

extension WorkSpacesClientTypes {
    public enum Application: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case microsoftOffice2016
        case microsoftOffice2019
        case sdkUnknown(Swift.String)

        public static var allCases: [Application] {
            return [
                .microsoftOffice2016,
                .microsoftOffice2019,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .microsoftOffice2016: return "Microsoft_Office_2016"
            case .microsoftOffice2019: return "Microsoft_Office_2019"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Application(rawValue: rawValue) ?? Application.sdkUnknown(rawValue)
        }
    }
}

extension AssociateConnectionAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension AssociateConnectionAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateConnectionAliasInput: Swift.Equatable {
    /// The identifier of the connection alias.
    /// This member is required.
    public var aliasId: Swift.String?
    /// The identifier of the directory to associate the connection alias with.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        aliasId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
        self.resourceId = resourceId
    }
}

struct AssociateConnectionAliasInputBody: Swift.Equatable {
    let aliasId: Swift.String?
    let resourceId: Swift.String?
}

extension AssociateConnectionAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension AssociateConnectionAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateConnectionAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateConnectionAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateConnectionAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateConnectionAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionIdentifier = output.connectionIdentifier
        } else {
            self.connectionIdentifier = nil
        }
    }
}

public struct AssociateConnectionAliasOutputResponse: Swift.Equatable {
    /// The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when you're configuring your DNS routing policies.
    public var connectionIdentifier: Swift.String?

    public init (
        connectionIdentifier: Swift.String? = nil
    )
    {
        self.connectionIdentifier = connectionIdentifier
    }
}

struct AssociateConnectionAliasOutputResponseBody: Swift.Equatable {
    let connectionIdentifier: Swift.String?
}

extension AssociateConnectionAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionIdentifier = "ConnectionIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionIdentifier)
        connectionIdentifier = connectionIdentifierDecoded
    }
}

extension AssociateIpGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for ipgroupidlist0 in groupIds {
                try groupIdsContainer.encode(ipgroupidlist0)
            }
        }
    }
}

extension AssociateIpGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateIpGroupsInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The identifiers of one or more IP access control groups.
    /// This member is required.
    public var groupIds: [Swift.String]?

    public init (
        directoryId: Swift.String? = nil,
        groupIds: [Swift.String]? = nil
    )
    {
        self.directoryId = directoryId
        self.groupIds = groupIds
    }
}

struct AssociateIpGroupsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let groupIds: [Swift.String]?
}

extension AssociateIpGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let groupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[Swift.String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [Swift.String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
    }
}

extension AssociateIpGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateIpGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateIpGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateIpGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateIpGroupsOutputResponse: Swift.Equatable {

}

extension WorkSpacesClientTypes {
    public enum AssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associatedWithOwnerAccount
        case associatedWithSharedAccount
        case notAssociated
        case pendingAssociation
        case pendingDisassociation
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationStatus] {
            return [
                .associatedWithOwnerAccount,
                .associatedWithSharedAccount,
                .notAssociated,
                .pendingAssociation,
                .pendingDisassociation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associatedWithOwnerAccount: return "ASSOCIATED_WITH_OWNER_ACCOUNT"
            case .associatedWithSharedAccount: return "ASSOCIATED_WITH_SHARED_ACCOUNT"
            case .notAssociated: return "NOT_ASSOCIATED"
            case .pendingAssociation: return "PENDING_ASSOCIATION"
            case .pendingDisassociation: return "PENDING_DISASSOCIATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationStatus(rawValue: rawValue) ?? AssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuthorizeIpRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for iprulelist0 in userRules {
                try userRulesContainer.encode(iprulelist0)
            }
        }
    }
}

extension AuthorizeIpRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AuthorizeIpRulesInput: Swift.Equatable {
    /// The identifier of the group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The rules to add to the group.
    /// This member is required.
    public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

    public init (
        groupId: Swift.String? = nil,
        userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

struct AuthorizeIpRulesInputBody: Swift.Equatable {
    let groupId: Swift.String?
    let userRules: [WorkSpacesClientTypes.IpRuleItem]?
}

extension AuthorizeIpRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[WorkSpacesClientTypes.IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [WorkSpacesClientTypes.IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension AuthorizeIpRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AuthorizeIpRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AuthorizeIpRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AuthorizeIpRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AuthorizeIpRulesOutputResponse: Swift.Equatable {

}

extension WorkSpacesClientTypes.ClientProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reconnectEnabled = "ReconnectEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reconnectEnabled = reconnectEnabled {
            try encodeContainer.encode(reconnectEnabled.rawValue, forKey: .reconnectEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reconnectEnabledDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .reconnectEnabled)
        reconnectEnabled = reconnectEnabledDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes an Amazon WorkSpaces client.
    public struct ClientProperties: Swift.Equatable {
        /// Specifies whether users can cache their credentials on the Amazon WorkSpaces client. When enabled, users can choose to reconnect to their WorkSpaces without re-entering their credentials.
        public var reconnectEnabled: WorkSpacesClientTypes.ReconnectEnum?

        public init (
            reconnectEnabled: WorkSpacesClientTypes.ReconnectEnum? = nil
        )
        {
            self.reconnectEnabled = reconnectEnabled
        }
    }

}

extension WorkSpacesClientTypes.ClientPropertiesResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientProperties = "ClientProperties"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientProperties = clientProperties {
            try encodeContainer.encode(clientProperties, forKey: .clientProperties)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let clientPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ClientProperties.self, forKey: .clientProperties)
        clientProperties = clientPropertiesDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Information about the Amazon WorkSpaces client.
    public struct ClientPropertiesResult: Swift.Equatable {
        /// Information about the Amazon WorkSpaces client.
        public var clientProperties: WorkSpacesClientTypes.ClientProperties?
        /// The resource identifier, in the form of a directory ID.
        public var resourceId: Swift.String?

        public init (
            clientProperties: WorkSpacesClientTypes.ClientProperties? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.clientProperties = clientProperties
            self.resourceId = resourceId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum Compute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case graphics
        case graphicspro
        case performance
        case power
        case powerpro
        case standard
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [Compute] {
            return [
                .graphics,
                .graphicspro,
                .performance,
                .power,
                .powerpro,
                .standard,
                .value,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .graphics: return "GRAPHICS"
            case .graphicspro: return "GRAPHICSPRO"
            case .performance: return "PERFORMANCE"
            case .power: return "POWER"
            case .powerpro: return "POWERPRO"
            case .standard: return "STANDARD"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Compute(rawValue: rawValue) ?? Compute.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.ComputeType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.Compute.self, forKey: .name)
        name = nameDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the compute type of the bundle.
    public struct ComputeType: Swift.Equatable {
        /// The compute type.
        public var name: WorkSpacesClientTypes.Compute?

        public init (
            name: WorkSpacesClientTypes.Compute? = nil
        )
        {
            self.name = name
        }
    }

}

extension WorkSpacesClientTypes.ConnectionAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case associations = "Associations"
        case connectionString = "ConnectionString"
        case ownerAccountId = "OwnerAccountId"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let associations = associations {
            var associationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associations)
            for connectionaliasassociationlist0 in associations {
                try associationsContainer.encode(connectionaliasassociationlist0)
            }
        }
        if let connectionString = connectionString {
            try encodeContainer.encode(connectionString, forKey: .connectionString)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionString)
        connectionString = connectionStringDecoded
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ConnectionAliasState.self, forKey: .state)
        state = stateDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let associationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ConnectionAliasAssociation?].self, forKey: .associations)
        var associationsDecoded0:[WorkSpacesClientTypes.ConnectionAliasAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [WorkSpacesClientTypes.ConnectionAliasAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes a connection alias. Connection aliases are used for cross-Region redirection. For more information, see [ Cross-Region Redirection for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html).
    public struct ConnectionAlias: Swift.Equatable {
        /// The identifier of the connection alias.
        public var aliasId: Swift.String?
        /// The association status of the connection alias.
        public var associations: [WorkSpacesClientTypes.ConnectionAliasAssociation]?
        /// The connection string specified for the connection alias. The connection string must be in the form of a fully qualified domain name (FQDN), such as www.example.com.
        public var connectionString: Swift.String?
        /// The identifier of the Amazon Web Services account that owns the connection alias.
        public var ownerAccountId: Swift.String?
        /// The current state of the connection alias.
        public var state: WorkSpacesClientTypes.ConnectionAliasState?

        public init (
            aliasId: Swift.String? = nil,
            associations: [WorkSpacesClientTypes.ConnectionAliasAssociation]? = nil,
            connectionString: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            state: WorkSpacesClientTypes.ConnectionAliasState? = nil
        )
        {
            self.aliasId = aliasId
            self.associations = associations
            self.connectionString = connectionString
            self.ownerAccountId = ownerAccountId
            self.state = state
        }
    }

}

extension WorkSpacesClientTypes.ConnectionAliasAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAccountId = "AssociatedAccountId"
        case associationStatus = "AssociationStatus"
        case connectionIdentifier = "ConnectionIdentifier"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedAccountId = associatedAccountId {
            try encodeContainer.encode(associatedAccountId, forKey: .associatedAccountId)
        }
        if let associationStatus = associationStatus {
            try encodeContainer.encode(associationStatus.rawValue, forKey: .associationStatus)
        }
        if let connectionIdentifier = connectionIdentifier {
            try encodeContainer.encode(connectionIdentifier, forKey: .connectionIdentifier)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let associatedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAccountId)
        associatedAccountId = associatedAccountIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let connectionIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionIdentifier)
        connectionIdentifier = connectionIdentifierDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a connection alias association that is used for cross-Region redirection. For more information, see [ Cross-Region Redirection for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html).
    public struct ConnectionAliasAssociation: Swift.Equatable {
        /// The identifier of the Amazon Web Services account that associated the connection alias with a directory.
        public var associatedAccountId: Swift.String?
        /// The association status of the connection alias.
        public var associationStatus: WorkSpacesClientTypes.AssociationStatus?
        /// The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when you're configuring your DNS routing policies.
        public var connectionIdentifier: Swift.String?
        /// The identifier of the directory associated with a connection alias.
        public var resourceId: Swift.String?

        public init (
            associatedAccountId: Swift.String? = nil,
            associationStatus: WorkSpacesClientTypes.AssociationStatus? = nil,
            connectionIdentifier: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.associatedAccountId = associatedAccountId
            self.associationStatus = associationStatus
            self.connectionIdentifier = connectionIdentifier
            self.resourceId = resourceId
        }
    }

}

extension WorkSpacesClientTypes.ConnectionAliasPermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowAssociation = "AllowAssociation"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowAssociation = allowAssociation {
            try encodeContainer.encode(allowAssociation, forKey: .allowAssociation)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let allowAssociationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowAssociation)
        allowAssociation = allowAssociationDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the permissions for a connection alias. Connection aliases are used for cross-Region redirection. For more information, see [ Cross-Region Redirection for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html).
    public struct ConnectionAliasPermission: Swift.Equatable {
        /// Indicates whether the specified Amazon Web Services account is allowed to associate the connection alias with a directory.
        /// This member is required.
        public var allowAssociation: Swift.Bool?
        /// The identifier of the Amazon Web Services account that the connection alias is shared with.
        /// This member is required.
        public var sharedAccountId: Swift.String?

        public init (
            allowAssociation: Swift.Bool? = nil,
            sharedAccountId: Swift.String? = nil
        )
        {
            self.allowAssociation = allowAssociation
            self.sharedAccountId = sharedAccountId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum ConnectionAliasState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionAliasState] {
            return [
                .created,
                .creating,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionAliasState(rawValue: rawValue) ?? ConnectionAliasState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum ConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case disconnected
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionState] {
            return [
                .connected,
                .disconnected,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
        }
    }
}

extension CopyWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case sourceRegion = "SourceRegion"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceImageId = sourceImageId {
            try encodeContainer.encode(sourceImageId, forKey: .sourceImageId)
        }
        if let sourceRegion = sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CopyWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CopyWorkspaceImageInput: Swift.Equatable {
    /// A description of the image.
    public var description: Swift.String?
    /// The name of the image.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the source image.
    /// This member is required.
    public var sourceImageId: Swift.String?
    /// The identifier of the source Region.
    /// This member is required.
    public var sourceRegion: Swift.String?
    /// The tags for the image.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceImageId: Swift.String? = nil,
        sourceRegion: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.sourceImageId = sourceImageId
        self.sourceRegion = sourceRegion
        self.tags = tags
    }
}

struct CopyWorkspaceImageInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let sourceImageId: Swift.String?
    let sourceRegion: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CopyWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case sourceRegion = "SourceRegion"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceImageId)
        sourceImageId = sourceImageIdDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CopyWorkspaceImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyWorkspaceImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyWorkspaceImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyWorkspaceImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyWorkspaceImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
        } else {
            self.imageId = nil
        }
    }
}

public struct CopyWorkspaceImageOutputResponse: Swift.Equatable {
    /// The identifier of the image.
    public var imageId: Swift.String?

    public init (
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct CopyWorkspaceImageOutputResponseBody: Swift.Equatable {
    let imageId: Swift.String?
}

extension CopyWorkspaceImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension CreateConnectionAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionString = "ConnectionString"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionString = connectionString {
            try encodeContainer.encode(connectionString, forKey: .connectionString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateConnectionAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConnectionAliasInput: Swift.Equatable {
    /// A connection string in the form of a fully qualified domain name (FQDN), such as www.example.com. After you create a connection string, it is always associated to your Amazon Web Services account. You cannot recreate the same connection string with a different account, even if you delete all instances of it from the original account. The connection string is globally reserved for your account.
    /// This member is required.
    public var connectionString: Swift.String?
    /// The tags to associate with the connection alias.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init (
        connectionString: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.connectionString = connectionString
        self.tags = tags
    }
}

struct CreateConnectionAliasInputBody: Swift.Equatable {
    let connectionString: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateConnectionAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionString = "ConnectionString"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionString)
        connectionString = connectionStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectionAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectionAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasId = output.aliasId
        } else {
            self.aliasId = nil
        }
    }
}

public struct CreateConnectionAliasOutputResponse: Swift.Equatable {
    /// The identifier of the connection alias.
    public var aliasId: Swift.String?

    public init (
        aliasId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

struct CreateConnectionAliasOutputResponseBody: Swift.Equatable {
    let aliasId: Swift.String?
}

extension CreateConnectionAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
    }
}

extension CreateIpGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupDesc = "GroupDesc"
        case groupName = "GroupName"
        case tags = "Tags"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupDesc = groupDesc {
            try encodeContainer.encode(groupDesc, forKey: .groupDesc)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for iprulelist0 in userRules {
                try userRulesContainer.encode(iprulelist0)
            }
        }
    }
}

extension CreateIpGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateIpGroupInput: Swift.Equatable {
    /// The description of the group.
    public var groupDesc: Swift.String?
    /// The name of the group.
    /// This member is required.
    public var groupName: Swift.String?
    /// The tags. Each WorkSpaces resource can have a maximum of 50 tags.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// The rules to add to the group.
    public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

    public init (
        groupDesc: Swift.String? = nil,
        groupName: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
    )
    {
        self.groupDesc = groupDesc
        self.groupName = groupName
        self.tags = tags
        self.userRules = userRules
    }
}

struct CreateIpGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let groupDesc: Swift.String?
    let userRules: [WorkSpacesClientTypes.IpRuleItem]?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateIpGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupDesc = "GroupDesc"
        case groupName = "GroupName"
        case tags = "Tags"
        case userRules = "UserRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDescDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupDesc)
        groupDesc = groupDescDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[WorkSpacesClientTypes.IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [WorkSpacesClientTypes.IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIpGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIpGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceCreationFailedException" : self = .resourceCreationFailedException(try ResourceCreationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIpGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceCreationFailedException(ResourceCreationFailedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIpGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIpGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupId = output.groupId
        } else {
            self.groupId = nil
        }
    }
}

public struct CreateIpGroupOutputResponse: Swift.Equatable {
    /// The identifier of the group.
    public var groupId: Swift.String?

    public init (
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct CreateIpGroupOutputResponseBody: Swift.Equatable {
    let groupId: Swift.String?
}

extension CreateIpGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension CreateTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTagsInput: Swift.Equatable {
    /// The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces, registered directories, images, custom bundles, IP access control groups, and connection aliases.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The tags. Each WorkSpaces resource can have a maximum of 50 tags.
    /// This member is required.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init (
        resourceId: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tags = tags
    }
}

struct CreateTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateTagsOutputResponse: Swift.Equatable {

}

extension CreateUpdatedWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceImageId = sourceImageId {
            try encodeContainer.encode(sourceImageId, forKey: .sourceImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateUpdatedWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUpdatedWorkspaceImageInput: Swift.Equatable {
    /// A description of whether updates for the WorkSpace image are available.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the new updated WorkSpace image.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the source WorkSpace image.
    /// This member is required.
    public var sourceImageId: Swift.String?
    /// The tags that you want to add to the new updated WorkSpace image. To add tags at the same time when you're creating the updated image, you must create an IAM policy that grants your IAM user permissions to use workspaces:CreateTags.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceImageId: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.sourceImageId = sourceImageId
        self.tags = tags
    }
}

struct CreateUpdatedWorkspaceImageInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let sourceImageId: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateUpdatedWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceImageId)
        sourceImageId = sourceImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUpdatedWorkspaceImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUpdatedWorkspaceImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUpdatedWorkspaceImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUpdatedWorkspaceImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUpdatedWorkspaceImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
        } else {
            self.imageId = nil
        }
    }
}

public struct CreateUpdatedWorkspaceImageOutputResponse: Swift.Equatable {
    /// The identifier of the new updated WorkSpace image.
    public var imageId: Swift.String?

    public init (
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct CreateUpdatedWorkspaceImageOutputResponseBody: Swift.Equatable {
    let imageId: Swift.String?
}

extension CreateUpdatedWorkspaceImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension CreateWorkspaceBundleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleDescription = "BundleDescription"
        case bundleName = "BundleName"
        case computeType = "ComputeType"
        case imageId = "ImageId"
        case rootStorage = "RootStorage"
        case tags = "Tags"
        case userStorage = "UserStorage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleDescription = bundleDescription {
            try encodeContainer.encode(bundleDescription, forKey: .bundleDescription)
        }
        if let bundleName = bundleName {
            try encodeContainer.encode(bundleName, forKey: .bundleName)
        }
        if let computeType = computeType {
            try encodeContainer.encode(computeType, forKey: .computeType)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let rootStorage = rootStorage {
            try encodeContainer.encode(rootStorage, forKey: .rootStorage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let userStorage = userStorage {
            try encodeContainer.encode(userStorage, forKey: .userStorage)
        }
    }
}

extension CreateWorkspaceBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkspaceBundleInput: Swift.Equatable {
    /// The description of the bundle.
    /// This member is required.
    public var bundleDescription: Swift.String?
    /// The name of the bundle.
    /// This member is required.
    public var bundleName: Swift.String?
    /// Describes the compute type of the bundle.
    /// This member is required.
    public var computeType: WorkSpacesClientTypes.ComputeType?
    /// The identifier of the image that is used to create the bundle.
    /// This member is required.
    public var imageId: Swift.String?
    /// Describes the root volume for a WorkSpace bundle.
    public var rootStorage: WorkSpacesClientTypes.RootStorage?
    /// The tags associated with the bundle. To add tags at the same time when you're creating the bundle, you must create an IAM policy that grants your IAM user permissions to use workspaces:CreateTags.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// Describes the user volume for a WorkSpace bundle.
    /// This member is required.
    public var userStorage: WorkSpacesClientTypes.UserStorage?

    public init (
        bundleDescription: Swift.String? = nil,
        bundleName: Swift.String? = nil,
        computeType: WorkSpacesClientTypes.ComputeType? = nil,
        imageId: Swift.String? = nil,
        rootStorage: WorkSpacesClientTypes.RootStorage? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        userStorage: WorkSpacesClientTypes.UserStorage? = nil
    )
    {
        self.bundleDescription = bundleDescription
        self.bundleName = bundleName
        self.computeType = computeType
        self.imageId = imageId
        self.rootStorage = rootStorage
        self.tags = tags
        self.userStorage = userStorage
    }
}

struct CreateWorkspaceBundleInputBody: Swift.Equatable {
    let bundleName: Swift.String?
    let bundleDescription: Swift.String?
    let imageId: Swift.String?
    let computeType: WorkSpacesClientTypes.ComputeType?
    let userStorage: WorkSpacesClientTypes.UserStorage?
    let rootStorage: WorkSpacesClientTypes.RootStorage?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateWorkspaceBundleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleDescription = "BundleDescription"
        case bundleName = "BundleName"
        case computeType = "ComputeType"
        case imageId = "ImageId"
        case rootStorage = "RootStorage"
        case tags = "Tags"
        case userStorage = "UserStorage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleName)
        bundleName = bundleNameDecoded
        let bundleDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleDescription)
        bundleDescription = bundleDescriptionDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let userStorageDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.UserStorage.self, forKey: .userStorage)
        userStorage = userStorageDecoded
        let rootStorageDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.RootStorage.self, forKey: .rootStorage)
        rootStorage = rootStorageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkspaceBundleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkspaceBundleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkspaceBundleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkspaceBundleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorkspaceBundleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workspaceBundle = output.workspaceBundle
        } else {
            self.workspaceBundle = nil
        }
    }
}

public struct CreateWorkspaceBundleOutputResponse: Swift.Equatable {
    /// Describes a WorkSpace bundle.
    public var workspaceBundle: WorkSpacesClientTypes.WorkspaceBundle?

    public init (
        workspaceBundle: WorkSpacesClientTypes.WorkspaceBundle? = nil
    )
    {
        self.workspaceBundle = workspaceBundle
    }
}

struct CreateWorkspaceBundleOutputResponseBody: Swift.Equatable {
    let workspaceBundle: WorkSpacesClientTypes.WorkspaceBundle?
}

extension CreateWorkspaceBundleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceBundle = "WorkspaceBundle"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceBundleDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceBundle.self, forKey: .workspaceBundle)
        workspaceBundle = workspaceBundleDecoded
    }
}

extension CreateWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaces = "Workspaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaces = workspaces {
            var workspacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaces)
            for workspacerequestlist0 in workspaces {
                try workspacesContainer.encode(workspacerequestlist0)
            }
        }
    }
}

extension CreateWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to create. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var workspaces: [WorkSpacesClientTypes.WorkspaceRequest]?

    public init (
        workspaces: [WorkSpacesClientTypes.WorkspaceRequest]? = nil
    )
    {
        self.workspaces = workspaces
    }
}

struct CreateWorkspacesInputBody: Swift.Equatable {
    let workspaces: [WorkSpacesClientTypes.WorkspaceRequest]?
}

extension CreateWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaces = "Workspaces"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceRequest?].self, forKey: .workspaces)
        var workspacesDecoded0:[WorkSpacesClientTypes.WorkspaceRequest]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [WorkSpacesClientTypes.WorkspaceRequest]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
    }
}

extension CreateWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
            self.pendingRequests = output.pendingRequests
        } else {
            self.failedRequests = nil
            self.pendingRequests = nil
        }
    }
}

public struct CreateWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the WorkSpaces that could not be created.
    public var failedRequests: [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]?
    /// Information about the WorkSpaces that were created. Because this operation is asynchronous, the identifier returned is not immediately available for use with other operations. For example, if you call [DescribeWorkspaces] before the WorkSpace is created, the information returned can be incomplete.
    public var pendingRequests: [WorkSpacesClientTypes.Workspace]?

    public init (
        failedRequests: [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]? = nil,
        pendingRequests: [WorkSpacesClientTypes.Workspace]? = nil
    )
    {
        self.failedRequests = failedRequests
        self.pendingRequests = pendingRequests
    }
}

struct CreateWorkspacesOutputResponseBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]?
    let pendingRequests: [WorkSpacesClientTypes.Workspace]?
}

extension CreateWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
        case pendingRequests = "PendingRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedCreateWorkspaceRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedCreateWorkspaceRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
        let pendingRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Workspace?].self, forKey: .pendingRequests)
        var pendingRequestsDecoded0:[WorkSpacesClientTypes.Workspace]? = nil
        if let pendingRequestsContainer = pendingRequestsContainer {
            pendingRequestsDecoded0 = [WorkSpacesClientTypes.Workspace]()
            for structure0 in pendingRequestsContainer {
                if let structure0 = structure0 {
                    pendingRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingRequests = pendingRequestsDecoded0
    }
}

extension WorkSpacesClientTypes {
    public enum DedicatedTenancyModificationStateEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancyModificationStateEnum] {
            return [
                .completed,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DedicatedTenancyModificationStateEnum(rawValue: rawValue) ?? DedicatedTenancyModificationStateEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum DedicatedTenancySupportEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancySupportEnum] {
            return [
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DedicatedTenancySupportEnum(rawValue: rawValue) ?? DedicatedTenancySupportEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum DedicatedTenancySupportResultEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancySupportResultEnum] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DedicatedTenancySupportResultEnum(rawValue: rawValue) ?? DedicatedTenancySupportResultEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.DefaultWorkspaceCreationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customSecurityGroupId = "CustomSecurityGroupId"
        case defaultOu = "DefaultOu"
        case enableInternetAccess = "EnableInternetAccess"
        case enableMaintenanceMode = "EnableMaintenanceMode"
        case enableWorkDocs = "EnableWorkDocs"
        case userEnabledAsLocalAdministrator = "UserEnabledAsLocalAdministrator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customSecurityGroupId = customSecurityGroupId {
            try encodeContainer.encode(customSecurityGroupId, forKey: .customSecurityGroupId)
        }
        if let defaultOu = defaultOu {
            try encodeContainer.encode(defaultOu, forKey: .defaultOu)
        }
        if let enableInternetAccess = enableInternetAccess {
            try encodeContainer.encode(enableInternetAccess, forKey: .enableInternetAccess)
        }
        if let enableMaintenanceMode = enableMaintenanceMode {
            try encodeContainer.encode(enableMaintenanceMode, forKey: .enableMaintenanceMode)
        }
        if let enableWorkDocs = enableWorkDocs {
            try encodeContainer.encode(enableWorkDocs, forKey: .enableWorkDocs)
        }
        if let userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator {
            try encodeContainer.encode(userEnabledAsLocalAdministrator, forKey: .userEnabledAsLocalAdministrator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableWorkDocsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWorkDocs)
        enableWorkDocs = enableWorkDocsDecoded
        let enableInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableInternetAccess)
        enableInternetAccess = enableInternetAccessDecoded
        let defaultOuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOu)
        defaultOu = defaultOuDecoded
        let customSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customSecurityGroupId)
        customSecurityGroupId = customSecurityGroupIdDecoded
        let userEnabledAsLocalAdministratorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userEnabledAsLocalAdministrator)
        userEnabledAsLocalAdministrator = userEnabledAsLocalAdministratorDecoded
        let enableMaintenanceModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMaintenanceMode)
        enableMaintenanceMode = enableMaintenanceModeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the default values that are used to create WorkSpaces. For more information, see [Update Directory Details for Your WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html).
    public struct DefaultWorkspaceCreationProperties: Swift.Equatable {
        /// The identifier of the default security group to apply to WorkSpaces when they are created. For more information, see [ Security Groups for Your WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-security-groups.html).
        public var customSecurityGroupId: Swift.String?
        /// The organizational unit (OU) in the directory for the WorkSpace machine accounts.
        public var defaultOu: Swift.String?
        /// Specifies whether to automatically assign an Elastic public IP address to WorkSpaces in this directory by default. If enabled, the Elastic public IP address allows outbound internet access from your WorkSpaces when youre using an internet gateway in the Amazon VPC in which your WorkSpaces are located. If you're using a Network Address Translation (NAT) gateway for outbound internet access from your VPC, or if your WorkSpaces are in public subnets and you manually assign them Elastic IP addresses, you should disable this setting. This setting applies to new WorkSpaces that you launch or to existing WorkSpaces that you rebuild. For more information, see [ Configure a VPC for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html).
        public var enableInternetAccess: Swift.Bool?
        /// Specifies whether maintenance mode is enabled for WorkSpaces. For more information, see [WorkSpace Maintenance](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html).
        public var enableMaintenanceMode: Swift.Bool?
        /// Specifies whether the directory is enabled for Amazon WorkDocs.
        public var enableWorkDocs: Swift.Bool?
        /// Specifies whether WorkSpace users are local administrators on their WorkSpaces.
        public var userEnabledAsLocalAdministrator: Swift.Bool?

        public init (
            customSecurityGroupId: Swift.String? = nil,
            defaultOu: Swift.String? = nil,
            enableInternetAccess: Swift.Bool? = nil,
            enableMaintenanceMode: Swift.Bool? = nil,
            enableWorkDocs: Swift.Bool? = nil,
            userEnabledAsLocalAdministrator: Swift.Bool? = nil
        )
        {
            self.customSecurityGroupId = customSecurityGroupId
            self.defaultOu = defaultOu
            self.enableInternetAccess = enableInternetAccess
            self.enableMaintenanceMode = enableMaintenanceMode
            self.enableWorkDocs = enableWorkDocs
            self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
        }
    }

}

extension DeleteConnectionAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
    }
}

extension DeleteConnectionAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConnectionAliasInput: Swift.Equatable {
    /// The identifier of the connection alias to delete.
    /// This member is required.
    public var aliasId: Swift.String?

    public init (
        aliasId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

struct DeleteConnectionAliasInputBody: Swift.Equatable {
    let aliasId: Swift.String?
}

extension DeleteConnectionAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
    }
}

extension DeleteConnectionAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConnectionAliasOutputResponse: Swift.Equatable {

}

extension DeleteIpGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
    }
}

extension DeleteIpGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteIpGroupInput: Swift.Equatable {
    /// The identifier of the IP access control group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct DeleteIpGroupInputBody: Swift.Equatable {
    let groupId: Swift.String?
}

extension DeleteIpGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DeleteIpGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIpGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIpGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIpGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIpGroupOutputResponse: Swift.Equatable {

}

extension DeleteTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension DeleteTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTagsInput: Swift.Equatable {
    /// The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces, registered directories, images, custom bundles, IP access control groups, and connection aliases.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeys = tagKeys
    }
}

struct DeleteTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagKeys: [Swift.String]?
}

extension DeleteTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension DeleteTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsOutputResponse: Swift.Equatable {

}

extension DeleteWorkspaceBundleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
    }
}

extension DeleteWorkspaceBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkspaceBundleInput: Swift.Equatable {
    /// The identifier of the bundle.
    public var bundleId: Swift.String?

    public init (
        bundleId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
    }
}

struct DeleteWorkspaceBundleInputBody: Swift.Equatable {
    let bundleId: Swift.String?
}

extension DeleteWorkspaceBundleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
    }
}

extension DeleteWorkspaceBundleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkspaceBundleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkspaceBundleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkspaceBundleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkspaceBundleOutputResponse: Swift.Equatable {

}

extension DeleteWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }
}

extension DeleteWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkspaceImageInput: Swift.Equatable {
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?

    public init (
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct DeleteWorkspaceImageInputBody: Swift.Equatable {
    let imageId: Swift.String?
}

extension DeleteWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension DeleteWorkspaceImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkspaceImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkspaceImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceAssociatedException(ResourceAssociatedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkspaceImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkspaceImageOutputResponse: Swift.Equatable {

}

extension DeregisterWorkspaceDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension DeregisterWorkspaceDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterWorkspaceDirectoryInput: Swift.Equatable {
    /// The identifier of the directory. If any WorkSpaces are registered to this directory, you must remove them before you deregister the directory, or you will receive an OperationNotSupportedException error.
    /// This member is required.
    public var directoryId: Swift.String?

    public init (
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct DeregisterWorkspaceDirectoryInputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension DeregisterWorkspaceDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension DeregisterWorkspaceDirectoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterWorkspaceDirectoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterWorkspaceDirectoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterWorkspaceDirectoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterWorkspaceDirectoryOutputResponse: Swift.Equatable {

}

extension DescribeAccountInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountInput: Swift.Equatable {

}

struct DescribeAccountInputBody: Swift.Equatable {
}

extension DescribeAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountModificationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAccountModificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountModificationsInput: Swift.Equatable {
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct DescribeAccountModificationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension DescribeAccountModificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAccountModificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountModificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountModificationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountModificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountModificationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountModifications = output.accountModifications
            self.nextToken = output.nextToken
        } else {
            self.accountModifications = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAccountModificationsOutputResponse: Swift.Equatable {
    /// The list of modifications to the configuration of BYOL.
    public var accountModifications: [WorkSpacesClientTypes.AccountModification]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        accountModifications: [WorkSpacesClientTypes.AccountModification]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountModifications = accountModifications
        self.nextToken = nextToken
    }
}

struct DescribeAccountModificationsOutputResponseBody: Swift.Equatable {
    let accountModifications: [WorkSpacesClientTypes.AccountModification]?
    let nextToken: Swift.String?
}

extension DescribeAccountModificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountModifications = "AccountModifications"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountModificationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.AccountModification?].self, forKey: .accountModifications)
        var accountModificationsDecoded0:[WorkSpacesClientTypes.AccountModification]? = nil
        if let accountModificationsContainer = accountModificationsContainer {
            accountModificationsDecoded0 = [WorkSpacesClientTypes.AccountModification]()
            for structure0 in accountModificationsContainer {
                if let structure0 = structure0 {
                    accountModificationsDecoded0?.append(structure0)
                }
            }
        }
        accountModifications = accountModificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dedicatedTenancyManagementCidrRange = output.dedicatedTenancyManagementCidrRange
            self.dedicatedTenancySupport = output.dedicatedTenancySupport
        } else {
            self.dedicatedTenancyManagementCidrRange = nil
            self.dedicatedTenancySupport = nil
        }
    }
}

public struct DescribeAccountOutputResponse: Swift.Equatable {
    /// The IP address range, specified as an IPv4 CIDR block, used for the management network interface. The management network interface is connected to a secure Amazon WorkSpaces management network. It is used for interactive streaming of the WorkSpace desktop to Amazon WorkSpaces clients, and to allow Amazon WorkSpaces to manage the WorkSpace.
    public var dedicatedTenancyManagementCidrRange: Swift.String?
    /// The status of BYOL (whether BYOL is enabled or disabled).
    public var dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum?

    public init (
        dedicatedTenancyManagementCidrRange: Swift.String? = nil,
        dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum? = nil
    )
    {
        self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
        self.dedicatedTenancySupport = dedicatedTenancySupport
    }
}

struct DescribeAccountOutputResponseBody: Swift.Equatable {
    let dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum?
    let dedicatedTenancyManagementCidrRange: Swift.String?
}

extension DescribeAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedTenancySupportDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DedicatedTenancySupportResultEnum.self, forKey: .dedicatedTenancySupport)
        dedicatedTenancySupport = dedicatedTenancySupportDecoded
        let dedicatedTenancyManagementCidrRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedTenancyManagementCidrRange)
        dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRangeDecoded
    }
}

extension DescribeClientPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIds = "ResourceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for resourceidlist0 in resourceIds {
                try resourceIdsContainer.encode(resourceidlist0)
            }
        }
    }
}

extension DescribeClientPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeClientPropertiesInput: Swift.Equatable {
    /// The resource identifier, in the form of directory IDs.
    /// This member is required.
    public var resourceIds: [Swift.String]?

    public init (
        resourceIds: [Swift.String]? = nil
    )
    {
        self.resourceIds = resourceIds
    }
}

struct DescribeClientPropertiesInputBody: Swift.Equatable {
    let resourceIds: [Swift.String]?
}

extension DescribeClientPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIds = "ResourceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Swift.String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Swift.String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
    }
}

extension DescribeClientPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClientPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClientPropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClientPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClientPropertiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientPropertiesList = output.clientPropertiesList
        } else {
            self.clientPropertiesList = nil
        }
    }
}

public struct DescribeClientPropertiesOutputResponse: Swift.Equatable {
    /// Information about the specified Amazon WorkSpaces clients.
    public var clientPropertiesList: [WorkSpacesClientTypes.ClientPropertiesResult]?

    public init (
        clientPropertiesList: [WorkSpacesClientTypes.ClientPropertiesResult]? = nil
    )
    {
        self.clientPropertiesList = clientPropertiesList
    }
}

struct DescribeClientPropertiesOutputResponseBody: Swift.Equatable {
    let clientPropertiesList: [WorkSpacesClientTypes.ClientPropertiesResult]?
}

extension DescribeClientPropertiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientPropertiesList = "ClientPropertiesList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientPropertiesListContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ClientPropertiesResult?].self, forKey: .clientPropertiesList)
        var clientPropertiesListDecoded0:[WorkSpacesClientTypes.ClientPropertiesResult]? = nil
        if let clientPropertiesListContainer = clientPropertiesListContainer {
            clientPropertiesListDecoded0 = [WorkSpacesClientTypes.ClientPropertiesResult]()
            for structure0 in clientPropertiesListContainer {
                if let structure0 = structure0 {
                    clientPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        clientPropertiesList = clientPropertiesListDecoded0
    }
}

extension DescribeConnectionAliasPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConnectionAliasPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectionAliasPermissionsInput: Swift.Equatable {
    /// The identifier of the connection alias.
    /// This member is required.
    public var aliasId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        aliasId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeConnectionAliasPermissionsInputBody: Swift.Equatable {
    let aliasId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeConnectionAliasPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeConnectionAliasPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionAliasPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectionAliasPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionAliasPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectionAliasPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasId = output.aliasId
            self.connectionAliasPermissions = output.connectionAliasPermissions
            self.nextToken = output.nextToken
        } else {
            self.aliasId = nil
            self.connectionAliasPermissions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectionAliasPermissionsOutputResponse: Swift.Equatable {
    /// The identifier of the connection alias.
    public var aliasId: Swift.String?
    /// The permissions associated with a connection alias.
    public var connectionAliasPermissions: [WorkSpacesClientTypes.ConnectionAliasPermission]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        aliasId: Swift.String? = nil,
        connectionAliasPermissions: [WorkSpacesClientTypes.ConnectionAliasPermission]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
        self.connectionAliasPermissions = connectionAliasPermissions
        self.nextToken = nextToken
    }
}

struct DescribeConnectionAliasPermissionsOutputResponseBody: Swift.Equatable {
    let aliasId: Swift.String?
    let connectionAliasPermissions: [WorkSpacesClientTypes.ConnectionAliasPermission]?
    let nextToken: Swift.String?
}

extension DescribeConnectionAliasPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case connectionAliasPermissions = "ConnectionAliasPermissions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let connectionAliasPermissionsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ConnectionAliasPermission?].self, forKey: .connectionAliasPermissions)
        var connectionAliasPermissionsDecoded0:[WorkSpacesClientTypes.ConnectionAliasPermission]? = nil
        if let connectionAliasPermissionsContainer = connectionAliasPermissionsContainer {
            connectionAliasPermissionsDecoded0 = [WorkSpacesClientTypes.ConnectionAliasPermission]()
            for structure0 in connectionAliasPermissionsContainer {
                if let structure0 = structure0 {
                    connectionAliasPermissionsDecoded0?.append(structure0)
                }
            }
        }
        connectionAliasPermissions = connectionAliasPermissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectionAliasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasIds = "AliasIds"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasIds = aliasIds {
            var aliasIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliasIds)
            for connectionaliasidlist0 in aliasIds {
                try aliasIdsContainer.encode(connectionaliasidlist0)
            }
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DescribeConnectionAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectionAliasesInput: Swift.Equatable {
    /// The identifiers of the connection aliases to describe.
    public var aliasIds: [Swift.String]?
    /// The maximum number of connection aliases to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the directory associated with the connection alias.
    public var resourceId: Swift.String?

    public init (
        aliasIds: [Swift.String]? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.aliasIds = aliasIds
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct DescribeConnectionAliasesInputBody: Swift.Equatable {
    let aliasIds: [Swift.String]?
    let resourceId: Swift.String?
    let limit: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeConnectionAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasIds = "AliasIds"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .aliasIds)
        var aliasIdsDecoded0:[Swift.String]? = nil
        if let aliasIdsContainer = aliasIdsContainer {
            aliasIdsDecoded0 = [Swift.String]()
            for string0 in aliasIdsContainer {
                if let string0 = string0 {
                    aliasIdsDecoded0?.append(string0)
                }
            }
        }
        aliasIds = aliasIdsDecoded0
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectionAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectionAliasesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConnectionAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionAliases = output.connectionAliases
            self.nextToken = output.nextToken
        } else {
            self.connectionAliases = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectionAliasesOutputResponse: Swift.Equatable {
    /// Information about the specified connection aliases.
    public var connectionAliases: [WorkSpacesClientTypes.ConnectionAlias]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        connectionAliases: [WorkSpacesClientTypes.ConnectionAlias]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionAliases = connectionAliases
        self.nextToken = nextToken
    }
}

struct DescribeConnectionAliasesOutputResponseBody: Swift.Equatable {
    let connectionAliases: [WorkSpacesClientTypes.ConnectionAlias]?
    let nextToken: Swift.String?
}

extension DescribeConnectionAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionAliases = "ConnectionAliases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionAliasesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ConnectionAlias?].self, forKey: .connectionAliases)
        var connectionAliasesDecoded0:[WorkSpacesClientTypes.ConnectionAlias]? = nil
        if let connectionAliasesContainer = connectionAliasesContainer {
            connectionAliasesDecoded0 = [WorkSpacesClientTypes.ConnectionAlias]()
            for structure0 in connectionAliasesContainer {
                if let structure0 = structure0 {
                    connectionAliasesDecoded0?.append(structure0)
                }
            }
        }
        connectionAliases = connectionAliasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeIpGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIds = "GroupIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for ipgroupidlist0 in groupIds {
                try groupIdsContainer.encode(ipgroupidlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeIpGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeIpGroupsInput: Swift.Equatable {
    /// The identifiers of one or more IP access control groups.
    public var groupIds: [Swift.String]?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        groupIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupIds = groupIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeIpGroupsInputBody: Swift.Equatable {
    let groupIds: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeIpGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIds = "GroupIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[Swift.String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [Swift.String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeIpGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIpGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIpGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIpGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIpGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.result = output.result
        } else {
            self.nextToken = nil
            self.result = nil
        }
    }
}

public struct DescribeIpGroupsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the IP access control groups.
    public var result: [WorkSpacesClientTypes.WorkspacesIpGroup]?

    public init (
        nextToken: Swift.String? = nil,
        result: [WorkSpacesClientTypes.WorkspacesIpGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.result = result
    }
}

struct DescribeIpGroupsOutputResponseBody: Swift.Equatable {
    let result: [WorkSpacesClientTypes.WorkspacesIpGroup]?
    let nextToken: Swift.String?
}

extension DescribeIpGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case result = "Result"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspacesIpGroup?].self, forKey: .result)
        var resultDecoded0:[WorkSpacesClientTypes.WorkspacesIpGroup]? = nil
        if let resultContainer = resultContainer {
            resultDecoded0 = [WorkSpacesClientTypes.WorkspacesIpGroup]()
            for structure0 in resultContainer {
                if let structure0 = structure0 {
                    resultDecoded0?.append(structure0)
                }
            }
        }
        result = resultDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DescribeTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeTagsInput: Swift.Equatable {
    /// The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces, registered directories, images, custom bundles, IP access control groups, and connection aliases.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct DescribeTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension DescribeTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DescribeTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct DescribeTagsOutputResponse: Swift.Equatable {
    /// The tags.
    public var tagList: [WorkSpacesClientTypes.Tag]?

    public init (
        tagList: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct DescribeTagsOutputResponseBody: Swift.Equatable {
    let tagList: [WorkSpacesClientTypes.Tag]?
}

extension DescribeTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension DescribeWorkspaceBundlesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleIds = "BundleIds"
        case nextToken = "NextToken"
        case owner = "Owner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleIds = bundleIds {
            var bundleIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bundleIds)
            for bundleidlist0 in bundleIds {
                try bundleIdsContainer.encode(bundleidlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
    }
}

extension DescribeWorkspaceBundlesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceBundlesInput: Swift.Equatable {
    /// The identifiers of the bundles. You cannot combine this parameter with any other filter.
    public var bundleIds: [Swift.String]?
    /// The token for the next set of results. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The owner of the bundles. You cannot combine this parameter with any other filter. To describe the bundles provided by Amazon Web Services, specify AMAZON. To describe the bundles that belong to your account, don't specify a value.
    public var owner: Swift.String?

    public init (
        bundleIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        owner: Swift.String? = nil
    )
    {
        self.bundleIds = bundleIds
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct DescribeWorkspaceBundlesInputBody: Swift.Equatable {
    let bundleIds: [Swift.String]?
    let owner: Swift.String?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceBundlesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleIds = "BundleIds"
        case nextToken = "NextToken"
        case owner = "Owner"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bundleIds)
        var bundleIdsDecoded0:[Swift.String]? = nil
        if let bundleIdsContainer = bundleIdsContainer {
            bundleIdsDecoded0 = [Swift.String]()
            for string0 in bundleIdsContainer {
                if let string0 = string0 {
                    bundleIdsDecoded0?.append(string0)
                }
            }
        }
        bundleIds = bundleIdsDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceBundlesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceBundlesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceBundlesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceBundlesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkspaceBundlesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bundles = output.bundles
            self.nextToken = output.nextToken
        } else {
            self.bundles = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceBundlesOutputResponse: Swift.Equatable {
    /// Information about the bundles.
    public var bundles: [WorkSpacesClientTypes.WorkspaceBundle]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return. This token is valid for one day and must be used within that time frame.
    public var nextToken: Swift.String?

    public init (
        bundles: [WorkSpacesClientTypes.WorkspaceBundle]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bundles = bundles
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceBundlesOutputResponseBody: Swift.Equatable {
    let bundles: [WorkSpacesClientTypes.WorkspaceBundle]?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceBundlesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundles = "Bundles"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundlesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceBundle?].self, forKey: .bundles)
        var bundlesDecoded0:[WorkSpacesClientTypes.WorkspaceBundle]? = nil
        if let bundlesContainer = bundlesContainer {
            bundlesDecoded0 = [WorkSpacesClientTypes.WorkspaceBundle]()
            for structure0 in bundlesContainer {
                if let structure0 = structure0 {
                    bundlesDecoded0?.append(structure0)
                }
            }
        }
        bundles = bundlesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceDirectoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryIds = "DirectoryIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryIds = directoryIds {
            var directoryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .directoryIds)
            for directoryidlist0 in directoryIds {
                try directoryIdsContainer.encode(directoryidlist0)
            }
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeWorkspaceDirectoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceDirectoriesInput: Swift.Equatable {
    /// The identifiers of the directories. If the value is null, all directories are retrieved.
    public var directoryIds: [Swift.String]?
    /// The maximum number of directories to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        directoryIds: [Swift.String]? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryIds = directoryIds
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceDirectoriesInputBody: Swift.Equatable {
    let directoryIds: [Swift.String]?
    let limit: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceDirectoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryIds = "DirectoryIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .directoryIds)
        var directoryIdsDecoded0:[Swift.String]? = nil
        if let directoryIdsContainer = directoryIdsContainer {
            directoryIdsDecoded0 = [Swift.String]()
            for string0 in directoryIdsContainer {
                if let string0 = string0 {
                    directoryIdsDecoded0?.append(string0)
                }
            }
        }
        directoryIds = directoryIdsDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceDirectoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceDirectoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceDirectoriesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceDirectoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkspaceDirectoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directories = output.directories
            self.nextToken = output.nextToken
        } else {
            self.directories = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceDirectoriesOutputResponse: Swift.Equatable {
    /// Information about the directories.
    public var directories: [WorkSpacesClientTypes.WorkspaceDirectory]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        directories: [WorkSpacesClientTypes.WorkspaceDirectory]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directories = directories
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceDirectoriesOutputResponseBody: Swift.Equatable {
    let directories: [WorkSpacesClientTypes.WorkspaceDirectory]?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceDirectoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directories = "Directories"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoriesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceDirectory?].self, forKey: .directories)
        var directoriesDecoded0:[WorkSpacesClientTypes.WorkspaceDirectory]? = nil
        if let directoriesContainer = directoriesContainer {
            directoriesDecoded0 = [WorkSpacesClientTypes.WorkspaceDirectory]()
            for structure0 in directoriesContainer {
                if let structure0 = structure0 {
                    directoriesDecoded0?.append(structure0)
                }
            }
        }
        directories = directoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceImagePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeWorkspaceImagePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceImagePermissionsInput: Swift.Equatable {
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        imageId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagePermissionsInputBody: Swift.Equatable {
    let imageId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeWorkspaceImagePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeWorkspaceImagePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceImagePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceImagePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceImagePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkspaceImagePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
            self.imagePermissions = output.imagePermissions
            self.nextToken = output.nextToken
        } else {
            self.imageId = nil
            self.imagePermissions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceImagePermissionsOutputResponse: Swift.Equatable {
    /// The identifier of the image.
    public var imageId: Swift.String?
    /// The identifiers of the Amazon Web Services accounts that the image has been shared with.
    public var imagePermissions: [WorkSpacesClientTypes.ImagePermission]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        imageId: Swift.String? = nil,
        imagePermissions: [WorkSpacesClientTypes.ImagePermission]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.imagePermissions = imagePermissions
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagePermissionsOutputResponseBody: Swift.Equatable {
    let imageId: Swift.String?
    let imagePermissions: [WorkSpacesClientTypes.ImagePermission]?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceImagePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
        case imagePermissions = "ImagePermissions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imagePermissionsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ImagePermission?].self, forKey: .imagePermissions)
        var imagePermissionsDecoded0:[WorkSpacesClientTypes.ImagePermission]? = nil
        if let imagePermissionsContainer = imagePermissionsContainer {
            imagePermissionsDecoded0 = [WorkSpacesClientTypes.ImagePermission]()
            for structure0 in imagePermissionsContainer {
                if let structure0 = structure0 {
                    imagePermissionsDecoded0?.append(structure0)
                }
            }
        }
        imagePermissions = imagePermissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds = "ImageIds"
        case imageType = "ImageType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for workspaceimageidlist0 in imageIds {
                try imageIdsContainer.encode(workspaceimageidlist0)
            }
        }
        if let imageType = imageType {
            try encodeContainer.encode(imageType.rawValue, forKey: .imageType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeWorkspaceImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceImagesInput: Swift.Equatable {
    /// The identifier of the image.
    public var imageIds: [Swift.String]?
    /// The type (owned or shared) of the image.
    public var imageType: WorkSpacesClientTypes.ImageType?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        imageIds: [Swift.String]? = nil,
        imageType: WorkSpacesClientTypes.ImageType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageIds = imageIds
        self.imageType = imageType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagesInputBody: Swift.Equatable {
    let imageIds: [Swift.String]?
    let imageType: WorkSpacesClientTypes.ImageType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeWorkspaceImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds = "ImageIds"
        case imageType = "ImageType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageIds)
        var imageIdsDecoded0:[Swift.String]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [Swift.String]()
            for string0 in imageIdsContainer {
                if let string0 = string0 {
                    imageIdsDecoded0?.append(string0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let imageTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ImageType.self, forKey: .imageType)
        imageType = imageTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeWorkspaceImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceImagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkspaceImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.images = output.images
            self.nextToken = output.nextToken
        } else {
            self.images = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceImagesOutputResponse: Swift.Equatable {
    /// Information about the images.
    public var images: [WorkSpacesClientTypes.WorkspaceImage]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        images: [WorkSpacesClientTypes.WorkspaceImage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.images = images
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagesOutputResponseBody: Swift.Equatable {
    let images: [WorkSpacesClientTypes.WorkspaceImage]?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case images = "Images"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceImage?].self, forKey: .images)
        var imagesDecoded0:[WorkSpacesClientTypes.WorkspaceImage]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [WorkSpacesClientTypes.WorkspaceImage]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceSnapshotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension DescribeWorkspaceSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceSnapshotsInput: Swift.Equatable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceSnapshotsInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
}

extension DescribeWorkspaceSnapshotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension DescribeWorkspaceSnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceSnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceSnapshotsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkspaceSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rebuildSnapshots = output.rebuildSnapshots
            self.restoreSnapshots = output.restoreSnapshots
        } else {
            self.rebuildSnapshots = nil
            self.restoreSnapshots = nil
        }
    }
}

public struct DescribeWorkspaceSnapshotsOutputResponse: Swift.Equatable {
    /// Information about the snapshots that can be used to rebuild a WorkSpace. These snapshots include the user volume.
    public var rebuildSnapshots: [WorkSpacesClientTypes.Snapshot]?
    /// Information about the snapshots that can be used to restore a WorkSpace. These snapshots include both the root volume and the user volume.
    public var restoreSnapshots: [WorkSpacesClientTypes.Snapshot]?

    public init (
        rebuildSnapshots: [WorkSpacesClientTypes.Snapshot]? = nil,
        restoreSnapshots: [WorkSpacesClientTypes.Snapshot]? = nil
    )
    {
        self.rebuildSnapshots = rebuildSnapshots
        self.restoreSnapshots = restoreSnapshots
    }
}

struct DescribeWorkspaceSnapshotsOutputResponseBody: Swift.Equatable {
    let rebuildSnapshots: [WorkSpacesClientTypes.Snapshot]?
    let restoreSnapshots: [WorkSpacesClientTypes.Snapshot]?
}

extension DescribeWorkspaceSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebuildSnapshots = "RebuildSnapshots"
        case restoreSnapshots = "RestoreSnapshots"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rebuildSnapshotsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Snapshot?].self, forKey: .rebuildSnapshots)
        var rebuildSnapshotsDecoded0:[WorkSpacesClientTypes.Snapshot]? = nil
        if let rebuildSnapshotsContainer = rebuildSnapshotsContainer {
            rebuildSnapshotsDecoded0 = [WorkSpacesClientTypes.Snapshot]()
            for structure0 in rebuildSnapshotsContainer {
                if let structure0 = structure0 {
                    rebuildSnapshotsDecoded0?.append(structure0)
                }
            }
        }
        rebuildSnapshots = rebuildSnapshotsDecoded0
        let restoreSnapshotsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Snapshot?].self, forKey: .restoreSnapshots)
        var restoreSnapshotsDecoded0:[WorkSpacesClientTypes.Snapshot]? = nil
        if let restoreSnapshotsContainer = restoreSnapshotsContainer {
            restoreSnapshotsDecoded0 = [WorkSpacesClientTypes.Snapshot]()
            for structure0 in restoreSnapshotsContainer {
                if let structure0 = structure0 {
                    restoreSnapshotsDecoded0?.append(structure0)
                }
            }
        }
        restoreSnapshots = restoreSnapshotsDecoded0
    }
}

extension DescribeWorkspacesConnectionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workspaceIds = "WorkspaceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workspaceIds = workspaceIds {
            var workspaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceIds)
            for workspaceidlist0 in workspaceIds {
                try workspaceIdsContainer.encode(workspaceidlist0)
            }
        }
    }
}

extension DescribeWorkspacesConnectionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspacesConnectionStatusInput: Swift.Equatable {
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The identifiers of the WorkSpaces. You can specify up to 25 WorkSpaces.
    public var workspaceIds: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        workspaceIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaceIds = workspaceIds
    }
}

struct DescribeWorkspacesConnectionStatusInputBody: Swift.Equatable {
    let workspaceIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension DescribeWorkspacesConnectionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workspaceIds = "WorkspaceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workspaceIds)
        var workspaceIdsDecoded0:[Swift.String]? = nil
        if let workspaceIdsContainer = workspaceIdsContainer {
            workspaceIdsDecoded0 = [Swift.String]()
            for string0 in workspaceIdsContainer {
                if let string0 = string0 {
                    workspaceIdsDecoded0?.append(string0)
                }
            }
        }
        workspaceIds = workspaceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspacesConnectionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspacesConnectionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspacesConnectionStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspacesConnectionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkspacesConnectionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspacesConnectionStatus = output.workspacesConnectionStatus
        } else {
            self.nextToken = nil
            self.workspacesConnectionStatus = nil
        }
    }
}

public struct DescribeWorkspacesConnectionStatusOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the connection status of the WorkSpace.
    public var workspacesConnectionStatus: [WorkSpacesClientTypes.WorkspaceConnectionStatus]?

    public init (
        nextToken: Swift.String? = nil,
        workspacesConnectionStatus: [WorkSpacesClientTypes.WorkspaceConnectionStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspacesConnectionStatus = workspacesConnectionStatus
    }
}

struct DescribeWorkspacesConnectionStatusOutputResponseBody: Swift.Equatable {
    let workspacesConnectionStatus: [WorkSpacesClientTypes.WorkspaceConnectionStatus]?
    let nextToken: Swift.String?
}

extension DescribeWorkspacesConnectionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workspacesConnectionStatus = "WorkspacesConnectionStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesConnectionStatusContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceConnectionStatus?].self, forKey: .workspacesConnectionStatus)
        var workspacesConnectionStatusDecoded0:[WorkSpacesClientTypes.WorkspaceConnectionStatus]? = nil
        if let workspacesConnectionStatusContainer = workspacesConnectionStatusContainer {
            workspacesConnectionStatusDecoded0 = [WorkSpacesClientTypes.WorkspaceConnectionStatus]()
            for structure0 in workspacesConnectionStatusContainer {
                if let structure0 = structure0 {
                    workspacesConnectionStatusDecoded0?.append(structure0)
                }
            }
        }
        workspacesConnectionStatus = workspacesConnectionStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case userName = "UserName"
        case workspaceIds = "WorkspaceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let workspaceIds = workspaceIds {
            var workspaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceIds)
            for workspaceidlist0 in workspaceIds {
                try workspaceIdsContainer.encode(workspaceidlist0)
            }
        }
    }
}

extension DescribeWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspacesInput: Swift.Equatable {
    /// The identifier of the bundle. All WorkSpaces that are created from this bundle are retrieved. You cannot combine this parameter with any other filter.
    public var bundleId: Swift.String?
    /// The identifier of the directory. In addition, you can optionally specify a specific directory user (see UserName). You cannot combine this parameter with any other filter.
    public var directoryId: Swift.String?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The name of the directory user. You must specify this parameter with DirectoryId.
    public var userName: Swift.String?
    /// The identifiers of the WorkSpaces. You cannot combine this parameter with any other filter. Because the [CreateWorkspaces] operation is asynchronous, the identifier it returns is not immediately available. If you immediately call [DescribeWorkspaces] with this identifier, no information is returned.
    public var workspaceIds: [Swift.String]?

    public init (
        bundleId: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userName: Swift.String? = nil,
        workspaceIds: [Swift.String]? = nil
    )
    {
        self.bundleId = bundleId
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
        self.userName = userName
        self.workspaceIds = workspaceIds
    }
}

struct DescribeWorkspacesInputBody: Swift.Equatable {
    let workspaceIds: [Swift.String]?
    let directoryId: Swift.String?
    let userName: Swift.String?
    let bundleId: Swift.String?
    let limit: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case userName = "UserName"
        case workspaceIds = "WorkspaceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workspaceIds)
        var workspaceIdsDecoded0:[Swift.String]? = nil
        if let workspaceIdsContainer = workspaceIdsContainer {
            workspaceIdsDecoded0 = [Swift.String]()
            for string0 in workspaceIdsContainer {
                if let string0 = string0 {
                    workspaceIdsDecoded0?.append(string0)
                }
            }
        }
        workspaceIds = workspaceIdsDecoded0
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspaces = output.workspaces
        } else {
            self.nextToken = nil
            self.workspaces = nil
        }
    }
}

public struct DescribeWorkspacesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the WorkSpaces. Because [CreateWorkspaces] is an asynchronous operation, some of the returned information could be incomplete.
    public var workspaces: [WorkSpacesClientTypes.Workspace]?

    public init (
        nextToken: Swift.String? = nil,
        workspaces: [WorkSpacesClientTypes.Workspace]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaces = workspaces
    }
}

struct DescribeWorkspacesOutputResponseBody: Swift.Equatable {
    let workspaces: [WorkSpacesClientTypes.Workspace]?
    let nextToken: Swift.String?
}

extension DescribeWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workspaces = "Workspaces"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Workspace?].self, forKey: .workspaces)
        var workspacesDecoded0:[WorkSpacesClientTypes.Workspace]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [WorkSpacesClientTypes.Workspace]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DisassociateConnectionAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
    }
}

extension DisassociateConnectionAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateConnectionAliasInput: Swift.Equatable {
    /// The identifier of the connection alias to disassociate.
    /// This member is required.
    public var aliasId: Swift.String?

    public init (
        aliasId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

struct DisassociateConnectionAliasInputBody: Swift.Equatable {
    let aliasId: Swift.String?
}

extension DisassociateConnectionAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
    }
}

extension DisassociateConnectionAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateConnectionAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateConnectionAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateConnectionAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateConnectionAliasOutputResponse: Swift.Equatable {

}

extension DisassociateIpGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for ipgroupidlist0 in groupIds {
                try groupIdsContainer.encode(ipgroupidlist0)
            }
        }
    }
}

extension DisassociateIpGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateIpGroupsInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The identifiers of one or more IP access control groups.
    /// This member is required.
    public var groupIds: [Swift.String]?

    public init (
        directoryId: Swift.String? = nil,
        groupIds: [Swift.String]? = nil
    )
    {
        self.directoryId = directoryId
        self.groupIds = groupIds
    }
}

struct DisassociateIpGroupsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let groupIds: [Swift.String]?
}

extension DisassociateIpGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let groupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[Swift.String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [Swift.String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
    }
}

extension DisassociateIpGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateIpGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateIpGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateIpGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateIpGroupsOutputResponse: Swift.Equatable {

}

extension WorkSpacesClientTypes.FailedCreateWorkspaceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case workspaceRequest = "WorkspaceRequest"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let workspaceRequest = workspaceRequest {
            try encodeContainer.encode(workspaceRequest, forKey: .workspaceRequest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceRequestDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceRequest.self, forKey: .workspaceRequest)
        workspaceRequest = workspaceRequestDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace that cannot be created.
    public struct FailedCreateWorkspaceRequest: Swift.Equatable {
        /// The error code that is returned if the WorkSpace cannot be created.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the WorkSpace cannot be created.
        public var errorMessage: Swift.String?
        /// Information about the WorkSpace.
        public var workspaceRequest: WorkSpacesClientTypes.WorkspaceRequest?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            workspaceRequest: WorkSpacesClientTypes.WorkspaceRequest? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.workspaceRequest = workspaceRequest
        }
    }

}

extension WorkSpacesClientTypes.FailedWorkspaceChangeRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace that could not be rebooted. ([RebootWorkspaces]), rebuilt ([RebuildWorkspaces]), restored ([RestoreWorkspace]), terminated ([TerminateWorkspaces]), started ([StartWorkspaces]), or stopped ([StopWorkspaces]).
    public struct FailedWorkspaceChangeRequest: Swift.Equatable {
        /// The error code that is returned if the WorkSpace cannot be rebooted.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the WorkSpace cannot be rebooted.
        public var errorMessage: Swift.String?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.workspaceId = workspaceId
        }
    }

}

extension WorkSpacesClientTypes.ImagePermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the Amazon Web Services accounts that have been granted permission to use a shared image. For more information about sharing images, see [ Share or Unshare a Custom WorkSpaces Image](https://docs.aws.amazon.com/workspaces/latest/adminguide/share-custom-image.html).
    public struct ImagePermission: Swift.Equatable {
        /// The identifier of the Amazon Web Services account that an image has been shared with.
        public var sharedAccountId: Swift.String?

        public init (
            sharedAccountId: Swift.String? = nil
        )
        {
            self.sharedAccountId = sharedAccountId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum ImageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case owned
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageType] {
            return [
                .owned,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .owned: return "OWNED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageType(rawValue: rawValue) ?? ImageType.sdkUnknown(rawValue)
        }
    }
}

extension ImportWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case ec2ImageId = "Ec2ImageId"
        case imageDescription = "ImageDescription"
        case imageName = "ImageName"
        case ingestionProcess = "IngestionProcess"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for applicationlist0 in applications {
                try applicationsContainer.encode(applicationlist0.rawValue)
            }
        }
        if let ec2ImageId = ec2ImageId {
            try encodeContainer.encode(ec2ImageId, forKey: .ec2ImageId)
        }
        if let imageDescription = imageDescription {
            try encodeContainer.encode(imageDescription, forKey: .imageDescription)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let ingestionProcess = ingestionProcess {
            try encodeContainer.encode(ingestionProcess.rawValue, forKey: .ingestionProcess)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension ImportWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportWorkspaceImageInput: Swift.Equatable {
    /// If specified, the version of Microsoft Office to subscribe to. Valid only for Windows 10 BYOL images. For more information about subscribing to Office for BYOL images, see [ Bring Your Own Windows Desktop Licenses](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html). Although this parameter is an array, only one item is allowed at this time.
    public var applications: [WorkSpacesClientTypes.Application]?
    /// The identifier of the EC2 image.
    /// This member is required.
    public var ec2ImageId: Swift.String?
    /// The description of the WorkSpace image.
    /// This member is required.
    public var imageDescription: Swift.String?
    /// The name of the WorkSpace image.
    /// This member is required.
    public var imageName: Swift.String?
    /// The ingestion process to be used when importing the image, depending on which protocol you want to use for your BYOL Workspace image, either PCoIP or WorkSpaces Streaming Protocol (WSP). To use WSP, specify a value that ends in _WSP. To use PCoIP, specify a value that does not end in _WSP. For non-GPU-enabled bundles (bundles other than Graphics or GraphicsPro), specify BYOL_REGULAR or BYOL_REGULAR_WSP, depending on the protocol.
    /// This member is required.
    public var ingestionProcess: WorkSpacesClientTypes.WorkspaceImageIngestionProcess?
    /// The tags. Each WorkSpaces resource can have a maximum of 50 tags.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init (
        applications: [WorkSpacesClientTypes.Application]? = nil,
        ec2ImageId: Swift.String? = nil,
        imageDescription: Swift.String? = nil,
        imageName: Swift.String? = nil,
        ingestionProcess: WorkSpacesClientTypes.WorkspaceImageIngestionProcess? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.applications = applications
        self.ec2ImageId = ec2ImageId
        self.imageDescription = imageDescription
        self.imageName = imageName
        self.ingestionProcess = ingestionProcess
        self.tags = tags
    }
}

struct ImportWorkspaceImageInputBody: Swift.Equatable {
    let ec2ImageId: Swift.String?
    let ingestionProcess: WorkSpacesClientTypes.WorkspaceImageIngestionProcess?
    let imageName: Swift.String?
    let imageDescription: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
    let applications: [WorkSpacesClientTypes.Application]?
}

extension ImportWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case ec2ImageId = "Ec2ImageId"
        case imageDescription = "ImageDescription"
        case imageName = "ImageName"
        case ingestionProcess = "IngestionProcess"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2ImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2ImageId)
        ec2ImageId = ec2ImageIdDecoded
        let ingestionProcessDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageIngestionProcess.self, forKey: .ingestionProcess)
        ingestionProcess = ingestionProcessDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDescription)
        imageDescription = imageDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let applicationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[WorkSpacesClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [WorkSpacesClientTypes.Application]()
            for string0 in applicationsContainer {
                if let string0 = string0 {
                    applicationsDecoded0?.append(string0)
                }
            }
        }
        applications = applicationsDecoded0
    }
}

extension ImportWorkspaceImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportWorkspaceImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportWorkspaceImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportWorkspaceImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportWorkspaceImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
        } else {
            self.imageId = nil
        }
    }
}

public struct ImportWorkspaceImageOutputResponse: Swift.Equatable {
    /// The identifier of the WorkSpace image.
    public var imageId: Swift.String?

    public init (
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct ImportWorkspaceImageOutputResponseBody: Swift.Equatable {
    let imageId: Swift.String?
}

extension ImportWorkspaceImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension InvalidParameterValuesException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterValuesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameter values are not valid.
public struct InvalidParameterValuesException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception error message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValuesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterValuesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The state of the resource is not valid for this operation.
public struct InvalidResourceStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesClientTypes.IpRuleItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipRule
        case ruleDesc
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipRule = ipRule {
            try encodeContainer.encode(ipRule, forKey: .ipRule)
        }
        if let ruleDesc = ruleDesc {
            try encodeContainer.encode(ruleDesc, forKey: .ruleDesc)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipRuleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipRule)
        ipRule = ipRuleDecoded
        let ruleDescDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleDesc)
        ruleDesc = ruleDescDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a rule for an IP access control group.
    public struct IpRuleItem: Swift.Equatable {
        /// The IP address range, in CIDR notation.
        public var ipRule: Swift.String?
        /// The description.
        public var ruleDesc: Swift.String?

        public init (
            ipRule: Swift.String? = nil,
            ruleDesc: Swift.String? = nil
        )
        {
            self.ipRule = ipRule
            self.ruleDesc = ruleDesc
        }
    }

}

extension ListAvailableManagementCidrRangesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managementCidrRangeConstraint = "ManagementCidrRangeConstraint"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let managementCidrRangeConstraint = managementCidrRangeConstraint {
            try encodeContainer.encode(managementCidrRangeConstraint, forKey: .managementCidrRangeConstraint)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAvailableManagementCidrRangesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAvailableManagementCidrRangesInput: Swift.Equatable {
    /// The IP address range to search. Specify an IP address range that is compatible with your network and in CIDR notation (that is, specify the range as an IPv4 CIDR block).
    /// This member is required.
    public var managementCidrRangeConstraint: Swift.String?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        managementCidrRangeConstraint: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.managementCidrRangeConstraint = managementCidrRangeConstraint
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAvailableManagementCidrRangesInputBody: Swift.Equatable {
    let managementCidrRangeConstraint: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAvailableManagementCidrRangesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managementCidrRangeConstraint = "ManagementCidrRangeConstraint"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managementCidrRangeConstraintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managementCidrRangeConstraint)
        managementCidrRangeConstraint = managementCidrRangeConstraintDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAvailableManagementCidrRangesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAvailableManagementCidrRangesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAvailableManagementCidrRangesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAvailableManagementCidrRangesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAvailableManagementCidrRangesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.managementCidrRanges = output.managementCidrRanges
            self.nextToken = output.nextToken
        } else {
            self.managementCidrRanges = nil
            self.nextToken = nil
        }
    }
}

public struct ListAvailableManagementCidrRangesOutputResponse: Swift.Equatable {
    /// The list of available IP address ranges, specified as IPv4 CIDR blocks.
    public var managementCidrRanges: [Swift.String]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        managementCidrRanges: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.managementCidrRanges = managementCidrRanges
        self.nextToken = nextToken
    }
}

struct ListAvailableManagementCidrRangesOutputResponseBody: Swift.Equatable {
    let managementCidrRanges: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAvailableManagementCidrRangesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managementCidrRanges = "ManagementCidrRanges"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managementCidrRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managementCidrRanges)
        var managementCidrRangesDecoded0:[Swift.String]? = nil
        if let managementCidrRangesContainer = managementCidrRangesContainer {
            managementCidrRangesDecoded0 = [Swift.String]()
            for string0 in managementCidrRangesContainer {
                if let string0 = string0 {
                    managementCidrRangesDecoded0?.append(string0)
                }
            }
        }
        managementCidrRanges = managementCidrRangesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MigrateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case sourceWorkspaceId = "SourceWorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let sourceWorkspaceId = sourceWorkspaceId {
            try encodeContainer.encode(sourceWorkspaceId, forKey: .sourceWorkspaceId)
        }
    }
}

extension MigrateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MigrateWorkspaceInput: Swift.Equatable {
    /// The identifier of the target bundle type to migrate the WorkSpace to.
    /// This member is required.
    public var bundleId: Swift.String?
    /// The identifier of the WorkSpace to migrate from.
    /// This member is required.
    public var sourceWorkspaceId: Swift.String?

    public init (
        bundleId: Swift.String? = nil,
        sourceWorkspaceId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
        self.sourceWorkspaceId = sourceWorkspaceId
    }
}

struct MigrateWorkspaceInputBody: Swift.Equatable {
    let sourceWorkspaceId: Swift.String?
    let bundleId: Swift.String?
}

extension MigrateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case sourceWorkspaceId = "SourceWorkspaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceWorkspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceWorkspaceId)
        sourceWorkspaceId = sourceWorkspaceIdDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
    }
}

extension MigrateWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MigrateWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MigrateWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationInProgressException(OperationInProgressException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MigrateWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MigrateWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sourceWorkspaceId = output.sourceWorkspaceId
            self.targetWorkspaceId = output.targetWorkspaceId
        } else {
            self.sourceWorkspaceId = nil
            self.targetWorkspaceId = nil
        }
    }
}

public struct MigrateWorkspaceOutputResponse: Swift.Equatable {
    /// The original identifier of the WorkSpace that is being migrated.
    public var sourceWorkspaceId: Swift.String?
    /// The new identifier of the WorkSpace that is being migrated. If the migration does not succeed, the target WorkSpace ID will not be used, and the WorkSpace will still have the original WorkSpace ID.
    public var targetWorkspaceId: Swift.String?

    public init (
        sourceWorkspaceId: Swift.String? = nil,
        targetWorkspaceId: Swift.String? = nil
    )
    {
        self.sourceWorkspaceId = sourceWorkspaceId
        self.targetWorkspaceId = targetWorkspaceId
    }
}

struct MigrateWorkspaceOutputResponseBody: Swift.Equatable {
    let sourceWorkspaceId: Swift.String?
    let targetWorkspaceId: Swift.String?
}

extension MigrateWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceWorkspaceId = "SourceWorkspaceId"
        case targetWorkspaceId = "TargetWorkspaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceWorkspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceWorkspaceId)
        sourceWorkspaceId = sourceWorkspaceIdDecoded
        let targetWorkspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetWorkspaceId)
        targetWorkspaceId = targetWorkspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    public enum ModificationResourceEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case computeType
        case rootVolume
        case userVolume
        case sdkUnknown(Swift.String)

        public static var allCases: [ModificationResourceEnum] {
            return [
                .computeType,
                .rootVolume,
                .userVolume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .computeType: return "COMPUTE_TYPE"
            case .rootVolume: return "ROOT_VOLUME"
            case .userVolume: return "USER_VOLUME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModificationResourceEnum(rawValue: rawValue) ?? ModificationResourceEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.ModificationState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = resource {
            try encodeContainer.encode(resource.rawValue, forKey: .resource)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ModificationResourceEnum.self, forKey: .resource)
        resource = resourceDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ModificationStateEnum.self, forKey: .state)
        state = stateDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace modification.
    public struct ModificationState: Swift.Equatable {
        /// The resource.
        public var resource: WorkSpacesClientTypes.ModificationResourceEnum?
        /// The modification state.
        public var state: WorkSpacesClientTypes.ModificationStateEnum?

        public init (
            resource: WorkSpacesClientTypes.ModificationResourceEnum? = nil,
            state: WorkSpacesClientTypes.ModificationStateEnum? = nil
        )
        {
            self.resource = resource
            self.state = state
        }
    }

}

extension WorkSpacesClientTypes {
    public enum ModificationStateEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case updateInitiated
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ModificationStateEnum] {
            return [
                .updateInitiated,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .updateInitiated: return "UPDATE_INITIATED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModificationStateEnum(rawValue: rawValue) ?? ModificationStateEnum.sdkUnknown(rawValue)
        }
    }
}

extension ModifyAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange {
            try encodeContainer.encode(dedicatedTenancyManagementCidrRange, forKey: .dedicatedTenancyManagementCidrRange)
        }
        if let dedicatedTenancySupport = dedicatedTenancySupport {
            try encodeContainer.encode(dedicatedTenancySupport.rawValue, forKey: .dedicatedTenancySupport)
        }
    }
}

extension ModifyAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyAccountInput: Swift.Equatable {
    /// The IP address range, specified as an IPv4 CIDR block, for the management network interface. Specify an IP address range that is compatible with your network and in CIDR notation (that is, specify the range as an IPv4 CIDR block). The CIDR block size must be /16 (for example, 203.0.113.25/16). It must also be specified as available by the ListAvailableManagementCidrRanges operation.
    public var dedicatedTenancyManagementCidrRange: Swift.String?
    /// The status of BYOL.
    public var dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportEnum?

    public init (
        dedicatedTenancyManagementCidrRange: Swift.String? = nil,
        dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportEnum? = nil
    )
    {
        self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
        self.dedicatedTenancySupport = dedicatedTenancySupport
    }
}

struct ModifyAccountInputBody: Swift.Equatable {
    let dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportEnum?
    let dedicatedTenancyManagementCidrRange: Swift.String?
}

extension ModifyAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedTenancySupportDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DedicatedTenancySupportEnum.self, forKey: .dedicatedTenancySupport)
        dedicatedTenancySupport = dedicatedTenancySupportDecoded
        let dedicatedTenancyManagementCidrRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedTenancyManagementCidrRange)
        dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRangeDecoded
    }
}

extension ModifyAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyAccountOutputResponse: Swift.Equatable {

}

extension ModifyClientPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientProperties = "ClientProperties"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientProperties = clientProperties {
            try encodeContainer.encode(clientProperties, forKey: .clientProperties)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ModifyClientPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyClientPropertiesInput: Swift.Equatable {
    /// Information about the Amazon WorkSpaces client.
    /// This member is required.
    public var clientProperties: WorkSpacesClientTypes.ClientProperties?
    /// The resource identifiers, in the form of directory IDs.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        clientProperties: WorkSpacesClientTypes.ClientProperties? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.clientProperties = clientProperties
        self.resourceId = resourceId
    }
}

struct ModifyClientPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let clientProperties: WorkSpacesClientTypes.ClientProperties?
}

extension ModifyClientPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientProperties = "ClientProperties"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let clientPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ClientProperties.self, forKey: .clientProperties)
        clientProperties = clientPropertiesDecoded
    }
}

extension ModifyClientPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyClientPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyClientPropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClientPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyClientPropertiesOutputResponse: Swift.Equatable {

}

extension ModifySelfservicePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case selfservicePermissions = "SelfservicePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let selfservicePermissions = selfservicePermissions {
            try encodeContainer.encode(selfservicePermissions, forKey: .selfservicePermissions)
        }
    }
}

extension ModifySelfservicePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifySelfservicePermissionsInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The permissions to enable or disable self-service capabilities.
    /// This member is required.
    public var selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions?

    public init (
        resourceId: Swift.String? = nil,
        selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions? = nil
    )
    {
        self.resourceId = resourceId
        self.selfservicePermissions = selfservicePermissions
    }
}

struct ModifySelfservicePermissionsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions?
}

extension ModifySelfservicePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case selfservicePermissions = "SelfservicePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let selfservicePermissionsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.SelfservicePermissions.self, forKey: .selfservicePermissions)
        selfservicePermissions = selfservicePermissionsDecoded
    }
}

extension ModifySelfservicePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifySelfservicePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifySelfservicePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifySelfservicePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifySelfservicePermissionsOutputResponse: Swift.Equatable {

}

extension ModifyWorkspaceAccessPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case workspaceAccessProperties = "WorkspaceAccessProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let workspaceAccessProperties = workspaceAccessProperties {
            try encodeContainer.encode(workspaceAccessProperties, forKey: .workspaceAccessProperties)
        }
    }
}

extension ModifyWorkspaceAccessPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyWorkspaceAccessPropertiesInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The device types and operating systems to enable or disable for access.
    /// This member is required.
    public var workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties?

    public init (
        resourceId: Swift.String? = nil,
        workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties? = nil
    )
    {
        self.resourceId = resourceId
        self.workspaceAccessProperties = workspaceAccessProperties
    }
}

struct ModifyWorkspaceAccessPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties?
}

extension ModifyWorkspaceAccessPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case workspaceAccessProperties = "WorkspaceAccessProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let workspaceAccessPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceAccessProperties.self, forKey: .workspaceAccessProperties)
        workspaceAccessProperties = workspaceAccessPropertiesDecoded
    }
}

extension ModifyWorkspaceAccessPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyWorkspaceAccessPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyWorkspaceAccessPropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyWorkspaceAccessPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyWorkspaceAccessPropertiesOutputResponse: Swift.Equatable {

}

extension ModifyWorkspaceCreationPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case workspaceCreationProperties = "WorkspaceCreationProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let workspaceCreationProperties = workspaceCreationProperties {
            try encodeContainer.encode(workspaceCreationProperties, forKey: .workspaceCreationProperties)
        }
    }
}

extension ModifyWorkspaceCreationPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyWorkspaceCreationPropertiesInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The default properties for creating WorkSpaces.
    /// This member is required.
    public var workspaceCreationProperties: WorkSpacesClientTypes.WorkspaceCreationProperties?

    public init (
        resourceId: Swift.String? = nil,
        workspaceCreationProperties: WorkSpacesClientTypes.WorkspaceCreationProperties? = nil
    )
    {
        self.resourceId = resourceId
        self.workspaceCreationProperties = workspaceCreationProperties
    }
}

struct ModifyWorkspaceCreationPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let workspaceCreationProperties: WorkSpacesClientTypes.WorkspaceCreationProperties?
}

extension ModifyWorkspaceCreationPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case workspaceCreationProperties = "WorkspaceCreationProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let workspaceCreationPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceCreationProperties.self, forKey: .workspaceCreationProperties)
        workspaceCreationProperties = workspaceCreationPropertiesDecoded
    }
}

extension ModifyWorkspaceCreationPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyWorkspaceCreationPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyWorkspaceCreationPropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyWorkspaceCreationPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyWorkspaceCreationPropertiesOutputResponse: Swift.Equatable {

}

extension ModifyWorkspacePropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceProperties = "WorkspaceProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
        if let workspaceProperties = workspaceProperties {
            try encodeContainer.encode(workspaceProperties, forKey: .workspaceProperties)
        }
    }
}

extension ModifyWorkspacePropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyWorkspacePropertiesInput: Swift.Equatable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?
    /// The properties of the WorkSpace.
    /// This member is required.
    public var workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?

    public init (
        workspaceId: Swift.String? = nil,
        workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties? = nil
    )
    {
        self.workspaceId = workspaceId
        self.workspaceProperties = workspaceProperties
    }
}

struct ModifyWorkspacePropertiesInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?
}

extension ModifyWorkspacePropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceProperties = "WorkspaceProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let workspacePropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceProperties.self, forKey: .workspaceProperties)
        workspaceProperties = workspacePropertiesDecoded
    }
}

extension ModifyWorkspacePropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyWorkspacePropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedWorkspaceConfigurationException" : self = .unsupportedWorkspaceConfigurationException(try UnsupportedWorkspaceConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyWorkspacePropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationInProgressException(OperationInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unsupportedWorkspaceConfigurationException(UnsupportedWorkspaceConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyWorkspacePropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyWorkspacePropertiesOutputResponse: Swift.Equatable {

}

extension ModifyWorkspaceStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceState = "WorkspaceState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
        if let workspaceState = workspaceState {
            try encodeContainer.encode(workspaceState.rawValue, forKey: .workspaceState)
        }
    }
}

extension ModifyWorkspaceStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyWorkspaceStateInput: Swift.Equatable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?
    /// The WorkSpace state.
    /// This member is required.
    public var workspaceState: WorkSpacesClientTypes.TargetWorkspaceState?

    public init (
        workspaceId: Swift.String? = nil,
        workspaceState: WorkSpacesClientTypes.TargetWorkspaceState? = nil
    )
    {
        self.workspaceId = workspaceId
        self.workspaceState = workspaceState
    }
}

struct ModifyWorkspaceStateInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let workspaceState: WorkSpacesClientTypes.TargetWorkspaceState?
}

extension ModifyWorkspaceStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceState = "WorkspaceState"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let workspaceStateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.TargetWorkspaceState.self, forKey: .workspaceState)
        workspaceState = workspaceStateDecoded
    }
}

extension ModifyWorkspaceStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyWorkspaceStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyWorkspaceStateOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyWorkspaceStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyWorkspaceStateOutputResponse: Swift.Equatable {

}

extension WorkSpacesClientTypes.OperatingSystem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.OperatingSystemType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// The operating system that the image is running.
    public struct OperatingSystem: Swift.Equatable {
        /// The operating system.
        public var type: WorkSpacesClientTypes.OperatingSystemType?

        public init (
            type: WorkSpacesClientTypes.OperatingSystemType? = nil
        )
        {
            self.type = type
        }
    }

}

extension WorkSpacesClientTypes {
    public enum OperatingSystemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatingSystemType] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperatingSystemType(rawValue: rawValue) ?? OperatingSystemType.sdkUnknown(rawValue)
        }
    }
}

extension OperationInProgressException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The properties of this WorkSpace are currently being modified. Try again in a moment.
public struct OperationInProgressException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationInProgressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This operation is not supported.
public struct OperationNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesClientTypes.RebootRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to reboot a WorkSpace.
    public struct RebootRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init (
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension RebootWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebootWorkspaceRequests = "RebootWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rebootWorkspaceRequests = rebootWorkspaceRequests {
            var rebootWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rebootWorkspaceRequests)
            for rebootworkspacerequests0 in rebootWorkspaceRequests {
                try rebootWorkspaceRequestsContainer.encode(rebootworkspacerequests0)
            }
        }
    }
}

extension RebootWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RebootWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to reboot. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var rebootWorkspaceRequests: [WorkSpacesClientTypes.RebootRequest]?

    public init (
        rebootWorkspaceRequests: [WorkSpacesClientTypes.RebootRequest]? = nil
    )
    {
        self.rebootWorkspaceRequests = rebootWorkspaceRequests
    }
}

struct RebootWorkspacesInputBody: Swift.Equatable {
    let rebootWorkspaceRequests: [WorkSpacesClientTypes.RebootRequest]?
}

extension RebootWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebootWorkspaceRequests = "RebootWorkspaceRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rebootWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.RebootRequest?].self, forKey: .rebootWorkspaceRequests)
        var rebootWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.RebootRequest]? = nil
        if let rebootWorkspaceRequestsContainer = rebootWorkspaceRequestsContainer {
            rebootWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.RebootRequest]()
            for structure0 in rebootWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    rebootWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        rebootWorkspaceRequests = rebootWorkspaceRequestsDecoded0
    }
}

extension RebootWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RebootWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct RebootWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the WorkSpaces that could not be rebooted.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct RebootWorkspacesOutputResponseBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension RebootWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension WorkSpacesClientTypes.RebuildRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to rebuild a WorkSpace.
    public struct RebuildRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init (
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension RebuildWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebuildWorkspaceRequests = "RebuildWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rebuildWorkspaceRequests = rebuildWorkspaceRequests {
            var rebuildWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rebuildWorkspaceRequests)
            for rebuildworkspacerequests0 in rebuildWorkspaceRequests {
                try rebuildWorkspaceRequestsContainer.encode(rebuildworkspacerequests0)
            }
        }
    }
}

extension RebuildWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RebuildWorkspacesInput: Swift.Equatable {
    /// The WorkSpace to rebuild. You can specify a single WorkSpace.
    /// This member is required.
    public var rebuildWorkspaceRequests: [WorkSpacesClientTypes.RebuildRequest]?

    public init (
        rebuildWorkspaceRequests: [WorkSpacesClientTypes.RebuildRequest]? = nil
    )
    {
        self.rebuildWorkspaceRequests = rebuildWorkspaceRequests
    }
}

struct RebuildWorkspacesInputBody: Swift.Equatable {
    let rebuildWorkspaceRequests: [WorkSpacesClientTypes.RebuildRequest]?
}

extension RebuildWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebuildWorkspaceRequests = "RebuildWorkspaceRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rebuildWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.RebuildRequest?].self, forKey: .rebuildWorkspaceRequests)
        var rebuildWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.RebuildRequest]? = nil
        if let rebuildWorkspaceRequestsContainer = rebuildWorkspaceRequestsContainer {
            rebuildWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.RebuildRequest]()
            for structure0 in rebuildWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    rebuildWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        rebuildWorkspaceRequests = rebuildWorkspaceRequestsDecoded0
    }
}

extension RebuildWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebuildWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebuildWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension RebuildWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RebuildWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct RebuildWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the WorkSpace that could not be rebuilt.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct RebuildWorkspacesOutputResponseBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension RebuildWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension WorkSpacesClientTypes {
    public enum ReconnectEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReconnectEnum] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReconnectEnum(rawValue: rawValue) ?? ReconnectEnum.sdkUnknown(rawValue)
        }
    }
}

extension RegisterWorkspaceDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case enableSelfService = "EnableSelfService"
        case enableWorkDocs = "EnableWorkDocs"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case tenancy = "Tenancy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let enableSelfService = enableSelfService {
            try encodeContainer.encode(enableSelfService, forKey: .enableSelfService)
        }
        if let enableWorkDocs = enableWorkDocs {
            try encodeContainer.encode(enableWorkDocs, forKey: .enableWorkDocs)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let tenancy = tenancy {
            try encodeContainer.encode(tenancy.rawValue, forKey: .tenancy)
        }
    }
}

extension RegisterWorkspaceDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterWorkspaceDirectoryInput: Swift.Equatable {
    /// The identifier of the directory. You cannot register a directory if it does not have a status of Active. If the directory does not have a status of Active, you will receive an InvalidResourceStateException error. If you have already registered the maximum number of directories that you can register with Amazon WorkSpaces, you will receive a ResourceLimitExceededException error. Deregister directories that you are not using for WorkSpaces, and try again.
    /// This member is required.
    public var directoryId: Swift.String?
    /// Indicates whether self-service capabilities are enabled or disabled.
    public var enableSelfService: Swift.Bool?
    /// Indicates whether Amazon WorkDocs is enabled or disabled. If you have enabled this parameter and WorkDocs is not available in the Region, you will receive an OperationNotSupportedException error. Set EnableWorkDocs to disabled, and try again.
    /// This member is required.
    public var enableWorkDocs: Swift.Bool?
    /// The identifiers of the subnets for your virtual private cloud (VPC). Make sure that the subnets are in supported Availability Zones. The subnets must also be in separate Availability Zones. If these conditions are not met, you will receive an OperationNotSupportedException error.
    public var subnetIds: [Swift.String]?
    /// The tags associated with the directory.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// Indicates whether your WorkSpace directory is dedicated or shared. To use Bring Your Own License (BYOL) images, this value must be set to DEDICATED and your Amazon Web Services account must be enabled for BYOL. If your account has not been enabled for BYOL, you will receive an InvalidParameterValuesException error. For more information about BYOL images, see [Bring Your Own Windows Desktop Images](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
    public var tenancy: WorkSpacesClientTypes.Tenancy?

    public init (
        directoryId: Swift.String? = nil,
        enableSelfService: Swift.Bool? = nil,
        enableWorkDocs: Swift.Bool? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        tenancy: WorkSpacesClientTypes.Tenancy? = nil
    )
    {
        self.directoryId = directoryId
        self.enableSelfService = enableSelfService
        self.enableWorkDocs = enableWorkDocs
        self.subnetIds = subnetIds
        self.tags = tags
        self.tenancy = tenancy
    }
}

struct RegisterWorkspaceDirectoryInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let subnetIds: [Swift.String]?
    let enableWorkDocs: Swift.Bool?
    let enableSelfService: Swift.Bool?
    let tenancy: WorkSpacesClientTypes.Tenancy?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension RegisterWorkspaceDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case enableSelfService = "EnableSelfService"
        case enableWorkDocs = "EnableWorkDocs"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case tenancy = "Tenancy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let enableWorkDocsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWorkDocs)
        enableWorkDocs = enableWorkDocsDecoded
        let enableSelfServiceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSelfService)
        enableSelfService = enableSelfServiceDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.Tenancy.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RegisterWorkspaceDirectoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterWorkspaceDirectoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedNetworkConfigurationException" : self = .unsupportedNetworkConfigurationException(try UnsupportedNetworkConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WorkspacesDefaultRoleNotFoundException" : self = .workspacesDefaultRoleNotFoundException(try WorkspacesDefaultRoleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterWorkspaceDirectoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedNetworkConfigurationException(UnsupportedNetworkConfigurationException)
    case workspacesDefaultRoleNotFoundException(WorkspacesDefaultRoleNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterWorkspaceDirectoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RegisterWorkspaceDirectoryOutputResponse: Swift.Equatable {

}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceAssociatedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAssociatedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is associated with a directory.
public struct ResourceAssociatedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAssociatedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAssociatedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceCreationFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceCreationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource could not be created.
public struct ResourceCreationFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceCreationFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceCreationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your resource limits have been exceeded.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception error message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.resourceId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The resource could not be found.
    public var message: Swift.String?
    /// The ID of the resource that could not be found.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ResourceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.resourceId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource is not available.
public struct ResourceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception error message.
    public var message: Swift.String?
    /// The identifier of the resource that is not available.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ResourceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ResourceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension RestoreWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension RestoreWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreWorkspaceInput: Swift.Equatable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct RestoreWorkspaceInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
}

extension RestoreWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension RestoreWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RestoreWorkspaceOutputResponse: Swift.Equatable {

}

extension RevokeIpRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for iprevokedrulelist0 in userRules {
                try userRulesContainer.encode(iprevokedrulelist0)
            }
        }
    }
}

extension RevokeIpRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RevokeIpRulesInput: Swift.Equatable {
    /// The identifier of the group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The rules to remove from the group.
    /// This member is required.
    public var userRules: [Swift.String]?

    public init (
        groupId: Swift.String? = nil,
        userRules: [Swift.String]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

struct RevokeIpRulesInputBody: Swift.Equatable {
    let groupId: Swift.String?
    let userRules: [Swift.String]?
}

extension RevokeIpRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userRules)
        var userRulesDecoded0:[Swift.String]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [Swift.String]()
            for string0 in userRulesContainer {
                if let string0 = string0 {
                    userRulesDecoded0?.append(string0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension RevokeIpRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeIpRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeIpRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeIpRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RevokeIpRulesOutputResponse: Swift.Equatable {

}

extension WorkSpacesClientTypes.RootStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity = "Capacity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacity)
        capacity = capacityDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the root volume for a WorkSpace bundle.
    public struct RootStorage: Swift.Equatable {
        /// The size of the root volume.
        public var capacity: Swift.String?

        public init (
            capacity: Swift.String? = nil
        )
        {
            self.capacity = capacity
        }
    }

}

extension WorkSpacesClientTypes {
    public enum RunningMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alwaysOn
        case autoStop
        case sdkUnknown(Swift.String)

        public static var allCases: [RunningMode] {
            return [
                .alwaysOn,
                .autoStop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alwaysOn: return "ALWAYS_ON"
            case .autoStop: return "AUTO_STOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunningMode(rawValue: rawValue) ?? RunningMode.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.SelfservicePermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeComputeType = "ChangeComputeType"
        case increaseVolumeSize = "IncreaseVolumeSize"
        case rebuildWorkspace = "RebuildWorkspace"
        case restartWorkspace = "RestartWorkspace"
        case switchRunningMode = "SwitchRunningMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeComputeType = changeComputeType {
            try encodeContainer.encode(changeComputeType.rawValue, forKey: .changeComputeType)
        }
        if let increaseVolumeSize = increaseVolumeSize {
            try encodeContainer.encode(increaseVolumeSize.rawValue, forKey: .increaseVolumeSize)
        }
        if let rebuildWorkspace = rebuildWorkspace {
            try encodeContainer.encode(rebuildWorkspace.rawValue, forKey: .rebuildWorkspace)
        }
        if let restartWorkspace = restartWorkspace {
            try encodeContainer.encode(restartWorkspace.rawValue, forKey: .restartWorkspace)
        }
        if let switchRunningMode = switchRunningMode {
            try encodeContainer.encode(switchRunningMode.rawValue, forKey: .switchRunningMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restartWorkspaceDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .restartWorkspace)
        restartWorkspace = restartWorkspaceDecoded
        let increaseVolumeSizeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .increaseVolumeSize)
        increaseVolumeSize = increaseVolumeSizeDecoded
        let changeComputeTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .changeComputeType)
        changeComputeType = changeComputeTypeDecoded
        let switchRunningModeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .switchRunningMode)
        switchRunningMode = switchRunningModeDecoded
        let rebuildWorkspaceDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .rebuildWorkspace)
        rebuildWorkspace = rebuildWorkspaceDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the self-service permissions for a directory. For more information, see [Enable Self-Service WorkSpace Management Capabilities for Your Users](https://docs.aws.amazon.com/workspaces/latest/adminguide/enable-user-self-service-workspace-management.html).
    public struct SelfservicePermissions: Swift.Equatable {
        /// Specifies whether users can change the compute type (bundle) for their WorkSpace.
        public var changeComputeType: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can increase the volume size of the drives on their WorkSpace.
        public var increaseVolumeSize: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can rebuild the operating system of a WorkSpace to its original state.
        public var rebuildWorkspace: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can restart their WorkSpace.
        public var restartWorkspace: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can switch the running mode of their WorkSpace.
        public var switchRunningMode: WorkSpacesClientTypes.ReconnectEnum?

        public init (
            changeComputeType: WorkSpacesClientTypes.ReconnectEnum? = nil,
            increaseVolumeSize: WorkSpacesClientTypes.ReconnectEnum? = nil,
            rebuildWorkspace: WorkSpacesClientTypes.ReconnectEnum? = nil,
            restartWorkspace: WorkSpacesClientTypes.ReconnectEnum? = nil,
            switchRunningMode: WorkSpacesClientTypes.ReconnectEnum? = nil
        )
        {
            self.changeComputeType = changeComputeType
            self.increaseVolumeSize = increaseVolumeSize
            self.rebuildWorkspace = rebuildWorkspace
            self.restartWorkspace = restartWorkspace
            self.switchRunningMode = switchRunningMode
        }
    }

}

extension WorkSpacesClientTypes.Snapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotTime = "SnapshotTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotTime = snapshotTime {
            try encodeContainer.encode(snapshotTime.timeIntervalSince1970, forKey: .snapshotTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .snapshotTime)
        snapshotTime = snapshotTimeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a snapshot.
    public struct Snapshot: Swift.Equatable {
        /// The time when the snapshot was created.
        public var snapshotTime: ClientRuntime.Date?

        public init (
            snapshotTime: ClientRuntime.Date? = nil
        )
        {
            self.snapshotTime = snapshotTime
        }
    }

}

extension WorkSpacesClientTypes.StartRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Information used to start a WorkSpace.
    public struct StartRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init (
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension StartWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startWorkspaceRequests = "StartWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startWorkspaceRequests = startWorkspaceRequests {
            var startWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startWorkspaceRequests)
            for startworkspacerequests0 in startWorkspaceRequests {
                try startWorkspaceRequestsContainer.encode(startworkspacerequests0)
            }
        }
    }
}

extension StartWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to start. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var startWorkspaceRequests: [WorkSpacesClientTypes.StartRequest]?

    public init (
        startWorkspaceRequests: [WorkSpacesClientTypes.StartRequest]? = nil
    )
    {
        self.startWorkspaceRequests = startWorkspaceRequests
    }
}

struct StartWorkspacesInputBody: Swift.Equatable {
    let startWorkspaceRequests: [WorkSpacesClientTypes.StartRequest]?
}

extension StartWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startWorkspaceRequests = "StartWorkspaceRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.StartRequest?].self, forKey: .startWorkspaceRequests)
        var startWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.StartRequest]? = nil
        if let startWorkspaceRequestsContainer = startWorkspaceRequestsContainer {
            startWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.StartRequest]()
            for structure0 in startWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    startWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        startWorkspaceRequests = startWorkspaceRequestsDecoded0
    }
}

extension StartWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StartWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct StartWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the WorkSpaces that could not be started.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct StartWorkspacesOutputResponseBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension StartWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension WorkSpacesClientTypes.StopRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to stop a WorkSpace.
    public struct StopRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init (
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension StopWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stopWorkspaceRequests = "StopWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stopWorkspaceRequests = stopWorkspaceRequests {
            var stopWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopWorkspaceRequests)
            for stopworkspacerequests0 in stopWorkspaceRequests {
                try stopWorkspaceRequestsContainer.encode(stopworkspacerequests0)
            }
        }
    }
}

extension StopWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to stop. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var stopWorkspaceRequests: [WorkSpacesClientTypes.StopRequest]?

    public init (
        stopWorkspaceRequests: [WorkSpacesClientTypes.StopRequest]? = nil
    )
    {
        self.stopWorkspaceRequests = stopWorkspaceRequests
    }
}

struct StopWorkspacesInputBody: Swift.Equatable {
    let stopWorkspaceRequests: [WorkSpacesClientTypes.StopRequest]?
}

extension StopWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stopWorkspaceRequests = "StopWorkspaceRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stopWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.StopRequest?].self, forKey: .stopWorkspaceRequests)
        var stopWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.StopRequest]? = nil
        if let stopWorkspaceRequestsContainer = stopWorkspaceRequestsContainer {
            stopWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.StopRequest]()
            for structure0 in stopWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    stopWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        stopWorkspaceRequests = stopWorkspaceRequestsDecoded0
    }
}

extension StopWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StopWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct StopWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the WorkSpaces that could not be stopped.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct StopWorkspacesOutputResponseBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension StopWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension WorkSpacesClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a tag.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension WorkSpacesClientTypes {
    public enum TargetWorkspaceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adminMaintenance
        case available
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetWorkspaceState] {
            return [
                .adminMaintenance,
                .available,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adminMaintenance: return "ADMIN_MAINTENANCE"
            case .available: return "AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetWorkspaceState(rawValue: rawValue) ?? TargetWorkspaceState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum Tenancy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dedicated
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [Tenancy] {
            return [
                .dedicated,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "DEDICATED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Tenancy(rawValue: rawValue) ?? Tenancy.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.TerminateRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to terminate a WorkSpace.
    public struct TerminateRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init (
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension TerminateWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminateWorkspaceRequests = "TerminateWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let terminateWorkspaceRequests = terminateWorkspaceRequests {
            var terminateWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terminateWorkspaceRequests)
            for terminateworkspacerequests0 in terminateWorkspaceRequests {
                try terminateWorkspaceRequestsContainer.encode(terminateworkspacerequests0)
            }
        }
    }
}

extension TerminateWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TerminateWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to terminate. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var terminateWorkspaceRequests: [WorkSpacesClientTypes.TerminateRequest]?

    public init (
        terminateWorkspaceRequests: [WorkSpacesClientTypes.TerminateRequest]? = nil
    )
    {
        self.terminateWorkspaceRequests = terminateWorkspaceRequests
    }
}

struct TerminateWorkspacesInputBody: Swift.Equatable {
    let terminateWorkspaceRequests: [WorkSpacesClientTypes.TerminateRequest]?
}

extension TerminateWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminateWorkspaceRequests = "TerminateWorkspaceRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminateWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.TerminateRequest?].self, forKey: .terminateWorkspaceRequests)
        var terminateWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.TerminateRequest]? = nil
        if let terminateWorkspaceRequestsContainer = terminateWorkspaceRequestsContainer {
            terminateWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.TerminateRequest]()
            for structure0 in terminateWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    terminateWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        terminateWorkspaceRequests = terminateWorkspaceRequestsDecoded0
    }
}

extension TerminateWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TerminateWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TerminateWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct TerminateWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the WorkSpaces that could not be terminated.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct TerminateWorkspacesOutputResponseBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension TerminateWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension UnsupportedNetworkConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedNetworkConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The configuration of this network is not supported for this operation, or your network configuration conflicts with the Amazon WorkSpaces management network IP range. For more information, see [ Configure a VPC for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html).
public struct UnsupportedNetworkConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedNetworkConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedNetworkConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedWorkspaceConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedWorkspaceConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The configuration of this WorkSpace is not supported for this operation. For more information, see [Required Configuration and Service Components for WorkSpaces ](https://docs.aws.amazon.com/workspaces/latest/adminguide/required-service-components.html).
public struct UnsupportedWorkspaceConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedWorkspaceConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedWorkspaceConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateConnectionAliasPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case connectionAliasPermission = "ConnectionAliasPermission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let connectionAliasPermission = connectionAliasPermission {
            try encodeContainer.encode(connectionAliasPermission, forKey: .connectionAliasPermission)
        }
    }
}

extension UpdateConnectionAliasPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateConnectionAliasPermissionInput: Swift.Equatable {
    /// The identifier of the connection alias that you want to update permissions for.
    /// This member is required.
    public var aliasId: Swift.String?
    /// Indicates whether to share or unshare the connection alias with the specified Amazon Web Services account.
    /// This member is required.
    public var connectionAliasPermission: WorkSpacesClientTypes.ConnectionAliasPermission?

    public init (
        aliasId: Swift.String? = nil,
        connectionAliasPermission: WorkSpacesClientTypes.ConnectionAliasPermission? = nil
    )
    {
        self.aliasId = aliasId
        self.connectionAliasPermission = connectionAliasPermission
    }
}

struct UpdateConnectionAliasPermissionInputBody: Swift.Equatable {
    let aliasId: Swift.String?
    let connectionAliasPermission: WorkSpacesClientTypes.ConnectionAliasPermission?
}

extension UpdateConnectionAliasPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case connectionAliasPermission = "ConnectionAliasPermission"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let connectionAliasPermissionDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ConnectionAliasPermission.self, forKey: .connectionAliasPermission)
        connectionAliasPermission = connectionAliasPermissionDecoded
    }
}

extension UpdateConnectionAliasPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionAliasPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectionAliasPermissionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionAliasPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateConnectionAliasPermissionOutputResponse: Swift.Equatable {

}

extension WorkSpacesClientTypes.UpdateResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case updateAvailable = "UpdateAvailable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let updateAvailable = updateAvailable {
            try encodeContainer.encode(updateAvailable, forKey: .updateAvailable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateAvailableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .updateAvailable)
        updateAvailable = updateAvailableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes whether a WorkSpace image needs to be updated with the latest drivers and other components required by Amazon WorkSpaces. Only Windows 10 WorkSpace images can be programmatically updated at this time.
    public struct UpdateResult: Swift.Equatable {
        /// A description of whether updates for the WorkSpace image are pending or available.
        public var description: Swift.String?
        /// Indicates whether updated drivers or other components are available for the specified WorkSpace image.
        public var updateAvailable: Swift.Bool?

        public init (
            description: Swift.String? = nil,
            updateAvailable: Swift.Bool? = nil
        )
        {
            self.description = description
            self.updateAvailable = updateAvailable
        }
    }

}

extension UpdateRulesOfIpGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for iprulelist0 in userRules {
                try userRulesContainer.encode(iprulelist0)
            }
        }
    }
}

extension UpdateRulesOfIpGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRulesOfIpGroupInput: Swift.Equatable {
    /// The identifier of the group.
    /// This member is required.
    public var groupId: Swift.String?
    /// One or more rules.
    /// This member is required.
    public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

    public init (
        groupId: Swift.String? = nil,
        userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

struct UpdateRulesOfIpGroupInputBody: Swift.Equatable {
    let groupId: Swift.String?
    let userRules: [WorkSpacesClientTypes.IpRuleItem]?
}

extension UpdateRulesOfIpGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[WorkSpacesClientTypes.IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [WorkSpacesClientTypes.IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension UpdateRulesOfIpGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRulesOfIpGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRulesOfIpGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRulesOfIpGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRulesOfIpGroupOutputResponse: Swift.Equatable {

}

extension UpdateWorkspaceBundleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case imageId = "ImageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }
}

extension UpdateWorkspaceBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWorkspaceBundleInput: Swift.Equatable {
    /// The identifier of the bundle.
    public var bundleId: Swift.String?
    /// The identifier of the image.
    public var imageId: Swift.String?

    public init (
        bundleId: Swift.String? = nil,
        imageId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
        self.imageId = imageId
    }
}

struct UpdateWorkspaceBundleInputBody: Swift.Equatable {
    let bundleId: Swift.String?
    let imageId: Swift.String?
}

extension UpdateWorkspaceBundleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case imageId = "ImageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension UpdateWorkspaceBundleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkspaceBundleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkspaceBundleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkspaceBundleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWorkspaceBundleOutputResponse: Swift.Equatable {

}

extension UpdateWorkspaceImagePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCopyImage = "AllowCopyImage"
        case imageId = "ImageId"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowCopyImage = allowCopyImage {
            try encodeContainer.encode(allowCopyImage, forKey: .allowCopyImage)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }
}

extension UpdateWorkspaceImagePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWorkspaceImagePermissionInput: Swift.Equatable {
    /// The permission to copy the image. This permission can be revoked only after an image has been shared.
    /// This member is required.
    public var allowCopyImage: Swift.Bool?
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?
    /// The identifier of the Amazon Web Services account to share or unshare the image with. Before sharing the image, confirm that you are sharing to the correct Amazon Web Services account ID.
    /// This member is required.
    public var sharedAccountId: Swift.String?

    public init (
        allowCopyImage: Swift.Bool? = nil,
        imageId: Swift.String? = nil,
        sharedAccountId: Swift.String? = nil
    )
    {
        self.allowCopyImage = allowCopyImage
        self.imageId = imageId
        self.sharedAccountId = sharedAccountId
    }
}

struct UpdateWorkspaceImagePermissionInputBody: Swift.Equatable {
    let imageId: Swift.String?
    let allowCopyImage: Swift.Bool?
    let sharedAccountId: Swift.String?
}

extension UpdateWorkspaceImagePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCopyImage = "AllowCopyImage"
        case imageId = "ImageId"
        case sharedAccountId = "SharedAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let allowCopyImageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowCopyImage)
        allowCopyImage = allowCopyImageDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
    }
}

extension UpdateWorkspaceImagePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkspaceImagePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkspaceImagePermissionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkspaceImagePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWorkspaceImagePermissionOutputResponse: Swift.Equatable {

}

extension WorkSpacesClientTypes.UserStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity = "Capacity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacity)
        capacity = capacityDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the user volume for a WorkSpace bundle.
    public struct UserStorage: Swift.Equatable {
        /// The size of the user volume.
        public var capacity: Swift.String?

        public init (
            capacity: Swift.String? = nil
        )
        {
            self.capacity = capacity
        }
    }

}

extension WorkSpacesClientTypes.Workspace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case computerName = "ComputerName"
        case directoryId = "DirectoryId"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case ipAddress = "IpAddress"
        case modificationStates = "ModificationStates"
        case rootVolumeEncryptionEnabled = "RootVolumeEncryptionEnabled"
        case state = "State"
        case subnetId = "SubnetId"
        case userName = "UserName"
        case userVolumeEncryptionEnabled = "UserVolumeEncryptionEnabled"
        case volumeEncryptionKey = "VolumeEncryptionKey"
        case workspaceId = "WorkspaceId"
        case workspaceProperties = "WorkspaceProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let computerName = computerName {
            try encodeContainer.encode(computerName, forKey: .computerName)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let modificationStates = modificationStates {
            var modificationStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modificationStates)
            for modificationstatelist0 in modificationStates {
                try modificationStatesContainer.encode(modificationstatelist0)
            }
        }
        if let rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled {
            try encodeContainer.encode(rootVolumeEncryptionEnabled, forKey: .rootVolumeEncryptionEnabled)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userVolumeEncryptionEnabled = userVolumeEncryptionEnabled {
            try encodeContainer.encode(userVolumeEncryptionEnabled, forKey: .userVolumeEncryptionEnabled)
        }
        if let volumeEncryptionKey = volumeEncryptionKey {
            try encodeContainer.encode(volumeEncryptionKey, forKey: .volumeEncryptionKey)
        }
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
        if let workspaceProperties = workspaceProperties {
            try encodeContainer.encode(workspaceProperties, forKey: .workspaceProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceState.self, forKey: .state)
        state = stateDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let computerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computerName)
        computerName = computerNameDecoded
        let volumeEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeEncryptionKey)
        volumeEncryptionKey = volumeEncryptionKeyDecoded
        let userVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userVolumeEncryptionEnabled)
        userVolumeEncryptionEnabled = userVolumeEncryptionEnabledDecoded
        let rootVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rootVolumeEncryptionEnabled)
        rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabledDecoded
        let workspacePropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceProperties.self, forKey: .workspaceProperties)
        workspaceProperties = workspacePropertiesDecoded
        let modificationStatesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ModificationState?].self, forKey: .modificationStates)
        var modificationStatesDecoded0:[WorkSpacesClientTypes.ModificationState]? = nil
        if let modificationStatesContainer = modificationStatesContainer {
            modificationStatesDecoded0 = [WorkSpacesClientTypes.ModificationState]()
            for structure0 in modificationStatesContainer {
                if let structure0 = structure0 {
                    modificationStatesDecoded0?.append(structure0)
                }
            }
        }
        modificationStates = modificationStatesDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace.
    public struct Workspace: Swift.Equatable {
        /// The identifier of the bundle used to create the WorkSpace.
        public var bundleId: Swift.String?
        /// The name of the WorkSpace, as seen by the operating system. The format of this name varies. For more information, see [ Launch a WorkSpace](https://docs.aws.amazon.com/workspaces/latest/adminguide/launch-workspaces-tutorials.html).
        public var computerName: Swift.String?
        /// The identifier of the Directory Service directory for the WorkSpace.
        public var directoryId: Swift.String?
        /// The error code that is returned if the WorkSpace cannot be created.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the WorkSpace cannot be created.
        public var errorMessage: Swift.String?
        /// The IP address of the WorkSpace.
        public var ipAddress: Swift.String?
        /// The modification states of the WorkSpace.
        public var modificationStates: [WorkSpacesClientTypes.ModificationState]?
        /// Indicates whether the data stored on the root volume is encrypted.
        public var rootVolumeEncryptionEnabled: Swift.Bool?
        /// The operational state of the WorkSpace. After a WorkSpace is terminated, the TERMINATED state is returned only briefly before the WorkSpace directory metadata is cleaned up, so this state is rarely returned. To confirm that a WorkSpace is terminated, check for the WorkSpace ID by using [ DescribeWorkSpaces](https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html). If the WorkSpace ID isn't returned, then the WorkSpace has been successfully terminated.
        public var state: WorkSpacesClientTypes.WorkspaceState?
        /// The identifier of the subnet for the WorkSpace.
        public var subnetId: Swift.String?
        /// The user for the WorkSpace.
        public var userName: Swift.String?
        /// Indicates whether the data stored on the user volume is encrypted.
        public var userVolumeEncryptionEnabled: Swift.Bool?
        /// The symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.
        public var volumeEncryptionKey: Swift.String?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?
        /// The properties of the WorkSpace.
        public var workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?

        public init (
            bundleId: Swift.String? = nil,
            computerName: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            modificationStates: [WorkSpacesClientTypes.ModificationState]? = nil,
            rootVolumeEncryptionEnabled: Swift.Bool? = nil,
            state: WorkSpacesClientTypes.WorkspaceState? = nil,
            subnetId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userVolumeEncryptionEnabled: Swift.Bool? = nil,
            volumeEncryptionKey: Swift.String? = nil,
            workspaceId: Swift.String? = nil,
            workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties? = nil
        )
        {
            self.bundleId = bundleId
            self.computerName = computerName
            self.directoryId = directoryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.ipAddress = ipAddress
            self.modificationStates = modificationStates
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.state = state
            self.subnetId = subnetId
            self.userName = userName
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.volumeEncryptionKey = volumeEncryptionKey
            self.workspaceId = workspaceId
            self.workspaceProperties = workspaceProperties
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceAccessProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceTypeAndroid = "DeviceTypeAndroid"
        case deviceTypeChromeOs = "DeviceTypeChromeOs"
        case deviceTypeIos = "DeviceTypeIos"
        case deviceTypeLinux = "DeviceTypeLinux"
        case deviceTypeOsx = "DeviceTypeOsx"
        case deviceTypeWeb = "DeviceTypeWeb"
        case deviceTypeWindows = "DeviceTypeWindows"
        case deviceTypeZeroClient = "DeviceTypeZeroClient"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceTypeAndroid = deviceTypeAndroid {
            try encodeContainer.encode(deviceTypeAndroid.rawValue, forKey: .deviceTypeAndroid)
        }
        if let deviceTypeChromeOs = deviceTypeChromeOs {
            try encodeContainer.encode(deviceTypeChromeOs.rawValue, forKey: .deviceTypeChromeOs)
        }
        if let deviceTypeIos = deviceTypeIos {
            try encodeContainer.encode(deviceTypeIos.rawValue, forKey: .deviceTypeIos)
        }
        if let deviceTypeLinux = deviceTypeLinux {
            try encodeContainer.encode(deviceTypeLinux.rawValue, forKey: .deviceTypeLinux)
        }
        if let deviceTypeOsx = deviceTypeOsx {
            try encodeContainer.encode(deviceTypeOsx.rawValue, forKey: .deviceTypeOsx)
        }
        if let deviceTypeWeb = deviceTypeWeb {
            try encodeContainer.encode(deviceTypeWeb.rawValue, forKey: .deviceTypeWeb)
        }
        if let deviceTypeWindows = deviceTypeWindows {
            try encodeContainer.encode(deviceTypeWindows.rawValue, forKey: .deviceTypeWindows)
        }
        if let deviceTypeZeroClient = deviceTypeZeroClient {
            try encodeContainer.encode(deviceTypeZeroClient.rawValue, forKey: .deviceTypeZeroClient)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTypeWindowsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeWindows)
        deviceTypeWindows = deviceTypeWindowsDecoded
        let deviceTypeOsxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeOsx)
        deviceTypeOsx = deviceTypeOsxDecoded
        let deviceTypeWebDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeWeb)
        deviceTypeWeb = deviceTypeWebDecoded
        let deviceTypeIosDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeIos)
        deviceTypeIos = deviceTypeIosDecoded
        let deviceTypeAndroidDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeAndroid)
        deviceTypeAndroid = deviceTypeAndroidDecoded
        let deviceTypeChromeOsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeChromeOs)
        deviceTypeChromeOs = deviceTypeChromeOsDecoded
        let deviceTypeZeroClientDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeZeroClient)
        deviceTypeZeroClient = deviceTypeZeroClientDecoded
        let deviceTypeLinuxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeLinux)
        deviceTypeLinux = deviceTypeLinuxDecoded
    }
}

extension WorkSpacesClientTypes {
    /// The device types and operating systems that can be used to access a WorkSpace. For more information, see [Amazon WorkSpaces Client Network Requirements](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-network-requirements.html).
    public struct WorkspaceAccessProperties: Swift.Equatable {
        /// Indicates whether users can use Android and Android-compatible Chrome OS devices to access their WorkSpaces.
        public var deviceTypeAndroid: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use Chromebooks to access their WorkSpaces.
        public var deviceTypeChromeOs: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use iOS devices to access their WorkSpaces.
        public var deviceTypeIos: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use Linux clients to access their WorkSpaces.
        public var deviceTypeLinux: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use macOS clients to access their WorkSpaces.
        public var deviceTypeOsx: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can access their WorkSpaces through a web browser.
        public var deviceTypeWeb: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use Windows clients to access their WorkSpaces.
        public var deviceTypeWindows: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use zero client devices to access their WorkSpaces.
        public var deviceTypeZeroClient: WorkSpacesClientTypes.AccessPropertyValue?

        public init (
            deviceTypeAndroid: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeChromeOs: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeIos: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeLinux: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeOsx: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeWeb: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeWindows: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeZeroClient: WorkSpacesClientTypes.AccessPropertyValue? = nil
        )
        {
            self.deviceTypeAndroid = deviceTypeAndroid
            self.deviceTypeChromeOs = deviceTypeChromeOs
            self.deviceTypeIos = deviceTypeIos
            self.deviceTypeLinux = deviceTypeLinux
            self.deviceTypeOsx = deviceTypeOsx
            self.deviceTypeWeb = deviceTypeWeb
            self.deviceTypeWindows = deviceTypeWindows
            self.deviceTypeZeroClient = deviceTypeZeroClient
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceBundle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case computeType = "ComputeType"
        case creationTime = "CreationTime"
        case description = "Description"
        case imageId = "ImageId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case owner = "Owner"
        case rootStorage = "RootStorage"
        case userStorage = "UserStorage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let computeType = computeType {
            try encodeContainer.encode(computeType, forKey: .computeType)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let rootStorage = rootStorage {
            try encodeContainer.encode(rootStorage, forKey: .rootStorage)
        }
        if let userStorage = userStorage {
            try encodeContainer.encode(userStorage, forKey: .userStorage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let rootStorageDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.RootStorage.self, forKey: .rootStorage)
        rootStorage = rootStorageDecoded
        let userStorageDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.UserStorage.self, forKey: .userStorage)
        userStorage = userStorageDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace bundle.
    public struct WorkspaceBundle: Swift.Equatable {
        /// The identifier of the bundle.
        public var bundleId: Swift.String?
        /// The compute type of the bundle. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles).
        public var computeType: WorkSpacesClientTypes.ComputeType?
        /// The time when the bundle was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the bundle.
        public var description: Swift.String?
        /// The identifier of the image that was used to create the bundle.
        public var imageId: Swift.String?
        /// The last time that the bundle was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the bundle.
        public var name: Swift.String?
        /// The owner of the bundle. This is the account identifier of the owner, or AMAZON if the bundle is provided by Amazon Web Services.
        public var owner: Swift.String?
        /// The size of the root volume.
        public var rootStorage: WorkSpacesClientTypes.RootStorage?
        /// The size of the user volume.
        public var userStorage: WorkSpacesClientTypes.UserStorage?

        public init (
            bundleId: Swift.String? = nil,
            computeType: WorkSpacesClientTypes.ComputeType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            imageId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            rootStorage: WorkSpacesClientTypes.RootStorage? = nil,
            userStorage: WorkSpacesClientTypes.UserStorage? = nil
        )
        {
            self.bundleId = bundleId
            self.computeType = computeType
            self.creationTime = creationTime
            self.description = description
            self.imageId = imageId
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.owner = owner
            self.rootStorage = rootStorage
            self.userStorage = userStorage
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceConnectionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionState = "ConnectionState"
        case connectionStateCheckTimestamp = "ConnectionStateCheckTimestamp"
        case lastKnownUserConnectionTimestamp = "LastKnownUserConnectionTimestamp"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionState = connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let connectionStateCheckTimestamp = connectionStateCheckTimestamp {
            try encodeContainer.encode(connectionStateCheckTimestamp.timeIntervalSince1970, forKey: .connectionStateCheckTimestamp)
        }
        if let lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestamp {
            try encodeContainer.encode(lastKnownUserConnectionTimestamp.timeIntervalSince1970, forKey: .lastKnownUserConnectionTimestamp)
        }
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let connectionStateCheckTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .connectionStateCheckTimestamp)
        connectionStateCheckTimestamp = connectionStateCheckTimestampDecoded
        let lastKnownUserConnectionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastKnownUserConnectionTimestamp)
        lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestampDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the connection status of a WorkSpace.
    public struct WorkspaceConnectionStatus: Swift.Equatable {
        /// The connection state of the WorkSpace. The connection state is unknown if the WorkSpace is stopped.
        public var connectionState: WorkSpacesClientTypes.ConnectionState?
        /// The timestamp of the connection status check.
        public var connectionStateCheckTimestamp: ClientRuntime.Date?
        /// The timestamp of the last known user connection.
        public var lastKnownUserConnectionTimestamp: ClientRuntime.Date?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init (
            connectionState: WorkSpacesClientTypes.ConnectionState? = nil,
            connectionStateCheckTimestamp: ClientRuntime.Date? = nil,
            lastKnownUserConnectionTimestamp: ClientRuntime.Date? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.connectionState = connectionState
            self.connectionStateCheckTimestamp = connectionStateCheckTimestamp
            self.lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestamp
            self.workspaceId = workspaceId
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceCreationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customSecurityGroupId = "CustomSecurityGroupId"
        case defaultOu = "DefaultOu"
        case enableInternetAccess = "EnableInternetAccess"
        case enableMaintenanceMode = "EnableMaintenanceMode"
        case enableWorkDocs = "EnableWorkDocs"
        case userEnabledAsLocalAdministrator = "UserEnabledAsLocalAdministrator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customSecurityGroupId = customSecurityGroupId {
            try encodeContainer.encode(customSecurityGroupId, forKey: .customSecurityGroupId)
        }
        if let defaultOu = defaultOu {
            try encodeContainer.encode(defaultOu, forKey: .defaultOu)
        }
        if let enableInternetAccess = enableInternetAccess {
            try encodeContainer.encode(enableInternetAccess, forKey: .enableInternetAccess)
        }
        if let enableMaintenanceMode = enableMaintenanceMode {
            try encodeContainer.encode(enableMaintenanceMode, forKey: .enableMaintenanceMode)
        }
        if let enableWorkDocs = enableWorkDocs {
            try encodeContainer.encode(enableWorkDocs, forKey: .enableWorkDocs)
        }
        if let userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator {
            try encodeContainer.encode(userEnabledAsLocalAdministrator, forKey: .userEnabledAsLocalAdministrator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableWorkDocsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWorkDocs)
        enableWorkDocs = enableWorkDocsDecoded
        let enableInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableInternetAccess)
        enableInternetAccess = enableInternetAccessDecoded
        let defaultOuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOu)
        defaultOu = defaultOuDecoded
        let customSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customSecurityGroupId)
        customSecurityGroupId = customSecurityGroupIdDecoded
        let userEnabledAsLocalAdministratorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userEnabledAsLocalAdministrator)
        userEnabledAsLocalAdministrator = userEnabledAsLocalAdministratorDecoded
        let enableMaintenanceModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMaintenanceMode)
        enableMaintenanceMode = enableMaintenanceModeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the default properties that are used for creating WorkSpaces. For more information, see [Update Directory Details for Your WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html).
    public struct WorkspaceCreationProperties: Swift.Equatable {
        /// The identifier of your custom security group.
        public var customSecurityGroupId: Swift.String?
        /// The default organizational unit (OU) for your WorkSpaces directories. This string must be the full Lightweight Directory Access Protocol (LDAP) distinguished name for the target domain and OU. It must be in the form "OU=value,DC=value,DC=value", where value is any string of characters, and the number of domain components (DCs) is two or more. For example, OU=WorkSpaces_machines,DC=machines,DC=example,DC=com.
        ///
        /// * To avoid errors, certain characters in the distinguished name must be escaped. For more information, see [ Distinguished Names](https://docs.microsoft.com/previous-versions/windows/desktop/ldap/distinguished-names) in the Microsoft documentation.
        ///
        /// * The API doesn't validate whether the OU exists.
        public var defaultOu: Swift.String?
        /// Indicates whether internet access is enabled for your WorkSpaces.
        public var enableInternetAccess: Swift.Bool?
        /// Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see [WorkSpace Maintenance](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html).
        public var enableMaintenanceMode: Swift.Bool?
        /// Indicates whether Amazon WorkDocs is enabled for your WorkSpaces.
        ///
        ///
        /// If WorkDocs is already enabled for a WorkSpaces directory and you disable it, new WorkSpaces launched in the directory will not have WorkDocs enabled. However, WorkDocs remains enabled for any existing WorkSpaces, unless you either disable users' access to WorkDocs or you delete the WorkDocs site. To disable users' access to WorkDocs, see [Disabling Users](https://docs.aws.amazon.com/workdocs/latest/adminguide/inactive-user.html) in the Amazon WorkDocs Administration Guide. To delete a WorkDocs site, see [Deleting a Site](https://docs.aws.amazon.com/workdocs/latest/adminguide/manage-sites.html) in the Amazon WorkDocs Administration Guide. If you enable WorkDocs on a directory that already has existing WorkSpaces, the existing WorkSpaces and any new WorkSpaces that are launched in the directory will have WorkDocs enabled.
        public var enableWorkDocs: Swift.Bool?
        /// Indicates whether users are local administrators of their WorkSpaces.
        public var userEnabledAsLocalAdministrator: Swift.Bool?

        public init (
            customSecurityGroupId: Swift.String? = nil,
            defaultOu: Swift.String? = nil,
            enableInternetAccess: Swift.Bool? = nil,
            enableMaintenanceMode: Swift.Bool? = nil,
            enableWorkDocs: Swift.Bool? = nil,
            userEnabledAsLocalAdministrator: Swift.Bool? = nil
        )
        {
            self.customSecurityGroupId = customSecurityGroupId
            self.defaultOu = defaultOu
            self.enableInternetAccess = enableInternetAccess
            self.enableMaintenanceMode = enableMaintenanceMode
            self.enableWorkDocs = enableWorkDocs
            self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceDirectory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case customerUserName = "CustomerUserName"
        case directoryId = "DirectoryId"
        case directoryName = "DirectoryName"
        case directoryType = "DirectoryType"
        case dnsIpAddresses = "DnsIpAddresses"
        case iamRoleId = "IamRoleId"
        case registrationCode = "RegistrationCode"
        case selfservicePermissions = "SelfservicePermissions"
        case state = "State"
        case subnetIds = "SubnetIds"
        case tenancy = "Tenancy"
        case workspaceAccessProperties = "WorkspaceAccessProperties"
        case workspaceCreationProperties = "WorkspaceCreationProperties"
        case workspaceSecurityGroupId = "WorkspaceSecurityGroupId"
        case ipGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let customerUserName = customerUserName {
            try encodeContainer.encode(customerUserName, forKey: .customerUserName)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let directoryType = directoryType {
            try encodeContainer.encode(directoryType.rawValue, forKey: .directoryType)
        }
        if let dnsIpAddresses = dnsIpAddresses {
            var dnsIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddresses)
            for dnsipaddresses0 in dnsIpAddresses {
                try dnsIpAddressesContainer.encode(dnsipaddresses0)
            }
        }
        if let iamRoleId = iamRoleId {
            try encodeContainer.encode(iamRoleId, forKey: .iamRoleId)
        }
        if let registrationCode = registrationCode {
            try encodeContainer.encode(registrationCode, forKey: .registrationCode)
        }
        if let selfservicePermissions = selfservicePermissions {
            try encodeContainer.encode(selfservicePermissions, forKey: .selfservicePermissions)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tenancy = tenancy {
            try encodeContainer.encode(tenancy.rawValue, forKey: .tenancy)
        }
        if let workspaceAccessProperties = workspaceAccessProperties {
            try encodeContainer.encode(workspaceAccessProperties, forKey: .workspaceAccessProperties)
        }
        if let workspaceCreationProperties = workspaceCreationProperties {
            try encodeContainer.encode(workspaceCreationProperties, forKey: .workspaceCreationProperties)
        }
        if let workspaceSecurityGroupId = workspaceSecurityGroupId {
            try encodeContainer.encode(workspaceSecurityGroupId, forKey: .workspaceSecurityGroupId)
        }
        if let ipGroupIds = ipGroupIds {
            var ipGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipGroupIds)
            for ipgroupidlist0 in ipGroupIds {
                try ipGroupIdsContainer.encode(ipgroupidlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let registrationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationCode)
        registrationCode = registrationCodeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let dnsIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIpAddresses)
        var dnsIpAddressesDecoded0:[Swift.String]? = nil
        if let dnsIpAddressesContainer = dnsIpAddressesContainer {
            dnsIpAddressesDecoded0 = [Swift.String]()
            for string0 in dnsIpAddressesContainer {
                if let string0 = string0 {
                    dnsIpAddressesDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddresses = dnsIpAddressesDecoded0
        let customerUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerUserName)
        customerUserName = customerUserNameDecoded
        let iamRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleId)
        iamRoleId = iamRoleIdDecoded
        let directoryTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceDirectoryType.self, forKey: .directoryType)
        directoryType = directoryTypeDecoded
        let workspaceSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceSecurityGroupId)
        workspaceSecurityGroupId = workspaceSecurityGroupIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceDirectoryState.self, forKey: .state)
        state = stateDecoded
        let workspaceCreationPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultWorkspaceCreationProperties.self, forKey: .workspaceCreationProperties)
        workspaceCreationProperties = workspaceCreationPropertiesDecoded
        let ipGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipGroupIds)
        var ipGroupIdsDecoded0:[Swift.String]? = nil
        if let ipGroupIdsContainer = ipGroupIdsContainer {
            ipGroupIdsDecoded0 = [Swift.String]()
            for string0 in ipGroupIdsContainer {
                if let string0 = string0 {
                    ipGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ipGroupIds = ipGroupIdsDecoded0
        let workspaceAccessPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceAccessProperties.self, forKey: .workspaceAccessProperties)
        workspaceAccessProperties = workspaceAccessPropertiesDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.Tenancy.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let selfservicePermissionsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.SelfservicePermissions.self, forKey: .selfservicePermissions)
        selfservicePermissions = selfservicePermissionsDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a directory that is used with Amazon WorkSpaces.
    public struct WorkspaceDirectory: Swift.Equatable {
        /// The directory alias.
        public var alias: Swift.String?
        /// The user name for the service account.
        public var customerUserName: Swift.String?
        /// The directory identifier.
        public var directoryId: Swift.String?
        /// The name of the directory.
        public var directoryName: Swift.String?
        /// The directory type.
        public var directoryType: WorkSpacesClientTypes.WorkspaceDirectoryType?
        /// The IP addresses of the DNS servers for the directory.
        public var dnsIpAddresses: [Swift.String]?
        /// The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.
        public var iamRoleId: Swift.String?
        /// The identifiers of the IP access control groups associated with the directory.
        public var ipGroupIds: [Swift.String]?
        /// The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.
        public var registrationCode: Swift.String?
        /// The default self-service permissions for WorkSpaces in the directory.
        public var selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions?
        /// The state of the directory's registration with Amazon WorkSpaces. After a directory is deregistered, the DEREGISTERED state is returned very briefly before the directory metadata is cleaned up, so this state is rarely returned. To confirm that a directory is deregistered, check for the directory ID by using [ DescribeWorkspaceDirectories](https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaceDirectories.html). If the directory ID isn't returned, then the directory has been successfully deregistered.
        public var state: WorkSpacesClientTypes.WorkspaceDirectoryState?
        /// The identifiers of the subnets used with the directory.
        public var subnetIds: [Swift.String]?
        /// Specifies whether the directory is dedicated or shared. To use Bring Your Own License (BYOL), this value must be set to DEDICATED. For more information, see [Bring Your Own Windows Desktop Images](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
        public var tenancy: WorkSpacesClientTypes.Tenancy?
        /// The devices and operating systems that users can use to access WorkSpaces.
        public var workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties?
        /// The default creation properties for all WorkSpaces in the directory.
        public var workspaceCreationProperties: WorkSpacesClientTypes.DefaultWorkspaceCreationProperties?
        /// The identifier of the security group that is assigned to new WorkSpaces.
        public var workspaceSecurityGroupId: Swift.String?

        public init (
            alias: Swift.String? = nil,
            customerUserName: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            directoryName: Swift.String? = nil,
            directoryType: WorkSpacesClientTypes.WorkspaceDirectoryType? = nil,
            dnsIpAddresses: [Swift.String]? = nil,
            iamRoleId: Swift.String? = nil,
            ipGroupIds: [Swift.String]? = nil,
            registrationCode: Swift.String? = nil,
            selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions? = nil,
            state: WorkSpacesClientTypes.WorkspaceDirectoryState? = nil,
            subnetIds: [Swift.String]? = nil,
            tenancy: WorkSpacesClientTypes.Tenancy? = nil,
            workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties? = nil,
            workspaceCreationProperties: WorkSpacesClientTypes.DefaultWorkspaceCreationProperties? = nil,
            workspaceSecurityGroupId: Swift.String? = nil
        )
        {
            self.alias = alias
            self.customerUserName = customerUserName
            self.directoryId = directoryId
            self.directoryName = directoryName
            self.directoryType = directoryType
            self.dnsIpAddresses = dnsIpAddresses
            self.iamRoleId = iamRoleId
            self.ipGroupIds = ipGroupIds
            self.registrationCode = registrationCode
            self.selfservicePermissions = selfservicePermissions
            self.state = state
            self.subnetIds = subnetIds
            self.tenancy = tenancy
            self.workspaceAccessProperties = workspaceAccessProperties
            self.workspaceCreationProperties = workspaceCreationProperties
            self.workspaceSecurityGroupId = workspaceSecurityGroupId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum WorkspaceDirectoryState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deregistered
        case deregistering
        case error
        case registered
        case registering
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceDirectoryState] {
            return [
                .deregistered,
                .deregistering,
                .error,
                .registered,
                .registering,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deregistered: return "DEREGISTERED"
            case .deregistering: return "DEREGISTERING"
            case .error: return "ERROR"
            case .registered: return "REGISTERED"
            case .registering: return "REGISTERING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceDirectoryState(rawValue: rawValue) ?? WorkspaceDirectoryState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum WorkspaceDirectoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adConnector
        case simpleAd
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceDirectoryType] {
            return [
                .adConnector,
                .simpleAd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adConnector: return "AD_CONNECTOR"
            case .simpleAd: return "SIMPLE_AD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceDirectoryType(rawValue: rawValue) ?? WorkspaceDirectoryType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.WorkspaceImage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case description = "Description"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case imageId = "ImageId"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case ownerAccountId = "OwnerAccountId"
        case requiredTenancy = "RequiredTenancy"
        case state = "State"
        case updates = "Updates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
        if let ownerAccountId = ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let requiredTenancy = requiredTenancy {
            try encodeContainer.encode(requiredTenancy.rawValue, forKey: .requiredTenancy)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let updates = updates {
            try encodeContainer.encode(updates, forKey: .updates)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageState.self, forKey: .state)
        state = stateDecoded
        let requiredTenancyDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageRequiredTenancy.self, forKey: .requiredTenancy)
        requiredTenancy = requiredTenancyDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let updatesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.UpdateResult.self, forKey: .updates)
        updates = updatesDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace image.
    public struct WorkspaceImage: Swift.Equatable {
        /// The date when the image was created. If the image has been shared, the Amazon Web Services account that the image has been shared with sees the original creation date of the image.
        public var created: ClientRuntime.Date?
        /// The description of the image.
        public var description: Swift.String?
        /// The error code that is returned for the image.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned for the image.
        public var errorMessage: Swift.String?
        /// The identifier of the image.
        public var imageId: Swift.String?
        /// The name of the image.
        public var name: Swift.String?
        /// The operating system that the image is running.
        public var operatingSystem: WorkSpacesClientTypes.OperatingSystem?
        /// The identifier of the Amazon Web Services account that owns the image.
        public var ownerAccountId: Swift.String?
        /// Specifies whether the image is running on dedicated hardware. When Bring Your Own License (BYOL) is enabled, this value is set to DEDICATED. For more information, see [Bring Your Own Windows Desktop Images](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
        public var requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy?
        /// The status of the image.
        public var state: WorkSpacesClientTypes.WorkspaceImageState?
        /// The updates (if any) that are available for the specified image.
        public var updates: WorkSpacesClientTypes.UpdateResult?

        public init (
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            imageId: Swift.String? = nil,
            name: Swift.String? = nil,
            operatingSystem: WorkSpacesClientTypes.OperatingSystem? = nil,
            ownerAccountId: Swift.String? = nil,
            requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy? = nil,
            state: WorkSpacesClientTypes.WorkspaceImageState? = nil,
            updates: WorkSpacesClientTypes.UpdateResult? = nil
        )
        {
            self.created = created
            self.description = description
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.imageId = imageId
            self.name = name
            self.operatingSystem = operatingSystem
            self.ownerAccountId = ownerAccountId
            self.requiredTenancy = requiredTenancy
            self.state = state
            self.updates = updates
        }
    }

}

extension WorkSpacesClientTypes {
    public enum WorkspaceImageIngestionProcess: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case byolGraphics
        case byolGraphicspro
        case byolRegular
        case byolRegularWsp
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageIngestionProcess] {
            return [
                .byolGraphics,
                .byolGraphicspro,
                .byolRegular,
                .byolRegularWsp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .byolGraphics: return "BYOL_GRAPHICS"
            case .byolGraphicspro: return "BYOL_GRAPHICSPRO"
            case .byolRegular: return "BYOL_REGULAR"
            case .byolRegularWsp: return "BYOL_REGULAR_WSP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceImageIngestionProcess(rawValue: rawValue) ?? WorkspaceImageIngestionProcess.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum WorkspaceImageRequiredTenancy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dedicated
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageRequiredTenancy] {
            return [
                .dedicated,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "DEDICATED"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceImageRequiredTenancy(rawValue: rawValue) ?? WorkspaceImageRequiredTenancy.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum WorkspaceImageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case error
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageState] {
            return [
                .available,
                .error,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceImageState(rawValue: rawValue) ?? WorkspaceImageState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.WorkspaceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeTypeName = "ComputeTypeName"
        case rootVolumeSizeGib = "RootVolumeSizeGib"
        case runningMode = "RunningMode"
        case runningModeAutoStopTimeoutInMinutes = "RunningModeAutoStopTimeoutInMinutes"
        case userVolumeSizeGib = "UserVolumeSizeGib"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeTypeName = computeTypeName {
            try encodeContainer.encode(computeTypeName.rawValue, forKey: .computeTypeName)
        }
        if let rootVolumeSizeGib = rootVolumeSizeGib {
            try encodeContainer.encode(rootVolumeSizeGib, forKey: .rootVolumeSizeGib)
        }
        if let runningMode = runningMode {
            try encodeContainer.encode(runningMode.rawValue, forKey: .runningMode)
        }
        if let runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutes {
            try encodeContainer.encode(runningModeAutoStopTimeoutInMinutes, forKey: .runningModeAutoStopTimeoutInMinutes)
        }
        if let userVolumeSizeGib = userVolumeSizeGib {
            try encodeContainer.encode(userVolumeSizeGib, forKey: .userVolumeSizeGib)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runningModeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.RunningMode.self, forKey: .runningMode)
        runningMode = runningModeDecoded
        let runningModeAutoStopTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .runningModeAutoStopTimeoutInMinutes)
        runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutesDecoded
        let rootVolumeSizeGibDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rootVolumeSizeGib)
        rootVolumeSizeGib = rootVolumeSizeGibDecoded
        let userVolumeSizeGibDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userVolumeSizeGib)
        userVolumeSizeGib = userVolumeSizeGibDecoded
        let computeTypeNameDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.Compute.self, forKey: .computeTypeName)
        computeTypeName = computeTypeNameDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace.
    public struct WorkspaceProperties: Swift.Equatable {
        /// The compute type. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles).
        public var computeTypeName: WorkSpacesClientTypes.Compute?
        /// The size of the root volume. For important information about how to modify the size of the root and user volumes, see [Modify a WorkSpace](https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html).
        public var rootVolumeSizeGib: Swift.Int?
        /// The running mode. For more information, see [Manage the WorkSpace Running Mode](https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html).
        public var runningMode: WorkSpacesClientTypes.RunningMode?
        /// The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.
        public var runningModeAutoStopTimeoutInMinutes: Swift.Int?
        /// The size of the user storage. For important information about how to modify the size of the root and user volumes, see [Modify a WorkSpace](https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html).
        public var userVolumeSizeGib: Swift.Int?

        public init (
            computeTypeName: WorkSpacesClientTypes.Compute? = nil,
            rootVolumeSizeGib: Swift.Int? = nil,
            runningMode: WorkSpacesClientTypes.RunningMode? = nil,
            runningModeAutoStopTimeoutInMinutes: Swift.Int? = nil,
            userVolumeSizeGib: Swift.Int? = nil
        )
        {
            self.computeTypeName = computeTypeName
            self.rootVolumeSizeGib = rootVolumeSizeGib
            self.runningMode = runningMode
            self.runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutes
            self.userVolumeSizeGib = userVolumeSizeGib
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case directoryId = "DirectoryId"
        case rootVolumeEncryptionEnabled = "RootVolumeEncryptionEnabled"
        case tags = "Tags"
        case userName = "UserName"
        case userVolumeEncryptionEnabled = "UserVolumeEncryptionEnabled"
        case volumeEncryptionKey = "VolumeEncryptionKey"
        case workspaceProperties = "WorkspaceProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled {
            try encodeContainer.encode(rootVolumeEncryptionEnabled, forKey: .rootVolumeEncryptionEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userVolumeEncryptionEnabled = userVolumeEncryptionEnabled {
            try encodeContainer.encode(userVolumeEncryptionEnabled, forKey: .userVolumeEncryptionEnabled)
        }
        if let volumeEncryptionKey = volumeEncryptionKey {
            try encodeContainer.encode(volumeEncryptionKey, forKey: .volumeEncryptionKey)
        }
        if let workspaceProperties = workspaceProperties {
            try encodeContainer.encode(workspaceProperties, forKey: .workspaceProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let volumeEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeEncryptionKey)
        volumeEncryptionKey = volumeEncryptionKeyDecoded
        let userVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userVolumeEncryptionEnabled)
        userVolumeEncryptionEnabled = userVolumeEncryptionEnabledDecoded
        let rootVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rootVolumeEncryptionEnabled)
        rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabledDecoded
        let workspacePropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceProperties.self, forKey: .workspaceProperties)
        workspaceProperties = workspacePropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to create a WorkSpace.
    public struct WorkspaceRequest: Swift.Equatable {
        /// The identifier of the bundle for the WorkSpace. You can use [DescribeWorkspaceBundles] to list the available bundles.
        /// This member is required.
        public var bundleId: Swift.String?
        /// The identifier of the Directory Service directory for the WorkSpace. You can use [DescribeWorkspaceDirectories] to list the available directories.
        /// This member is required.
        public var directoryId: Swift.String?
        /// Indicates whether the data stored on the root volume is encrypted.
        public var rootVolumeEncryptionEnabled: Swift.Bool?
        /// The tags for the WorkSpace.
        public var tags: [WorkSpacesClientTypes.Tag]?
        /// The user name of the user for the WorkSpace. This user name must exist in the Directory Service directory for the WorkSpace.
        /// This member is required.
        public var userName: Swift.String?
        /// Indicates whether the data stored on the user volume is encrypted.
        public var userVolumeEncryptionEnabled: Swift.Bool?
        /// The symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.
        public var volumeEncryptionKey: Swift.String?
        /// The WorkSpace properties.
        public var workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?

        public init (
            bundleId: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            rootVolumeEncryptionEnabled: Swift.Bool? = nil,
            tags: [WorkSpacesClientTypes.Tag]? = nil,
            userName: Swift.String? = nil,
            userVolumeEncryptionEnabled: Swift.Bool? = nil,
            volumeEncryptionKey: Swift.String? = nil,
            workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties? = nil
        )
        {
            self.bundleId = bundleId
            self.directoryId = directoryId
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.tags = tags
            self.userName = userName
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.volumeEncryptionKey = volumeEncryptionKey
            self.workspaceProperties = workspaceProperties
        }
    }

}

extension WorkSpacesClientTypes {
    public enum WorkspaceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adminMaintenance
        case available
        case error
        case impaired
        case maintenance
        case pending
        case rebooting
        case rebuilding
        case restoring
        case starting
        case stopped
        case stopping
        case suspended
        case terminated
        case terminating
        case unhealthy
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceState] {
            return [
                .adminMaintenance,
                .available,
                .error,
                .impaired,
                .maintenance,
                .pending,
                .rebooting,
                .rebuilding,
                .restoring,
                .starting,
                .stopped,
                .stopping,
                .suspended,
                .terminated,
                .terminating,
                .unhealthy,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adminMaintenance: return "ADMIN_MAINTENANCE"
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .impaired: return "IMPAIRED"
            case .maintenance: return "MAINTENANCE"
            case .pending: return "PENDING"
            case .rebooting: return "REBOOTING"
            case .rebuilding: return "REBUILDING"
            case .restoring: return "RESTORING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .suspended: return "SUSPENDED"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case .unhealthy: return "UNHEALTHY"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceState(rawValue: rawValue) ?? WorkspaceState.sdkUnknown(rawValue)
        }
    }
}

extension WorkspacesDefaultRoleNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: WorkspacesDefaultRoleNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The workspaces_DefaultRole role could not be found. If this is the first time you are registering a directory, you will need to create the workspaces_DefaultRole role before you can register a directory. For more information, see [Creating the workspaces_DefaultRole Role](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-access-control.html#create-default-role).
public struct WorkspacesDefaultRoleNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct WorkspacesDefaultRoleNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension WorkspacesDefaultRoleNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesClientTypes.WorkspacesIpGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupDesc
        case groupId
        case groupName
        case userRules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupDesc = groupDesc {
            try encodeContainer.encode(groupDesc, forKey: .groupDesc)
        }
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for iprulelist0 in userRules {
                try userRulesContainer.encode(iprulelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDescDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupDesc)
        groupDesc = groupDescDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[WorkSpacesClientTypes.IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [WorkSpacesClientTypes.IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes an IP access control group.
    public struct WorkspacesIpGroup: Swift.Equatable {
        /// The description of the group.
        public var groupDesc: Swift.String?
        /// The identifier of the group.
        public var groupId: Swift.String?
        /// The name of the group.
        public var groupName: Swift.String?
        /// The rules.
        public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

        public init (
            groupDesc: Swift.String? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
        )
        {
            self.groupDesc = groupDesc
            self.groupId = groupId
            self.groupName = groupName
            self.userRules = userRules
        }
    }

}
