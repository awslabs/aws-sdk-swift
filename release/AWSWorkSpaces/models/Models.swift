// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user is not authorized to access a resource.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesClientTypes {
    public enum AccessPropertyValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPropertyValue] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessPropertyValue(rawValue: rawValue) ?? AccessPropertyValue.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.AccountModification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case modificationState = "ModificationState"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dedicatedTenancyManagementCidrRange = self.dedicatedTenancyManagementCidrRange {
            try encodeContainer.encode(dedicatedTenancyManagementCidrRange, forKey: .dedicatedTenancyManagementCidrRange)
        }
        if let dedicatedTenancySupport = self.dedicatedTenancySupport {
            try encodeContainer.encode(dedicatedTenancySupport.rawValue, forKey: .dedicatedTenancySupport)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let modificationState = self.modificationState {
            try encodeContainer.encode(modificationState.rawValue, forKey: .modificationState)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modificationStateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DedicatedTenancyModificationStateEnum.self, forKey: .modificationState)
        modificationState = modificationStateDecoded
        let dedicatedTenancySupportDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DedicatedTenancySupportResultEnum.self, forKey: .dedicatedTenancySupport)
        dedicatedTenancySupport = dedicatedTenancySupportDecoded
        let dedicatedTenancyManagementCidrRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedTenancyManagementCidrRange)
        dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRangeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a modification to the configuration of Bring Your Own License (BYOL) for the specified account.
    public struct AccountModification: Swift.Equatable {
        /// The IP address range, specified as an IPv4 CIDR block, for the management network interface used for the account.
        public var dedicatedTenancyManagementCidrRange: Swift.String?
        /// The status of BYOL (whether BYOL is being enabled or disabled).
        public var dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum?
        /// The error code that is returned if the configuration of BYOL cannot be modified.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the configuration of BYOL cannot be modified.
        public var errorMessage: Swift.String?
        /// The state of the modification to the configuration of BYOL.
        public var modificationState: WorkSpacesClientTypes.DedicatedTenancyModificationStateEnum?
        /// The timestamp when the modification of the BYOL configuration was started.
        public var startTime: ClientRuntime.Date?

        public init (
            dedicatedTenancyManagementCidrRange: Swift.String? = nil,
            dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            modificationState: WorkSpacesClientTypes.DedicatedTenancyModificationStateEnum? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
            self.dedicatedTenancySupport = dedicatedTenancySupport
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.modificationState = modificationState
            self.startTime = startTime
        }
    }

}

extension WorkSpacesClientTypes {
    public enum Application: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case microsoftOffice2016
        case microsoftOffice2019
        case sdkUnknown(Swift.String)

        public static var allCases: [Application] {
            return [
                .microsoftOffice2016,
                .microsoftOffice2019,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .microsoftOffice2016: return "Microsoft_Office_2016"
            case .microsoftOffice2019: return "Microsoft_Office_2019"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Application(rawValue: rawValue) ?? Application.sdkUnknown(rawValue)
        }
    }
}

extension AssociateConnectionAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = self.aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension AssociateConnectionAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateConnectionAliasInput: Swift.Equatable {
    /// The identifier of the connection alias.
    /// This member is required.
    public var aliasId: Swift.String?
    /// The identifier of the directory to associate the connection alias with.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        aliasId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
        self.resourceId = resourceId
    }
}

struct AssociateConnectionAliasInputBody: Swift.Equatable {
    let aliasId: Swift.String?
    let resourceId: Swift.String?
}

extension AssociateConnectionAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension AssociateConnectionAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateConnectionAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateConnectionAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateConnectionAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateConnectionAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionIdentifier = output.connectionIdentifier
        } else {
            self.connectionIdentifier = nil
        }
    }
}

public struct AssociateConnectionAliasOutputResponse: Swift.Equatable {
    /// The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when you're configuring your DNS routing policies.
    public var connectionIdentifier: Swift.String?

    public init (
        connectionIdentifier: Swift.String? = nil
    )
    {
        self.connectionIdentifier = connectionIdentifier
    }
}

struct AssociateConnectionAliasOutputResponseBody: Swift.Equatable {
    let connectionIdentifier: Swift.String?
}

extension AssociateConnectionAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionIdentifier = "ConnectionIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionIdentifier)
        connectionIdentifier = connectionIdentifierDecoded
    }
}

extension AssociateIpGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for ipgroupid0 in groupIds {
                try groupIdsContainer.encode(ipgroupid0)
            }
        }
    }
}

extension AssociateIpGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateIpGroupsInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The identifiers of one or more IP access control groups.
    /// This member is required.
    public var groupIds: [Swift.String]?

    public init (
        directoryId: Swift.String? = nil,
        groupIds: [Swift.String]? = nil
    )
    {
        self.directoryId = directoryId
        self.groupIds = groupIds
    }
}

struct AssociateIpGroupsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let groupIds: [Swift.String]?
}

extension AssociateIpGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let groupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[Swift.String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [Swift.String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
    }
}

extension AssociateIpGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateIpGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateIpGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateIpGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateIpGroupsOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkSpacesClientTypes {
    public enum AssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associatedWithOwnerAccount
        case associatedWithSharedAccount
        case notAssociated
        case pendingAssociation
        case pendingDisassociation
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationStatus] {
            return [
                .associatedWithOwnerAccount,
                .associatedWithSharedAccount,
                .notAssociated,
                .pendingAssociation,
                .pendingDisassociation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associatedWithOwnerAccount: return "ASSOCIATED_WITH_OWNER_ACCOUNT"
            case .associatedWithSharedAccount: return "ASSOCIATED_WITH_SHARED_ACCOUNT"
            case .notAssociated: return "NOT_ASSOCIATED"
            case .pendingAssociation: return "PENDING_ASSOCIATION"
            case .pendingDisassociation: return "PENDING_DISASSOCIATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationStatus(rawValue: rawValue) ?? AssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuthorizeIpRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for ipruleitem0 in userRules {
                try userRulesContainer.encode(ipruleitem0)
            }
        }
    }
}

extension AuthorizeIpRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AuthorizeIpRulesInput: Swift.Equatable {
    /// The identifier of the group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The rules to add to the group.
    /// This member is required.
    public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

    public init (
        groupId: Swift.String? = nil,
        userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

struct AuthorizeIpRulesInputBody: Swift.Equatable {
    let groupId: Swift.String?
    let userRules: [WorkSpacesClientTypes.IpRuleItem]?
}

extension AuthorizeIpRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[WorkSpacesClientTypes.IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [WorkSpacesClientTypes.IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension AuthorizeIpRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AuthorizeIpRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AuthorizeIpRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AuthorizeIpRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AuthorizeIpRulesOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkSpacesClientTypes {
    public enum BundleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case regular
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [BundleType] {
            return [
                .regular,
                .standby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .regular: return "REGULAR"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BundleType(rawValue: rawValue) ?? BundleType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.CertificateBasedAuthProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = self.certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.CertificateBasedAuthStatusEnum.self, forKey: .status)
        status = statusDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the properties of the certificate-based authentication you want to use with your WorkSpaces.
    public struct CertificateBasedAuthProperties: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Certificate Manager Private CA resource.
        public var certificateAuthorityArn: Swift.String?
        /// The status of the certificate-based authentication properties.
        public var status: WorkSpacesClientTypes.CertificateBasedAuthStatusEnum?

        public init (
            certificateAuthorityArn: Swift.String? = nil,
            status: WorkSpacesClientTypes.CertificateBasedAuthStatusEnum? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.status = status
        }
    }

}

extension WorkSpacesClientTypes {
    public enum CertificateBasedAuthStatusEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateBasedAuthStatusEnum] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateBasedAuthStatusEnum(rawValue: rawValue) ?? CertificateBasedAuthStatusEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum ClientDeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deviceTypeAndroid
        case deviceTypeIos
        case deviceTypeLinux
        case deviceTypeOsx
        case deviceTypeWeb
        case deviceTypeWindows
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientDeviceType] {
            return [
                .deviceTypeAndroid,
                .deviceTypeIos,
                .deviceTypeLinux,
                .deviceTypeOsx,
                .deviceTypeWeb,
                .deviceTypeWindows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deviceTypeAndroid: return "DeviceTypeAndroid"
            case .deviceTypeIos: return "DeviceTypeIos"
            case .deviceTypeLinux: return "DeviceTypeLinux"
            case .deviceTypeOsx: return "DeviceTypeOsx"
            case .deviceTypeWeb: return "DeviceTypeWeb"
            case .deviceTypeWindows: return "DeviceTypeWindows"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientDeviceType(rawValue: rawValue) ?? ClientDeviceType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.ClientProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logUploadEnabled = "LogUploadEnabled"
        case reconnectEnabled = "ReconnectEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logUploadEnabled = self.logUploadEnabled {
            try encodeContainer.encode(logUploadEnabled.rawValue, forKey: .logUploadEnabled)
        }
        if let reconnectEnabled = self.reconnectEnabled {
            try encodeContainer.encode(reconnectEnabled.rawValue, forKey: .reconnectEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reconnectEnabledDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .reconnectEnabled)
        reconnectEnabled = reconnectEnabledDecoded
        let logUploadEnabledDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.LogUploadEnum.self, forKey: .logUploadEnabled)
        logUploadEnabled = logUploadEnabledDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes an Amazon WorkSpaces client.
    public struct ClientProperties: Swift.Equatable {
        /// Specifies whether users can upload diagnostic log files of Amazon WorkSpaces client directly to WorkSpaces to troubleshoot issues when using the WorkSpaces client. When enabled, the log files will be sent to WorkSpaces automatically and will be applied to all users in the specified directory.
        public var logUploadEnabled: WorkSpacesClientTypes.LogUploadEnum?
        /// Specifies whether users can cache their credentials on the Amazon WorkSpaces client. When enabled, users can choose to reconnect to their WorkSpaces without re-entering their credentials.
        public var reconnectEnabled: WorkSpacesClientTypes.ReconnectEnum?

        public init (
            logUploadEnabled: WorkSpacesClientTypes.LogUploadEnum? = nil,
            reconnectEnabled: WorkSpacesClientTypes.ReconnectEnum? = nil
        )
        {
            self.logUploadEnabled = logUploadEnabled
            self.reconnectEnabled = reconnectEnabled
        }
    }

}

extension WorkSpacesClientTypes.ClientPropertiesResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientProperties = "ClientProperties"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientProperties = self.clientProperties {
            try encodeContainer.encode(clientProperties, forKey: .clientProperties)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let clientPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ClientProperties.self, forKey: .clientProperties)
        clientProperties = clientPropertiesDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Information about the Amazon WorkSpaces client.
    public struct ClientPropertiesResult: Swift.Equatable {
        /// Information about the Amazon WorkSpaces client.
        public var clientProperties: WorkSpacesClientTypes.ClientProperties?
        /// The resource identifier, in the form of a directory ID.
        public var resourceId: Swift.String?

        public init (
            clientProperties: WorkSpacesClientTypes.ClientProperties? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.clientProperties = clientProperties
            self.resourceId = resourceId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum Compute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case graphics
        case graphicspro
        case graphicsproG4dn
        case graphicsG4dn
        case performance
        case power
        case powerpro
        case standard
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [Compute] {
            return [
                .graphics,
                .graphicspro,
                .graphicsproG4dn,
                .graphicsG4dn,
                .performance,
                .power,
                .powerpro,
                .standard,
                .value,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .graphics: return "GRAPHICS"
            case .graphicspro: return "GRAPHICSPRO"
            case .graphicsproG4dn: return "GRAPHICSPRO_G4DN"
            case .graphicsG4dn: return "GRAPHICS_G4DN"
            case .performance: return "PERFORMANCE"
            case .power: return "POWER"
            case .powerpro: return "POWERPRO"
            case .standard: return "STANDARD"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Compute(rawValue: rawValue) ?? Compute.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.ComputeType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.Compute.self, forKey: .name)
        name = nameDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the compute type of the bundle.
    public struct ComputeType: Swift.Equatable {
        /// The compute type.
        public var name: WorkSpacesClientTypes.Compute?

        public init (
            name: WorkSpacesClientTypes.Compute? = nil
        )
        {
            self.name = name
        }
    }

}

extension WorkSpacesClientTypes.ConnectClientAddIn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addInId = "AddInId"
        case name = "Name"
        case resourceId = "ResourceId"
        case url = "URL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addInId = self.addInId {
            try encodeContainer.encode(addInId, forKey: .addInId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addInIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addInId)
        addInId = addInIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes an Amazon Connect client add-in.
    public struct ConnectClientAddIn: Swift.Equatable {
        /// The client add-in identifier.
        public var addInId: Swift.String?
        /// The name of the client add in.
        public var name: Swift.String?
        /// The directory identifier for which the client add-in is configured.
        public var resourceId: Swift.String?
        /// The endpoint URL of the client add-in.
        public var url: Swift.String?

        public init (
            addInId: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.addInId = addInId
            self.name = name
            self.resourceId = resourceId
            self.url = url
        }
    }

}

extension WorkSpacesClientTypes.ConnectionAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case associations = "Associations"
        case connectionString = "ConnectionString"
        case ownerAccountId = "OwnerAccountId"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = self.aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let associations = associations {
            var associationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associations)
            for connectionaliasassociation0 in associations {
                try associationsContainer.encode(connectionaliasassociation0)
            }
        }
        if let connectionString = self.connectionString {
            try encodeContainer.encode(connectionString, forKey: .connectionString)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionString)
        connectionString = connectionStringDecoded
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ConnectionAliasState.self, forKey: .state)
        state = stateDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let associationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ConnectionAliasAssociation?].self, forKey: .associations)
        var associationsDecoded0:[WorkSpacesClientTypes.ConnectionAliasAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [WorkSpacesClientTypes.ConnectionAliasAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes a connection alias. Connection aliases are used for cross-Region redirection. For more information, see [ Cross-Region Redirection for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html).
    public struct ConnectionAlias: Swift.Equatable {
        /// The identifier of the connection alias.
        public var aliasId: Swift.String?
        /// The association status of the connection alias.
        public var associations: [WorkSpacesClientTypes.ConnectionAliasAssociation]?
        /// The connection string specified for the connection alias. The connection string must be in the form of a fully qualified domain name (FQDN), such as www.example.com.
        public var connectionString: Swift.String?
        /// The identifier of the Amazon Web Services account that owns the connection alias.
        public var ownerAccountId: Swift.String?
        /// The current state of the connection alias.
        public var state: WorkSpacesClientTypes.ConnectionAliasState?

        public init (
            aliasId: Swift.String? = nil,
            associations: [WorkSpacesClientTypes.ConnectionAliasAssociation]? = nil,
            connectionString: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            state: WorkSpacesClientTypes.ConnectionAliasState? = nil
        )
        {
            self.aliasId = aliasId
            self.associations = associations
            self.connectionString = connectionString
            self.ownerAccountId = ownerAccountId
            self.state = state
        }
    }

}

extension WorkSpacesClientTypes.ConnectionAliasAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAccountId = "AssociatedAccountId"
        case associationStatus = "AssociationStatus"
        case connectionIdentifier = "ConnectionIdentifier"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedAccountId = self.associatedAccountId {
            try encodeContainer.encode(associatedAccountId, forKey: .associatedAccountId)
        }
        if let associationStatus = self.associationStatus {
            try encodeContainer.encode(associationStatus.rawValue, forKey: .associationStatus)
        }
        if let connectionIdentifier = self.connectionIdentifier {
            try encodeContainer.encode(connectionIdentifier, forKey: .connectionIdentifier)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let associatedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAccountId)
        associatedAccountId = associatedAccountIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let connectionIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionIdentifier)
        connectionIdentifier = connectionIdentifierDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a connection alias association that is used for cross-Region redirection. For more information, see [ Cross-Region Redirection for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html).
    public struct ConnectionAliasAssociation: Swift.Equatable {
        /// The identifier of the Amazon Web Services account that associated the connection alias with a directory.
        public var associatedAccountId: Swift.String?
        /// The association status of the connection alias.
        public var associationStatus: WorkSpacesClientTypes.AssociationStatus?
        /// The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when you're configuring your DNS routing policies.
        public var connectionIdentifier: Swift.String?
        /// The identifier of the directory associated with a connection alias.
        public var resourceId: Swift.String?

        public init (
            associatedAccountId: Swift.String? = nil,
            associationStatus: WorkSpacesClientTypes.AssociationStatus? = nil,
            connectionIdentifier: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.associatedAccountId = associatedAccountId
            self.associationStatus = associationStatus
            self.connectionIdentifier = connectionIdentifier
            self.resourceId = resourceId
        }
    }

}

extension WorkSpacesClientTypes.ConnectionAliasPermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowAssociation = "AllowAssociation"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowAssociation = self.allowAssociation {
            try encodeContainer.encode(allowAssociation, forKey: .allowAssociation)
        }
        if let sharedAccountId = self.sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let allowAssociationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowAssociation)
        allowAssociation = allowAssociationDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the permissions for a connection alias. Connection aliases are used for cross-Region redirection. For more information, see [ Cross-Region Redirection for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html).
    public struct ConnectionAliasPermission: Swift.Equatable {
        /// Indicates whether the specified Amazon Web Services account is allowed to associate the connection alias with a directory.
        /// This member is required.
        public var allowAssociation: Swift.Bool?
        /// The identifier of the Amazon Web Services account that the connection alias is shared with.
        /// This member is required.
        public var sharedAccountId: Swift.String?

        public init (
            allowAssociation: Swift.Bool? = nil,
            sharedAccountId: Swift.String? = nil
        )
        {
            self.allowAssociation = allowAssociation
            self.sharedAccountId = sharedAccountId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum ConnectionAliasState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionAliasState] {
            return [
                .created,
                .creating,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionAliasState(rawValue: rawValue) ?? ConnectionAliasState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum ConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case disconnected
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionState] {
            return [
                .connected,
                .disconnected,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
        }
    }
}

extension CopyWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case sourceRegion = "SourceRegion"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceImageId = self.sourceImageId {
            try encodeContainer.encode(sourceImageId, forKey: .sourceImageId)
        }
        if let sourceRegion = self.sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CopyWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CopyWorkspaceImageInput: Swift.Equatable {
    /// A description of the image.
    public var description: Swift.String?
    /// The name of the image.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the source image.
    /// This member is required.
    public var sourceImageId: Swift.String?
    /// The identifier of the source Region.
    /// This member is required.
    public var sourceRegion: Swift.String?
    /// The tags for the image.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceImageId: Swift.String? = nil,
        sourceRegion: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.sourceImageId = sourceImageId
        self.sourceRegion = sourceRegion
        self.tags = tags
    }
}

struct CopyWorkspaceImageInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let sourceImageId: Swift.String?
    let sourceRegion: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CopyWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case sourceRegion = "SourceRegion"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceImageId)
        sourceImageId = sourceImageIdDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CopyWorkspaceImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyWorkspaceImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CopyWorkspaceImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyWorkspaceImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CopyWorkspaceImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
        } else {
            self.imageId = nil
        }
    }
}

public struct CopyWorkspaceImageOutputResponse: Swift.Equatable {
    /// The identifier of the image.
    public var imageId: Swift.String?

    public init (
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct CopyWorkspaceImageOutputResponseBody: Swift.Equatable {
    let imageId: Swift.String?
}

extension CopyWorkspaceImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension CreateConnectClientAddInInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resourceId = "ResourceId"
        case url = "URL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }
}

extension CreateConnectClientAddInInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConnectClientAddInInput: Swift.Equatable {
    /// The name of the client add-in.
    /// This member is required.
    public var name: Swift.String?
    /// The directory identifier for which to configure the client add-in.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The endpoint URL of the Amazon Connect client add-in.
    /// This member is required.
    public var url: Swift.String?

    public init (
        name: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        url: Swift.String? = nil
    )
    {
        self.name = name
        self.resourceId = resourceId
        self.url = url
    }
}

struct CreateConnectClientAddInInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let name: Swift.String?
    let url: Swift.String?
}

extension CreateConnectClientAddInInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resourceId = "ResourceId"
        case url = "URL"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension CreateConnectClientAddInOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectClientAddInOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceCreationFailedException" : self = .resourceCreationFailedException(try ResourceCreationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateConnectClientAddInOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceCreationFailedException(ResourceCreationFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectClientAddInOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateConnectClientAddInOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addInId = output.addInId
        } else {
            self.addInId = nil
        }
    }
}

public struct CreateConnectClientAddInOutputResponse: Swift.Equatable {
    /// The client add-in identifier.
    public var addInId: Swift.String?

    public init (
        addInId: Swift.String? = nil
    )
    {
        self.addInId = addInId
    }
}

struct CreateConnectClientAddInOutputResponseBody: Swift.Equatable {
    let addInId: Swift.String?
}

extension CreateConnectClientAddInOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addInId = "AddInId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addInIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addInId)
        addInId = addInIdDecoded
    }
}

extension CreateConnectionAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionString = "ConnectionString"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionString = self.connectionString {
            try encodeContainer.encode(connectionString, forKey: .connectionString)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateConnectionAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConnectionAliasInput: Swift.Equatable {
    /// A connection string in the form of a fully qualified domain name (FQDN), such as www.example.com. After you create a connection string, it is always associated to your Amazon Web Services account. You cannot recreate the same connection string with a different account, even if you delete all instances of it from the original account. The connection string is globally reserved for your account.
    /// This member is required.
    public var connectionString: Swift.String?
    /// The tags to associate with the connection alias.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init (
        connectionString: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.connectionString = connectionString
        self.tags = tags
    }
}

struct CreateConnectionAliasInputBody: Swift.Equatable {
    let connectionString: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateConnectionAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionString = "ConnectionString"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionString)
        connectionString = connectionStringDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectionAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateConnectionAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateConnectionAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasId = output.aliasId
        } else {
            self.aliasId = nil
        }
    }
}

public struct CreateConnectionAliasOutputResponse: Swift.Equatable {
    /// The identifier of the connection alias.
    public var aliasId: Swift.String?

    public init (
        aliasId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

struct CreateConnectionAliasOutputResponseBody: Swift.Equatable {
    let aliasId: Swift.String?
}

extension CreateConnectionAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
    }
}

extension CreateIpGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupDesc = "GroupDesc"
        case groupName = "GroupName"
        case tags = "Tags"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupDesc = self.groupDesc {
            try encodeContainer.encode(groupDesc, forKey: .groupDesc)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for ipruleitem0 in userRules {
                try userRulesContainer.encode(ipruleitem0)
            }
        }
    }
}

extension CreateIpGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateIpGroupInput: Swift.Equatable {
    /// The description of the group.
    public var groupDesc: Swift.String?
    /// The name of the group.
    /// This member is required.
    public var groupName: Swift.String?
    /// The tags. Each WorkSpaces resource can have a maximum of 50 tags.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// The rules to add to the group.
    public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

    public init (
        groupDesc: Swift.String? = nil,
        groupName: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
    )
    {
        self.groupDesc = groupDesc
        self.groupName = groupName
        self.tags = tags
        self.userRules = userRules
    }
}

struct CreateIpGroupInputBody: Swift.Equatable {
    let groupName: Swift.String?
    let groupDesc: Swift.String?
    let userRules: [WorkSpacesClientTypes.IpRuleItem]?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateIpGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupDesc = "GroupDesc"
        case groupName = "GroupName"
        case tags = "Tags"
        case userRules = "UserRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDescDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupDesc)
        groupDesc = groupDescDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[WorkSpacesClientTypes.IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [WorkSpacesClientTypes.IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIpGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIpGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceCreationFailedException" : self = .resourceCreationFailedException(try ResourceCreationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateIpGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceCreationFailedException(ResourceCreationFailedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIpGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateIpGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupId = output.groupId
        } else {
            self.groupId = nil
        }
    }
}

public struct CreateIpGroupOutputResponse: Swift.Equatable {
    /// The identifier of the group.
    public var groupId: Swift.String?

    public init (
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct CreateIpGroupOutputResponseBody: Swift.Equatable {
    let groupId: Swift.String?
}

extension CreateIpGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension CreateStandbyWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primaryRegion = "PrimaryRegion"
        case standbyWorkspaces = "StandbyWorkspaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let primaryRegion = self.primaryRegion {
            try encodeContainer.encode(primaryRegion, forKey: .primaryRegion)
        }
        if let standbyWorkspaces = standbyWorkspaces {
            var standbyWorkspacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standbyWorkspaces)
            for standbyworkspace0 in standbyWorkspaces {
                try standbyWorkspacesContainer.encode(standbyworkspace0)
            }
        }
    }
}

extension CreateStandbyWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateStandbyWorkspacesInput: Swift.Equatable {
    /// The Region of the primary WorkSpace.
    /// This member is required.
    public var primaryRegion: Swift.String?
    /// Information about the Standby WorkSpace to be created.
    /// This member is required.
    public var standbyWorkspaces: [WorkSpacesClientTypes.StandbyWorkspace]?

    public init (
        primaryRegion: Swift.String? = nil,
        standbyWorkspaces: [WorkSpacesClientTypes.StandbyWorkspace]? = nil
    )
    {
        self.primaryRegion = primaryRegion
        self.standbyWorkspaces = standbyWorkspaces
    }
}

struct CreateStandbyWorkspacesInputBody: Swift.Equatable {
    let primaryRegion: Swift.String?
    let standbyWorkspaces: [WorkSpacesClientTypes.StandbyWorkspace]?
}

extension CreateStandbyWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primaryRegion = "PrimaryRegion"
        case standbyWorkspaces = "StandbyWorkspaces"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryRegion)
        primaryRegion = primaryRegionDecoded
        let standbyWorkspacesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.StandbyWorkspace?].self, forKey: .standbyWorkspaces)
        var standbyWorkspacesDecoded0:[WorkSpacesClientTypes.StandbyWorkspace]? = nil
        if let standbyWorkspacesContainer = standbyWorkspacesContainer {
            standbyWorkspacesDecoded0 = [WorkSpacesClientTypes.StandbyWorkspace]()
            for structure0 in standbyWorkspacesContainer {
                if let structure0 = structure0 {
                    standbyWorkspacesDecoded0?.append(structure0)
                }
            }
        }
        standbyWorkspaces = standbyWorkspacesDecoded0
    }
}

extension CreateStandbyWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStandbyWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateStandbyWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStandbyWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateStandbyWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedStandbyRequests = output.failedStandbyRequests
            self.pendingStandbyRequests = output.pendingStandbyRequests
        } else {
            self.failedStandbyRequests = nil
            self.pendingStandbyRequests = nil
        }
    }
}

public struct CreateStandbyWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the Standby WorkSpace that could not be created.
    public var failedStandbyRequests: [WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest]?
    /// Information about the Standby WorkSpace that was created.
    public var pendingStandbyRequests: [WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest]?

    public init (
        failedStandbyRequests: [WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest]? = nil,
        pendingStandbyRequests: [WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest]? = nil
    )
    {
        self.failedStandbyRequests = failedStandbyRequests
        self.pendingStandbyRequests = pendingStandbyRequests
    }
}

struct CreateStandbyWorkspacesOutputResponseBody: Swift.Equatable {
    let failedStandbyRequests: [WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest]?
    let pendingStandbyRequests: [WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest]?
}

extension CreateStandbyWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedStandbyRequests = "FailedStandbyRequests"
        case pendingStandbyRequests = "PendingStandbyRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedStandbyRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest?].self, forKey: .failedStandbyRequests)
        var failedStandbyRequestsDecoded0:[WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest]? = nil
        if let failedStandbyRequestsContainer = failedStandbyRequestsContainer {
            failedStandbyRequestsDecoded0 = [WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest]()
            for structure0 in failedStandbyRequestsContainer {
                if let structure0 = structure0 {
                    failedStandbyRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedStandbyRequests = failedStandbyRequestsDecoded0
        let pendingStandbyRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest?].self, forKey: .pendingStandbyRequests)
        var pendingStandbyRequestsDecoded0:[WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest]? = nil
        if let pendingStandbyRequestsContainer = pendingStandbyRequestsContainer {
            pendingStandbyRequestsDecoded0 = [WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest]()
            for structure0 in pendingStandbyRequestsContainer {
                if let structure0 = structure0 {
                    pendingStandbyRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingStandbyRequests = pendingStandbyRequestsDecoded0
    }
}

extension CreateTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTagsInput: Swift.Equatable {
    /// The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces, registered directories, images, custom bundles, IP access control groups, and connection aliases.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The tags. Each WorkSpaces resource can have a maximum of 50 tags.
    /// This member is required.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init (
        resourceId: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tags = tags
    }
}

struct CreateTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateTagsOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateUpdatedWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceImageId = self.sourceImageId {
            try encodeContainer.encode(sourceImageId, forKey: .sourceImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateUpdatedWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUpdatedWorkspaceImageInput: Swift.Equatable {
    /// A description of whether updates for the WorkSpace image are available.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the new updated WorkSpace image.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the source WorkSpace image.
    /// This member is required.
    public var sourceImageId: Swift.String?
    /// The tags that you want to add to the new updated WorkSpace image. To add tags at the same time when you're creating the updated image, you must create an IAM policy that grants your IAM user permissions to use workspaces:CreateTags.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceImageId: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.sourceImageId = sourceImageId
        self.tags = tags
    }
}

struct CreateUpdatedWorkspaceImageInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let sourceImageId: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateUpdatedWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case sourceImageId = "SourceImageId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceImageId)
        sourceImageId = sourceImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUpdatedWorkspaceImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUpdatedWorkspaceImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateUpdatedWorkspaceImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUpdatedWorkspaceImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateUpdatedWorkspaceImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
        } else {
            self.imageId = nil
        }
    }
}

public struct CreateUpdatedWorkspaceImageOutputResponse: Swift.Equatable {
    /// The identifier of the new updated WorkSpace image.
    public var imageId: Swift.String?

    public init (
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct CreateUpdatedWorkspaceImageOutputResponseBody: Swift.Equatable {
    let imageId: Swift.String?
}

extension CreateUpdatedWorkspaceImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension CreateWorkspaceBundleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleDescription = "BundleDescription"
        case bundleName = "BundleName"
        case computeType = "ComputeType"
        case imageId = "ImageId"
        case rootStorage = "RootStorage"
        case tags = "Tags"
        case userStorage = "UserStorage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleDescription = self.bundleDescription {
            try encodeContainer.encode(bundleDescription, forKey: .bundleDescription)
        }
        if let bundleName = self.bundleName {
            try encodeContainer.encode(bundleName, forKey: .bundleName)
        }
        if let computeType = self.computeType {
            try encodeContainer.encode(computeType, forKey: .computeType)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let rootStorage = self.rootStorage {
            try encodeContainer.encode(rootStorage, forKey: .rootStorage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userStorage = self.userStorage {
            try encodeContainer.encode(userStorage, forKey: .userStorage)
        }
    }
}

extension CreateWorkspaceBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkspaceBundleInput: Swift.Equatable {
    /// The description of the bundle.
    /// This member is required.
    public var bundleDescription: Swift.String?
    /// The name of the bundle.
    /// This member is required.
    public var bundleName: Swift.String?
    /// Describes the compute type of the bundle.
    /// This member is required.
    public var computeType: WorkSpacesClientTypes.ComputeType?
    /// The identifier of the image that is used to create the bundle.
    /// This member is required.
    public var imageId: Swift.String?
    /// Describes the root volume for a WorkSpace bundle.
    public var rootStorage: WorkSpacesClientTypes.RootStorage?
    /// The tags associated with the bundle. To add tags at the same time when you're creating the bundle, you must create an IAM policy that grants your IAM user permissions to use workspaces:CreateTags.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// Describes the user volume for a WorkSpace bundle.
    /// This member is required.
    public var userStorage: WorkSpacesClientTypes.UserStorage?

    public init (
        bundleDescription: Swift.String? = nil,
        bundleName: Swift.String? = nil,
        computeType: WorkSpacesClientTypes.ComputeType? = nil,
        imageId: Swift.String? = nil,
        rootStorage: WorkSpacesClientTypes.RootStorage? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        userStorage: WorkSpacesClientTypes.UserStorage? = nil
    )
    {
        self.bundleDescription = bundleDescription
        self.bundleName = bundleName
        self.computeType = computeType
        self.imageId = imageId
        self.rootStorage = rootStorage
        self.tags = tags
        self.userStorage = userStorage
    }
}

struct CreateWorkspaceBundleInputBody: Swift.Equatable {
    let bundleName: Swift.String?
    let bundleDescription: Swift.String?
    let imageId: Swift.String?
    let computeType: WorkSpacesClientTypes.ComputeType?
    let userStorage: WorkSpacesClientTypes.UserStorage?
    let rootStorage: WorkSpacesClientTypes.RootStorage?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateWorkspaceBundleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleDescription = "BundleDescription"
        case bundleName = "BundleName"
        case computeType = "ComputeType"
        case imageId = "ImageId"
        case rootStorage = "RootStorage"
        case tags = "Tags"
        case userStorage = "UserStorage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleName)
        bundleName = bundleNameDecoded
        let bundleDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleDescription)
        bundleDescription = bundleDescriptionDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let userStorageDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.UserStorage.self, forKey: .userStorage)
        userStorage = userStorageDecoded
        let rootStorageDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.RootStorage.self, forKey: .rootStorage)
        rootStorage = rootStorageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkspaceBundleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkspaceBundleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorkspaceBundleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkspaceBundleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorkspaceBundleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workspaceBundle = output.workspaceBundle
        } else {
            self.workspaceBundle = nil
        }
    }
}

public struct CreateWorkspaceBundleOutputResponse: Swift.Equatable {
    /// Describes a WorkSpace bundle.
    public var workspaceBundle: WorkSpacesClientTypes.WorkspaceBundle?

    public init (
        workspaceBundle: WorkSpacesClientTypes.WorkspaceBundle? = nil
    )
    {
        self.workspaceBundle = workspaceBundle
    }
}

struct CreateWorkspaceBundleOutputResponseBody: Swift.Equatable {
    let workspaceBundle: WorkSpacesClientTypes.WorkspaceBundle?
}

extension CreateWorkspaceBundleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceBundle = "WorkspaceBundle"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceBundleDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceBundle.self, forKey: .workspaceBundle)
        workspaceBundle = workspaceBundleDecoded
    }
}

extension CreateWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension CreateWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkspaceImageInput: Swift.Equatable {
    /// The description of the new WorkSpace image.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the new WorkSpace image.
    /// This member is required.
    public var name: Swift.String?
    /// The tags that you want to add to the new WorkSpace image. To add tags when you're creating the image, you must create an IAM policy that grants your IAM user permission to use workspaces:CreateTags.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// The identifier of the source WorkSpace
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateWorkspaceImageInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let workspaceId: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension CreateWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
        case workspaceId = "WorkspaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkspaceImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkspaceImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorkspaceImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkspaceImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorkspaceImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.created = output.created
            self.description = output.description
            self.imageId = output.imageId
            self.name = output.name
            self.operatingSystem = output.operatingSystem
            self.ownerAccountId = output.ownerAccountId
            self.requiredTenancy = output.requiredTenancy
            self.state = output.state
        } else {
            self.created = nil
            self.description = nil
            self.imageId = nil
            self.name = nil
            self.operatingSystem = nil
            self.ownerAccountId = nil
            self.requiredTenancy = nil
            self.state = nil
        }
    }
}

public struct CreateWorkspaceImageOutputResponse: Swift.Equatable {
    /// The date when the image was created.
    public var created: ClientRuntime.Date?
    /// The description of the image.
    public var description: Swift.String?
    /// The identifier of the new WorkSpace image.
    public var imageId: Swift.String?
    /// The name of the image.
    public var name: Swift.String?
    /// The operating system that the image is running.
    public var operatingSystem: WorkSpacesClientTypes.OperatingSystem?
    /// The identifier of the Amazon Web Services account that owns the image.
    public var ownerAccountId: Swift.String?
    /// Specifies whether the image is running on dedicated hardware. When Bring Your Own License (BYOL) is enabled, this value is set to DEDICATED. For more information, see [ Bring Your Own Windows Desktop Images.](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.htm).
    public var requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy?
    /// The availability status of the image.
    public var state: WorkSpacesClientTypes.WorkspaceImageState?

    public init (
        created: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        imageId: Swift.String? = nil,
        name: Swift.String? = nil,
        operatingSystem: WorkSpacesClientTypes.OperatingSystem? = nil,
        ownerAccountId: Swift.String? = nil,
        requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy? = nil,
        state: WorkSpacesClientTypes.WorkspaceImageState? = nil
    )
    {
        self.created = created
        self.description = description
        self.imageId = imageId
        self.name = name
        self.operatingSystem = operatingSystem
        self.ownerAccountId = ownerAccountId
        self.requiredTenancy = requiredTenancy
        self.state = state
    }
}

struct CreateWorkspaceImageOutputResponseBody: Swift.Equatable {
    let imageId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let operatingSystem: WorkSpacesClientTypes.OperatingSystem?
    let state: WorkSpacesClientTypes.WorkspaceImageState?
    let requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy?
    let created: ClientRuntime.Date?
    let ownerAccountId: Swift.String?
}

extension CreateWorkspaceImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case description = "Description"
        case imageId = "ImageId"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case ownerAccountId = "OwnerAccountId"
        case requiredTenancy = "RequiredTenancy"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageState.self, forKey: .state)
        state = stateDecoded
        let requiredTenancyDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageRequiredTenancy.self, forKey: .requiredTenancy)
        requiredTenancy = requiredTenancyDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
    }
}

extension CreateWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaces = "Workspaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaces = workspaces {
            var workspacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaces)
            for workspacerequest0 in workspaces {
                try workspacesContainer.encode(workspacerequest0)
            }
        }
    }
}

extension CreateWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to create. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var workspaces: [WorkSpacesClientTypes.WorkspaceRequest]?

    public init (
        workspaces: [WorkSpacesClientTypes.WorkspaceRequest]? = nil
    )
    {
        self.workspaces = workspaces
    }
}

struct CreateWorkspacesInputBody: Swift.Equatable {
    let workspaces: [WorkSpacesClientTypes.WorkspaceRequest]?
}

extension CreateWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaces = "Workspaces"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceRequest?].self, forKey: .workspaces)
        var workspacesDecoded0:[WorkSpacesClientTypes.WorkspaceRequest]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [WorkSpacesClientTypes.WorkspaceRequest]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
    }
}

extension CreateWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
            self.pendingRequests = output.pendingRequests
        } else {
            self.failedRequests = nil
            self.pendingRequests = nil
        }
    }
}

public struct CreateWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the WorkSpaces that could not be created.
    public var failedRequests: [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]?
    /// Information about the WorkSpaces that were created. Because this operation is asynchronous, the identifier returned is not immediately available for use with other operations. For example, if you call [DescribeWorkspaces] before the WorkSpace is created, the information returned can be incomplete.
    public var pendingRequests: [WorkSpacesClientTypes.Workspace]?

    public init (
        failedRequests: [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]? = nil,
        pendingRequests: [WorkSpacesClientTypes.Workspace]? = nil
    )
    {
        self.failedRequests = failedRequests
        self.pendingRequests = pendingRequests
    }
}

struct CreateWorkspacesOutputResponseBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]?
    let pendingRequests: [WorkSpacesClientTypes.Workspace]?
}

extension CreateWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
        case pendingRequests = "PendingRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedCreateWorkspaceRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedCreateWorkspaceRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedCreateWorkspaceRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
        let pendingRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Workspace?].self, forKey: .pendingRequests)
        var pendingRequestsDecoded0:[WorkSpacesClientTypes.Workspace]? = nil
        if let pendingRequestsContainer = pendingRequestsContainer {
            pendingRequestsDecoded0 = [WorkSpacesClientTypes.Workspace]()
            for structure0 in pendingRequestsContainer {
                if let structure0 = structure0 {
                    pendingRequestsDecoded0?.append(structure0)
                }
            }
        }
        pendingRequests = pendingRequestsDecoded0
    }
}

extension WorkSpacesClientTypes {
    public enum DedicatedTenancyModificationStateEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancyModificationStateEnum] {
            return [
                .completed,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DedicatedTenancyModificationStateEnum(rawValue: rawValue) ?? DedicatedTenancyModificationStateEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum DedicatedTenancySupportEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancySupportEnum] {
            return [
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DedicatedTenancySupportEnum(rawValue: rawValue) ?? DedicatedTenancySupportEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum DedicatedTenancySupportResultEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DedicatedTenancySupportResultEnum] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DedicatedTenancySupportResultEnum(rawValue: rawValue) ?? DedicatedTenancySupportResultEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.DefaultClientBrandingAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPasswordLink = "ForgotPasswordLink"
        case loginMessage = "LoginMessage"
        case logoUrl = "LogoUrl"
        case supportEmail = "SupportEmail"
        case supportLink = "SupportLink"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPasswordLink = self.forgotPasswordLink {
            try encodeContainer.encode(forgotPasswordLink, forKey: .forgotPasswordLink)
        }
        if let loginMessage = loginMessage {
            var loginMessageContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .loginMessage)
            for (dictKey0, loginMessage0) in loginMessage {
                try loginMessageContainer.encode(loginMessage0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let logoUrl = self.logoUrl {
            try encodeContainer.encode(logoUrl, forKey: .logoUrl)
        }
        if let supportEmail = self.supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportLink = self.supportLink {
            try encodeContainer.encode(supportLink, forKey: .supportLink)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logoUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logoUrl)
        logoUrl = logoUrlDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportLink)
        supportLink = supportLinkDecoded
        let forgotPasswordLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forgotPasswordLink)
        forgotPasswordLink = forgotPasswordLinkDecoded
        let loginMessageContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .loginMessage)
        var loginMessageDecoded0: [Swift.String:Swift.String]? = nil
        if let loginMessageContainer = loginMessageContainer {
            loginMessageDecoded0 = [Swift.String:Swift.String]()
            for (key0, clientloginmessage0) in loginMessageContainer {
                if let clientloginmessage0 = clientloginmessage0 {
                    loginMessageDecoded0?[key0] = clientloginmessage0
                }
            }
        }
        loginMessage = loginMessageDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Returns default client branding attributes that were imported. These attributes display on the client login screen. Client branding attributes are public facing. Ensure that you don't include sensitive information.
    public struct DefaultClientBrandingAttributes: Swift.Equatable {
        /// The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.
        public var forgotPasswordLink: Swift.String?
        /// The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is en_US. The HTML tags supported include the following: a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul.
        public var loginMessage: [Swift.String:Swift.String]?
        /// The logo. The only image format accepted is a binary data object that is converted from a .png file.
        public var logoUrl: Swift.String?
        /// The support email. The company's customer support email address.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default email is workspaces-feedback@amazon.com.
        public var supportEmail: Swift.String?
        /// The support link. The link for the company's customer support page for their WorkSpace.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive.You can specify one parameter for each platform type, but not both.
        ///
        /// * The default support link is workspaces-feedback@amazon.com.
        public var supportLink: Swift.String?

        public init (
            forgotPasswordLink: Swift.String? = nil,
            loginMessage: [Swift.String:Swift.String]? = nil,
            logoUrl: Swift.String? = nil,
            supportEmail: Swift.String? = nil,
            supportLink: Swift.String? = nil
        )
        {
            self.forgotPasswordLink = forgotPasswordLink
            self.loginMessage = loginMessage
            self.logoUrl = logoUrl
            self.supportEmail = supportEmail
            self.supportLink = supportLink
        }
    }

}

extension WorkSpacesClientTypes.DefaultImportClientBrandingAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPasswordLink = "ForgotPasswordLink"
        case loginMessage = "LoginMessage"
        case logo = "Logo"
        case supportEmail = "SupportEmail"
        case supportLink = "SupportLink"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPasswordLink = self.forgotPasswordLink {
            try encodeContainer.encode(forgotPasswordLink, forKey: .forgotPasswordLink)
        }
        if let loginMessage = loginMessage {
            var loginMessageContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .loginMessage)
            for (dictKey0, loginMessage0) in loginMessage {
                try loginMessageContainer.encode(loginMessage0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let logo = self.logo {
            try encodeContainer.encode(logo.base64EncodedString(), forKey: .logo)
        }
        if let supportEmail = self.supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportLink = self.supportLink {
            try encodeContainer.encode(supportLink, forKey: .supportLink)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logoDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .logo)
        logo = logoDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportLink)
        supportLink = supportLinkDecoded
        let forgotPasswordLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forgotPasswordLink)
        forgotPasswordLink = forgotPasswordLinkDecoded
        let loginMessageContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .loginMessage)
        var loginMessageDecoded0: [Swift.String:Swift.String]? = nil
        if let loginMessageContainer = loginMessageContainer {
            loginMessageDecoded0 = [Swift.String:Swift.String]()
            for (key0, clientloginmessage0) in loginMessageContainer {
                if let clientloginmessage0 = clientloginmessage0 {
                    loginMessageDecoded0?[key0] = clientloginmessage0
                }
            }
        }
        loginMessage = loginMessageDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// The default client branding attributes to be imported. These attributes display on the client login screen. Client branding attributes are public facing. Ensure that you do not include sensitive information.
    public struct DefaultImportClientBrandingAttributes: Swift.Equatable {
        /// The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.
        public var forgotPasswordLink: Swift.String?
        /// The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is en_US. The HTML tags supported include the following: a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul.
        public var loginMessage: [Swift.String:Swift.String]?
        /// The logo. The only image format accepted is a binary data object that is converted from a .png file.
        public var logo: ClientRuntime.Data?
        /// The support email. The company's customer support email address.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default email is workspaces-feedback@amazon.com.
        public var supportEmail: Swift.String?
        /// The support link. The link for the company's customer support page for their WorkSpace.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default support link is workspaces-feedback@amazon.com.
        public var supportLink: Swift.String?

        public init (
            forgotPasswordLink: Swift.String? = nil,
            loginMessage: [Swift.String:Swift.String]? = nil,
            logo: ClientRuntime.Data? = nil,
            supportEmail: Swift.String? = nil,
            supportLink: Swift.String? = nil
        )
        {
            self.forgotPasswordLink = forgotPasswordLink
            self.loginMessage = loginMessage
            self.logo = logo
            self.supportEmail = supportEmail
            self.supportLink = supportLink
        }
    }

}

extension WorkSpacesClientTypes.DefaultWorkspaceCreationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customSecurityGroupId = "CustomSecurityGroupId"
        case defaultOu = "DefaultOu"
        case enableInternetAccess = "EnableInternetAccess"
        case enableMaintenanceMode = "EnableMaintenanceMode"
        case enableWorkDocs = "EnableWorkDocs"
        case userEnabledAsLocalAdministrator = "UserEnabledAsLocalAdministrator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customSecurityGroupId = self.customSecurityGroupId {
            try encodeContainer.encode(customSecurityGroupId, forKey: .customSecurityGroupId)
        }
        if let defaultOu = self.defaultOu {
            try encodeContainer.encode(defaultOu, forKey: .defaultOu)
        }
        if let enableInternetAccess = self.enableInternetAccess {
            try encodeContainer.encode(enableInternetAccess, forKey: .enableInternetAccess)
        }
        if let enableMaintenanceMode = self.enableMaintenanceMode {
            try encodeContainer.encode(enableMaintenanceMode, forKey: .enableMaintenanceMode)
        }
        if let enableWorkDocs = self.enableWorkDocs {
            try encodeContainer.encode(enableWorkDocs, forKey: .enableWorkDocs)
        }
        if let userEnabledAsLocalAdministrator = self.userEnabledAsLocalAdministrator {
            try encodeContainer.encode(userEnabledAsLocalAdministrator, forKey: .userEnabledAsLocalAdministrator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableWorkDocsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWorkDocs)
        enableWorkDocs = enableWorkDocsDecoded
        let enableInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableInternetAccess)
        enableInternetAccess = enableInternetAccessDecoded
        let defaultOuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOu)
        defaultOu = defaultOuDecoded
        let customSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customSecurityGroupId)
        customSecurityGroupId = customSecurityGroupIdDecoded
        let userEnabledAsLocalAdministratorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userEnabledAsLocalAdministrator)
        userEnabledAsLocalAdministrator = userEnabledAsLocalAdministratorDecoded
        let enableMaintenanceModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMaintenanceMode)
        enableMaintenanceMode = enableMaintenanceModeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the default values that are used to create WorkSpaces. For more information, see [Update Directory Details for Your WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html).
    public struct DefaultWorkspaceCreationProperties: Swift.Equatable {
        /// The identifier of the default security group to apply to WorkSpaces when they are created. For more information, see [ Security Groups for Your WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-security-groups.html).
        public var customSecurityGroupId: Swift.String?
        /// The organizational unit (OU) in the directory for the WorkSpace machine accounts.
        public var defaultOu: Swift.String?
        /// Specifies whether to automatically assign an Elastic public IP address to WorkSpaces in this directory by default. If enabled, the Elastic public IP address allows outbound internet access from your WorkSpaces when youre using an internet gateway in the Amazon VPC in which your WorkSpaces are located. If you're using a Network Address Translation (NAT) gateway for outbound internet access from your VPC, or if your WorkSpaces are in public subnets and you manually assign them Elastic IP addresses, you should disable this setting. This setting applies to new WorkSpaces that you launch or to existing WorkSpaces that you rebuild. For more information, see [ Configure a VPC for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html).
        public var enableInternetAccess: Swift.Bool?
        /// Specifies whether maintenance mode is enabled for WorkSpaces. For more information, see [WorkSpace Maintenance](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html).
        public var enableMaintenanceMode: Swift.Bool?
        /// Specifies whether the directory is enabled for Amazon WorkDocs.
        public var enableWorkDocs: Swift.Bool?
        /// Specifies whether WorkSpace users are local administrators on their WorkSpaces.
        public var userEnabledAsLocalAdministrator: Swift.Bool?

        public init (
            customSecurityGroupId: Swift.String? = nil,
            defaultOu: Swift.String? = nil,
            enableInternetAccess: Swift.Bool? = nil,
            enableMaintenanceMode: Swift.Bool? = nil,
            enableWorkDocs: Swift.Bool? = nil,
            userEnabledAsLocalAdministrator: Swift.Bool? = nil
        )
        {
            self.customSecurityGroupId = customSecurityGroupId
            self.defaultOu = defaultOu
            self.enableInternetAccess = enableInternetAccess
            self.enableMaintenanceMode = enableMaintenanceMode
            self.enableWorkDocs = enableWorkDocs
            self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
        }
    }

}

extension WorkSpacesClientTypes {
    public enum DeletableCertificateBasedAuthProperty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case certificateBasedAuthPropertiesCertificateAuthorityArn
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletableCertificateBasedAuthProperty] {
            return [
                .certificateBasedAuthPropertiesCertificateAuthorityArn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .certificateBasedAuthPropertiesCertificateAuthorityArn: return "CERTIFICATE_BASED_AUTH_PROPERTIES_CERTIFICATE_AUTHORITY_ARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeletableCertificateBasedAuthProperty(rawValue: rawValue) ?? DeletableCertificateBasedAuthProperty.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum DeletableSamlProperty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case samlPropertiesRelayStateParameterName
        case samlPropertiesUserAccessUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletableSamlProperty] {
            return [
                .samlPropertiesRelayStateParameterName,
                .samlPropertiesUserAccessUrl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .samlPropertiesRelayStateParameterName: return "SAML_PROPERTIES_RELAY_STATE_PARAMETER_NAME"
            case .samlPropertiesUserAccessUrl: return "SAML_PROPERTIES_USER_ACCESS_URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeletableSamlProperty(rawValue: rawValue) ?? DeletableSamlProperty.sdkUnknown(rawValue)
        }
    }
}

extension DeleteClientBrandingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platforms = "Platforms"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let platforms = platforms {
            var platformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platforms)
            for clientdevicetype0 in platforms {
                try platformsContainer.encode(clientdevicetype0.rawValue)
            }
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DeleteClientBrandingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteClientBrandingInput: Swift.Equatable {
    /// The device type for which you want to delete client branding.
    /// This member is required.
    public var platforms: [WorkSpacesClientTypes.ClientDeviceType]?
    /// The directory identifier of the WorkSpace for which you want to delete client branding.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        platforms: [WorkSpacesClientTypes.ClientDeviceType]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.platforms = platforms
        self.resourceId = resourceId
    }
}

struct DeleteClientBrandingInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let platforms: [WorkSpacesClientTypes.ClientDeviceType]?
}

extension DeleteClientBrandingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platforms = "Platforms"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let platformsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ClientDeviceType?].self, forKey: .platforms)
        var platformsDecoded0:[WorkSpacesClientTypes.ClientDeviceType]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [WorkSpacesClientTypes.ClientDeviceType]()
            for enum0 in platformsContainer {
                if let enum0 = enum0 {
                    platformsDecoded0?.append(enum0)
                }
            }
        }
        platforms = platformsDecoded0
    }
}

extension DeleteClientBrandingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteClientBrandingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteClientBrandingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClientBrandingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteClientBrandingOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteConnectClientAddInInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addInId = "AddInId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addInId = self.addInId {
            try encodeContainer.encode(addInId, forKey: .addInId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DeleteConnectClientAddInInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConnectClientAddInInput: Swift.Equatable {
    /// The identifier of the client add-in to delete.
    /// This member is required.
    public var addInId: Swift.String?
    /// The directory identifier for which the client add-in is configured.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        addInId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.addInId = addInId
        self.resourceId = resourceId
    }
}

struct DeleteConnectClientAddInInputBody: Swift.Equatable {
    let addInId: Swift.String?
    let resourceId: Swift.String?
}

extension DeleteConnectClientAddInInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addInId = "AddInId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addInIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addInId)
        addInId = addInIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DeleteConnectClientAddInOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectClientAddInOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConnectClientAddInOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectClientAddInOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConnectClientAddInOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteConnectionAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = self.aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
    }
}

extension DeleteConnectionAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConnectionAliasInput: Swift.Equatable {
    /// The identifier of the connection alias to delete.
    /// This member is required.
    public var aliasId: Swift.String?

    public init (
        aliasId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

struct DeleteConnectionAliasInputBody: Swift.Equatable {
    let aliasId: Swift.String?
}

extension DeleteConnectionAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
    }
}

extension DeleteConnectionAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConnectionAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConnectionAliasOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteIpGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
    }
}

extension DeleteIpGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteIpGroupInput: Swift.Equatable {
    /// The identifier of the IP access control group.
    /// This member is required.
    public var groupId: Swift.String?

    public init (
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct DeleteIpGroupInputBody: Swift.Equatable {
    let groupId: Swift.String?
}

extension DeleteIpGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DeleteIpGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIpGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteIpGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIpGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIpGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for nonemptystring0 in tagKeys {
                try tagKeysContainer.encode(nonemptystring0)
            }
        }
    }
}

extension DeleteTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTagsInput: Swift.Equatable {
    /// The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces, registered directories, images, custom bundles, IP access control groups, and connection aliases.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeys = tagKeys
    }
}

struct DeleteTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagKeys: [Swift.String]?
}

extension DeleteTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension DeleteTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWorkspaceBundleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
    }
}

extension DeleteWorkspaceBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkspaceBundleInput: Swift.Equatable {
    /// The identifier of the bundle.
    public var bundleId: Swift.String?

    public init (
        bundleId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
    }
}

struct DeleteWorkspaceBundleInputBody: Swift.Equatable {
    let bundleId: Swift.String?
}

extension DeleteWorkspaceBundleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
    }
}

extension DeleteWorkspaceBundleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkspaceBundleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWorkspaceBundleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkspaceBundleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkspaceBundleOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }
}

extension DeleteWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkspaceImageInput: Swift.Equatable {
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?

    public init (
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct DeleteWorkspaceImageInputBody: Swift.Equatable {
    let imageId: Swift.String?
}

extension DeleteWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension DeleteWorkspaceImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkspaceImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWorkspaceImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceAssociatedException(ResourceAssociatedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkspaceImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkspaceImageOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeregisterWorkspaceDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
    }
}

extension DeregisterWorkspaceDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterWorkspaceDirectoryInput: Swift.Equatable {
    /// The identifier of the directory. If any WorkSpaces are registered to this directory, you must remove them before you deregister the directory, or you will receive an OperationNotSupportedException error.
    /// This member is required.
    public var directoryId: Swift.String?

    public init (
        directoryId: Swift.String? = nil
    )
    {
        self.directoryId = directoryId
    }
}

struct DeregisterWorkspaceDirectoryInputBody: Swift.Equatable {
    let directoryId: Swift.String?
}

extension DeregisterWorkspaceDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension DeregisterWorkspaceDirectoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterWorkspaceDirectoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterWorkspaceDirectoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterWorkspaceDirectoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterWorkspaceDirectoryOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeAccountInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountInput: Swift.Equatable {

    public init () { }
}

struct DescribeAccountInputBody: Swift.Equatable {
}

extension DescribeAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountModificationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAccountModificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountModificationsInput: Swift.Equatable {
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct DescribeAccountModificationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension DescribeAccountModificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAccountModificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountModificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAccountModificationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountModificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAccountModificationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountModifications = output.accountModifications
            self.nextToken = output.nextToken
        } else {
            self.accountModifications = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAccountModificationsOutputResponse: Swift.Equatable {
    /// The list of modifications to the configuration of BYOL.
    public var accountModifications: [WorkSpacesClientTypes.AccountModification]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        accountModifications: [WorkSpacesClientTypes.AccountModification]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountModifications = accountModifications
        self.nextToken = nextToken
    }
}

struct DescribeAccountModificationsOutputResponseBody: Swift.Equatable {
    let accountModifications: [WorkSpacesClientTypes.AccountModification]?
    let nextToken: Swift.String?
}

extension DescribeAccountModificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountModifications = "AccountModifications"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountModificationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.AccountModification?].self, forKey: .accountModifications)
        var accountModificationsDecoded0:[WorkSpacesClientTypes.AccountModification]? = nil
        if let accountModificationsContainer = accountModificationsContainer {
            accountModificationsDecoded0 = [WorkSpacesClientTypes.AccountModification]()
            for structure0 in accountModificationsContainer {
                if let structure0 = structure0 {
                    accountModificationsDecoded0?.append(structure0)
                }
            }
        }
        accountModifications = accountModificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dedicatedTenancyManagementCidrRange = output.dedicatedTenancyManagementCidrRange
            self.dedicatedTenancySupport = output.dedicatedTenancySupport
        } else {
            self.dedicatedTenancyManagementCidrRange = nil
            self.dedicatedTenancySupport = nil
        }
    }
}

public struct DescribeAccountOutputResponse: Swift.Equatable {
    /// The IP address range, specified as an IPv4 CIDR block, used for the management network interface. The management network interface is connected to a secure Amazon WorkSpaces management network. It is used for interactive streaming of the WorkSpace desktop to Amazon WorkSpaces clients, and to allow Amazon WorkSpaces to manage the WorkSpace.
    public var dedicatedTenancyManagementCidrRange: Swift.String?
    /// The status of BYOL (whether BYOL is enabled or disabled).
    public var dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum?

    public init (
        dedicatedTenancyManagementCidrRange: Swift.String? = nil,
        dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum? = nil
    )
    {
        self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
        self.dedicatedTenancySupport = dedicatedTenancySupport
    }
}

struct DescribeAccountOutputResponseBody: Swift.Equatable {
    let dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportResultEnum?
    let dedicatedTenancyManagementCidrRange: Swift.String?
}

extension DescribeAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedTenancySupportDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DedicatedTenancySupportResultEnum.self, forKey: .dedicatedTenancySupport)
        dedicatedTenancySupport = dedicatedTenancySupportDecoded
        let dedicatedTenancyManagementCidrRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedTenancyManagementCidrRange)
        dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRangeDecoded
    }
}

extension DescribeClientBrandingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DescribeClientBrandingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeClientBrandingInput: Swift.Equatable {
    /// The directory identifier of the WorkSpace for which you want to view client branding information.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct DescribeClientBrandingInputBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension DescribeClientBrandingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DescribeClientBrandingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClientBrandingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeClientBrandingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClientBrandingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeClientBrandingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceTypeAndroid = output.deviceTypeAndroid
            self.deviceTypeIos = output.deviceTypeIos
            self.deviceTypeLinux = output.deviceTypeLinux
            self.deviceTypeOsx = output.deviceTypeOsx
            self.deviceTypeWeb = output.deviceTypeWeb
            self.deviceTypeWindows = output.deviceTypeWindows
        } else {
            self.deviceTypeAndroid = nil
            self.deviceTypeIos = nil
            self.deviceTypeLinux = nil
            self.deviceTypeOsx = nil
            self.deviceTypeWeb = nil
            self.deviceTypeWindows = nil
        }
    }
}

public struct DescribeClientBrandingOutputResponse: Swift.Equatable {
    /// The branding information for Android devices.
    public var deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information for iOS devices.
    public var deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes?
    /// The branding information for Linux devices.
    public var deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information for macOS devices.
    public var deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information for Web access.
    public var deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information for Windows devices.
    public var deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes?

    public init (
        deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes? = nil,
        deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil
    )
    {
        self.deviceTypeAndroid = deviceTypeAndroid
        self.deviceTypeIos = deviceTypeIos
        self.deviceTypeLinux = deviceTypeLinux
        self.deviceTypeOsx = deviceTypeOsx
        self.deviceTypeWeb = deviceTypeWeb
        self.deviceTypeWindows = deviceTypeWindows
    }
}

struct DescribeClientBrandingOutputResponseBody: Swift.Equatable {
    let deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes?
    let deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
}

extension DescribeClientBrandingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceTypeAndroid = "DeviceTypeAndroid"
        case deviceTypeIos = "DeviceTypeIos"
        case deviceTypeLinux = "DeviceTypeLinux"
        case deviceTypeOsx = "DeviceTypeOsx"
        case deviceTypeWeb = "DeviceTypeWeb"
        case deviceTypeWindows = "DeviceTypeWindows"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTypeWindowsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeWindows)
        deviceTypeWindows = deviceTypeWindowsDecoded
        let deviceTypeOsxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeOsx)
        deviceTypeOsx = deviceTypeOsxDecoded
        let deviceTypeAndroidDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeAndroid)
        deviceTypeAndroid = deviceTypeAndroidDecoded
        let deviceTypeIosDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.IosClientBrandingAttributes.self, forKey: .deviceTypeIos)
        deviceTypeIos = deviceTypeIosDecoded
        let deviceTypeLinuxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeLinux)
        deviceTypeLinux = deviceTypeLinuxDecoded
        let deviceTypeWebDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeWeb)
        deviceTypeWeb = deviceTypeWebDecoded
    }
}

extension DescribeClientPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIds = "ResourceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for nonemptystring0 in resourceIds {
                try resourceIdsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension DescribeClientPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeClientPropertiesInput: Swift.Equatable {
    /// The resource identifier, in the form of directory IDs.
    /// This member is required.
    public var resourceIds: [Swift.String]?

    public init (
        resourceIds: [Swift.String]? = nil
    )
    {
        self.resourceIds = resourceIds
    }
}

struct DescribeClientPropertiesInputBody: Swift.Equatable {
    let resourceIds: [Swift.String]?
}

extension DescribeClientPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIds = "ResourceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Swift.String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Swift.String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
    }
}

extension DescribeClientPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClientPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeClientPropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClientPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeClientPropertiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientPropertiesList = output.clientPropertiesList
        } else {
            self.clientPropertiesList = nil
        }
    }
}

public struct DescribeClientPropertiesOutputResponse: Swift.Equatable {
    /// Information about the specified Amazon WorkSpaces clients.
    public var clientPropertiesList: [WorkSpacesClientTypes.ClientPropertiesResult]?

    public init (
        clientPropertiesList: [WorkSpacesClientTypes.ClientPropertiesResult]? = nil
    )
    {
        self.clientPropertiesList = clientPropertiesList
    }
}

struct DescribeClientPropertiesOutputResponseBody: Swift.Equatable {
    let clientPropertiesList: [WorkSpacesClientTypes.ClientPropertiesResult]?
}

extension DescribeClientPropertiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientPropertiesList = "ClientPropertiesList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientPropertiesListContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ClientPropertiesResult?].self, forKey: .clientPropertiesList)
        var clientPropertiesListDecoded0:[WorkSpacesClientTypes.ClientPropertiesResult]? = nil
        if let clientPropertiesListContainer = clientPropertiesListContainer {
            clientPropertiesListDecoded0 = [WorkSpacesClientTypes.ClientPropertiesResult]()
            for structure0 in clientPropertiesListContainer {
                if let structure0 = structure0 {
                    clientPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        clientPropertiesList = clientPropertiesListDecoded0
    }
}

extension DescribeConnectClientAddInsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DescribeConnectClientAddInsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectClientAddInsInput: Swift.Equatable {
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The directory identifier for which the client add-in is configured.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct DescribeConnectClientAddInsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeConnectClientAddInsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeConnectClientAddInsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectClientAddInsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConnectClientAddInsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectClientAddInsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConnectClientAddInsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addIns = output.addIns
            self.nextToken = output.nextToken
        } else {
            self.addIns = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectClientAddInsOutputResponse: Swift.Equatable {
    /// Information about client add-ins.
    public var addIns: [WorkSpacesClientTypes.ConnectClientAddIn]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        addIns: [WorkSpacesClientTypes.ConnectClientAddIn]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.addIns = addIns
        self.nextToken = nextToken
    }
}

struct DescribeConnectClientAddInsOutputResponseBody: Swift.Equatable {
    let addIns: [WorkSpacesClientTypes.ConnectClientAddIn]?
    let nextToken: Swift.String?
}

extension DescribeConnectClientAddInsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addIns = "AddIns"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addInsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ConnectClientAddIn?].self, forKey: .addIns)
        var addInsDecoded0:[WorkSpacesClientTypes.ConnectClientAddIn]? = nil
        if let addInsContainer = addInsContainer {
            addInsDecoded0 = [WorkSpacesClientTypes.ConnectClientAddIn]()
            for structure0 in addInsContainer {
                if let structure0 = structure0 {
                    addInsDecoded0?.append(structure0)
                }
            }
        }
        addIns = addInsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectionAliasPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = self.aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConnectionAliasPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectionAliasPermissionsInput: Swift.Equatable {
    /// The identifier of the connection alias.
    /// This member is required.
    public var aliasId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        aliasId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeConnectionAliasPermissionsInputBody: Swift.Equatable {
    let aliasId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeConnectionAliasPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeConnectionAliasPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionAliasPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConnectionAliasPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionAliasPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConnectionAliasPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliasId = output.aliasId
            self.connectionAliasPermissions = output.connectionAliasPermissions
            self.nextToken = output.nextToken
        } else {
            self.aliasId = nil
            self.connectionAliasPermissions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectionAliasPermissionsOutputResponse: Swift.Equatable {
    /// The identifier of the connection alias.
    public var aliasId: Swift.String?
    /// The permissions associated with a connection alias.
    public var connectionAliasPermissions: [WorkSpacesClientTypes.ConnectionAliasPermission]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        aliasId: Swift.String? = nil,
        connectionAliasPermissions: [WorkSpacesClientTypes.ConnectionAliasPermission]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
        self.connectionAliasPermissions = connectionAliasPermissions
        self.nextToken = nextToken
    }
}

struct DescribeConnectionAliasPermissionsOutputResponseBody: Swift.Equatable {
    let aliasId: Swift.String?
    let connectionAliasPermissions: [WorkSpacesClientTypes.ConnectionAliasPermission]?
    let nextToken: Swift.String?
}

extension DescribeConnectionAliasPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case connectionAliasPermissions = "ConnectionAliasPermissions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let connectionAliasPermissionsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ConnectionAliasPermission?].self, forKey: .connectionAliasPermissions)
        var connectionAliasPermissionsDecoded0:[WorkSpacesClientTypes.ConnectionAliasPermission]? = nil
        if let connectionAliasPermissionsContainer = connectionAliasPermissionsContainer {
            connectionAliasPermissionsDecoded0 = [WorkSpacesClientTypes.ConnectionAliasPermission]()
            for structure0 in connectionAliasPermissionsContainer {
                if let structure0 = structure0 {
                    connectionAliasPermissionsDecoded0?.append(structure0)
                }
            }
        }
        connectionAliasPermissions = connectionAliasPermissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectionAliasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasIds = "AliasIds"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasIds = aliasIds {
            var aliasIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliasIds)
            for connectionaliasid0 in aliasIds {
                try aliasIdsContainer.encode(connectionaliasid0)
            }
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DescribeConnectionAliasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConnectionAliasesInput: Swift.Equatable {
    /// The identifiers of the connection aliases to describe.
    public var aliasIds: [Swift.String]?
    /// The maximum number of connection aliases to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The identifier of the directory associated with the connection alias.
    public var resourceId: Swift.String?

    public init (
        aliasIds: [Swift.String]? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.aliasIds = aliasIds
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct DescribeConnectionAliasesInputBody: Swift.Equatable {
    let aliasIds: [Swift.String]?
    let resourceId: Swift.String?
    let limit: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeConnectionAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasIds = "AliasIds"
        case limit = "Limit"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .aliasIds)
        var aliasIdsDecoded0:[Swift.String]? = nil
        if let aliasIdsContainer = aliasIdsContainer {
            aliasIdsDecoded0 = [Swift.String]()
            for string0 in aliasIdsContainer {
                if let string0 = string0 {
                    aliasIdsDecoded0?.append(string0)
                }
            }
        }
        aliasIds = aliasIdsDecoded0
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectionAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConnectionAliasesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConnectionAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionAliases = output.connectionAliases
            self.nextToken = output.nextToken
        } else {
            self.connectionAliases = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectionAliasesOutputResponse: Swift.Equatable {
    /// Information about the specified connection aliases.
    public var connectionAliases: [WorkSpacesClientTypes.ConnectionAlias]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        connectionAliases: [WorkSpacesClientTypes.ConnectionAlias]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionAliases = connectionAliases
        self.nextToken = nextToken
    }
}

struct DescribeConnectionAliasesOutputResponseBody: Swift.Equatable {
    let connectionAliases: [WorkSpacesClientTypes.ConnectionAlias]?
    let nextToken: Swift.String?
}

extension DescribeConnectionAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionAliases = "ConnectionAliases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionAliasesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ConnectionAlias?].self, forKey: .connectionAliases)
        var connectionAliasesDecoded0:[WorkSpacesClientTypes.ConnectionAlias]? = nil
        if let connectionAliasesContainer = connectionAliasesContainer {
            connectionAliasesDecoded0 = [WorkSpacesClientTypes.ConnectionAlias]()
            for structure0 in connectionAliasesContainer {
                if let structure0 = structure0 {
                    connectionAliasesDecoded0?.append(structure0)
                }
            }
        }
        connectionAliases = connectionAliasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeIpGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIds = "GroupIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for ipgroupid0 in groupIds {
                try groupIdsContainer.encode(ipgroupid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeIpGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeIpGroupsInput: Swift.Equatable {
    /// The identifiers of one or more IP access control groups.
    public var groupIds: [Swift.String]?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        groupIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupIds = groupIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeIpGroupsInputBody: Swift.Equatable {
    let groupIds: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeIpGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIds = "GroupIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[Swift.String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [Swift.String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeIpGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIpGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeIpGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIpGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeIpGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.result = output.result
        } else {
            self.nextToken = nil
            self.result = nil
        }
    }
}

public struct DescribeIpGroupsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the IP access control groups.
    public var result: [WorkSpacesClientTypes.WorkspacesIpGroup]?

    public init (
        nextToken: Swift.String? = nil,
        result: [WorkSpacesClientTypes.WorkspacesIpGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.result = result
    }
}

struct DescribeIpGroupsOutputResponseBody: Swift.Equatable {
    let result: [WorkSpacesClientTypes.WorkspacesIpGroup]?
    let nextToken: Swift.String?
}

extension DescribeIpGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case result = "Result"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspacesIpGroup?].self, forKey: .result)
        var resultDecoded0:[WorkSpacesClientTypes.WorkspacesIpGroup]? = nil
        if let resultContainer = resultContainer {
            resultDecoded0 = [WorkSpacesClientTypes.WorkspacesIpGroup]()
            for structure0 in resultContainer {
                if let structure0 = structure0 {
                    resultDecoded0?.append(structure0)
                }
            }
        }
        result = resultDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DescribeTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeTagsInput: Swift.Equatable {
    /// The identifier of the WorkSpaces resource. The supported resource types are WorkSpaces, registered directories, images, custom bundles, IP access control groups, and connection aliases.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct DescribeTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension DescribeTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DescribeTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTagsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct DescribeTagsOutputResponse: Swift.Equatable {
    /// The tags.
    public var tagList: [WorkSpacesClientTypes.Tag]?

    public init (
        tagList: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct DescribeTagsOutputResponseBody: Swift.Equatable {
    let tagList: [WorkSpacesClientTypes.Tag]?
}

extension DescribeTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension DescribeWorkspaceBundlesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleIds = "BundleIds"
        case nextToken = "NextToken"
        case owner = "Owner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleIds = bundleIds {
            var bundleIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bundleIds)
            for bundleid0 in bundleIds {
                try bundleIdsContainer.encode(bundleid0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
    }
}

extension DescribeWorkspaceBundlesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceBundlesInput: Swift.Equatable {
    /// The identifiers of the bundles. You cannot combine this parameter with any other filter.
    public var bundleIds: [Swift.String]?
    /// The token for the next set of results. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The owner of the bundles. You cannot combine this parameter with any other filter. To describe the bundles provided by Amazon Web Services, specify AMAZON. To describe the bundles that belong to your account, don't specify a value.
    public var owner: Swift.String?

    public init (
        bundleIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        owner: Swift.String? = nil
    )
    {
        self.bundleIds = bundleIds
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct DescribeWorkspaceBundlesInputBody: Swift.Equatable {
    let bundleIds: [Swift.String]?
    let owner: Swift.String?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceBundlesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleIds = "BundleIds"
        case nextToken = "NextToken"
        case owner = "Owner"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bundleIds)
        var bundleIdsDecoded0:[Swift.String]? = nil
        if let bundleIdsContainer = bundleIdsContainer {
            bundleIdsDecoded0 = [Swift.String]()
            for string0 in bundleIdsContainer {
                if let string0 = string0 {
                    bundleIdsDecoded0?.append(string0)
                }
            }
        }
        bundleIds = bundleIdsDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceBundlesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceBundlesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorkspaceBundlesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceBundlesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorkspaceBundlesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bundles = output.bundles
            self.nextToken = output.nextToken
        } else {
            self.bundles = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceBundlesOutputResponse: Swift.Equatable {
    /// Information about the bundles.
    public var bundles: [WorkSpacesClientTypes.WorkspaceBundle]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return. This token is valid for one day and must be used within that time frame.
    public var nextToken: Swift.String?

    public init (
        bundles: [WorkSpacesClientTypes.WorkspaceBundle]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bundles = bundles
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceBundlesOutputResponseBody: Swift.Equatable {
    let bundles: [WorkSpacesClientTypes.WorkspaceBundle]?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceBundlesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundles = "Bundles"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundlesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceBundle?].self, forKey: .bundles)
        var bundlesDecoded0:[WorkSpacesClientTypes.WorkspaceBundle]? = nil
        if let bundlesContainer = bundlesContainer {
            bundlesDecoded0 = [WorkSpacesClientTypes.WorkspaceBundle]()
            for structure0 in bundlesContainer {
                if let structure0 = structure0 {
                    bundlesDecoded0?.append(structure0)
                }
            }
        }
        bundles = bundlesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceDirectoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryIds = "DirectoryIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryIds = directoryIds {
            var directoryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .directoryIds)
            for directoryid0 in directoryIds {
                try directoryIdsContainer.encode(directoryid0)
            }
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeWorkspaceDirectoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceDirectoriesInput: Swift.Equatable {
    /// The identifiers of the directories. If the value is null, all directories are retrieved.
    public var directoryIds: [Swift.String]?
    /// The maximum number of directories to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        directoryIds: [Swift.String]? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryIds = directoryIds
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceDirectoriesInputBody: Swift.Equatable {
    let directoryIds: [Swift.String]?
    let limit: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceDirectoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryIds = "DirectoryIds"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .directoryIds)
        var directoryIdsDecoded0:[Swift.String]? = nil
        if let directoryIdsContainer = directoryIdsContainer {
            directoryIdsDecoded0 = [Swift.String]()
            for string0 in directoryIdsContainer {
                if let string0 = string0 {
                    directoryIdsDecoded0?.append(string0)
                }
            }
        }
        directoryIds = directoryIdsDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceDirectoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceDirectoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorkspaceDirectoriesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceDirectoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorkspaceDirectoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directories = output.directories
            self.nextToken = output.nextToken
        } else {
            self.directories = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceDirectoriesOutputResponse: Swift.Equatable {
    /// Information about the directories.
    public var directories: [WorkSpacesClientTypes.WorkspaceDirectory]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        directories: [WorkSpacesClientTypes.WorkspaceDirectory]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directories = directories
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceDirectoriesOutputResponseBody: Swift.Equatable {
    let directories: [WorkSpacesClientTypes.WorkspaceDirectory]?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceDirectoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directories = "Directories"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoriesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceDirectory?].self, forKey: .directories)
        var directoriesDecoded0:[WorkSpacesClientTypes.WorkspaceDirectory]? = nil
        if let directoriesContainer = directoriesContainer {
            directoriesDecoded0 = [WorkSpacesClientTypes.WorkspaceDirectory]()
            for structure0 in directoriesContainer {
                if let structure0 = structure0 {
                    directoriesDecoded0?.append(structure0)
                }
            }
        }
        directories = directoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceImagePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeWorkspaceImagePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceImagePermissionsInput: Swift.Equatable {
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        imageId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagePermissionsInputBody: Swift.Equatable {
    let imageId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeWorkspaceImagePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeWorkspaceImagePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceImagePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorkspaceImagePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceImagePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorkspaceImagePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
            self.imagePermissions = output.imagePermissions
            self.nextToken = output.nextToken
        } else {
            self.imageId = nil
            self.imagePermissions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceImagePermissionsOutputResponse: Swift.Equatable {
    /// The identifier of the image.
    public var imageId: Swift.String?
    /// The identifiers of the Amazon Web Services accounts that the image has been shared with.
    public var imagePermissions: [WorkSpacesClientTypes.ImagePermission]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        imageId: Swift.String? = nil,
        imagePermissions: [WorkSpacesClientTypes.ImagePermission]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.imagePermissions = imagePermissions
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagePermissionsOutputResponseBody: Swift.Equatable {
    let imageId: Swift.String?
    let imagePermissions: [WorkSpacesClientTypes.ImagePermission]?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceImagePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
        case imagePermissions = "ImagePermissions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imagePermissionsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ImagePermission?].self, forKey: .imagePermissions)
        var imagePermissionsDecoded0:[WorkSpacesClientTypes.ImagePermission]? = nil
        if let imagePermissionsContainer = imagePermissionsContainer {
            imagePermissionsDecoded0 = [WorkSpacesClientTypes.ImagePermission]()
            for structure0 in imagePermissionsContainer {
                if let structure0 = structure0 {
                    imagePermissionsDecoded0?.append(structure0)
                }
            }
        }
        imagePermissions = imagePermissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds = "ImageIds"
        case imageType = "ImageType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for workspaceimageid0 in imageIds {
                try imageIdsContainer.encode(workspaceimageid0)
            }
        }
        if let imageType = self.imageType {
            try encodeContainer.encode(imageType.rawValue, forKey: .imageType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeWorkspaceImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceImagesInput: Swift.Equatable {
    /// The identifier of the image.
    public var imageIds: [Swift.String]?
    /// The type (owned or shared) of the image.
    public var imageType: WorkSpacesClientTypes.ImageType?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        imageIds: [Swift.String]? = nil,
        imageType: WorkSpacesClientTypes.ImageType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageIds = imageIds
        self.imageType = imageType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagesInputBody: Swift.Equatable {
    let imageIds: [Swift.String]?
    let imageType: WorkSpacesClientTypes.ImageType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeWorkspaceImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds = "ImageIds"
        case imageType = "ImageType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageIds)
        var imageIdsDecoded0:[Swift.String]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [Swift.String]()
            for string0 in imageIdsContainer {
                if let string0 = string0 {
                    imageIdsDecoded0?.append(string0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let imageTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ImageType.self, forKey: .imageType)
        imageType = imageTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeWorkspaceImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorkspaceImagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorkspaceImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.images = output.images
            self.nextToken = output.nextToken
        } else {
            self.images = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeWorkspaceImagesOutputResponse: Swift.Equatable {
    /// Information about the images.
    public var images: [WorkSpacesClientTypes.WorkspaceImage]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        images: [WorkSpacesClientTypes.WorkspaceImage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.images = images
        self.nextToken = nextToken
    }
}

struct DescribeWorkspaceImagesOutputResponseBody: Swift.Equatable {
    let images: [WorkSpacesClientTypes.WorkspaceImage]?
    let nextToken: Swift.String?
}

extension DescribeWorkspaceImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case images = "Images"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceImage?].self, forKey: .images)
        var imagesDecoded0:[WorkSpacesClientTypes.WorkspaceImage]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [WorkSpacesClientTypes.WorkspaceImage]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspaceSnapshotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension DescribeWorkspaceSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspaceSnapshotsInput: Swift.Equatable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceSnapshotsInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
}

extension DescribeWorkspaceSnapshotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension DescribeWorkspaceSnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceSnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorkspaceSnapshotsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorkspaceSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rebuildSnapshots = output.rebuildSnapshots
            self.restoreSnapshots = output.restoreSnapshots
        } else {
            self.rebuildSnapshots = nil
            self.restoreSnapshots = nil
        }
    }
}

public struct DescribeWorkspaceSnapshotsOutputResponse: Swift.Equatable {
    /// Information about the snapshots that can be used to rebuild a WorkSpace. These snapshots include the user volume.
    public var rebuildSnapshots: [WorkSpacesClientTypes.Snapshot]?
    /// Information about the snapshots that can be used to restore a WorkSpace. These snapshots include both the root volume and the user volume.
    public var restoreSnapshots: [WorkSpacesClientTypes.Snapshot]?

    public init (
        rebuildSnapshots: [WorkSpacesClientTypes.Snapshot]? = nil,
        restoreSnapshots: [WorkSpacesClientTypes.Snapshot]? = nil
    )
    {
        self.rebuildSnapshots = rebuildSnapshots
        self.restoreSnapshots = restoreSnapshots
    }
}

struct DescribeWorkspaceSnapshotsOutputResponseBody: Swift.Equatable {
    let rebuildSnapshots: [WorkSpacesClientTypes.Snapshot]?
    let restoreSnapshots: [WorkSpacesClientTypes.Snapshot]?
}

extension DescribeWorkspaceSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebuildSnapshots = "RebuildSnapshots"
        case restoreSnapshots = "RestoreSnapshots"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rebuildSnapshotsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Snapshot?].self, forKey: .rebuildSnapshots)
        var rebuildSnapshotsDecoded0:[WorkSpacesClientTypes.Snapshot]? = nil
        if let rebuildSnapshotsContainer = rebuildSnapshotsContainer {
            rebuildSnapshotsDecoded0 = [WorkSpacesClientTypes.Snapshot]()
            for structure0 in rebuildSnapshotsContainer {
                if let structure0 = structure0 {
                    rebuildSnapshotsDecoded0?.append(structure0)
                }
            }
        }
        rebuildSnapshots = rebuildSnapshotsDecoded0
        let restoreSnapshotsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Snapshot?].self, forKey: .restoreSnapshots)
        var restoreSnapshotsDecoded0:[WorkSpacesClientTypes.Snapshot]? = nil
        if let restoreSnapshotsContainer = restoreSnapshotsContainer {
            restoreSnapshotsDecoded0 = [WorkSpacesClientTypes.Snapshot]()
            for structure0 in restoreSnapshotsContainer {
                if let structure0 = structure0 {
                    restoreSnapshotsDecoded0?.append(structure0)
                }
            }
        }
        restoreSnapshots = restoreSnapshotsDecoded0
    }
}

extension DescribeWorkspacesConnectionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workspaceIds = "WorkspaceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workspaceIds = workspaceIds {
            var workspaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceIds)
            for workspaceid0 in workspaceIds {
                try workspaceIdsContainer.encode(workspaceid0)
            }
        }
    }
}

extension DescribeWorkspacesConnectionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspacesConnectionStatusInput: Swift.Equatable {
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The identifiers of the WorkSpaces. You can specify up to 25 WorkSpaces.
    public var workspaceIds: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        workspaceIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaceIds = workspaceIds
    }
}

struct DescribeWorkspacesConnectionStatusInputBody: Swift.Equatable {
    let workspaceIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension DescribeWorkspacesConnectionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workspaceIds = "WorkspaceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workspaceIds)
        var workspaceIdsDecoded0:[Swift.String]? = nil
        if let workspaceIdsContainer = workspaceIdsContainer {
            workspaceIdsDecoded0 = [Swift.String]()
            for string0 in workspaceIdsContainer {
                if let string0 = string0 {
                    workspaceIdsDecoded0?.append(string0)
                }
            }
        }
        workspaceIds = workspaceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspacesConnectionStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspacesConnectionStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorkspacesConnectionStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspacesConnectionStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorkspacesConnectionStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspacesConnectionStatus = output.workspacesConnectionStatus
        } else {
            self.nextToken = nil
            self.workspacesConnectionStatus = nil
        }
    }
}

public struct DescribeWorkspacesConnectionStatusOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the connection status of the WorkSpace.
    public var workspacesConnectionStatus: [WorkSpacesClientTypes.WorkspaceConnectionStatus]?

    public init (
        nextToken: Swift.String? = nil,
        workspacesConnectionStatus: [WorkSpacesClientTypes.WorkspaceConnectionStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspacesConnectionStatus = workspacesConnectionStatus
    }
}

struct DescribeWorkspacesConnectionStatusOutputResponseBody: Swift.Equatable {
    let workspacesConnectionStatus: [WorkSpacesClientTypes.WorkspaceConnectionStatus]?
    let nextToken: Swift.String?
}

extension DescribeWorkspacesConnectionStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workspacesConnectionStatus = "WorkspacesConnectionStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesConnectionStatusContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.WorkspaceConnectionStatus?].self, forKey: .workspacesConnectionStatus)
        var workspacesConnectionStatusDecoded0:[WorkSpacesClientTypes.WorkspaceConnectionStatus]? = nil
        if let workspacesConnectionStatusContainer = workspacesConnectionStatusContainer {
            workspacesConnectionStatusDecoded0 = [WorkSpacesClientTypes.WorkspaceConnectionStatus]()
            for structure0 in workspacesConnectionStatusContainer {
                if let structure0 = structure0 {
                    workspacesConnectionStatusDecoded0?.append(structure0)
                }
            }
        }
        workspacesConnectionStatus = workspacesConnectionStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case userName = "UserName"
        case workspaceIds = "WorkspaceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let workspaceIds = workspaceIds {
            var workspaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workspaceIds)
            for workspaceid0 in workspaceIds {
                try workspaceIdsContainer.encode(workspaceid0)
            }
        }
    }
}

extension DescribeWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWorkspacesInput: Swift.Equatable {
    /// The identifier of the bundle. All WorkSpaces that are created from this bundle are retrieved. You cannot combine this parameter with any other filter.
    public var bundleId: Swift.String?
    /// The identifier of the directory. In addition, you can optionally specify a specific directory user (see UserName). You cannot combine this parameter with any other filter.
    public var directoryId: Swift.String?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?
    /// The name of the directory user. You must specify this parameter with DirectoryId.
    public var userName: Swift.String?
    /// The identifiers of the WorkSpaces. You cannot combine this parameter with any other filter. Because the [CreateWorkspaces] operation is asynchronous, the identifier it returns is not immediately available. If you immediately call [DescribeWorkspaces] with this identifier, no information is returned.
    public var workspaceIds: [Swift.String]?

    public init (
        bundleId: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userName: Swift.String? = nil,
        workspaceIds: [Swift.String]? = nil
    )
    {
        self.bundleId = bundleId
        self.directoryId = directoryId
        self.limit = limit
        self.nextToken = nextToken
        self.userName = userName
        self.workspaceIds = workspaceIds
    }
}

struct DescribeWorkspacesInputBody: Swift.Equatable {
    let workspaceIds: [Swift.String]?
    let directoryId: Swift.String?
    let userName: Swift.String?
    let bundleId: Swift.String?
    let limit: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case directoryId = "DirectoryId"
        case limit = "Limit"
        case nextToken = "NextToken"
        case userName = "UserName"
        case workspaceIds = "WorkspaceIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workspaceIds)
        var workspaceIdsDecoded0:[Swift.String]? = nil
        if let workspaceIdsContainer = workspaceIdsContainer {
            workspaceIdsDecoded0 = [Swift.String]()
            for string0 in workspaceIdsContainer {
                if let string0 = string0 {
                    workspaceIdsDecoded0?.append(string0)
                }
            }
        }
        workspaceIds = workspaceIdsDecoded0
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspaces = output.workspaces
        } else {
            self.nextToken = nil
            self.workspaces = nil
        }
    }
}

public struct DescribeWorkspacesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the WorkSpaces. Because [CreateWorkspaces] is an asynchronous operation, some of the returned information could be incomplete.
    public var workspaces: [WorkSpacesClientTypes.Workspace]?

    public init (
        nextToken: Swift.String? = nil,
        workspaces: [WorkSpacesClientTypes.Workspace]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaces = workspaces
    }
}

struct DescribeWorkspacesOutputResponseBody: Swift.Equatable {
    let workspaces: [WorkSpacesClientTypes.Workspace]?
    let nextToken: Swift.String?
}

extension DescribeWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workspaces = "Workspaces"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Workspace?].self, forKey: .workspaces)
        var workspacesDecoded0:[WorkSpacesClientTypes.Workspace]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [WorkSpacesClientTypes.Workspace]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DisassociateConnectionAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = self.aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
    }
}

extension DisassociateConnectionAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateConnectionAliasInput: Swift.Equatable {
    /// The identifier of the connection alias to disassociate.
    /// This member is required.
    public var aliasId: Swift.String?

    public init (
        aliasId: Swift.String? = nil
    )
    {
        self.aliasId = aliasId
    }
}

struct DisassociateConnectionAliasInputBody: Swift.Equatable {
    let aliasId: Swift.String?
}

extension DisassociateConnectionAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
    }
}

extension DisassociateConnectionAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateConnectionAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateConnectionAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateConnectionAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateConnectionAliasOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateIpGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for ipgroupid0 in groupIds {
                try groupIdsContainer.encode(ipgroupid0)
            }
        }
    }
}

extension DisassociateIpGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateIpGroupsInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var directoryId: Swift.String?
    /// The identifiers of one or more IP access control groups.
    /// This member is required.
    public var groupIds: [Swift.String]?

    public init (
        directoryId: Swift.String? = nil,
        groupIds: [Swift.String]? = nil
    )
    {
        self.directoryId = directoryId
        self.groupIds = groupIds
    }
}

struct DisassociateIpGroupsInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let groupIds: [Swift.String]?
}

extension DisassociateIpGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case groupIds = "GroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let groupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[Swift.String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [Swift.String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
    }
}

extension DisassociateIpGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateIpGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateIpGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateIpGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateIpGroupsOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkSpacesClientTypes.FailedCreateStandbyWorkspacesRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case standbyWorkspaceRequest = "StandbyWorkspaceRequest"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let standbyWorkspaceRequest = self.standbyWorkspaceRequest {
            try encodeContainer.encode(standbyWorkspaceRequest, forKey: .standbyWorkspaceRequest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standbyWorkspaceRequestDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.StandbyWorkspace.self, forKey: .standbyWorkspaceRequest)
        standbyWorkspaceRequest = standbyWorkspaceRequestDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the Standby WorkSpace that could not be created.
    public struct FailedCreateStandbyWorkspacesRequest: Swift.Equatable {
        /// The error code that is returned if the Standby WorkSpace could not be created.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the Standby WorkSpace could not be created.
        public var errorMessage: Swift.String?
        /// Information about the Standby WorkSpace that could not be created.
        public var standbyWorkspaceRequest: WorkSpacesClientTypes.StandbyWorkspace?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            standbyWorkspaceRequest: WorkSpacesClientTypes.StandbyWorkspace? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.standbyWorkspaceRequest = standbyWorkspaceRequest
        }
    }

}

extension WorkSpacesClientTypes.FailedCreateWorkspaceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case workspaceRequest = "WorkspaceRequest"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let workspaceRequest = self.workspaceRequest {
            try encodeContainer.encode(workspaceRequest, forKey: .workspaceRequest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceRequestDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceRequest.self, forKey: .workspaceRequest)
        workspaceRequest = workspaceRequestDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace that cannot be created.
    public struct FailedCreateWorkspaceRequest: Swift.Equatable {
        /// The error code that is returned if the WorkSpace cannot be created.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the WorkSpace cannot be created.
        public var errorMessage: Swift.String?
        /// Information about the WorkSpace.
        public var workspaceRequest: WorkSpacesClientTypes.WorkspaceRequest?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            workspaceRequest: WorkSpacesClientTypes.WorkspaceRequest? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.workspaceRequest = workspaceRequest
        }
    }

}

extension WorkSpacesClientTypes.FailedWorkspaceChangeRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace that could not be rebooted. ([RebootWorkspaces]), rebuilt ([RebuildWorkspaces]), restored ([RestoreWorkspace]), terminated ([TerminateWorkspaces]), started ([StartWorkspaces]), or stopped ([StopWorkspaces]).
    public struct FailedWorkspaceChangeRequest: Swift.Equatable {
        /// The error code that is returned if the WorkSpace cannot be rebooted.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the WorkSpace cannot be rebooted.
        public var errorMessage: Swift.String?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.workspaceId = workspaceId
        }
    }

}

extension WorkSpacesClientTypes.ImagePermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sharedAccountId = self.sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the Amazon Web Services accounts that have been granted permission to use a shared image. For more information about sharing images, see [ Share or Unshare a Custom WorkSpaces Image](https://docs.aws.amazon.com/workspaces/latest/adminguide/share-custom-image.html).
    public struct ImagePermission: Swift.Equatable {
        /// The identifier of the Amazon Web Services account that an image has been shared with.
        public var sharedAccountId: Swift.String?

        public init (
            sharedAccountId: Swift.String? = nil
        )
        {
            self.sharedAccountId = sharedAccountId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum ImageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case owned
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageType] {
            return [
                .owned,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .owned: return "OWNED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageType(rawValue: rawValue) ?? ImageType.sdkUnknown(rawValue)
        }
    }
}

extension ImportClientBrandingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceTypeAndroid = "DeviceTypeAndroid"
        case deviceTypeIos = "DeviceTypeIos"
        case deviceTypeLinux = "DeviceTypeLinux"
        case deviceTypeOsx = "DeviceTypeOsx"
        case deviceTypeWeb = "DeviceTypeWeb"
        case deviceTypeWindows = "DeviceTypeWindows"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceTypeAndroid = self.deviceTypeAndroid {
            try encodeContainer.encode(deviceTypeAndroid, forKey: .deviceTypeAndroid)
        }
        if let deviceTypeIos = self.deviceTypeIos {
            try encodeContainer.encode(deviceTypeIos, forKey: .deviceTypeIos)
        }
        if let deviceTypeLinux = self.deviceTypeLinux {
            try encodeContainer.encode(deviceTypeLinux, forKey: .deviceTypeLinux)
        }
        if let deviceTypeOsx = self.deviceTypeOsx {
            try encodeContainer.encode(deviceTypeOsx, forKey: .deviceTypeOsx)
        }
        if let deviceTypeWeb = self.deviceTypeWeb {
            try encodeContainer.encode(deviceTypeWeb, forKey: .deviceTypeWeb)
        }
        if let deviceTypeWindows = self.deviceTypeWindows {
            try encodeContainer.encode(deviceTypeWindows, forKey: .deviceTypeWindows)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ImportClientBrandingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportClientBrandingInput: Swift.Equatable {
    /// The branding information to import for Android devices.
    public var deviceTypeAndroid: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The branding information to import for iOS devices.
    public var deviceTypeIos: WorkSpacesClientTypes.IosImportClientBrandingAttributes?
    /// The branding information to import for Linux devices.
    public var deviceTypeLinux: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The branding information to import for macOS devices.
    public var deviceTypeOsx: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The branding information to import for web access.
    public var deviceTypeWeb: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The branding information to import for Windows devices.
    public var deviceTypeWindows: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    /// The directory identifier of the WorkSpace for which you want to import client branding.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        deviceTypeAndroid: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        deviceTypeIos: WorkSpacesClientTypes.IosImportClientBrandingAttributes? = nil,
        deviceTypeLinux: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        deviceTypeOsx: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        deviceTypeWeb: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        deviceTypeWindows: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.deviceTypeAndroid = deviceTypeAndroid
        self.deviceTypeIos = deviceTypeIos
        self.deviceTypeLinux = deviceTypeLinux
        self.deviceTypeOsx = deviceTypeOsx
        self.deviceTypeWeb = deviceTypeWeb
        self.deviceTypeWindows = deviceTypeWindows
        self.resourceId = resourceId
    }
}

struct ImportClientBrandingInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let deviceTypeWindows: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    let deviceTypeOsx: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    let deviceTypeAndroid: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    let deviceTypeIos: WorkSpacesClientTypes.IosImportClientBrandingAttributes?
    let deviceTypeLinux: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
    let deviceTypeWeb: WorkSpacesClientTypes.DefaultImportClientBrandingAttributes?
}

extension ImportClientBrandingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceTypeAndroid = "DeviceTypeAndroid"
        case deviceTypeIos = "DeviceTypeIos"
        case deviceTypeLinux = "DeviceTypeLinux"
        case deviceTypeOsx = "DeviceTypeOsx"
        case deviceTypeWeb = "DeviceTypeWeb"
        case deviceTypeWindows = "DeviceTypeWindows"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let deviceTypeWindowsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.self, forKey: .deviceTypeWindows)
        deviceTypeWindows = deviceTypeWindowsDecoded
        let deviceTypeOsxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.self, forKey: .deviceTypeOsx)
        deviceTypeOsx = deviceTypeOsxDecoded
        let deviceTypeAndroidDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.self, forKey: .deviceTypeAndroid)
        deviceTypeAndroid = deviceTypeAndroidDecoded
        let deviceTypeIosDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.IosImportClientBrandingAttributes.self, forKey: .deviceTypeIos)
        deviceTypeIos = deviceTypeIosDecoded
        let deviceTypeLinuxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.self, forKey: .deviceTypeLinux)
        deviceTypeLinux = deviceTypeLinuxDecoded
        let deviceTypeWebDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultImportClientBrandingAttributes.self, forKey: .deviceTypeWeb)
        deviceTypeWeb = deviceTypeWebDecoded
    }
}

extension ImportClientBrandingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportClientBrandingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportClientBrandingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportClientBrandingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportClientBrandingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceTypeAndroid = output.deviceTypeAndroid
            self.deviceTypeIos = output.deviceTypeIos
            self.deviceTypeLinux = output.deviceTypeLinux
            self.deviceTypeOsx = output.deviceTypeOsx
            self.deviceTypeWeb = output.deviceTypeWeb
            self.deviceTypeWindows = output.deviceTypeWindows
        } else {
            self.deviceTypeAndroid = nil
            self.deviceTypeIos = nil
            self.deviceTypeLinux = nil
            self.deviceTypeOsx = nil
            self.deviceTypeWeb = nil
            self.deviceTypeWindows = nil
        }
    }
}

public struct ImportClientBrandingOutputResponse: Swift.Equatable {
    /// The branding information configured for Android devices.
    public var deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information configured for iOS devices.
    public var deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes?
    /// The branding information configured for Linux devices.
    public var deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information configured for macOS devices.
    public var deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information configured for web access.
    public var deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    /// The branding information configured for Windows devices.
    public var deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes?

    public init (
        deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes? = nil,
        deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil,
        deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes? = nil
    )
    {
        self.deviceTypeAndroid = deviceTypeAndroid
        self.deviceTypeIos = deviceTypeIos
        self.deviceTypeLinux = deviceTypeLinux
        self.deviceTypeOsx = deviceTypeOsx
        self.deviceTypeWeb = deviceTypeWeb
        self.deviceTypeWindows = deviceTypeWindows
    }
}

struct ImportClientBrandingOutputResponseBody: Swift.Equatable {
    let deviceTypeWindows: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeOsx: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeAndroid: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeIos: WorkSpacesClientTypes.IosClientBrandingAttributes?
    let deviceTypeLinux: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
    let deviceTypeWeb: WorkSpacesClientTypes.DefaultClientBrandingAttributes?
}

extension ImportClientBrandingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceTypeAndroid = "DeviceTypeAndroid"
        case deviceTypeIos = "DeviceTypeIos"
        case deviceTypeLinux = "DeviceTypeLinux"
        case deviceTypeOsx = "DeviceTypeOsx"
        case deviceTypeWeb = "DeviceTypeWeb"
        case deviceTypeWindows = "DeviceTypeWindows"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTypeWindowsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeWindows)
        deviceTypeWindows = deviceTypeWindowsDecoded
        let deviceTypeOsxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeOsx)
        deviceTypeOsx = deviceTypeOsxDecoded
        let deviceTypeAndroidDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeAndroid)
        deviceTypeAndroid = deviceTypeAndroidDecoded
        let deviceTypeIosDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.IosClientBrandingAttributes.self, forKey: .deviceTypeIos)
        deviceTypeIos = deviceTypeIosDecoded
        let deviceTypeLinuxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeLinux)
        deviceTypeLinux = deviceTypeLinuxDecoded
        let deviceTypeWebDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultClientBrandingAttributes.self, forKey: .deviceTypeWeb)
        deviceTypeWeb = deviceTypeWebDecoded
    }
}

extension ImportWorkspaceImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case ec2ImageId = "Ec2ImageId"
        case imageDescription = "ImageDescription"
        case imageName = "ImageName"
        case ingestionProcess = "IngestionProcess"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for application0 in applications {
                try applicationsContainer.encode(application0.rawValue)
            }
        }
        if let ec2ImageId = self.ec2ImageId {
            try encodeContainer.encode(ec2ImageId, forKey: .ec2ImageId)
        }
        if let imageDescription = self.imageDescription {
            try encodeContainer.encode(imageDescription, forKey: .imageDescription)
        }
        if let imageName = self.imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let ingestionProcess = self.ingestionProcess {
            try encodeContainer.encode(ingestionProcess.rawValue, forKey: .ingestionProcess)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension ImportWorkspaceImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportWorkspaceImageInput: Swift.Equatable {
    /// If specified, the version of Microsoft Office to subscribe to. Valid only for Windows 10 BYOL images. For more information about subscribing to Office for BYOL images, see [ Bring Your Own Windows Desktop Licenses](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html). Although this parameter is an array, only one item is allowed at this time.
    public var applications: [WorkSpacesClientTypes.Application]?
    /// The identifier of the EC2 image.
    /// This member is required.
    public var ec2ImageId: Swift.String?
    /// The description of the WorkSpace image.
    /// This member is required.
    public var imageDescription: Swift.String?
    /// The name of the WorkSpace image.
    /// This member is required.
    public var imageName: Swift.String?
    /// The ingestion process to be used when importing the image, depending on which protocol you want to use for your BYOL Workspace image, either PCoIP, WorkSpaces Streaming Protocol (WSP), or bring your own protocol (BYOP). To use WSP, specify a value that ends in _WSP. To use PCoIP, specify a value that does not end in _WSP. To use BYOP, specify a value that ends in _BYOP. For non-GPU-enabled bundles (bundles other than Graphics or GraphicsPro), specify BYOL_REGULAR, BYOL_REGULAR_WSP, or BYOL_REGULAR_BYOP, depending on the protocol. The BYOL_REGULAR_BYOP and BYOL_GRAPHICS_G4DN_BYOP values are only supported by Amazon WorkSpaces Core. Contact your account team to be allow-listed to use these values. For more information, see [Amazon WorkSpaces Core](http://aws.amazon.com/workspaces/core/).
    /// This member is required.
    public var ingestionProcess: WorkSpacesClientTypes.WorkspaceImageIngestionProcess?
    /// The tags. Each WorkSpaces resource can have a maximum of 50 tags.
    public var tags: [WorkSpacesClientTypes.Tag]?

    public init (
        applications: [WorkSpacesClientTypes.Application]? = nil,
        ec2ImageId: Swift.String? = nil,
        imageDescription: Swift.String? = nil,
        imageName: Swift.String? = nil,
        ingestionProcess: WorkSpacesClientTypes.WorkspaceImageIngestionProcess? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil
    )
    {
        self.applications = applications
        self.ec2ImageId = ec2ImageId
        self.imageDescription = imageDescription
        self.imageName = imageName
        self.ingestionProcess = ingestionProcess
        self.tags = tags
    }
}

struct ImportWorkspaceImageInputBody: Swift.Equatable {
    let ec2ImageId: Swift.String?
    let ingestionProcess: WorkSpacesClientTypes.WorkspaceImageIngestionProcess?
    let imageName: Swift.String?
    let imageDescription: Swift.String?
    let tags: [WorkSpacesClientTypes.Tag]?
    let applications: [WorkSpacesClientTypes.Application]?
}

extension ImportWorkspaceImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case ec2ImageId = "Ec2ImageId"
        case imageDescription = "ImageDescription"
        case imageName = "ImageName"
        case ingestionProcess = "IngestionProcess"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2ImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2ImageId)
        ec2ImageId = ec2ImageIdDecoded
        let ingestionProcessDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageIngestionProcess.self, forKey: .ingestionProcess)
        ingestionProcess = ingestionProcessDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDescription)
        imageDescription = imageDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let applicationsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[WorkSpacesClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [WorkSpacesClientTypes.Application]()
            for enum0 in applicationsContainer {
                if let enum0 = enum0 {
                    applicationsDecoded0?.append(enum0)
                }
            }
        }
        applications = applicationsDecoded0
    }
}

extension ImportWorkspaceImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportWorkspaceImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportWorkspaceImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportWorkspaceImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportWorkspaceImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
        } else {
            self.imageId = nil
        }
    }
}

public struct ImportWorkspaceImageOutputResponse: Swift.Equatable {
    /// The identifier of the WorkSpace image.
    public var imageId: Swift.String?

    public init (
        imageId: Swift.String? = nil
    )
    {
        self.imageId = imageId
    }
}

struct ImportWorkspaceImageOutputResponseBody: Swift.Equatable {
    let imageId: Swift.String?
}

extension ImportWorkspaceImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId = "ImageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension InvalidParameterValuesException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterValuesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameter values are not valid.
public struct InvalidParameterValuesException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception error message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValuesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterValuesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The state of the resource is not valid for this operation.
public struct InvalidResourceStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesClientTypes.IosClientBrandingAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPasswordLink = "ForgotPasswordLink"
        case loginMessage = "LoginMessage"
        case logo2xUrl = "Logo2xUrl"
        case logo3xUrl = "Logo3xUrl"
        case logoUrl = "LogoUrl"
        case supportEmail = "SupportEmail"
        case supportLink = "SupportLink"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPasswordLink = self.forgotPasswordLink {
            try encodeContainer.encode(forgotPasswordLink, forKey: .forgotPasswordLink)
        }
        if let loginMessage = loginMessage {
            var loginMessageContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .loginMessage)
            for (dictKey0, loginMessage0) in loginMessage {
                try loginMessageContainer.encode(loginMessage0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let logo2xUrl = self.logo2xUrl {
            try encodeContainer.encode(logo2xUrl, forKey: .logo2xUrl)
        }
        if let logo3xUrl = self.logo3xUrl {
            try encodeContainer.encode(logo3xUrl, forKey: .logo3xUrl)
        }
        if let logoUrl = self.logoUrl {
            try encodeContainer.encode(logoUrl, forKey: .logoUrl)
        }
        if let supportEmail = self.supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportLink = self.supportLink {
            try encodeContainer.encode(supportLink, forKey: .supportLink)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logoUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logoUrl)
        logoUrl = logoUrlDecoded
        let logo2xUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logo2xUrl)
        logo2xUrl = logo2xUrlDecoded
        let logo3xUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logo3xUrl)
        logo3xUrl = logo3xUrlDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportLink)
        supportLink = supportLinkDecoded
        let forgotPasswordLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forgotPasswordLink)
        forgotPasswordLink = forgotPasswordLinkDecoded
        let loginMessageContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .loginMessage)
        var loginMessageDecoded0: [Swift.String:Swift.String]? = nil
        if let loginMessageContainer = loginMessageContainer {
            loginMessageDecoded0 = [Swift.String:Swift.String]()
            for (key0, clientloginmessage0) in loginMessageContainer {
                if let clientloginmessage0 = clientloginmessage0 {
                    loginMessageDecoded0?[key0] = clientloginmessage0
                }
            }
        }
        loginMessage = loginMessageDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// The client branding attributes for iOS device types. These attributes are displayed on the iOS client login screen only. Client branding attributes are public facing. Ensure you do not include sensitive information.
    public struct IosClientBrandingAttributes: Swift.Equatable {
        /// The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.
        public var forgotPasswordLink: Swift.String?
        /// The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is en_US. The HTML tags supported include the following: a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul.
        public var loginMessage: [Swift.String:Swift.String]?
        /// The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a .png file. For more information about iOS image size and resolution, see [Image Size and Resolution ](https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/) in the Apple Human Interface Guidelines.
        public var logo2xUrl: Swift.String?
        /// The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x).The only image format accepted is a binary data object that is converted from a .png file. For more information about iOS image size and resolution, see [Image Size and Resolution ](https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/) in the Apple Human Interface Guidelines.
        public var logo3xUrl: Swift.String?
        /// The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a .png file.
        public var logoUrl: Swift.String?
        /// The support email. The company's customer support email address.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default email is workspaces-feedback@amazon.com.
        public var supportEmail: Swift.String?
        /// The support link. The link for the company's customer support page for their WorkSpace.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default support link is workspaces-feedback@amazon.com.
        public var supportLink: Swift.String?

        public init (
            forgotPasswordLink: Swift.String? = nil,
            loginMessage: [Swift.String:Swift.String]? = nil,
            logo2xUrl: Swift.String? = nil,
            logo3xUrl: Swift.String? = nil,
            logoUrl: Swift.String? = nil,
            supportEmail: Swift.String? = nil,
            supportLink: Swift.String? = nil
        )
        {
            self.forgotPasswordLink = forgotPasswordLink
            self.loginMessage = loginMessage
            self.logo2xUrl = logo2xUrl
            self.logo3xUrl = logo3xUrl
            self.logoUrl = logoUrl
            self.supportEmail = supportEmail
            self.supportLink = supportLink
        }
    }

}

extension WorkSpacesClientTypes.IosImportClientBrandingAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPasswordLink = "ForgotPasswordLink"
        case loginMessage = "LoginMessage"
        case logo = "Logo"
        case logo2x = "Logo2x"
        case logo3x = "Logo3x"
        case supportEmail = "SupportEmail"
        case supportLink = "SupportLink"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPasswordLink = self.forgotPasswordLink {
            try encodeContainer.encode(forgotPasswordLink, forKey: .forgotPasswordLink)
        }
        if let loginMessage = loginMessage {
            var loginMessageContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .loginMessage)
            for (dictKey0, loginMessage0) in loginMessage {
                try loginMessageContainer.encode(loginMessage0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let logo = self.logo {
            try encodeContainer.encode(logo.base64EncodedString(), forKey: .logo)
        }
        if let logo2x = self.logo2x {
            try encodeContainer.encode(logo2x.base64EncodedString(), forKey: .logo2x)
        }
        if let logo3x = self.logo3x {
            try encodeContainer.encode(logo3x.base64EncodedString(), forKey: .logo3x)
        }
        if let supportEmail = self.supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportLink = self.supportLink {
            try encodeContainer.encode(supportLink, forKey: .supportLink)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logoDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .logo)
        logo = logoDecoded
        let logo2xDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .logo2x)
        logo2x = logo2xDecoded
        let logo3xDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .logo3x)
        logo3x = logo3xDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportLink)
        supportLink = supportLinkDecoded
        let forgotPasswordLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forgotPasswordLink)
        forgotPasswordLink = forgotPasswordLinkDecoded
        let loginMessageContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .loginMessage)
        var loginMessageDecoded0: [Swift.String:Swift.String]? = nil
        if let loginMessageContainer = loginMessageContainer {
            loginMessageDecoded0 = [Swift.String:Swift.String]()
            for (key0, clientloginmessage0) in loginMessageContainer {
                if let clientloginmessage0 = clientloginmessage0 {
                    loginMessageDecoded0?[key0] = clientloginmessage0
                }
            }
        }
        loginMessage = loginMessageDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// The client branding attributes to import for iOS device types. These attributes are displayed on the iOS client login screen. Client branding attributes are public facing. Ensure you do not include sensitive information.
    public struct IosImportClientBrandingAttributes: Swift.Equatable {
        /// The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.
        public var forgotPasswordLink: Swift.String?
        /// The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is en_US. The HTML tags supported include the following: a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul.
        public var loginMessage: [Swift.String:Swift.String]?
        /// The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a .png file.
        public var logo: ClientRuntime.Data?
        /// The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a .png file. For more information about iOS image size and resolution, see [Image Size and Resolution ](https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/) in the Apple Human Interface Guidelines.
        public var logo2x: ClientRuntime.Data?
        /// The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x). The only image format accepted is a binary data object that is converted from a .png file. For more information about iOS image size and resolution, see [Image Size and Resolution ](https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/) in the Apple Human Interface Guidelines.
        public var logo3x: ClientRuntime.Data?
        /// The support email. The company's customer support email address.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default email is workspaces-feedback@amazon.com.
        public var supportEmail: Swift.String?
        /// The support link. The link for the company's customer support page for their WorkSpace.
        ///
        /// * In each platform type, the SupportEmail and SupportLink parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.
        ///
        /// * The default support link is workspaces-feedback@amazon.com.
        public var supportLink: Swift.String?

        public init (
            forgotPasswordLink: Swift.String? = nil,
            loginMessage: [Swift.String:Swift.String]? = nil,
            logo: ClientRuntime.Data? = nil,
            logo2x: ClientRuntime.Data? = nil,
            logo3x: ClientRuntime.Data? = nil,
            supportEmail: Swift.String? = nil,
            supportLink: Swift.String? = nil
        )
        {
            self.forgotPasswordLink = forgotPasswordLink
            self.loginMessage = loginMessage
            self.logo = logo
            self.logo2x = logo2x
            self.logo3x = logo3x
            self.supportEmail = supportEmail
            self.supportLink = supportLink
        }
    }

}

extension WorkSpacesClientTypes.IpRuleItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipRule
        case ruleDesc
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipRule = self.ipRule {
            try encodeContainer.encode(ipRule, forKey: .ipRule)
        }
        if let ruleDesc = self.ruleDesc {
            try encodeContainer.encode(ruleDesc, forKey: .ruleDesc)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipRuleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipRule)
        ipRule = ipRuleDecoded
        let ruleDescDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleDesc)
        ruleDesc = ruleDescDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a rule for an IP access control group.
    public struct IpRuleItem: Swift.Equatable {
        /// The IP address range, in CIDR notation.
        public var ipRule: Swift.String?
        /// The description.
        public var ruleDesc: Swift.String?

        public init (
            ipRule: Swift.String? = nil,
            ruleDesc: Swift.String? = nil
        )
        {
            self.ipRule = ipRule
            self.ruleDesc = ruleDesc
        }
    }

}

extension ListAvailableManagementCidrRangesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managementCidrRangeConstraint = "ManagementCidrRangeConstraint"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let managementCidrRangeConstraint = self.managementCidrRangeConstraint {
            try encodeContainer.encode(managementCidrRangeConstraint, forKey: .managementCidrRangeConstraint)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAvailableManagementCidrRangesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAvailableManagementCidrRangesInput: Swift.Equatable {
    /// The IP address range to search. Specify an IP address range that is compatible with your network and in CIDR notation (that is, specify the range as an IPv4 CIDR block).
    /// This member is required.
    public var managementCidrRangeConstraint: Swift.String?
    /// The maximum number of items to return.
    public var maxResults: Swift.Int?
    /// If you received a NextToken from a previous call that was paginated, provide this token to receive the next set of results.
    public var nextToken: Swift.String?

    public init (
        managementCidrRangeConstraint: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.managementCidrRangeConstraint = managementCidrRangeConstraint
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAvailableManagementCidrRangesInputBody: Swift.Equatable {
    let managementCidrRangeConstraint: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAvailableManagementCidrRangesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managementCidrRangeConstraint = "ManagementCidrRangeConstraint"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managementCidrRangeConstraintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managementCidrRangeConstraint)
        managementCidrRangeConstraint = managementCidrRangeConstraintDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAvailableManagementCidrRangesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAvailableManagementCidrRangesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAvailableManagementCidrRangesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAvailableManagementCidrRangesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAvailableManagementCidrRangesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.managementCidrRanges = output.managementCidrRanges
            self.nextToken = output.nextToken
        } else {
            self.managementCidrRanges = nil
            self.nextToken = nil
        }
    }
}

public struct ListAvailableManagementCidrRangesOutputResponse: Swift.Equatable {
    /// The list of available IP address ranges, specified as IPv4 CIDR blocks.
    public var managementCidrRanges: [Swift.String]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        managementCidrRanges: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.managementCidrRanges = managementCidrRanges
        self.nextToken = nextToken
    }
}

struct ListAvailableManagementCidrRangesOutputResponseBody: Swift.Equatable {
    let managementCidrRanges: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAvailableManagementCidrRangesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managementCidrRanges = "ManagementCidrRanges"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managementCidrRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .managementCidrRanges)
        var managementCidrRangesDecoded0:[Swift.String]? = nil
        if let managementCidrRangesContainer = managementCidrRangesContainer {
            managementCidrRangesDecoded0 = [Swift.String]()
            for string0 in managementCidrRangesContainer {
                if let string0 = string0 {
                    managementCidrRangesDecoded0?.append(string0)
                }
            }
        }
        managementCidrRanges = managementCidrRangesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WorkSpacesClientTypes {
    public enum LogUploadEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LogUploadEnum] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogUploadEnum(rawValue: rawValue) ?? LogUploadEnum.sdkUnknown(rawValue)
        }
    }
}

extension MigrateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case sourceWorkspaceId = "SourceWorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let sourceWorkspaceId = self.sourceWorkspaceId {
            try encodeContainer.encode(sourceWorkspaceId, forKey: .sourceWorkspaceId)
        }
    }
}

extension MigrateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct MigrateWorkspaceInput: Swift.Equatable {
    /// The identifier of the target bundle type to migrate the WorkSpace to.
    /// This member is required.
    public var bundleId: Swift.String?
    /// The identifier of the WorkSpace to migrate from.
    /// This member is required.
    public var sourceWorkspaceId: Swift.String?

    public init (
        bundleId: Swift.String? = nil,
        sourceWorkspaceId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
        self.sourceWorkspaceId = sourceWorkspaceId
    }
}

struct MigrateWorkspaceInputBody: Swift.Equatable {
    let sourceWorkspaceId: Swift.String?
    let bundleId: Swift.String?
}

extension MigrateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case sourceWorkspaceId = "SourceWorkspaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceWorkspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceWorkspaceId)
        sourceWorkspaceId = sourceWorkspaceIdDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
    }
}

extension MigrateWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MigrateWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum MigrateWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationInProgressException(OperationInProgressException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MigrateWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MigrateWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sourceWorkspaceId = output.sourceWorkspaceId
            self.targetWorkspaceId = output.targetWorkspaceId
        } else {
            self.sourceWorkspaceId = nil
            self.targetWorkspaceId = nil
        }
    }
}

public struct MigrateWorkspaceOutputResponse: Swift.Equatable {
    /// The original identifier of the WorkSpace that is being migrated.
    public var sourceWorkspaceId: Swift.String?
    /// The new identifier of the WorkSpace that is being migrated. If the migration does not succeed, the target WorkSpace ID will not be used, and the WorkSpace will still have the original WorkSpace ID.
    public var targetWorkspaceId: Swift.String?

    public init (
        sourceWorkspaceId: Swift.String? = nil,
        targetWorkspaceId: Swift.String? = nil
    )
    {
        self.sourceWorkspaceId = sourceWorkspaceId
        self.targetWorkspaceId = targetWorkspaceId
    }
}

struct MigrateWorkspaceOutputResponseBody: Swift.Equatable {
    let sourceWorkspaceId: Swift.String?
    let targetWorkspaceId: Swift.String?
}

extension MigrateWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceWorkspaceId = "SourceWorkspaceId"
        case targetWorkspaceId = "TargetWorkspaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceWorkspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceWorkspaceId)
        sourceWorkspaceId = sourceWorkspaceIdDecoded
        let targetWorkspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetWorkspaceId)
        targetWorkspaceId = targetWorkspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    public enum ModificationResourceEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case computeType
        case rootVolume
        case userVolume
        case sdkUnknown(Swift.String)

        public static var allCases: [ModificationResourceEnum] {
            return [
                .computeType,
                .rootVolume,
                .userVolume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .computeType: return "COMPUTE_TYPE"
            case .rootVolume: return "ROOT_VOLUME"
            case .userVolume: return "USER_VOLUME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModificationResourceEnum(rawValue: rawValue) ?? ModificationResourceEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.ModificationState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "Resource"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource.rawValue, forKey: .resource)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ModificationResourceEnum.self, forKey: .resource)
        resource = resourceDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ModificationStateEnum.self, forKey: .state)
        state = stateDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace modification.
    public struct ModificationState: Swift.Equatable {
        /// The resource.
        public var resource: WorkSpacesClientTypes.ModificationResourceEnum?
        /// The modification state.
        public var state: WorkSpacesClientTypes.ModificationStateEnum?

        public init (
            resource: WorkSpacesClientTypes.ModificationResourceEnum? = nil,
            state: WorkSpacesClientTypes.ModificationStateEnum? = nil
        )
        {
            self.resource = resource
            self.state = state
        }
    }

}

extension WorkSpacesClientTypes {
    public enum ModificationStateEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case updateInitiated
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ModificationStateEnum] {
            return [
                .updateInitiated,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .updateInitiated: return "UPDATE_INITIATED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModificationStateEnum(rawValue: rawValue) ?? ModificationStateEnum.sdkUnknown(rawValue)
        }
    }
}

extension ModifyAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dedicatedTenancyManagementCidrRange = self.dedicatedTenancyManagementCidrRange {
            try encodeContainer.encode(dedicatedTenancyManagementCidrRange, forKey: .dedicatedTenancyManagementCidrRange)
        }
        if let dedicatedTenancySupport = self.dedicatedTenancySupport {
            try encodeContainer.encode(dedicatedTenancySupport.rawValue, forKey: .dedicatedTenancySupport)
        }
    }
}

extension ModifyAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyAccountInput: Swift.Equatable {
    /// The IP address range, specified as an IPv4 CIDR block, for the management network interface. Specify an IP address range that is compatible with your network and in CIDR notation (that is, specify the range as an IPv4 CIDR block). The CIDR block size must be /16 (for example, 203.0.113.25/16). It must also be specified as available by the ListAvailableManagementCidrRanges operation.
    public var dedicatedTenancyManagementCidrRange: Swift.String?
    /// The status of BYOL.
    public var dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportEnum?

    public init (
        dedicatedTenancyManagementCidrRange: Swift.String? = nil,
        dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportEnum? = nil
    )
    {
        self.dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRange
        self.dedicatedTenancySupport = dedicatedTenancySupport
    }
}

struct ModifyAccountInputBody: Swift.Equatable {
    let dedicatedTenancySupport: WorkSpacesClientTypes.DedicatedTenancySupportEnum?
    let dedicatedTenancyManagementCidrRange: Swift.String?
}

extension ModifyAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedTenancyManagementCidrRange = "DedicatedTenancyManagementCidrRange"
        case dedicatedTenancySupport = "DedicatedTenancySupport"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedTenancySupportDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DedicatedTenancySupportEnum.self, forKey: .dedicatedTenancySupport)
        dedicatedTenancySupport = dedicatedTenancySupportDecoded
        let dedicatedTenancyManagementCidrRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedTenancyManagementCidrRange)
        dedicatedTenancyManagementCidrRange = dedicatedTenancyManagementCidrRangeDecoded
    }
}

extension ModifyAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension ModifyCertificateBasedAuthPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBasedAuthProperties = "CertificateBasedAuthProperties"
        case propertiesToDelete = "PropertiesToDelete"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateBasedAuthProperties = self.certificateBasedAuthProperties {
            try encodeContainer.encode(certificateBasedAuthProperties, forKey: .certificateBasedAuthProperties)
        }
        if let propertiesToDelete = propertiesToDelete {
            var propertiesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertiesToDelete)
            for deletablecertificatebasedauthproperty0 in propertiesToDelete {
                try propertiesToDeleteContainer.encode(deletablecertificatebasedauthproperty0.rawValue)
            }
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ModifyCertificateBasedAuthPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyCertificateBasedAuthPropertiesInput: Swift.Equatable {
    /// The properties of the certificate-based authentication.
    public var certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties?
    /// The properties of the certificate-based authentication you want to delete.
    public var propertiesToDelete: [WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty]?
    /// The resource identifiers, in the form of directory IDs.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties? = nil,
        propertiesToDelete: [WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.certificateBasedAuthProperties = certificateBasedAuthProperties
        self.propertiesToDelete = propertiesToDelete
        self.resourceId = resourceId
    }
}

struct ModifyCertificateBasedAuthPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties?
    let propertiesToDelete: [WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty]?
}

extension ModifyCertificateBasedAuthPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateBasedAuthProperties = "CertificateBasedAuthProperties"
        case propertiesToDelete = "PropertiesToDelete"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let certificateBasedAuthPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.CertificateBasedAuthProperties.self, forKey: .certificateBasedAuthProperties)
        certificateBasedAuthProperties = certificateBasedAuthPropertiesDecoded
        let propertiesToDeleteContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty?].self, forKey: .propertiesToDelete)
        var propertiesToDeleteDecoded0:[WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty]? = nil
        if let propertiesToDeleteContainer = propertiesToDeleteContainer {
            propertiesToDeleteDecoded0 = [WorkSpacesClientTypes.DeletableCertificateBasedAuthProperty]()
            for enum0 in propertiesToDeleteContainer {
                if let enum0 = enum0 {
                    propertiesToDeleteDecoded0?.append(enum0)
                }
            }
        }
        propertiesToDelete = propertiesToDeleteDecoded0
    }
}

extension ModifyCertificateBasedAuthPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyCertificateBasedAuthPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyCertificateBasedAuthPropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyCertificateBasedAuthPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyCertificateBasedAuthPropertiesOutputResponse: Swift.Equatable {

    public init () { }
}

extension ModifyClientPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientProperties = "ClientProperties"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientProperties = self.clientProperties {
            try encodeContainer.encode(clientProperties, forKey: .clientProperties)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ModifyClientPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyClientPropertiesInput: Swift.Equatable {
    /// Information about the Amazon WorkSpaces client.
    /// This member is required.
    public var clientProperties: WorkSpacesClientTypes.ClientProperties?
    /// The resource identifiers, in the form of directory IDs.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        clientProperties: WorkSpacesClientTypes.ClientProperties? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.clientProperties = clientProperties
        self.resourceId = resourceId
    }
}

struct ModifyClientPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let clientProperties: WorkSpacesClientTypes.ClientProperties?
}

extension ModifyClientPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientProperties = "ClientProperties"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let clientPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ClientProperties.self, forKey: .clientProperties)
        clientProperties = clientPropertiesDecoded
    }
}

extension ModifyClientPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyClientPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyClientPropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyClientPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyClientPropertiesOutputResponse: Swift.Equatable {

    public init () { }
}

extension ModifySamlPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertiesToDelete = "PropertiesToDelete"
        case resourceId = "ResourceId"
        case samlProperties = "SamlProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertiesToDelete = propertiesToDelete {
            var propertiesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertiesToDelete)
            for deletablesamlproperty0 in propertiesToDelete {
                try propertiesToDeleteContainer.encode(deletablesamlproperty0.rawValue)
            }
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let samlProperties = self.samlProperties {
            try encodeContainer.encode(samlProperties, forKey: .samlProperties)
        }
    }
}

extension ModifySamlPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifySamlPropertiesInput: Swift.Equatable {
    /// The SAML properties to delete as part of your request. Specify one of the following options:
    ///
    /// * SAML_PROPERTIES_USER_ACCESS_URL to delete the user access URL.
    ///
    /// * SAML_PROPERTIES_RELAY_STATE_PARAMETER_NAME to delete the relay state parameter name.
    public var propertiesToDelete: [WorkSpacesClientTypes.DeletableSamlProperty]?
    /// The directory identifier for which you want to configure SAML properties.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The properties for configuring SAML 2.0 authentication.
    public var samlProperties: WorkSpacesClientTypes.SamlProperties?

    public init (
        propertiesToDelete: [WorkSpacesClientTypes.DeletableSamlProperty]? = nil,
        resourceId: Swift.String? = nil,
        samlProperties: WorkSpacesClientTypes.SamlProperties? = nil
    )
    {
        self.propertiesToDelete = propertiesToDelete
        self.resourceId = resourceId
        self.samlProperties = samlProperties
    }
}

struct ModifySamlPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let samlProperties: WorkSpacesClientTypes.SamlProperties?
    let propertiesToDelete: [WorkSpacesClientTypes.DeletableSamlProperty]?
}

extension ModifySamlPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertiesToDelete = "PropertiesToDelete"
        case resourceId = "ResourceId"
        case samlProperties = "SamlProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let samlPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.SamlProperties.self, forKey: .samlProperties)
        samlProperties = samlPropertiesDecoded
        let propertiesToDeleteContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.DeletableSamlProperty?].self, forKey: .propertiesToDelete)
        var propertiesToDeleteDecoded0:[WorkSpacesClientTypes.DeletableSamlProperty]? = nil
        if let propertiesToDeleteContainer = propertiesToDeleteContainer {
            propertiesToDeleteDecoded0 = [WorkSpacesClientTypes.DeletableSamlProperty]()
            for enum0 in propertiesToDeleteContainer {
                if let enum0 = enum0 {
                    propertiesToDeleteDecoded0?.append(enum0)
                }
            }
        }
        propertiesToDelete = propertiesToDeleteDecoded0
    }
}

extension ModifySamlPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifySamlPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifySamlPropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifySamlPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifySamlPropertiesOutputResponse: Swift.Equatable {

    public init () { }
}

extension ModifySelfservicePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case selfservicePermissions = "SelfservicePermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let selfservicePermissions = self.selfservicePermissions {
            try encodeContainer.encode(selfservicePermissions, forKey: .selfservicePermissions)
        }
    }
}

extension ModifySelfservicePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifySelfservicePermissionsInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The permissions to enable or disable self-service capabilities.
    /// This member is required.
    public var selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions?

    public init (
        resourceId: Swift.String? = nil,
        selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions? = nil
    )
    {
        self.resourceId = resourceId
        self.selfservicePermissions = selfservicePermissions
    }
}

struct ModifySelfservicePermissionsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions?
}

extension ModifySelfservicePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case selfservicePermissions = "SelfservicePermissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let selfservicePermissionsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.SelfservicePermissions.self, forKey: .selfservicePermissions)
        selfservicePermissions = selfservicePermissionsDecoded
    }
}

extension ModifySelfservicePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifySelfservicePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifySelfservicePermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifySelfservicePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifySelfservicePermissionsOutputResponse: Swift.Equatable {

    public init () { }
}

extension ModifyWorkspaceAccessPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case workspaceAccessProperties = "WorkspaceAccessProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let workspaceAccessProperties = self.workspaceAccessProperties {
            try encodeContainer.encode(workspaceAccessProperties, forKey: .workspaceAccessProperties)
        }
    }
}

extension ModifyWorkspaceAccessPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyWorkspaceAccessPropertiesInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The device types and operating systems to enable or disable for access.
    /// This member is required.
    public var workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties?

    public init (
        resourceId: Swift.String? = nil,
        workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties? = nil
    )
    {
        self.resourceId = resourceId
        self.workspaceAccessProperties = workspaceAccessProperties
    }
}

struct ModifyWorkspaceAccessPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties?
}

extension ModifyWorkspaceAccessPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case workspaceAccessProperties = "WorkspaceAccessProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let workspaceAccessPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceAccessProperties.self, forKey: .workspaceAccessProperties)
        workspaceAccessProperties = workspaceAccessPropertiesDecoded
    }
}

extension ModifyWorkspaceAccessPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyWorkspaceAccessPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyWorkspaceAccessPropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyWorkspaceAccessPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyWorkspaceAccessPropertiesOutputResponse: Swift.Equatable {

    public init () { }
}

extension ModifyWorkspaceCreationPropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case workspaceCreationProperties = "WorkspaceCreationProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let workspaceCreationProperties = self.workspaceCreationProperties {
            try encodeContainer.encode(workspaceCreationProperties, forKey: .workspaceCreationProperties)
        }
    }
}

extension ModifyWorkspaceCreationPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyWorkspaceCreationPropertiesInput: Swift.Equatable {
    /// The identifier of the directory.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The default properties for creating WorkSpaces.
    /// This member is required.
    public var workspaceCreationProperties: WorkSpacesClientTypes.WorkspaceCreationProperties?

    public init (
        resourceId: Swift.String? = nil,
        workspaceCreationProperties: WorkSpacesClientTypes.WorkspaceCreationProperties? = nil
    )
    {
        self.resourceId = resourceId
        self.workspaceCreationProperties = workspaceCreationProperties
    }
}

struct ModifyWorkspaceCreationPropertiesInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let workspaceCreationProperties: WorkSpacesClientTypes.WorkspaceCreationProperties?
}

extension ModifyWorkspaceCreationPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case workspaceCreationProperties = "WorkspaceCreationProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let workspaceCreationPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceCreationProperties.self, forKey: .workspaceCreationProperties)
        workspaceCreationProperties = workspaceCreationPropertiesDecoded
    }
}

extension ModifyWorkspaceCreationPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyWorkspaceCreationPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyWorkspaceCreationPropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyWorkspaceCreationPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyWorkspaceCreationPropertiesOutputResponse: Swift.Equatable {

    public init () { }
}

extension ModifyWorkspacePropertiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceProperties = "WorkspaceProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
        if let workspaceProperties = self.workspaceProperties {
            try encodeContainer.encode(workspaceProperties, forKey: .workspaceProperties)
        }
    }
}

extension ModifyWorkspacePropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyWorkspacePropertiesInput: Swift.Equatable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?
    /// The properties of the WorkSpace.
    /// This member is required.
    public var workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?

    public init (
        workspaceId: Swift.String? = nil,
        workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties? = nil
    )
    {
        self.workspaceId = workspaceId
        self.workspaceProperties = workspaceProperties
    }
}

struct ModifyWorkspacePropertiesInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?
}

extension ModifyWorkspacePropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceProperties = "WorkspaceProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let workspacePropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceProperties.self, forKey: .workspaceProperties)
        workspaceProperties = workspacePropertiesDecoded
    }
}

extension ModifyWorkspacePropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyWorkspacePropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationInProgressException" : self = .operationInProgressException(try OperationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedWorkspaceConfigurationException" : self = .unsupportedWorkspaceConfigurationException(try UnsupportedWorkspaceConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyWorkspacePropertiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationInProgressException(OperationInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unsupportedWorkspaceConfigurationException(UnsupportedWorkspaceConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyWorkspacePropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyWorkspacePropertiesOutputResponse: Swift.Equatable {

    public init () { }
}

extension ModifyWorkspaceStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceState = "WorkspaceState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
        if let workspaceState = self.workspaceState {
            try encodeContainer.encode(workspaceState.rawValue, forKey: .workspaceState)
        }
    }
}

extension ModifyWorkspaceStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyWorkspaceStateInput: Swift.Equatable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?
    /// The WorkSpace state.
    /// This member is required.
    public var workspaceState: WorkSpacesClientTypes.TargetWorkspaceState?

    public init (
        workspaceId: Swift.String? = nil,
        workspaceState: WorkSpacesClientTypes.TargetWorkspaceState? = nil
    )
    {
        self.workspaceId = workspaceId
        self.workspaceState = workspaceState
    }
}

struct ModifyWorkspaceStateInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let workspaceState: WorkSpacesClientTypes.TargetWorkspaceState?
}

extension ModifyWorkspaceStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
        case workspaceState = "WorkspaceState"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let workspaceStateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.TargetWorkspaceState.self, forKey: .workspaceState)
        workspaceState = workspaceStateDecoded
    }
}

extension ModifyWorkspaceStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyWorkspaceStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyWorkspaceStateOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyWorkspaceStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ModifyWorkspaceStateOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkSpacesClientTypes.OperatingSystem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.OperatingSystemType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// The operating system that the image is running.
    public struct OperatingSystem: Swift.Equatable {
        /// The operating system.
        public var type: WorkSpacesClientTypes.OperatingSystemType?

        public init (
            type: WorkSpacesClientTypes.OperatingSystemType? = nil
        )
        {
            self.type = type
        }
    }

}

extension WorkSpacesClientTypes {
    public enum OperatingSystemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatingSystemType] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperatingSystemType(rawValue: rawValue) ?? OperatingSystemType.sdkUnknown(rawValue)
        }
    }
}

extension OperationInProgressException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OperationInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The properties of this WorkSpace are currently being modified. Try again in a moment.
public struct OperationInProgressException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationInProgressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OperationNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This operation is not supported.
public struct OperationNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception error message.
    public var message: Swift.String?
    /// The exception error reason.
    public var reason: Swift.String?

    public init (
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct OperationNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Swift.String?
}

extension OperationNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WorkSpacesClientTypes.PendingCreateStandbyWorkspacesRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case state = "State"
        case userName = "UserName"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceState.self, forKey: .state)
        state = stateDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Information about the Standby WorkSpace.
    public struct PendingCreateStandbyWorkspacesRequest: Swift.Equatable {
        /// The identifier of the directory for the Standby WorkSpace.
        public var directoryId: Swift.String?
        /// The operational state of the Standby WorkSpace.
        public var state: WorkSpacesClientTypes.WorkspaceState?
        /// Describes the Standby WorkSpace that was created. Because this operation is asynchronous, the identifier returned is not immediately available for use with other operations. For example, if you call [ DescribeWorkspaces](https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html) before the WorkSpace is created, the information returned can be incomplete.
        public var userName: Swift.String?
        /// The identifier of the Standby WorkSpace.
        public var workspaceId: Swift.String?

        public init (
            directoryId: Swift.String? = nil,
            state: WorkSpacesClientTypes.WorkspaceState? = nil,
            userName: Swift.String? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
            self.state = state
            self.userName = userName
            self.workspaceId = workspaceId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pcoip
        case wsp
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .pcoip,
                .wsp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pcoip: return "PCOIP"
            case .wsp: return "WSP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.RebootRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to reboot a WorkSpace.
    public struct RebootRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init (
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension RebootWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebootWorkspaceRequests = "RebootWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rebootWorkspaceRequests = rebootWorkspaceRequests {
            var rebootWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rebootWorkspaceRequests)
            for rebootrequest0 in rebootWorkspaceRequests {
                try rebootWorkspaceRequestsContainer.encode(rebootrequest0)
            }
        }
    }
}

extension RebootWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RebootWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to reboot. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var rebootWorkspaceRequests: [WorkSpacesClientTypes.RebootRequest]?

    public init (
        rebootWorkspaceRequests: [WorkSpacesClientTypes.RebootRequest]? = nil
    )
    {
        self.rebootWorkspaceRequests = rebootWorkspaceRequests
    }
}

struct RebootWorkspacesInputBody: Swift.Equatable {
    let rebootWorkspaceRequests: [WorkSpacesClientTypes.RebootRequest]?
}

extension RebootWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebootWorkspaceRequests = "RebootWorkspaceRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rebootWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.RebootRequest?].self, forKey: .rebootWorkspaceRequests)
        var rebootWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.RebootRequest]? = nil
        if let rebootWorkspaceRequestsContainer = rebootWorkspaceRequestsContainer {
            rebootWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.RebootRequest]()
            for structure0 in rebootWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    rebootWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        rebootWorkspaceRequests = rebootWorkspaceRequestsDecoded0
    }
}

extension RebootWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RebootWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case operationNotSupportedException(OperationNotSupportedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RebootWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct RebootWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the WorkSpaces that could not be rebooted.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct RebootWorkspacesOutputResponseBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension RebootWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension WorkSpacesClientTypes.RebuildRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to rebuild a WorkSpace.
    public struct RebuildRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init (
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension RebuildWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebuildWorkspaceRequests = "RebuildWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rebuildWorkspaceRequests = rebuildWorkspaceRequests {
            var rebuildWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rebuildWorkspaceRequests)
            for rebuildrequest0 in rebuildWorkspaceRequests {
                try rebuildWorkspaceRequestsContainer.encode(rebuildrequest0)
            }
        }
    }
}

extension RebuildWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RebuildWorkspacesInput: Swift.Equatable {
    /// The WorkSpace to rebuild. You can specify a single WorkSpace.
    /// This member is required.
    public var rebuildWorkspaceRequests: [WorkSpacesClientTypes.RebuildRequest]?

    public init (
        rebuildWorkspaceRequests: [WorkSpacesClientTypes.RebuildRequest]? = nil
    )
    {
        self.rebuildWorkspaceRequests = rebuildWorkspaceRequests
    }
}

struct RebuildWorkspacesInputBody: Swift.Equatable {
    let rebuildWorkspaceRequests: [WorkSpacesClientTypes.RebuildRequest]?
}

extension RebuildWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rebuildWorkspaceRequests = "RebuildWorkspaceRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rebuildWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.RebuildRequest?].self, forKey: .rebuildWorkspaceRequests)
        var rebuildWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.RebuildRequest]? = nil
        if let rebuildWorkspaceRequestsContainer = rebuildWorkspaceRequestsContainer {
            rebuildWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.RebuildRequest]()
            for structure0 in rebuildWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    rebuildWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        rebuildWorkspaceRequests = rebuildWorkspaceRequestsDecoded0
    }
}

extension RebuildWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebuildWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RebuildWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case operationNotSupportedException(OperationNotSupportedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebuildWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RebuildWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct RebuildWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the WorkSpace that could not be rebuilt.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct RebuildWorkspacesOutputResponseBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension RebuildWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension WorkSpacesClientTypes {
    public enum ReconnectEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ReconnectEnum] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReconnectEnum(rawValue: rawValue) ?? ReconnectEnum.sdkUnknown(rawValue)
        }
    }
}

extension RegisterWorkspaceDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case enableSelfService = "EnableSelfService"
        case enableWorkDocs = "EnableWorkDocs"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case tenancy = "Tenancy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let enableSelfService = self.enableSelfService {
            try encodeContainer.encode(enableSelfService, forKey: .enableSelfService)
        }
        if let enableWorkDocs = self.enableWorkDocs {
            try encodeContainer.encode(enableWorkDocs, forKey: .enableWorkDocs)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let tenancy = self.tenancy {
            try encodeContainer.encode(tenancy.rawValue, forKey: .tenancy)
        }
    }
}

extension RegisterWorkspaceDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterWorkspaceDirectoryInput: Swift.Equatable {
    /// The identifier of the directory. You cannot register a directory if it does not have a status of Active. If the directory does not have a status of Active, you will receive an InvalidResourceStateException error. If you have already registered the maximum number of directories that you can register with Amazon WorkSpaces, you will receive a ResourceLimitExceededException error. Deregister directories that you are not using for WorkSpaces, and try again.
    /// This member is required.
    public var directoryId: Swift.String?
    /// Indicates whether self-service capabilities are enabled or disabled.
    public var enableSelfService: Swift.Bool?
    /// Indicates whether Amazon WorkDocs is enabled or disabled. If you have enabled this parameter and WorkDocs is not available in the Region, you will receive an OperationNotSupportedException error. Set EnableWorkDocs to disabled, and try again.
    /// This member is required.
    public var enableWorkDocs: Swift.Bool?
    /// The identifiers of the subnets for your virtual private cloud (VPC). Make sure that the subnets are in supported Availability Zones. The subnets must also be in separate Availability Zones. If these conditions are not met, you will receive an OperationNotSupportedException error.
    public var subnetIds: [Swift.String]?
    /// The tags associated with the directory.
    public var tags: [WorkSpacesClientTypes.Tag]?
    /// Indicates whether your WorkSpace directory is dedicated or shared. To use Bring Your Own License (BYOL) images, this value must be set to DEDICATED and your Amazon Web Services account must be enabled for BYOL. If your account has not been enabled for BYOL, you will receive an InvalidParameterValuesException error. For more information about BYOL images, see [Bring Your Own Windows Desktop Images](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
    public var tenancy: WorkSpacesClientTypes.Tenancy?

    public init (
        directoryId: Swift.String? = nil,
        enableSelfService: Swift.Bool? = nil,
        enableWorkDocs: Swift.Bool? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [WorkSpacesClientTypes.Tag]? = nil,
        tenancy: WorkSpacesClientTypes.Tenancy? = nil
    )
    {
        self.directoryId = directoryId
        self.enableSelfService = enableSelfService
        self.enableWorkDocs = enableWorkDocs
        self.subnetIds = subnetIds
        self.tags = tags
        self.tenancy = tenancy
    }
}

struct RegisterWorkspaceDirectoryInputBody: Swift.Equatable {
    let directoryId: Swift.String?
    let subnetIds: [Swift.String]?
    let enableWorkDocs: Swift.Bool?
    let enableSelfService: Swift.Bool?
    let tenancy: WorkSpacesClientTypes.Tenancy?
    let tags: [WorkSpacesClientTypes.Tag]?
}

extension RegisterWorkspaceDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case enableSelfService = "EnableSelfService"
        case enableWorkDocs = "EnableWorkDocs"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case tenancy = "Tenancy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let enableWorkDocsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWorkDocs)
        enableWorkDocs = enableWorkDocsDecoded
        let enableSelfServiceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSelfService)
        enableSelfService = enableSelfServiceDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.Tenancy.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RegisterWorkspaceDirectoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterWorkspaceDirectoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedNetworkConfigurationException" : self = .unsupportedNetworkConfigurationException(try UnsupportedNetworkConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WorkspacesDefaultRoleNotFoundException" : self = .workspacesDefaultRoleNotFoundException(try WorkspacesDefaultRoleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterWorkspaceDirectoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedNetworkConfigurationException(UnsupportedNetworkConfigurationException)
    case workspacesDefaultRoleNotFoundException(WorkspacesDefaultRoleNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterWorkspaceDirectoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RegisterWorkspaceDirectoryOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkSpacesClientTypes.RelatedWorkspaceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case region = "Region"
        case state = "State"
        case type = "Type"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.StandbyWorkspaceRelationshipType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the related WorkSpace. The related WorkSpace could be a Standby WorkSpace or Primary WorkSpace related to the specified WorkSpace.
    public struct RelatedWorkspaceProperties: Swift.Equatable {
        /// The Region of the related WorkSpace.
        public var region: Swift.String?
        /// Indicates the state of the WorkSpace.
        public var state: WorkSpacesClientTypes.WorkspaceState?
        /// Indicates the type of WorkSpace.
        public var type: WorkSpacesClientTypes.StandbyWorkspaceRelationshipType?
        /// The identifier of the related WorkSpace.
        public var workspaceId: Swift.String?

        public init (
            region: Swift.String? = nil,
            state: WorkSpacesClientTypes.WorkspaceState? = nil,
            type: WorkSpacesClientTypes.StandbyWorkspaceRelationshipType? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.region = region
            self.state = state
            self.type = type
            self.workspaceId = workspaceId
        }
    }

}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceAssociatedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAssociatedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is associated with a directory.
public struct ResourceAssociatedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAssociatedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAssociatedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceCreationFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceCreationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource could not be created.
public struct ResourceCreationFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceCreationFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceCreationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your resource limits have been exceeded.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception error message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.resourceId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The resource could not be found.
    public var message: Swift.String?
    /// The ID of the resource that could not be found.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ResourceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.resourceId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource is not available.
public struct ResourceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The exception error message.
    public var message: Swift.String?
    /// The identifier of the resource that is not available.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ResourceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ResourceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension RestoreWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension RestoreWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreWorkspaceInput: Swift.Equatable {
    /// The identifier of the WorkSpace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct RestoreWorkspaceInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
}

extension RestoreWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension RestoreWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RestoreWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RestoreWorkspaceOutputResponse: Swift.Equatable {

    public init () { }
}

extension RevokeIpRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for iprule0 in userRules {
                try userRulesContainer.encode(iprule0)
            }
        }
    }
}

extension RevokeIpRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RevokeIpRulesInput: Swift.Equatable {
    /// The identifier of the group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The rules to remove from the group.
    /// This member is required.
    public var userRules: [Swift.String]?

    public init (
        groupId: Swift.String? = nil,
        userRules: [Swift.String]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

struct RevokeIpRulesInputBody: Swift.Equatable {
    let groupId: Swift.String?
    let userRules: [Swift.String]?
}

extension RevokeIpRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userRules)
        var userRulesDecoded0:[Swift.String]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [Swift.String]()
            for string0 in userRulesContainer {
                if let string0 = string0 {
                    userRulesDecoded0?.append(string0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension RevokeIpRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeIpRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RevokeIpRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeIpRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RevokeIpRulesOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkSpacesClientTypes.RootStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity = "Capacity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = self.capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacity)
        capacity = capacityDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the root volume for a WorkSpace bundle.
    public struct RootStorage: Swift.Equatable {
        /// The size of the root volume.
        public var capacity: Swift.String?

        public init (
            capacity: Swift.String? = nil
        )
        {
            self.capacity = capacity
        }
    }

}

extension WorkSpacesClientTypes {
    public enum RunningMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alwaysOn
        case autoStop
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [RunningMode] {
            return [
                .alwaysOn,
                .autoStop,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alwaysOn: return "ALWAYS_ON"
            case .autoStop: return "AUTO_STOP"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunningMode(rawValue: rawValue) ?? RunningMode.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.SamlProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relayStateParameterName = "RelayStateParameterName"
        case status = "Status"
        case userAccessUrl = "UserAccessUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relayStateParameterName = self.relayStateParameterName {
            try encodeContainer.encode(relayStateParameterName, forKey: .relayStateParameterName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let userAccessUrl = self.userAccessUrl {
            try encodeContainer.encode(userAccessUrl, forKey: .userAccessUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.SamlStatusEnum.self, forKey: .status)
        status = statusDecoded
        let userAccessUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAccessUrl)
        userAccessUrl = userAccessUrlDecoded
        let relayStateParameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relayStateParameterName)
        relayStateParameterName = relayStateParameterNameDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the enablement status, user access URL, and relay state parameter name that are used for configuring federation with an SAML 2.0 identity provider.
    public struct SamlProperties: Swift.Equatable {
        /// The relay state parameter name supported by the SAML 2.0 identity provider (IdP). When the end user is redirected to the user access URL from the WorkSpaces client application, this relay state parameter name is appended as a query parameter to the URL along with the relay state endpoint to return the user to the client application session. To use SAML 2.0 authentication with WorkSpaces, the IdP must support IdP-initiated deep linking for the relay state URL. Consult your IdP documentation for more information.
        public var relayStateParameterName: Swift.String?
        /// Indicates the status of SAML 2.0 authentication. These statuses include the following.
        ///
        /// * If the setting is DISABLED, end users will be directed to login with their directory credentials.
        ///
        /// * If the setting is ENABLED, end users will be directed to login via the user access URL. Users attempting to connect to WorkSpaces from a client application that does not support SAML 2.0 authentication will not be able to connect.
        ///
        /// * If the setting is ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK, end users will be directed to login via the user access URL on supported client applications, but will not prevent clients that do not support SAML 2.0 authentication from connecting as if SAML 2.0 authentication was disabled.
        public var status: WorkSpacesClientTypes.SamlStatusEnum?
        /// The SAML 2.0 identity provider (IdP) user access URL is the URL a user would navigate to in their web browser in order to federate from the IdP and directly access the application, without any SAML 2.0 service provider (SP) bindings.
        public var userAccessUrl: Swift.String?

        public init (
            relayStateParameterName: Swift.String? = nil,
            status: WorkSpacesClientTypes.SamlStatusEnum? = nil,
            userAccessUrl: Swift.String? = nil
        )
        {
            self.relayStateParameterName = relayStateParameterName
            self.status = status
            self.userAccessUrl = userAccessUrl
        }
    }

}

extension WorkSpacesClientTypes {
    public enum SamlStatusEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case enabledWithDirectoryLoginFallback
        case sdkUnknown(Swift.String)

        public static var allCases: [SamlStatusEnum] {
            return [
                .disabled,
                .enabled,
                .enabledWithDirectoryLoginFallback,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .enabledWithDirectoryLoginFallback: return "ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SamlStatusEnum(rawValue: rawValue) ?? SamlStatusEnum.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.SelfservicePermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeComputeType = "ChangeComputeType"
        case increaseVolumeSize = "IncreaseVolumeSize"
        case rebuildWorkspace = "RebuildWorkspace"
        case restartWorkspace = "RestartWorkspace"
        case switchRunningMode = "SwitchRunningMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeComputeType = self.changeComputeType {
            try encodeContainer.encode(changeComputeType.rawValue, forKey: .changeComputeType)
        }
        if let increaseVolumeSize = self.increaseVolumeSize {
            try encodeContainer.encode(increaseVolumeSize.rawValue, forKey: .increaseVolumeSize)
        }
        if let rebuildWorkspace = self.rebuildWorkspace {
            try encodeContainer.encode(rebuildWorkspace.rawValue, forKey: .rebuildWorkspace)
        }
        if let restartWorkspace = self.restartWorkspace {
            try encodeContainer.encode(restartWorkspace.rawValue, forKey: .restartWorkspace)
        }
        if let switchRunningMode = self.switchRunningMode {
            try encodeContainer.encode(switchRunningMode.rawValue, forKey: .switchRunningMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restartWorkspaceDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .restartWorkspace)
        restartWorkspace = restartWorkspaceDecoded
        let increaseVolumeSizeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .increaseVolumeSize)
        increaseVolumeSize = increaseVolumeSizeDecoded
        let changeComputeTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .changeComputeType)
        changeComputeType = changeComputeTypeDecoded
        let switchRunningModeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .switchRunningMode)
        switchRunningMode = switchRunningModeDecoded
        let rebuildWorkspaceDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ReconnectEnum.self, forKey: .rebuildWorkspace)
        rebuildWorkspace = rebuildWorkspaceDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the self-service permissions for a directory. For more information, see [Enable Self-Service WorkSpace Management Capabilities for Your Users](https://docs.aws.amazon.com/workspaces/latest/adminguide/enable-user-self-service-workspace-management.html).
    public struct SelfservicePermissions: Swift.Equatable {
        /// Specifies whether users can change the compute type (bundle) for their WorkSpace.
        public var changeComputeType: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can increase the volume size of the drives on their WorkSpace.
        public var increaseVolumeSize: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can rebuild the operating system of a WorkSpace to its original state.
        public var rebuildWorkspace: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can restart their WorkSpace.
        public var restartWorkspace: WorkSpacesClientTypes.ReconnectEnum?
        /// Specifies whether users can switch the running mode of their WorkSpace.
        public var switchRunningMode: WorkSpacesClientTypes.ReconnectEnum?

        public init (
            changeComputeType: WorkSpacesClientTypes.ReconnectEnum? = nil,
            increaseVolumeSize: WorkSpacesClientTypes.ReconnectEnum? = nil,
            rebuildWorkspace: WorkSpacesClientTypes.ReconnectEnum? = nil,
            restartWorkspace: WorkSpacesClientTypes.ReconnectEnum? = nil,
            switchRunningMode: WorkSpacesClientTypes.ReconnectEnum? = nil
        )
        {
            self.changeComputeType = changeComputeType
            self.increaseVolumeSize = increaseVolumeSize
            self.rebuildWorkspace = rebuildWorkspace
            self.restartWorkspace = restartWorkspace
            self.switchRunningMode = switchRunningMode
        }
    }

}

extension WorkSpacesClientTypes.Snapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshotTime = "SnapshotTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snapshotTime = self.snapshotTime {
            try encodeContainer.encodeTimestamp(snapshotTime, format: .epochSeconds, forKey: .snapshotTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .snapshotTime)
        snapshotTime = snapshotTimeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a snapshot.
    public struct Snapshot: Swift.Equatable {
        /// The time when the snapshot was created.
        public var snapshotTime: ClientRuntime.Date?

        public init (
            snapshotTime: ClientRuntime.Date? = nil
        )
        {
            self.snapshotTime = snapshotTime
        }
    }

}

extension WorkSpacesClientTypes.StandbyWorkspace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryId = "DirectoryId"
        case primaryWorkspaceId = "PrimaryWorkspaceId"
        case tags = "Tags"
        case volumeEncryptionKey = "VolumeEncryptionKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let primaryWorkspaceId = self.primaryWorkspaceId {
            try encodeContainer.encode(primaryWorkspaceId, forKey: .primaryWorkspaceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let volumeEncryptionKey = self.volumeEncryptionKey {
            try encodeContainer.encode(volumeEncryptionKey, forKey: .volumeEncryptionKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryWorkspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryWorkspaceId)
        primaryWorkspaceId = primaryWorkspaceIdDecoded
        let volumeEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeEncryptionKey)
        volumeEncryptionKey = volumeEncryptionKeyDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes a Standby WorkSpace.
    public struct StandbyWorkspace: Swift.Equatable {
        /// The identifier of the directory for the Standby WorkSpace.
        /// This member is required.
        public var directoryId: Swift.String?
        /// The identifier of the Standby WorkSpace.
        /// This member is required.
        public var primaryWorkspaceId: Swift.String?
        /// The tags associated with the Standby WorkSpace.
        public var tags: [WorkSpacesClientTypes.Tag]?
        /// The volume encryption key of the Standby WorkSpace.
        public var volumeEncryptionKey: Swift.String?

        public init (
            directoryId: Swift.String? = nil,
            primaryWorkspaceId: Swift.String? = nil,
            tags: [WorkSpacesClientTypes.Tag]? = nil,
            volumeEncryptionKey: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
            self.primaryWorkspaceId = primaryWorkspaceId
            self.tags = tags
            self.volumeEncryptionKey = volumeEncryptionKey
        }
    }

}

extension WorkSpacesClientTypes {
    public enum StandbyWorkspaceRelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case primary
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [StandbyWorkspaceRelationshipType] {
            return [
                .primary,
                .standby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .primary: return "PRIMARY"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StandbyWorkspaceRelationshipType(rawValue: rawValue) ?? StandbyWorkspaceRelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.StartRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Information used to start a WorkSpace.
    public struct StartRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init (
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension StartWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startWorkspaceRequests = "StartWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startWorkspaceRequests = startWorkspaceRequests {
            var startWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startWorkspaceRequests)
            for startrequest0 in startWorkspaceRequests {
                try startWorkspaceRequestsContainer.encode(startrequest0)
            }
        }
    }
}

extension StartWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to start. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var startWorkspaceRequests: [WorkSpacesClientTypes.StartRequest]?

    public init (
        startWorkspaceRequests: [WorkSpacesClientTypes.StartRequest]? = nil
    )
    {
        self.startWorkspaceRequests = startWorkspaceRequests
    }
}

struct StartWorkspacesInputBody: Swift.Equatable {
    let startWorkspaceRequests: [WorkSpacesClientTypes.StartRequest]?
}

extension StartWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startWorkspaceRequests = "StartWorkspaceRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.StartRequest?].self, forKey: .startWorkspaceRequests)
        var startWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.StartRequest]? = nil
        if let startWorkspaceRequestsContainer = startWorkspaceRequestsContainer {
            startWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.StartRequest]()
            for structure0 in startWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    startWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        startWorkspaceRequests = startWorkspaceRequestsDecoded0
    }
}

extension StartWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StartWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct StartWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the WorkSpaces that could not be started.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct StartWorkspacesOutputResponseBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension StartWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension WorkSpacesClientTypes.StopRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to stop a WorkSpace.
    public struct StopRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init (
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension StopWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stopWorkspaceRequests = "StopWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stopWorkspaceRequests = stopWorkspaceRequests {
            var stopWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopWorkspaceRequests)
            for stoprequest0 in stopWorkspaceRequests {
                try stopWorkspaceRequestsContainer.encode(stoprequest0)
            }
        }
    }
}

extension StopWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to stop. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var stopWorkspaceRequests: [WorkSpacesClientTypes.StopRequest]?

    public init (
        stopWorkspaceRequests: [WorkSpacesClientTypes.StopRequest]? = nil
    )
    {
        self.stopWorkspaceRequests = stopWorkspaceRequests
    }
}

struct StopWorkspacesInputBody: Swift.Equatable {
    let stopWorkspaceRequests: [WorkSpacesClientTypes.StopRequest]?
}

extension StopWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stopWorkspaceRequests = "StopWorkspaceRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stopWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.StopRequest?].self, forKey: .stopWorkspaceRequests)
        var stopWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.StopRequest]? = nil
        if let stopWorkspaceRequestsContainer = stopWorkspaceRequestsContainer {
            stopWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.StopRequest]()
            for structure0 in stopWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    stopWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        stopWorkspaceRequests = stopWorkspaceRequestsDecoded0
    }
}

extension StopWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StopWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct StopWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the WorkSpaces that could not be stopped.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct StopWorkspacesOutputResponseBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension StopWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension WorkSpacesClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a tag.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension WorkSpacesClientTypes {
    public enum TargetWorkspaceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adminMaintenance
        case available
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetWorkspaceState] {
            return [
                .adminMaintenance,
                .available,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adminMaintenance: return "ADMIN_MAINTENANCE"
            case .available: return "AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetWorkspaceState(rawValue: rawValue) ?? TargetWorkspaceState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum Tenancy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dedicated
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [Tenancy] {
            return [
                .dedicated,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "DEDICATED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Tenancy(rawValue: rawValue) ?? Tenancy.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.TerminateRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to terminate a WorkSpace.
    public struct TerminateRequest: Swift.Equatable {
        /// The identifier of the WorkSpace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init (
            workspaceId: Swift.String? = nil
        )
        {
            self.workspaceId = workspaceId
        }
    }

}

extension TerminateWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminateWorkspaceRequests = "TerminateWorkspaceRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let terminateWorkspaceRequests = terminateWorkspaceRequests {
            var terminateWorkspaceRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terminateWorkspaceRequests)
            for terminaterequest0 in terminateWorkspaceRequests {
                try terminateWorkspaceRequestsContainer.encode(terminaterequest0)
            }
        }
    }
}

extension TerminateWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TerminateWorkspacesInput: Swift.Equatable {
    /// The WorkSpaces to terminate. You can specify up to 25 WorkSpaces.
    /// This member is required.
    public var terminateWorkspaceRequests: [WorkSpacesClientTypes.TerminateRequest]?

    public init (
        terminateWorkspaceRequests: [WorkSpacesClientTypes.TerminateRequest]? = nil
    )
    {
        self.terminateWorkspaceRequests = terminateWorkspaceRequests
    }
}

struct TerminateWorkspacesInputBody: Swift.Equatable {
    let terminateWorkspaceRequests: [WorkSpacesClientTypes.TerminateRequest]?
}

extension TerminateWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminateWorkspaceRequests = "TerminateWorkspaceRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminateWorkspaceRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.TerminateRequest?].self, forKey: .terminateWorkspaceRequests)
        var terminateWorkspaceRequestsDecoded0:[WorkSpacesClientTypes.TerminateRequest]? = nil
        if let terminateWorkspaceRequestsContainer = terminateWorkspaceRequestsContainer {
            terminateWorkspaceRequestsDecoded0 = [WorkSpacesClientTypes.TerminateRequest]()
            for structure0 in terminateWorkspaceRequestsContainer {
                if let structure0 = structure0 {
                    terminateWorkspaceRequestsDecoded0?.append(structure0)
                }
            }
        }
        terminateWorkspaceRequests = terminateWorkspaceRequestsDecoded0
    }
}

extension TerminateWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TerminateWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TerminateWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
        } else {
            self.failedRequests = nil
        }
    }
}

public struct TerminateWorkspacesOutputResponse: Swift.Equatable {
    /// Information about the WorkSpaces that could not be terminated.
    public var failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?

    public init (
        failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
    }
}

struct TerminateWorkspacesOutputResponseBody: Swift.Equatable {
    let failedRequests: [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]?
}

extension TerminateWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests = "FailedRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedRequestsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.FailedWorkspaceChangeRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[WorkSpacesClientTypes.FailedWorkspaceChangeRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [WorkSpacesClientTypes.FailedWorkspaceChangeRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

extension UnsupportedNetworkConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedNetworkConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The configuration of this network is not supported for this operation, or your network configuration conflicts with the Amazon WorkSpaces management network IP range. For more information, see [ Configure a VPC for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html).
public struct UnsupportedNetworkConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedNetworkConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedNetworkConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedWorkspaceConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedWorkspaceConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The configuration of this WorkSpace is not supported for this operation. For more information, see [Required Configuration and Service Components for WorkSpaces ](https://docs.aws.amazon.com/workspaces/latest/adminguide/required-service-components.html).
public struct UnsupportedWorkspaceConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedWorkspaceConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedWorkspaceConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateConnectClientAddInInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addInId = "AddInId"
        case name = "Name"
        case resourceId = "ResourceId"
        case url = "URL"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addInId = self.addInId {
            try encodeContainer.encode(addInId, forKey: .addInId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }
}

extension UpdateConnectClientAddInInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateConnectClientAddInInput: Swift.Equatable {
    /// The identifier of the client add-in to update.
    /// This member is required.
    public var addInId: Swift.String?
    /// The name of the client add-in.
    public var name: Swift.String?
    /// The directory identifier for which the client add-in is configured.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The endpoint URL of the Amazon Connect client add-in.
    public var url: Swift.String?

    public init (
        addInId: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        url: Swift.String? = nil
    )
    {
        self.addInId = addInId
        self.name = name
        self.resourceId = resourceId
        self.url = url
    }
}

struct UpdateConnectClientAddInInputBody: Swift.Equatable {
    let addInId: Swift.String?
    let resourceId: Swift.String?
    let name: Swift.String?
    let url: Swift.String?
}

extension UpdateConnectClientAddInInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addInId = "AddInId"
        case name = "Name"
        case resourceId = "ResourceId"
        case url = "URL"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addInIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addInId)
        addInId = addInIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension UpdateConnectClientAddInOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectClientAddInOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateConnectClientAddInOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectClientAddInOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateConnectClientAddInOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateConnectionAliasPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case connectionAliasPermission = "ConnectionAliasPermission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasId = self.aliasId {
            try encodeContainer.encode(aliasId, forKey: .aliasId)
        }
        if let connectionAliasPermission = self.connectionAliasPermission {
            try encodeContainer.encode(connectionAliasPermission, forKey: .connectionAliasPermission)
        }
    }
}

extension UpdateConnectionAliasPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateConnectionAliasPermissionInput: Swift.Equatable {
    /// The identifier of the connection alias that you want to update permissions for.
    /// This member is required.
    public var aliasId: Swift.String?
    /// Indicates whether to share or unshare the connection alias with the specified Amazon Web Services account.
    /// This member is required.
    public var connectionAliasPermission: WorkSpacesClientTypes.ConnectionAliasPermission?

    public init (
        aliasId: Swift.String? = nil,
        connectionAliasPermission: WorkSpacesClientTypes.ConnectionAliasPermission? = nil
    )
    {
        self.aliasId = aliasId
        self.connectionAliasPermission = connectionAliasPermission
    }
}

struct UpdateConnectionAliasPermissionInputBody: Swift.Equatable {
    let aliasId: Swift.String?
    let connectionAliasPermission: WorkSpacesClientTypes.ConnectionAliasPermission?
}

extension UpdateConnectionAliasPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasId = "AliasId"
        case connectionAliasPermission = "ConnectionAliasPermission"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasId)
        aliasId = aliasIdDecoded
        let connectionAliasPermissionDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ConnectionAliasPermission.self, forKey: .connectionAliasPermission)
        connectionAliasPermission = connectionAliasPermissionDecoded
    }
}

extension UpdateConnectionAliasPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionAliasPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateConnectionAliasPermissionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceAssociatedException(ResourceAssociatedException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionAliasPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateConnectionAliasPermissionOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkSpacesClientTypes.UpdateResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case updateAvailable = "UpdateAvailable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let updateAvailable = self.updateAvailable {
            try encodeContainer.encode(updateAvailable, forKey: .updateAvailable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateAvailableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .updateAvailable)
        updateAvailable = updateAvailableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes whether a WorkSpace image needs to be updated with the latest drivers and other components required by Amazon WorkSpaces. Only Windows 10 WorkSpace images can be programmatically updated at this time.
    public struct UpdateResult: Swift.Equatable {
        /// A description of whether updates for the WorkSpace image are pending or available.
        public var description: Swift.String?
        /// Indicates whether updated drivers or other components are available for the specified WorkSpace image.
        public var updateAvailable: Swift.Bool?

        public init (
            description: Swift.String? = nil,
            updateAvailable: Swift.Bool? = nil
        )
        {
            self.description = description
            self.updateAvailable = updateAvailable
        }
    }

}

extension UpdateRulesOfIpGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for ipruleitem0 in userRules {
                try userRulesContainer.encode(ipruleitem0)
            }
        }
    }
}

extension UpdateRulesOfIpGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRulesOfIpGroupInput: Swift.Equatable {
    /// The identifier of the group.
    /// This member is required.
    public var groupId: Swift.String?
    /// One or more rules.
    /// This member is required.
    public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

    public init (
        groupId: Swift.String? = nil,
        userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
    )
    {
        self.groupId = groupId
        self.userRules = userRules
    }
}

struct UpdateRulesOfIpGroupInputBody: Swift.Equatable {
    let groupId: Swift.String?
    let userRules: [WorkSpacesClientTypes.IpRuleItem]?
}

extension UpdateRulesOfIpGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case userRules = "UserRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[WorkSpacesClientTypes.IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [WorkSpacesClientTypes.IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension UpdateRulesOfIpGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRulesOfIpGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRulesOfIpGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case invalidResourceStateException(InvalidResourceStateException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRulesOfIpGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRulesOfIpGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateWorkspaceBundleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case imageId = "ImageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }
}

extension UpdateWorkspaceBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWorkspaceBundleInput: Swift.Equatable {
    /// The identifier of the bundle.
    public var bundleId: Swift.String?
    /// The identifier of the image.
    public var imageId: Swift.String?

    public init (
        bundleId: Swift.String? = nil,
        imageId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
        self.imageId = imageId
    }
}

struct UpdateWorkspaceBundleInputBody: Swift.Equatable {
    let bundleId: Swift.String?
    let imageId: Swift.String?
}

extension UpdateWorkspaceBundleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case imageId = "ImageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension UpdateWorkspaceBundleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkspaceBundleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWorkspaceBundleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkspaceBundleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWorkspaceBundleOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateWorkspaceImagePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCopyImage = "AllowCopyImage"
        case imageId = "ImageId"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowCopyImage = self.allowCopyImage {
            try encodeContainer.encode(allowCopyImage, forKey: .allowCopyImage)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let sharedAccountId = self.sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }
}

extension UpdateWorkspaceImagePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWorkspaceImagePermissionInput: Swift.Equatable {
    /// The permission to copy the image. This permission can be revoked only after an image has been shared.
    /// This member is required.
    public var allowCopyImage: Swift.Bool?
    /// The identifier of the image.
    /// This member is required.
    public var imageId: Swift.String?
    /// The identifier of the Amazon Web Services account to share or unshare the image with. Before sharing the image, confirm that you are sharing to the correct Amazon Web Services account ID.
    /// This member is required.
    public var sharedAccountId: Swift.String?

    public init (
        allowCopyImage: Swift.Bool? = nil,
        imageId: Swift.String? = nil,
        sharedAccountId: Swift.String? = nil
    )
    {
        self.allowCopyImage = allowCopyImage
        self.imageId = imageId
        self.sharedAccountId = sharedAccountId
    }
}

struct UpdateWorkspaceImagePermissionInputBody: Swift.Equatable {
    let imageId: Swift.String?
    let allowCopyImage: Swift.Bool?
    let sharedAccountId: Swift.String?
}

extension UpdateWorkspaceImagePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCopyImage = "AllowCopyImage"
        case imageId = "ImageId"
        case sharedAccountId = "SharedAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let allowCopyImageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowCopyImage)
        allowCopyImage = allowCopyImageDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
    }
}

extension UpdateWorkspaceImagePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkspaceImagePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValuesException" : self = .invalidParameterValuesException(try InvalidParameterValuesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWorkspaceImagePermissionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case invalidParameterValuesException(InvalidParameterValuesException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkspaceImagePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWorkspaceImagePermissionOutputResponse: Swift.Equatable {

    public init () { }
}

extension WorkSpacesClientTypes.UserStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity = "Capacity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = self.capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacity)
        capacity = capacityDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the user volume for a WorkSpace bundle.
    public struct UserStorage: Swift.Equatable {
        /// The size of the user volume.
        public var capacity: Swift.String?

        public init (
            capacity: Swift.String? = nil
        )
        {
            self.capacity = capacity
        }
    }

}

extension WorkSpacesClientTypes.Workspace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case computerName = "ComputerName"
        case directoryId = "DirectoryId"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case ipAddress = "IpAddress"
        case modificationStates = "ModificationStates"
        case relatedWorkspaces = "RelatedWorkspaces"
        case rootVolumeEncryptionEnabled = "RootVolumeEncryptionEnabled"
        case state = "State"
        case subnetId = "SubnetId"
        case userName = "UserName"
        case userVolumeEncryptionEnabled = "UserVolumeEncryptionEnabled"
        case volumeEncryptionKey = "VolumeEncryptionKey"
        case workspaceId = "WorkspaceId"
        case workspaceProperties = "WorkspaceProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let computerName = self.computerName {
            try encodeContainer.encode(computerName, forKey: .computerName)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let modificationStates = modificationStates {
            var modificationStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modificationStates)
            for modificationstate0 in modificationStates {
                try modificationStatesContainer.encode(modificationstate0)
            }
        }
        if let relatedWorkspaces = relatedWorkspaces {
            var relatedWorkspacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedWorkspaces)
            for relatedworkspaceproperties0 in relatedWorkspaces {
                try relatedWorkspacesContainer.encode(relatedworkspaceproperties0)
            }
        }
        if let rootVolumeEncryptionEnabled = self.rootVolumeEncryptionEnabled {
            try encodeContainer.encode(rootVolumeEncryptionEnabled, forKey: .rootVolumeEncryptionEnabled)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userVolumeEncryptionEnabled = self.userVolumeEncryptionEnabled {
            try encodeContainer.encode(userVolumeEncryptionEnabled, forKey: .userVolumeEncryptionEnabled)
        }
        if let volumeEncryptionKey = self.volumeEncryptionKey {
            try encodeContainer.encode(volumeEncryptionKey, forKey: .volumeEncryptionKey)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
        if let workspaceProperties = self.workspaceProperties {
            try encodeContainer.encode(workspaceProperties, forKey: .workspaceProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceState.self, forKey: .state)
        state = stateDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let computerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computerName)
        computerName = computerNameDecoded
        let volumeEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeEncryptionKey)
        volumeEncryptionKey = volumeEncryptionKeyDecoded
        let userVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userVolumeEncryptionEnabled)
        userVolumeEncryptionEnabled = userVolumeEncryptionEnabledDecoded
        let rootVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rootVolumeEncryptionEnabled)
        rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabledDecoded
        let workspacePropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceProperties.self, forKey: .workspaceProperties)
        workspaceProperties = workspacePropertiesDecoded
        let modificationStatesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ModificationState?].self, forKey: .modificationStates)
        var modificationStatesDecoded0:[WorkSpacesClientTypes.ModificationState]? = nil
        if let modificationStatesContainer = modificationStatesContainer {
            modificationStatesDecoded0 = [WorkSpacesClientTypes.ModificationState]()
            for structure0 in modificationStatesContainer {
                if let structure0 = structure0 {
                    modificationStatesDecoded0?.append(structure0)
                }
            }
        }
        modificationStates = modificationStatesDecoded0
        let relatedWorkspacesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.RelatedWorkspaceProperties?].self, forKey: .relatedWorkspaces)
        var relatedWorkspacesDecoded0:[WorkSpacesClientTypes.RelatedWorkspaceProperties]? = nil
        if let relatedWorkspacesContainer = relatedWorkspacesContainer {
            relatedWorkspacesDecoded0 = [WorkSpacesClientTypes.RelatedWorkspaceProperties]()
            for structure0 in relatedWorkspacesContainer {
                if let structure0 = structure0 {
                    relatedWorkspacesDecoded0?.append(structure0)
                }
            }
        }
        relatedWorkspaces = relatedWorkspacesDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace.
    public struct Workspace: Swift.Equatable {
        /// The identifier of the bundle used to create the WorkSpace.
        public var bundleId: Swift.String?
        /// The name of the WorkSpace, as seen by the operating system. The format of this name varies. For more information, see [ Launch a WorkSpace](https://docs.aws.amazon.com/workspaces/latest/adminguide/launch-workspaces-tutorials.html).
        public var computerName: Swift.String?
        /// The identifier of the Directory Service directory for the WorkSpace.
        public var directoryId: Swift.String?
        /// The error code that is returned if the WorkSpace cannot be created.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned if the WorkSpace cannot be created.
        public var errorMessage: Swift.String?
        /// The IP address of the WorkSpace.
        public var ipAddress: Swift.String?
        /// The modification states of the WorkSpace.
        public var modificationStates: [WorkSpacesClientTypes.ModificationState]?
        /// The Standby WorkSpace or Primary WorkSpace related to the specified WorkSpace.
        public var relatedWorkspaces: [WorkSpacesClientTypes.RelatedWorkspaceProperties]?
        /// Indicates whether the data stored on the root volume is encrypted.
        public var rootVolumeEncryptionEnabled: Swift.Bool?
        /// The operational state of the WorkSpace. After a WorkSpace is terminated, the TERMINATED state is returned only briefly before the WorkSpace directory metadata is cleaned up, so this state is rarely returned. To confirm that a WorkSpace is terminated, check for the WorkSpace ID by using [ DescribeWorkSpaces](https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html). If the WorkSpace ID isn't returned, then the WorkSpace has been successfully terminated.
        public var state: WorkSpacesClientTypes.WorkspaceState?
        /// The identifier of the subnet for the WorkSpace.
        public var subnetId: Swift.String?
        /// The user for the WorkSpace.
        public var userName: Swift.String?
        /// Indicates whether the data stored on the user volume is encrypted.
        public var userVolumeEncryptionEnabled: Swift.Bool?
        /// The symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.
        public var volumeEncryptionKey: Swift.String?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?
        /// The properties of the WorkSpace.
        public var workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?

        public init (
            bundleId: Swift.String? = nil,
            computerName: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            modificationStates: [WorkSpacesClientTypes.ModificationState]? = nil,
            relatedWorkspaces: [WorkSpacesClientTypes.RelatedWorkspaceProperties]? = nil,
            rootVolumeEncryptionEnabled: Swift.Bool? = nil,
            state: WorkSpacesClientTypes.WorkspaceState? = nil,
            subnetId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userVolumeEncryptionEnabled: Swift.Bool? = nil,
            volumeEncryptionKey: Swift.String? = nil,
            workspaceId: Swift.String? = nil,
            workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties? = nil
        )
        {
            self.bundleId = bundleId
            self.computerName = computerName
            self.directoryId = directoryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.ipAddress = ipAddress
            self.modificationStates = modificationStates
            self.relatedWorkspaces = relatedWorkspaces
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.state = state
            self.subnetId = subnetId
            self.userName = userName
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.volumeEncryptionKey = volumeEncryptionKey
            self.workspaceId = workspaceId
            self.workspaceProperties = workspaceProperties
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceAccessProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceTypeAndroid = "DeviceTypeAndroid"
        case deviceTypeChromeOs = "DeviceTypeChromeOs"
        case deviceTypeIos = "DeviceTypeIos"
        case deviceTypeLinux = "DeviceTypeLinux"
        case deviceTypeOsx = "DeviceTypeOsx"
        case deviceTypeWeb = "DeviceTypeWeb"
        case deviceTypeWindows = "DeviceTypeWindows"
        case deviceTypeZeroClient = "DeviceTypeZeroClient"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceTypeAndroid = self.deviceTypeAndroid {
            try encodeContainer.encode(deviceTypeAndroid.rawValue, forKey: .deviceTypeAndroid)
        }
        if let deviceTypeChromeOs = self.deviceTypeChromeOs {
            try encodeContainer.encode(deviceTypeChromeOs.rawValue, forKey: .deviceTypeChromeOs)
        }
        if let deviceTypeIos = self.deviceTypeIos {
            try encodeContainer.encode(deviceTypeIos.rawValue, forKey: .deviceTypeIos)
        }
        if let deviceTypeLinux = self.deviceTypeLinux {
            try encodeContainer.encode(deviceTypeLinux.rawValue, forKey: .deviceTypeLinux)
        }
        if let deviceTypeOsx = self.deviceTypeOsx {
            try encodeContainer.encode(deviceTypeOsx.rawValue, forKey: .deviceTypeOsx)
        }
        if let deviceTypeWeb = self.deviceTypeWeb {
            try encodeContainer.encode(deviceTypeWeb.rawValue, forKey: .deviceTypeWeb)
        }
        if let deviceTypeWindows = self.deviceTypeWindows {
            try encodeContainer.encode(deviceTypeWindows.rawValue, forKey: .deviceTypeWindows)
        }
        if let deviceTypeZeroClient = self.deviceTypeZeroClient {
            try encodeContainer.encode(deviceTypeZeroClient.rawValue, forKey: .deviceTypeZeroClient)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTypeWindowsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeWindows)
        deviceTypeWindows = deviceTypeWindowsDecoded
        let deviceTypeOsxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeOsx)
        deviceTypeOsx = deviceTypeOsxDecoded
        let deviceTypeWebDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeWeb)
        deviceTypeWeb = deviceTypeWebDecoded
        let deviceTypeIosDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeIos)
        deviceTypeIos = deviceTypeIosDecoded
        let deviceTypeAndroidDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeAndroid)
        deviceTypeAndroid = deviceTypeAndroidDecoded
        let deviceTypeChromeOsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeChromeOs)
        deviceTypeChromeOs = deviceTypeChromeOsDecoded
        let deviceTypeZeroClientDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeZeroClient)
        deviceTypeZeroClient = deviceTypeZeroClientDecoded
        let deviceTypeLinuxDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.AccessPropertyValue.self, forKey: .deviceTypeLinux)
        deviceTypeLinux = deviceTypeLinuxDecoded
    }
}

extension WorkSpacesClientTypes {
    /// The device types and operating systems that can be used to access a WorkSpace. For more information, see [Amazon WorkSpaces Client Network Requirements](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-network-requirements.html).
    public struct WorkspaceAccessProperties: Swift.Equatable {
        /// Indicates whether users can use Android and Android-compatible Chrome OS devices to access their WorkSpaces.
        public var deviceTypeAndroid: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use Chromebooks to access their WorkSpaces.
        public var deviceTypeChromeOs: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use iOS devices to access their WorkSpaces.
        public var deviceTypeIos: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use Linux clients to access their WorkSpaces.
        public var deviceTypeLinux: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use macOS clients to access their WorkSpaces.
        public var deviceTypeOsx: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can access their WorkSpaces through a web browser.
        public var deviceTypeWeb: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use Windows clients to access their WorkSpaces.
        public var deviceTypeWindows: WorkSpacesClientTypes.AccessPropertyValue?
        /// Indicates whether users can use zero client devices to access their WorkSpaces.
        public var deviceTypeZeroClient: WorkSpacesClientTypes.AccessPropertyValue?

        public init (
            deviceTypeAndroid: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeChromeOs: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeIos: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeLinux: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeOsx: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeWeb: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeWindows: WorkSpacesClientTypes.AccessPropertyValue? = nil,
            deviceTypeZeroClient: WorkSpacesClientTypes.AccessPropertyValue? = nil
        )
        {
            self.deviceTypeAndroid = deviceTypeAndroid
            self.deviceTypeChromeOs = deviceTypeChromeOs
            self.deviceTypeIos = deviceTypeIos
            self.deviceTypeLinux = deviceTypeLinux
            self.deviceTypeOsx = deviceTypeOsx
            self.deviceTypeWeb = deviceTypeWeb
            self.deviceTypeWindows = deviceTypeWindows
            self.deviceTypeZeroClient = deviceTypeZeroClient
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceBundle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case bundleType = "BundleType"
        case computeType = "ComputeType"
        case creationTime = "CreationTime"
        case description = "Description"
        case imageId = "ImageId"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case owner = "Owner"
        case rootStorage = "RootStorage"
        case state = "State"
        case userStorage = "UserStorage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let bundleType = self.bundleType {
            try encodeContainer.encode(bundleType.rawValue, forKey: .bundleType)
        }
        if let computeType = self.computeType {
            try encodeContainer.encode(computeType, forKey: .computeType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let rootStorage = self.rootStorage {
            try encodeContainer.encode(rootStorage, forKey: .rootStorage)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userStorage = self.userStorage {
            try encodeContainer.encode(userStorage, forKey: .userStorage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let rootStorageDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.RootStorage.self, forKey: .rootStorage)
        rootStorage = rootStorageDecoded
        let userStorageDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.UserStorage.self, forKey: .userStorage)
        userStorage = userStorageDecoded
        let computeTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ComputeType.self, forKey: .computeType)
        computeType = computeTypeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceBundleState.self, forKey: .state)
        state = stateDecoded
        let bundleTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.BundleType.self, forKey: .bundleType)
        bundleType = bundleTypeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace bundle.
    public struct WorkspaceBundle: Swift.Equatable {
        /// The identifier of the bundle.
        public var bundleId: Swift.String?
        /// The type of WorkSpace bundle.
        public var bundleType: WorkSpacesClientTypes.BundleType?
        /// The compute type of the bundle. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles).
        public var computeType: WorkSpacesClientTypes.ComputeType?
        /// The time when the bundle was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the bundle.
        public var description: Swift.String?
        /// The identifier of the image that was used to create the bundle.
        public var imageId: Swift.String?
        /// The last time that the bundle was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the bundle.
        public var name: Swift.String?
        /// The owner of the bundle. This is the account identifier of the owner, or AMAZON if the bundle is provided by Amazon Web Services.
        public var owner: Swift.String?
        /// The size of the root volume.
        public var rootStorage: WorkSpacesClientTypes.RootStorage?
        /// The state of the WorkSpace bundle.
        public var state: WorkSpacesClientTypes.WorkspaceBundleState?
        /// The size of the user volume.
        public var userStorage: WorkSpacesClientTypes.UserStorage?

        public init (
            bundleId: Swift.String? = nil,
            bundleType: WorkSpacesClientTypes.BundleType? = nil,
            computeType: WorkSpacesClientTypes.ComputeType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            imageId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            rootStorage: WorkSpacesClientTypes.RootStorage? = nil,
            state: WorkSpacesClientTypes.WorkspaceBundleState? = nil,
            userStorage: WorkSpacesClientTypes.UserStorage? = nil
        )
        {
            self.bundleId = bundleId
            self.bundleType = bundleType
            self.computeType = computeType
            self.creationTime = creationTime
            self.description = description
            self.imageId = imageId
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.owner = owner
            self.rootStorage = rootStorage
            self.state = state
            self.userStorage = userStorage
        }
    }

}

extension WorkSpacesClientTypes {
    public enum WorkspaceBundleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case error
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceBundleState] {
            return [
                .available,
                .error,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceBundleState(rawValue: rawValue) ?? WorkspaceBundleState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.WorkspaceConnectionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionState = "ConnectionState"
        case connectionStateCheckTimestamp = "ConnectionStateCheckTimestamp"
        case lastKnownUserConnectionTimestamp = "LastKnownUserConnectionTimestamp"
        case workspaceId = "WorkspaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionState = self.connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let connectionStateCheckTimestamp = self.connectionStateCheckTimestamp {
            try encodeContainer.encodeTimestamp(connectionStateCheckTimestamp, format: .epochSeconds, forKey: .connectionStateCheckTimestamp)
        }
        if let lastKnownUserConnectionTimestamp = self.lastKnownUserConnectionTimestamp {
            try encodeContainer.encodeTimestamp(lastKnownUserConnectionTimestamp, format: .epochSeconds, forKey: .lastKnownUserConnectionTimestamp)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let connectionStateCheckTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .connectionStateCheckTimestamp)
        connectionStateCheckTimestamp = connectionStateCheckTimestampDecoded
        let lastKnownUserConnectionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastKnownUserConnectionTimestamp)
        lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestampDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the connection status of a WorkSpace.
    public struct WorkspaceConnectionStatus: Swift.Equatable {
        /// The connection state of the WorkSpace. The connection state is unknown if the WorkSpace is stopped.
        public var connectionState: WorkSpacesClientTypes.ConnectionState?
        /// The timestamp of the connection status check.
        public var connectionStateCheckTimestamp: ClientRuntime.Date?
        /// The timestamp of the last known user connection.
        public var lastKnownUserConnectionTimestamp: ClientRuntime.Date?
        /// The identifier of the WorkSpace.
        public var workspaceId: Swift.String?

        public init (
            connectionState: WorkSpacesClientTypes.ConnectionState? = nil,
            connectionStateCheckTimestamp: ClientRuntime.Date? = nil,
            lastKnownUserConnectionTimestamp: ClientRuntime.Date? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.connectionState = connectionState
            self.connectionStateCheckTimestamp = connectionStateCheckTimestamp
            self.lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestamp
            self.workspaceId = workspaceId
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceCreationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customSecurityGroupId = "CustomSecurityGroupId"
        case defaultOu = "DefaultOu"
        case enableInternetAccess = "EnableInternetAccess"
        case enableMaintenanceMode = "EnableMaintenanceMode"
        case enableWorkDocs = "EnableWorkDocs"
        case userEnabledAsLocalAdministrator = "UserEnabledAsLocalAdministrator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customSecurityGroupId = self.customSecurityGroupId {
            try encodeContainer.encode(customSecurityGroupId, forKey: .customSecurityGroupId)
        }
        if let defaultOu = self.defaultOu {
            try encodeContainer.encode(defaultOu, forKey: .defaultOu)
        }
        if let enableInternetAccess = self.enableInternetAccess {
            try encodeContainer.encode(enableInternetAccess, forKey: .enableInternetAccess)
        }
        if let enableMaintenanceMode = self.enableMaintenanceMode {
            try encodeContainer.encode(enableMaintenanceMode, forKey: .enableMaintenanceMode)
        }
        if let enableWorkDocs = self.enableWorkDocs {
            try encodeContainer.encode(enableWorkDocs, forKey: .enableWorkDocs)
        }
        if let userEnabledAsLocalAdministrator = self.userEnabledAsLocalAdministrator {
            try encodeContainer.encode(userEnabledAsLocalAdministrator, forKey: .userEnabledAsLocalAdministrator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableWorkDocsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWorkDocs)
        enableWorkDocs = enableWorkDocsDecoded
        let enableInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableInternetAccess)
        enableInternetAccess = enableInternetAccessDecoded
        let defaultOuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOu)
        defaultOu = defaultOuDecoded
        let customSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customSecurityGroupId)
        customSecurityGroupId = customSecurityGroupIdDecoded
        let userEnabledAsLocalAdministratorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userEnabledAsLocalAdministrator)
        userEnabledAsLocalAdministrator = userEnabledAsLocalAdministratorDecoded
        let enableMaintenanceModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMaintenanceMode)
        enableMaintenanceMode = enableMaintenanceModeDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes the default properties that are used for creating WorkSpaces. For more information, see [Update Directory Details for Your WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html).
    public struct WorkspaceCreationProperties: Swift.Equatable {
        /// The identifier of your custom security group.
        public var customSecurityGroupId: Swift.String?
        /// The default organizational unit (OU) for your WorkSpaces directories. This string must be the full Lightweight Directory Access Protocol (LDAP) distinguished name for the target domain and OU. It must be in the form "OU=value,DC=value,DC=value", where value is any string of characters, and the number of domain components (DCs) is two or more. For example, OU=WorkSpaces_machines,DC=machines,DC=example,DC=com.
        ///
        /// * To avoid errors, certain characters in the distinguished name must be escaped. For more information, see [ Distinguished Names](https://docs.microsoft.com/previous-versions/windows/desktop/ldap/distinguished-names) in the Microsoft documentation.
        ///
        /// * The API doesn't validate whether the OU exists.
        public var defaultOu: Swift.String?
        /// Indicates whether internet access is enabled for your WorkSpaces.
        public var enableInternetAccess: Swift.Bool?
        /// Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see [WorkSpace Maintenance](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html).
        public var enableMaintenanceMode: Swift.Bool?
        /// Indicates whether Amazon WorkDocs is enabled for your WorkSpaces. If WorkDocs is already enabled for a WorkSpaces directory and you disable it, new WorkSpaces launched in the directory will not have WorkDocs enabled. However, WorkDocs remains enabled for any existing WorkSpaces, unless you either disable users' access to WorkDocs or you delete the WorkDocs site. To disable users' access to WorkDocs, see [Disabling Users](https://docs.aws.amazon.com/workdocs/latest/adminguide/inactive-user.html) in the Amazon WorkDocs Administration Guide. To delete a WorkDocs site, see [Deleting a Site](https://docs.aws.amazon.com/workdocs/latest/adminguide/manage-sites.html) in the Amazon WorkDocs Administration Guide. If you enable WorkDocs on a directory that already has existing WorkSpaces, the existing WorkSpaces and any new WorkSpaces that are launched in the directory will have WorkDocs enabled.
        public var enableWorkDocs: Swift.Bool?
        /// Indicates whether users are local administrators of their WorkSpaces.
        public var userEnabledAsLocalAdministrator: Swift.Bool?

        public init (
            customSecurityGroupId: Swift.String? = nil,
            defaultOu: Swift.String? = nil,
            enableInternetAccess: Swift.Bool? = nil,
            enableMaintenanceMode: Swift.Bool? = nil,
            enableWorkDocs: Swift.Bool? = nil,
            userEnabledAsLocalAdministrator: Swift.Bool? = nil
        )
        {
            self.customSecurityGroupId = customSecurityGroupId
            self.defaultOu = defaultOu
            self.enableInternetAccess = enableInternetAccess
            self.enableMaintenanceMode = enableMaintenanceMode
            self.enableWorkDocs = enableWorkDocs
            self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceDirectory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case certificateBasedAuthProperties = "CertificateBasedAuthProperties"
        case customerUserName = "CustomerUserName"
        case directoryId = "DirectoryId"
        case directoryName = "DirectoryName"
        case directoryType = "DirectoryType"
        case dnsIpAddresses = "DnsIpAddresses"
        case iamRoleId = "IamRoleId"
        case registrationCode = "RegistrationCode"
        case samlProperties = "SamlProperties"
        case selfservicePermissions = "SelfservicePermissions"
        case state = "State"
        case subnetIds = "SubnetIds"
        case tenancy = "Tenancy"
        case workspaceAccessProperties = "WorkspaceAccessProperties"
        case workspaceCreationProperties = "WorkspaceCreationProperties"
        case workspaceSecurityGroupId = "WorkspaceSecurityGroupId"
        case ipGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let certificateBasedAuthProperties = self.certificateBasedAuthProperties {
            try encodeContainer.encode(certificateBasedAuthProperties, forKey: .certificateBasedAuthProperties)
        }
        if let customerUserName = self.customerUserName {
            try encodeContainer.encode(customerUserName, forKey: .customerUserName)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let directoryName = self.directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let directoryType = self.directoryType {
            try encodeContainer.encode(directoryType.rawValue, forKey: .directoryType)
        }
        if let dnsIpAddresses = dnsIpAddresses {
            var dnsIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddresses)
            for ipaddress0 in dnsIpAddresses {
                try dnsIpAddressesContainer.encode(ipaddress0)
            }
        }
        if let iamRoleId = self.iamRoleId {
            try encodeContainer.encode(iamRoleId, forKey: .iamRoleId)
        }
        if let registrationCode = self.registrationCode {
            try encodeContainer.encode(registrationCode, forKey: .registrationCode)
        }
        if let samlProperties = self.samlProperties {
            try encodeContainer.encode(samlProperties, forKey: .samlProperties)
        }
        if let selfservicePermissions = self.selfservicePermissions {
            try encodeContainer.encode(selfservicePermissions, forKey: .selfservicePermissions)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
        if let tenancy = self.tenancy {
            try encodeContainer.encode(tenancy.rawValue, forKey: .tenancy)
        }
        if let workspaceAccessProperties = self.workspaceAccessProperties {
            try encodeContainer.encode(workspaceAccessProperties, forKey: .workspaceAccessProperties)
        }
        if let workspaceCreationProperties = self.workspaceCreationProperties {
            try encodeContainer.encode(workspaceCreationProperties, forKey: .workspaceCreationProperties)
        }
        if let workspaceSecurityGroupId = self.workspaceSecurityGroupId {
            try encodeContainer.encode(workspaceSecurityGroupId, forKey: .workspaceSecurityGroupId)
        }
        if let ipGroupIds = ipGroupIds {
            var ipGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipGroupIds)
            for ipgroupid0 in ipGroupIds {
                try ipGroupIdsContainer.encode(ipgroupid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let registrationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registrationCode)
        registrationCode = registrationCodeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let dnsIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIpAddresses)
        var dnsIpAddressesDecoded0:[Swift.String]? = nil
        if let dnsIpAddressesContainer = dnsIpAddressesContainer {
            dnsIpAddressesDecoded0 = [Swift.String]()
            for string0 in dnsIpAddressesContainer {
                if let string0 = string0 {
                    dnsIpAddressesDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddresses = dnsIpAddressesDecoded0
        let customerUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerUserName)
        customerUserName = customerUserNameDecoded
        let iamRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleId)
        iamRoleId = iamRoleIdDecoded
        let directoryTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceDirectoryType.self, forKey: .directoryType)
        directoryType = directoryTypeDecoded
        let workspaceSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceSecurityGroupId)
        workspaceSecurityGroupId = workspaceSecurityGroupIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceDirectoryState.self, forKey: .state)
        state = stateDecoded
        let workspaceCreationPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.DefaultWorkspaceCreationProperties.self, forKey: .workspaceCreationProperties)
        workspaceCreationProperties = workspaceCreationPropertiesDecoded
        let ipGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipGroupIds)
        var ipGroupIdsDecoded0:[Swift.String]? = nil
        if let ipGroupIdsContainer = ipGroupIdsContainer {
            ipGroupIdsDecoded0 = [Swift.String]()
            for string0 in ipGroupIdsContainer {
                if let string0 = string0 {
                    ipGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ipGroupIds = ipGroupIdsDecoded0
        let workspaceAccessPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceAccessProperties.self, forKey: .workspaceAccessProperties)
        workspaceAccessProperties = workspaceAccessPropertiesDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.Tenancy.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let selfservicePermissionsDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.SelfservicePermissions.self, forKey: .selfservicePermissions)
        selfservicePermissions = selfservicePermissionsDecoded
        let samlPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.SamlProperties.self, forKey: .samlProperties)
        samlProperties = samlPropertiesDecoded
        let certificateBasedAuthPropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.CertificateBasedAuthProperties.self, forKey: .certificateBasedAuthProperties)
        certificateBasedAuthProperties = certificateBasedAuthPropertiesDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a directory that is used with Amazon WorkSpaces.
    public struct WorkspaceDirectory: Swift.Equatable {
        /// The directory alias.
        public var alias: Swift.String?
        /// The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory for WorkSpaces login.
        public var certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties?
        /// The user name for the service account.
        public var customerUserName: Swift.String?
        /// The directory identifier.
        public var directoryId: Swift.String?
        /// The name of the directory.
        public var directoryName: Swift.String?
        /// The directory type.
        public var directoryType: WorkSpacesClientTypes.WorkspaceDirectoryType?
        /// The IP addresses of the DNS servers for the directory.
        public var dnsIpAddresses: [Swift.String]?
        /// The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.
        public var iamRoleId: Swift.String?
        /// The identifiers of the IP access control groups associated with the directory.
        public var ipGroupIds: [Swift.String]?
        /// The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.
        public var registrationCode: Swift.String?
        /// Describes the enablement status, user access URL, and relay state parameter name that are used for configuring federation with an SAML 2.0 identity provider.
        public var samlProperties: WorkSpacesClientTypes.SamlProperties?
        /// The default self-service permissions for WorkSpaces in the directory.
        public var selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions?
        /// The state of the directory's registration with Amazon WorkSpaces. After a directory is deregistered, the DEREGISTERED state is returned very briefly before the directory metadata is cleaned up, so this state is rarely returned. To confirm that a directory is deregistered, check for the directory ID by using [ DescribeWorkspaceDirectories](https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaceDirectories.html). If the directory ID isn't returned, then the directory has been successfully deregistered.
        public var state: WorkSpacesClientTypes.WorkspaceDirectoryState?
        /// The identifiers of the subnets used with the directory.
        public var subnetIds: [Swift.String]?
        /// Specifies whether the directory is dedicated or shared. To use Bring Your Own License (BYOL), this value must be set to DEDICATED. For more information, see [Bring Your Own Windows Desktop Images](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
        public var tenancy: WorkSpacesClientTypes.Tenancy?
        /// The devices and operating systems that users can use to access WorkSpaces.
        public var workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties?
        /// The default creation properties for all WorkSpaces in the directory.
        public var workspaceCreationProperties: WorkSpacesClientTypes.DefaultWorkspaceCreationProperties?
        /// The identifier of the security group that is assigned to new WorkSpaces.
        public var workspaceSecurityGroupId: Swift.String?

        public init (
            alias: Swift.String? = nil,
            certificateBasedAuthProperties: WorkSpacesClientTypes.CertificateBasedAuthProperties? = nil,
            customerUserName: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            directoryName: Swift.String? = nil,
            directoryType: WorkSpacesClientTypes.WorkspaceDirectoryType? = nil,
            dnsIpAddresses: [Swift.String]? = nil,
            iamRoleId: Swift.String? = nil,
            ipGroupIds: [Swift.String]? = nil,
            registrationCode: Swift.String? = nil,
            samlProperties: WorkSpacesClientTypes.SamlProperties? = nil,
            selfservicePermissions: WorkSpacesClientTypes.SelfservicePermissions? = nil,
            state: WorkSpacesClientTypes.WorkspaceDirectoryState? = nil,
            subnetIds: [Swift.String]? = nil,
            tenancy: WorkSpacesClientTypes.Tenancy? = nil,
            workspaceAccessProperties: WorkSpacesClientTypes.WorkspaceAccessProperties? = nil,
            workspaceCreationProperties: WorkSpacesClientTypes.DefaultWorkspaceCreationProperties? = nil,
            workspaceSecurityGroupId: Swift.String? = nil
        )
        {
            self.alias = alias
            self.certificateBasedAuthProperties = certificateBasedAuthProperties
            self.customerUserName = customerUserName
            self.directoryId = directoryId
            self.directoryName = directoryName
            self.directoryType = directoryType
            self.dnsIpAddresses = dnsIpAddresses
            self.iamRoleId = iamRoleId
            self.ipGroupIds = ipGroupIds
            self.registrationCode = registrationCode
            self.samlProperties = samlProperties
            self.selfservicePermissions = selfservicePermissions
            self.state = state
            self.subnetIds = subnetIds
            self.tenancy = tenancy
            self.workspaceAccessProperties = workspaceAccessProperties
            self.workspaceCreationProperties = workspaceCreationProperties
            self.workspaceSecurityGroupId = workspaceSecurityGroupId
        }
    }

}

extension WorkSpacesClientTypes {
    public enum WorkspaceDirectoryState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deregistered
        case deregistering
        case error
        case registered
        case registering
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceDirectoryState] {
            return [
                .deregistered,
                .deregistering,
                .error,
                .registered,
                .registering,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deregistered: return "DEREGISTERED"
            case .deregistering: return "DEREGISTERING"
            case .error: return "ERROR"
            case .registered: return "REGISTERED"
            case .registering: return "REGISTERING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceDirectoryState(rawValue: rawValue) ?? WorkspaceDirectoryState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum WorkspaceDirectoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adConnector
        case simpleAd
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceDirectoryType] {
            return [
                .adConnector,
                .simpleAd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adConnector: return "AD_CONNECTOR"
            case .simpleAd: return "SIMPLE_AD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceDirectoryType(rawValue: rawValue) ?? WorkspaceDirectoryType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.WorkspaceImage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case description = "Description"
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case imageId = "ImageId"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case ownerAccountId = "OwnerAccountId"
        case requiredTenancy = "RequiredTenancy"
        case state = "State"
        case updates = "Updates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = self.created {
            try encodeContainer.encodeTimestamp(created, format: .epochSeconds, forKey: .created)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operatingSystem = self.operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let requiredTenancy = self.requiredTenancy {
            try encodeContainer.encode(requiredTenancy.rawValue, forKey: .requiredTenancy)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let updates = self.updates {
            try encodeContainer.encode(updates, forKey: .updates)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageState.self, forKey: .state)
        state = stateDecoded
        let requiredTenancyDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceImageRequiredTenancy.self, forKey: .requiredTenancy)
        requiredTenancy = requiredTenancyDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let updatesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.UpdateResult.self, forKey: .updates)
        updates = updatesDecoded
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace image.
    public struct WorkspaceImage: Swift.Equatable {
        /// The date when the image was created. If the image has been shared, the Amazon Web Services account that the image has been shared with sees the original creation date of the image.
        public var created: ClientRuntime.Date?
        /// The description of the image.
        public var description: Swift.String?
        /// The error code that is returned for the image.
        public var errorCode: Swift.String?
        /// The text of the error message that is returned for the image.
        public var errorMessage: Swift.String?
        /// The identifier of the image.
        public var imageId: Swift.String?
        /// The name of the image.
        public var name: Swift.String?
        /// The operating system that the image is running.
        public var operatingSystem: WorkSpacesClientTypes.OperatingSystem?
        /// The identifier of the Amazon Web Services account that owns the image.
        public var ownerAccountId: Swift.String?
        /// Specifies whether the image is running on dedicated hardware. When Bring Your Own License (BYOL) is enabled, this value is set to DEDICATED. For more information, see [Bring Your Own Windows Desktop Images](https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html).
        public var requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy?
        /// The status of the image.
        public var state: WorkSpacesClientTypes.WorkspaceImageState?
        /// The updates (if any) that are available for the specified image.
        public var updates: WorkSpacesClientTypes.UpdateResult?

        public init (
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            imageId: Swift.String? = nil,
            name: Swift.String? = nil,
            operatingSystem: WorkSpacesClientTypes.OperatingSystem? = nil,
            ownerAccountId: Swift.String? = nil,
            requiredTenancy: WorkSpacesClientTypes.WorkspaceImageRequiredTenancy? = nil,
            state: WorkSpacesClientTypes.WorkspaceImageState? = nil,
            updates: WorkSpacesClientTypes.UpdateResult? = nil
        )
        {
            self.created = created
            self.description = description
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.imageId = imageId
            self.name = name
            self.operatingSystem = operatingSystem
            self.ownerAccountId = ownerAccountId
            self.requiredTenancy = requiredTenancy
            self.state = state
            self.updates = updates
        }
    }

}

extension WorkSpacesClientTypes {
    public enum WorkspaceImageIngestionProcess: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case byolGraphics
        case byolGraphicspro
        case byolGraphicsG4dn
        case byolGraphicsG4dnByop
        case byolRegular
        case byolRegularByop
        case byolRegularWsp
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageIngestionProcess] {
            return [
                .byolGraphics,
                .byolGraphicspro,
                .byolGraphicsG4dn,
                .byolGraphicsG4dnByop,
                .byolRegular,
                .byolRegularByop,
                .byolRegularWsp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .byolGraphics: return "BYOL_GRAPHICS"
            case .byolGraphicspro: return "BYOL_GRAPHICSPRO"
            case .byolGraphicsG4dn: return "BYOL_GRAPHICS_G4DN"
            case .byolGraphicsG4dnByop: return "BYOL_GRAPHICS_G4DN_BYOP"
            case .byolRegular: return "BYOL_REGULAR"
            case .byolRegularByop: return "BYOL_REGULAR_BYOP"
            case .byolRegularWsp: return "BYOL_REGULAR_WSP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceImageIngestionProcess(rawValue: rawValue) ?? WorkspaceImageIngestionProcess.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum WorkspaceImageRequiredTenancy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dedicated
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageRequiredTenancy] {
            return [
                .dedicated,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "DEDICATED"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceImageRequiredTenancy(rawValue: rawValue) ?? WorkspaceImageRequiredTenancy.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes {
    public enum WorkspaceImageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case error
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceImageState] {
            return [
                .available,
                .error,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceImageState(rawValue: rawValue) ?? WorkspaceImageState.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesClientTypes.WorkspaceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeTypeName = "ComputeTypeName"
        case protocols = "Protocols"
        case rootVolumeSizeGib = "RootVolumeSizeGib"
        case runningMode = "RunningMode"
        case runningModeAutoStopTimeoutInMinutes = "RunningModeAutoStopTimeoutInMinutes"
        case userVolumeSizeGib = "UserVolumeSizeGib"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeTypeName = self.computeTypeName {
            try encodeContainer.encode(computeTypeName.rawValue, forKey: .computeTypeName)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocol0 in protocols {
                try protocolsContainer.encode(protocol0.rawValue)
            }
        }
        if let rootVolumeSizeGib = self.rootVolumeSizeGib {
            try encodeContainer.encode(rootVolumeSizeGib, forKey: .rootVolumeSizeGib)
        }
        if let runningMode = self.runningMode {
            try encodeContainer.encode(runningMode.rawValue, forKey: .runningMode)
        }
        if let runningModeAutoStopTimeoutInMinutes = self.runningModeAutoStopTimeoutInMinutes {
            try encodeContainer.encode(runningModeAutoStopTimeoutInMinutes, forKey: .runningModeAutoStopTimeoutInMinutes)
        }
        if let userVolumeSizeGib = self.userVolumeSizeGib {
            try encodeContainer.encode(userVolumeSizeGib, forKey: .userVolumeSizeGib)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runningModeDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.RunningMode.self, forKey: .runningMode)
        runningMode = runningModeDecoded
        let runningModeAutoStopTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .runningModeAutoStopTimeoutInMinutes)
        runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutesDecoded
        let rootVolumeSizeGibDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rootVolumeSizeGib)
        rootVolumeSizeGib = rootVolumeSizeGibDecoded
        let userVolumeSizeGibDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userVolumeSizeGib)
        userVolumeSizeGib = userVolumeSizeGibDecoded
        let computeTypeNameDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.Compute.self, forKey: .computeTypeName)
        computeTypeName = computeTypeNameDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.ModelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[WorkSpacesClientTypes.ModelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [WorkSpacesClientTypes.ModelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes a WorkSpace.
    public struct WorkspaceProperties: Swift.Equatable {
        /// The compute type. For more information, see [Amazon WorkSpaces Bundles](http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles).
        public var computeTypeName: WorkSpacesClientTypes.Compute?
        /// The protocol. For more information, see [ Protocols for Amazon WorkSpaces](https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-protocols.html).
        ///
        /// * Only available for WorkSpaces created with PCoIP bundles.
        ///
        /// * The Protocols property is case sensitive. Ensure you use PCOIP or WSP.
        ///
        /// * Unavailable for Windows 7 WorkSpaces and WorkSpaces using GPU-based bundles (Graphics, GraphicsPro, Graphics.g4dn, and GraphicsPro.g4dn).
        public var protocols: [WorkSpacesClientTypes.ModelProtocol]?
        /// The size of the root volume. For important information about how to modify the size of the root and user volumes, see [Modify a WorkSpace](https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html).
        public var rootVolumeSizeGib: Swift.Int?
        /// The running mode. For more information, see [Manage the WorkSpace Running Mode](https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html). The MANUAL value is only supported by Amazon WorkSpaces Core. Contact your account team to be allow-listed to use this value. For more information, see [Amazon WorkSpaces Core](http://aws.amazon.com/workspaces/core/).
        public var runningMode: WorkSpacesClientTypes.RunningMode?
        /// The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.
        public var runningModeAutoStopTimeoutInMinutes: Swift.Int?
        /// The size of the user storage. For important information about how to modify the size of the root and user volumes, see [Modify a WorkSpace](https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html).
        public var userVolumeSizeGib: Swift.Int?

        public init (
            computeTypeName: WorkSpacesClientTypes.Compute? = nil,
            protocols: [WorkSpacesClientTypes.ModelProtocol]? = nil,
            rootVolumeSizeGib: Swift.Int? = nil,
            runningMode: WorkSpacesClientTypes.RunningMode? = nil,
            runningModeAutoStopTimeoutInMinutes: Swift.Int? = nil,
            userVolumeSizeGib: Swift.Int? = nil
        )
        {
            self.computeTypeName = computeTypeName
            self.protocols = protocols
            self.rootVolumeSizeGib = rootVolumeSizeGib
            self.runningMode = runningMode
            self.runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutes
            self.userVolumeSizeGib = userVolumeSizeGib
        }
    }

}

extension WorkSpacesClientTypes.WorkspaceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleId = "BundleId"
        case directoryId = "DirectoryId"
        case rootVolumeEncryptionEnabled = "RootVolumeEncryptionEnabled"
        case tags = "Tags"
        case userName = "UserName"
        case userVolumeEncryptionEnabled = "UserVolumeEncryptionEnabled"
        case volumeEncryptionKey = "VolumeEncryptionKey"
        case workspaceProperties = "WorkspaceProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let rootVolumeEncryptionEnabled = self.rootVolumeEncryptionEnabled {
            try encodeContainer.encode(rootVolumeEncryptionEnabled, forKey: .rootVolumeEncryptionEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userVolumeEncryptionEnabled = self.userVolumeEncryptionEnabled {
            try encodeContainer.encode(userVolumeEncryptionEnabled, forKey: .userVolumeEncryptionEnabled)
        }
        if let volumeEncryptionKey = self.volumeEncryptionKey {
            try encodeContainer.encode(volumeEncryptionKey, forKey: .volumeEncryptionKey)
        }
        if let workspaceProperties = self.workspaceProperties {
            try encodeContainer.encode(workspaceProperties, forKey: .workspaceProperties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let volumeEncryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeEncryptionKey)
        volumeEncryptionKey = volumeEncryptionKeyDecoded
        let userVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userVolumeEncryptionEnabled)
        userVolumeEncryptionEnabled = userVolumeEncryptionEnabledDecoded
        let rootVolumeEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rootVolumeEncryptionEnabled)
        rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabledDecoded
        let workspacePropertiesDecoded = try containerValues.decodeIfPresent(WorkSpacesClientTypes.WorkspaceProperties.self, forKey: .workspaceProperties)
        workspaceProperties = workspacePropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes the information used to create a WorkSpace.
    public struct WorkspaceRequest: Swift.Equatable {
        /// The identifier of the bundle for the WorkSpace. You can use [DescribeWorkspaceBundles] to list the available bundles.
        /// This member is required.
        public var bundleId: Swift.String?
        /// The identifier of the Directory Service directory for the WorkSpace. You can use [DescribeWorkspaceDirectories] to list the available directories.
        /// This member is required.
        public var directoryId: Swift.String?
        /// Indicates whether the data stored on the root volume is encrypted.
        public var rootVolumeEncryptionEnabled: Swift.Bool?
        /// The tags for the WorkSpace.
        public var tags: [WorkSpacesClientTypes.Tag]?
        /// The user name of the user for the WorkSpace. This user name must exist in the Directory Service directory for the WorkSpace.
        /// This member is required.
        public var userName: Swift.String?
        /// Indicates whether the data stored on the user volume is encrypted.
        public var userVolumeEncryptionEnabled: Swift.Bool?
        /// The symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.
        public var volumeEncryptionKey: Swift.String?
        /// The WorkSpace properties.
        public var workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties?

        public init (
            bundleId: Swift.String? = nil,
            directoryId: Swift.String? = nil,
            rootVolumeEncryptionEnabled: Swift.Bool? = nil,
            tags: [WorkSpacesClientTypes.Tag]? = nil,
            userName: Swift.String? = nil,
            userVolumeEncryptionEnabled: Swift.Bool? = nil,
            volumeEncryptionKey: Swift.String? = nil,
            workspaceProperties: WorkSpacesClientTypes.WorkspaceProperties? = nil
        )
        {
            self.bundleId = bundleId
            self.directoryId = directoryId
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.tags = tags
            self.userName = userName
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.volumeEncryptionKey = volumeEncryptionKey
            self.workspaceProperties = workspaceProperties
        }
    }

}

extension WorkSpacesClientTypes {
    public enum WorkspaceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adminMaintenance
        case available
        case error
        case impaired
        case maintenance
        case pending
        case rebooting
        case rebuilding
        case restoring
        case starting
        case stopped
        case stopping
        case suspended
        case terminated
        case terminating
        case unhealthy
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceState] {
            return [
                .adminMaintenance,
                .available,
                .error,
                .impaired,
                .maintenance,
                .pending,
                .rebooting,
                .rebuilding,
                .restoring,
                .starting,
                .stopped,
                .stopping,
                .suspended,
                .terminated,
                .terminating,
                .unhealthy,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adminMaintenance: return "ADMIN_MAINTENANCE"
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .impaired: return "IMPAIRED"
            case .maintenance: return "MAINTENANCE"
            case .pending: return "PENDING"
            case .rebooting: return "REBOOTING"
            case .rebuilding: return "REBUILDING"
            case .restoring: return "RESTORING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .suspended: return "SUSPENDED"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case .unhealthy: return "UNHEALTHY"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceState(rawValue: rawValue) ?? WorkspaceState.sdkUnknown(rawValue)
        }
    }
}

extension WorkspacesDefaultRoleNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: WorkspacesDefaultRoleNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The workspaces_DefaultRole role could not be found. If this is the first time you are registering a directory, you will need to create the workspaces_DefaultRole role before you can register a directory. For more information, see [Creating the workspaces_DefaultRole Role](https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-access-control.html#create-default-role).
public struct WorkspacesDefaultRoleNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct WorkspacesDefaultRoleNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension WorkspacesDefaultRoleNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesClientTypes.WorkspacesIpGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupDesc
        case groupId
        case groupName
        case userRules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupDesc = self.groupDesc {
            try encodeContainer.encode(groupDesc, forKey: .groupDesc)
        }
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let userRules = userRules {
            var userRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userRules)
            for ipruleitem0 in userRules {
                try userRulesContainer.encode(ipruleitem0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupDescDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupDesc)
        groupDesc = groupDescDecoded
        let userRulesContainer = try containerValues.decodeIfPresent([WorkSpacesClientTypes.IpRuleItem?].self, forKey: .userRules)
        var userRulesDecoded0:[WorkSpacesClientTypes.IpRuleItem]? = nil
        if let userRulesContainer = userRulesContainer {
            userRulesDecoded0 = [WorkSpacesClientTypes.IpRuleItem]()
            for structure0 in userRulesContainer {
                if let structure0 = structure0 {
                    userRulesDecoded0?.append(structure0)
                }
            }
        }
        userRules = userRulesDecoded0
    }
}

extension WorkSpacesClientTypes {
    /// Describes an IP access control group.
    public struct WorkspacesIpGroup: Swift.Equatable {
        /// The description of the group.
        public var groupDesc: Swift.String?
        /// The identifier of the group.
        public var groupId: Swift.String?
        /// The name of the group.
        public var groupName: Swift.String?
        /// The rules.
        public var userRules: [WorkSpacesClientTypes.IpRuleItem]?

        public init (
            groupDesc: Swift.String? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            userRules: [WorkSpacesClientTypes.IpRuleItem]? = nil
        )
        {
            self.groupDesc = groupDesc
            self.groupId = groupId
            self.groupName = groupName
            self.userRules = userRules
        }
    }

}
