// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessForbidden: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessForbidden(message: \(String(describing: message)))"}
}

extension AccessForbidden: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessForbiddenBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have permission to perform an action.</p>
public struct AccessForbidden: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessForbiddenBody: Equatable {
    public let message: String?
}

extension AccessForbiddenBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteRecordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRecordInput(eventTime: \(String(describing: eventTime)), featureGroupName: \(String(describing: featureGroupName)), recordIdentifierValueAsString: \(String(describing: recordIdentifierValueAsString)))"}
}

extension DeleteRecordInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRecordInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRecordInput>
    public typealias MOutput = OperationOutput<DeleteRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRecordOutputError>
}

public struct DeleteRecordInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let recordIdentifierValueAsString = input.operationInput.recordIdentifierValueAsString {
            let recordIdentifierValueAsStringQueryItem = URLQueryItem(name: "RecordIdentifierValueAsString".urlPercentEncoding(), value: String(recordIdentifierValueAsString).urlPercentEncoding())
            input.builder.withQueryItem(recordIdentifierValueAsStringQueryItem)
        }
        if let eventTime = input.operationInput.eventTime {
            let eventTimeQueryItem = URLQueryItem(name: "EventTime".urlPercentEncoding(), value: String(eventTime).urlPercentEncoding())
            input.builder.withQueryItem(eventTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRecordInput>
    public typealias MOutput = OperationOutput<DeleteRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRecordOutputError>
}

public struct DeleteRecordInput: Equatable {
    /// <p>Timestamp indicating when the deletion event occurred. <code>EventTime</code> can be
    ///          used to query data at a certain point in time.</p>
    public let eventTime: String?
    /// <p>The name of the feature group to delete the record from. </p>
    public let featureGroupName: String?
    /// <p>The value for the <code>RecordIdentifier</code> that uniquely identifies the record, in
    ///          string format. </p>
    public let recordIdentifierValueAsString: String?

    public init (
        eventTime: String? = nil,
        featureGroupName: String? = nil,
        recordIdentifierValueAsString: String? = nil
    )
    {
        self.eventTime = eventTime
        self.featureGroupName = featureGroupName
        self.recordIdentifierValueAsString = recordIdentifierValueAsString
    }
}

struct DeleteRecordInputBody: Equatable {
}

extension DeleteRecordInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRecordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecordOutputError: Swift.Error, Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRecordOutputResponse()"}
}

extension DeleteRecordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecordOutputResponse: Equatable {

    public init() {}
}

struct DeleteRecordOutputResponseBody: Equatable {
}

extension DeleteRecordOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension FeatureValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case featureName = "FeatureName"
        case valueAsString = "ValueAsString"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureName = featureName {
            try encodeContainer.encode(featureName, forKey: .featureName)
        }
        if let valueAsString = valueAsString {
            try encodeContainer.encode(valueAsString, forKey: .valueAsString)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .featureName)
        featureName = featureNameDecoded
        let valueAsStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .valueAsString)
        valueAsString = valueAsStringDecoded
    }
}

extension FeatureValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FeatureValue(featureName: \(String(describing: featureName)), valueAsString: \(String(describing: valueAsString)))"}
}

/// <p>The value associated with a feature.</p>
public struct FeatureValue: Equatable {
    /// <p>The name of a feature that a feature value corresponds to.</p>
    public let featureName: String?
    /// <p>The value associated with a feature, in string format. Note that features types can be
    ///          String, Integral, or Fractional. This value represents all three types as a string.</p>
    public let valueAsString: String?

    public init (
        featureName: String? = nil,
        valueAsString: String? = nil
    )
    {
        self.featureName = featureName
        self.valueAsString = valueAsString
    }
}

extension GetRecordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecordInput(featureGroupName: \(String(describing: featureGroupName)), featureNames: \(String(describing: featureNames)), recordIdentifierValueAsString: \(String(describing: recordIdentifierValueAsString)))"}
}

extension GetRecordInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRecordInputHeadersMiddleware: Middleware {
    public let id: String = "GetRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecordInput>
    public typealias MOutput = OperationOutput<GetRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecordOutputError>
}

public struct GetRecordInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let recordIdentifierValueAsString = input.operationInput.recordIdentifierValueAsString {
            let recordIdentifierValueAsStringQueryItem = URLQueryItem(name: "RecordIdentifierValueAsString".urlPercentEncoding(), value: String(recordIdentifierValueAsString).urlPercentEncoding())
            input.builder.withQueryItem(recordIdentifierValueAsStringQueryItem)
        }
        if let featureNames = input.operationInput.featureNames {
            featureNames.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "FeatureName".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecordInput>
    public typealias MOutput = OperationOutput<GetRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecordOutputError>
}

public struct GetRecordInput: Equatable {
    /// <p>The name of the feature group in which you want to put the records.</p>
    public let featureGroupName: String?
    /// <p>List of names of Features to be retrieved. If not specified, the latest value for all
    ///          the Features are returned.</p>
    public let featureNames: [String]?
    /// <p>The value that corresponds to <code>RecordIdentifier</code> type and uniquely identifies
    ///          the record in the <code>FeatureGroup</code>. </p>
    public let recordIdentifierValueAsString: String?

    public init (
        featureGroupName: String? = nil,
        featureNames: [String]? = nil,
        recordIdentifierValueAsString: String? = nil
    )
    {
        self.featureGroupName = featureGroupName
        self.featureNames = featureNames
        self.recordIdentifierValueAsString = recordIdentifierValueAsString
    }
}

struct GetRecordInputBody: Equatable {
}

extension GetRecordInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRecordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecordOutputError: Swift.Error, Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case resourceNotFound(ResourceNotFound)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecordOutputResponse(record: \(String(describing: record)))"}
}

extension GetRecordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.record = output.record
        } else {
            self.record = nil
        }
    }
}

public struct GetRecordOutputResponse: Equatable {
    /// <p>The record you requested. A list of <code>FeatureValues</code>.</p>
    public let record: [FeatureValue]?

    public init (
        record: [FeatureValue]? = nil
    )
    {
        self.record = record
    }
}

struct GetRecordOutputResponseBody: Equatable {
    public let record: [FeatureValue]?
}

extension GetRecordOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case record = "Record"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([FeatureValue?].self, forKey: .record)
        var recordDecoded0:[FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
    }
}

extension InternalFailure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailure(message: \(String(describing: message)))"}
}

extension InternalFailure: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal failure occurred. Try your request again. If the problem
///       persists, contact AWS customer support.</p>
public struct InternalFailure: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureBody: Equatable {
    public let message: String?
}

extension InternalFailureBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutRecordInputBodyMiddleware: Middleware {
    public let id: String = "PutRecordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRecordInput>
    public typealias MOutput = OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRecordOutputError>
}

extension PutRecordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRecordInput(featureGroupName: \(String(describing: featureGroupName)), record: \(String(describing: record)))"}
}

extension PutRecordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case record = "Record"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let record = record {
            var recordContainer = encodeContainer.nestedUnkeyedContainer(forKey: .record)
            for record0 in record {
                try recordContainer.encode(record0)
            }
        }
    }
}

public struct PutRecordInputHeadersMiddleware: Middleware {
    public let id: String = "PutRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRecordInput>
    public typealias MOutput = OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRecordOutputError>
}

public struct PutRecordInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRecordInput>
    public typealias MOutput = OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRecordOutputError>
}

public struct PutRecordInput: Equatable {
    /// <p>The name of the feature group that you want to insert the record into.</p>
    public let featureGroupName: String?
    /// <p>List of FeatureValues to be inserted. This will be a full over-write. If you only want
    ///          to update few of the feature values, do the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Use <code>GetRecord</code> to retrieve the latest record.</p>
    ///             </li>
    ///             <li>
    ///                <p>Update the record returned from <code>GetRecord</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>Use <code>PutRecord</code> to update feature values.</p>
    ///             </li>
    ///          </ul>
    public let record: [FeatureValue]?

    public init (
        featureGroupName: String? = nil,
        record: [FeatureValue]? = nil
    )
    {
        self.featureGroupName = featureGroupName
        self.record = record
    }
}

struct PutRecordInputBody: Equatable {
    public let record: [FeatureValue]?
}

extension PutRecordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case record = "Record"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([FeatureValue?].self, forKey: .record)
        var recordDecoded0:[FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
    }
}

extension PutRecordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRecordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRecordOutputError: Swift.Error, Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRecordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRecordOutputResponse()"}
}

extension PutRecordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutRecordOutputResponse: Equatable {

    public init() {}
}

struct PutRecordOutputResponseBody: Equatable {
}

extension PutRecordOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFound(message: \(String(describing: message)))"}
}

extension ResourceNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource that is required to perform an action was not found.</p>
public struct ResourceNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailable(message: \(String(describing: message)))"}
}

extension ServiceUnavailable: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is currently unavailable.</p>
public struct ServiceUnavailable: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationError(message: \(String(describing: message)))"}
}

extension ValidationError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was an error validating your request.</p>
public struct ValidationError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationErrorBody: Equatable {
    public let message: String?
}

extension ValidationErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
