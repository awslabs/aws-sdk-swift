// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Operating denied due to a file permission or access check error.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CPU: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cores
        case modelName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cores != 0 {
            try encodeContainer.encode(cores, forKey: .cores)
        }
        if let modelName = modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coresDecoded = try containerValues.decode(Int.self, forKey: .cores)
        cores = coresDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
    }
}

extension CPU: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CPU(cores: \(String(describing: cores)), modelName: \(String(describing: modelName)))"}
}

/// <p>Source server CPU information.</p>
public struct CPU: Equatable {
    /// <p>The number of CPU cores on the source server.</p>
    public let cores: Int
    /// <p>The source server's CPU model name.</p>
    public let modelName: String?

    public init (
        cores: Int = 0,
        modelName: String? = nil
    )
    {
        self.cores = cores
        self.modelName = modelName
    }
}

public struct ChangeServerLifeCycleStateInputBodyMiddleware: Middleware {
    public let id: String = "ChangeServerLifeCycleStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ChangeServerLifeCycleStateInput>,
                  next: H) -> Swift.Result<OperationOutput<ChangeServerLifeCycleStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ChangeServerLifeCycleStateInput>
    public typealias MOutput = OperationOutput<ChangeServerLifeCycleStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ChangeServerLifeCycleStateOutputError>
}

extension ChangeServerLifeCycleStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangeServerLifeCycleStateInput(lifeCycle: \(String(describing: lifeCycle)), sourceServerID: \(String(describing: sourceServerID)))"}
}

extension ChangeServerLifeCycleStateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lifeCycle
        case sourceServerID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifeCycle = lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

public struct ChangeServerLifeCycleStateInputHeadersMiddleware: Middleware {
    public let id: String = "ChangeServerLifeCycleStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ChangeServerLifeCycleStateInput>,
                  next: H) -> Swift.Result<OperationOutput<ChangeServerLifeCycleStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ChangeServerLifeCycleStateInput>
    public typealias MOutput = OperationOutput<ChangeServerLifeCycleStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ChangeServerLifeCycleStateOutputError>
}

public struct ChangeServerLifeCycleStateInputQueryItemMiddleware: Middleware {
    public let id: String = "ChangeServerLifeCycleStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ChangeServerLifeCycleStateInput>,
                  next: H) -> Swift.Result<OperationOutput<ChangeServerLifeCycleStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ChangeServerLifeCycleStateInput>
    public typealias MOutput = OperationOutput<ChangeServerLifeCycleStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ChangeServerLifeCycleStateOutputError>
}

public struct ChangeServerLifeCycleStateInput: Equatable {
    /// <p>The request to change the source server migration lifecycle state.</p>
    public let lifeCycle: ChangeServerLifeCycleStateSourceServerLifecycle?
    /// <p>The request to change the source server migration lifecycle state by source server ID.</p>
    public let sourceServerID: String?

    public init (
        lifeCycle: ChangeServerLifeCycleStateSourceServerLifecycle? = nil,
        sourceServerID: String? = nil
    )
    {
        self.lifeCycle = lifeCycle
        self.sourceServerID = sourceServerID
    }
}

struct ChangeServerLifeCycleStateInputBody: Equatable {
    public let sourceServerID: String?
    public let lifeCycle: ChangeServerLifeCycleStateSourceServerLifecycle?
}

extension ChangeServerLifeCycleStateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lifeCycle
        case sourceServerID
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(ChangeServerLifeCycleStateSourceServerLifecycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
    }
}

extension ChangeServerLifeCycleStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ChangeServerLifeCycleStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ChangeServerLifeCycleStateOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ChangeServerLifeCycleStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangeServerLifeCycleStateOutputResponse(arn: \(String(describing: arn)), dataReplicationInfo: \(String(describing: dataReplicationInfo)), isArchived: \(String(describing: isArchived)), launchedInstance: \(String(describing: launchedInstance)), lifeCycle: \(String(describing: lifeCycle)), sourceProperties: \(String(describing: sourceProperties)), sourceServerID: \(String(describing: sourceServerID)), tags: \(String(describing: tags)))"}
}

extension ChangeServerLifeCycleStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ChangeServerLifeCycleStateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
        }
    }
}

public struct ChangeServerLifeCycleStateOutputResponse: Equatable {
    /// <p>Source server ARN.</p>
    public let arn: String?
    /// <p>Source server data replication info.</p>
    public let dataReplicationInfo: DataReplicationInfo?
    /// <p>Source server archived status.</p>
    public let isArchived: Bool?
    /// <p>Source server launched instance.</p>
    public let launchedInstance: LaunchedInstance?
    /// <p>Source server lifecycle state.</p>
    public let lifeCycle: LifeCycle?
    /// <p>Source server properties.</p>
    public let sourceProperties: SourceProperties?
    /// <p>Source server ID.</p>
    public let sourceServerID: String?
    /// <p>Source server Tags.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        dataReplicationInfo: DataReplicationInfo? = nil,
        isArchived: Bool? = nil,
        launchedInstance: LaunchedInstance? = nil,
        lifeCycle: LifeCycle? = nil,
        sourceProperties: SourceProperties? = nil,
        sourceServerID: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
    }
}

struct ChangeServerLifeCycleStateOutputResponseBody: Equatable {
    public let sourceServerID: String?
    public let arn: String?
    public let isArchived: Bool?
    public let tags: [String:String]?
    public let launchedInstance: LaunchedInstance?
    public let dataReplicationInfo: DataReplicationInfo?
    public let lifeCycle: LifeCycle?
    public let sourceProperties: SourceProperties?
}

extension ChangeServerLifeCycleStateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case sourceProperties
        case sourceServerID
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
    }
}

extension ChangeServerLifeCycleStateSourceServerLifecycle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChangeServerLifeCycleStateSourceServerLifecycleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChangeServerLifeCycleStateSourceServerLifecycle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangeServerLifeCycleStateSourceServerLifecycle(state: \(String(describing: state)))"}
}

/// <p>The request to change the source server migration lifecycle state.</p>
public struct ChangeServerLifeCycleStateSourceServerLifecycle: Equatable {
    /// <p>The request to change the source server migration lifecycle state.</p>
    public let state: ChangeServerLifeCycleStateSourceServerLifecycleState?

    public init (
        state: ChangeServerLifeCycleStateSourceServerLifecycleState? = nil
    )
    {
        self.state = state
    }
}

public enum ChangeServerLifeCycleStateSourceServerLifecycleState {
    case cutover
    case readyForCutover
    case readyForTest
    case sdkUnknown(String)
}

extension ChangeServerLifeCycleStateSourceServerLifecycleState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeServerLifeCycleStateSourceServerLifecycleState] {
        return [
            .cutover,
            .readyForCutover,
            .readyForTest,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cutover: return "CUTOVER"
        case .readyForCutover: return "READY_FOR_CUTOVER"
        case .readyForTest: return "READY_FOR_TEST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeServerLifeCycleStateSourceServerLifecycleState(rawValue: rawValue) ?? ChangeServerLifeCycleStateSourceServerLifecycleState.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(code: \(String(describing: code)), message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.code = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request could not be completed due to a conflict with the current state of the target resource.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?
    /// <p>A conflict occured when prompting for the Resource ID.</p>
    public var resourceId: String?
    /// <p>A conflict occured when prompting for resource type.</p>
    public var resourceType: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let code: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateReplicationConfigurationTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateReplicationConfigurationTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<CreateReplicationConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationConfigurationTemplateOutputError>
}

extension CreateReplicationConfigurationTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReplicationConfigurationTemplateInput(associateDefaultSecurityGroup: \(String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(String(describing: bandwidthThrottling)), createPublicIP: \(String(describing: createPublicIP)), dataPlaneRouting: \(String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(String(describing: ebsEncryptionKeyArn)), replicationServerInstanceType: \(String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(String(describing: stagingAreaSubnetId)), stagingAreaTags: \(String(describing: stagingAreaTags)), tags: \(String(describing: tags)), useDedicatedReplicationServer: \(String(describing: useDedicatedReplicationServer)))"}
}

extension CreateReplicationConfigurationTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associateDefaultSecurityGroup = associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let replicationServerInstanceType = replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for replicationserverssecuritygroupsids0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(replicationserverssecuritygroupsids0)
            }
        }
        if let stagingAreaSubnetId = stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsmap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

public struct CreateReplicationConfigurationTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateReplicationConfigurationTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<CreateReplicationConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationConfigurationTemplateOutputError>
}

public struct CreateReplicationConfigurationTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateReplicationConfigurationTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<CreateReplicationConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationConfigurationTemplateOutputError>
}

public struct CreateReplicationConfigurationTemplateInput: Equatable {
    /// <p>Request to associate the default Application Migration Service Security group with the Replication Settings template.</p>
    public let associateDefaultSecurityGroup: Bool?
    /// <p>Request to configure bandwidth throttling during Replication Settings template creation.</p>
    public let bandwidthThrottling: Int
    /// <p>Request to create Public IP during Replication Settings template creation.</p>
    public let createPublicIP: Bool?
    /// <p>Request to configure  data plane routing during Replication Settings template creation.</p>
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    /// <p>Request to configure the Staging Disk EBS volume type to "gp2" during Replication Settings template creation.</p>
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    /// <p>Request to configure EBS enryption during Replication Settings template creation.</p>
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    /// <p>Request to configure an EBS enryption key during Replication Settings template creation.</p>
    public let ebsEncryptionKeyArn: String?
    /// <p>Request to configure the Replication Server instance type during Replication Settings template creation.</p>
    public let replicationServerInstanceType: String?
    /// <p>Request to configure the Replication Server Secuirity group ID during Replication Settings template creation.</p>
    public let replicationServersSecurityGroupsIDs: [String]?
    /// <p>Request to configure the Staging Area subnet ID during Replication Settings template creation.</p>
    public let stagingAreaSubnetId: String?
    /// <p>Request to configure Staiging Area tags during Replication Settings template creation.</p>
    public let stagingAreaTags: [String:String]?
    /// <p>Request to configure tags during Replication Settings template creation.</p>
    public let tags: [String:String]?
    /// <p>Request to use Dedicated Replication Servers during Replication Settings template creation.</p>
    public let useDedicatedReplicationServer: Bool?

    public init (
        associateDefaultSecurityGroup: Bool? = nil,
        bandwidthThrottling: Int = 0,
        createPublicIP: Bool? = nil,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: String? = nil,
        replicationServerInstanceType: String? = nil,
        replicationServersSecurityGroupsIDs: [String]? = nil,
        stagingAreaSubnetId: String? = nil,
        stagingAreaTags: [String:String]? = nil,
        tags: [String:String]? = nil,
        useDedicatedReplicationServer: Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct CreateReplicationConfigurationTemplateInputBody: Equatable {
    public let stagingAreaSubnetId: String?
    public let associateDefaultSecurityGroup: Bool?
    public let replicationServersSecurityGroupsIDs: [String]?
    public let replicationServerInstanceType: String?
    public let useDedicatedReplicationServer: Bool?
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    public let ebsEncryptionKeyArn: String?
    public let bandwidthThrottling: Int
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    public let createPublicIP: Bool?
    public let stagingAreaTags: [String:String]?
    public let tags: [String:String]?
}

extension CreateReplicationConfigurationTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [String:String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReplicationConfigurationTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationConfigurationTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReplicationConfigurationTemplateOutputError: Equatable {
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationConfigurationTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReplicationConfigurationTemplateOutputResponse(arn: \(String(describing: arn)), associateDefaultSecurityGroup: \(String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(String(describing: bandwidthThrottling)), createPublicIP: \(String(describing: createPublicIP)), dataPlaneRouting: \(String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(String(describing: stagingAreaSubnetId)), stagingAreaTags: \(String(describing: stagingAreaTags)), tags: \(String(describing: tags)), useDedicatedReplicationServer: \(String(describing: useDedicatedReplicationServer)))"}
}

extension CreateReplicationConfigurationTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateReplicationConfigurationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = output.replicationConfigurationTemplateID
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.tags = output.tags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.arn = nil
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.replicationConfigurationTemplateID = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.tags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct CreateReplicationConfigurationTemplateOutputResponse: Equatable {
    /// <p>Replication Configuration template ARN.</p>
    public let arn: String?
    /// <p>Replication Configuration template associate default Application Migration Service Security group.</p>
    public let associateDefaultSecurityGroup: Bool?
    /// <p>Replication Configuration template bandwidth throtting.</p>
    public let bandwidthThrottling: Int
    /// <p>Replication Configuration template create Public IP.</p>
    public let createPublicIP: Bool?
    /// <p>Replication Configuration template data plane routing.</p>
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    /// <p>Replication Configuration template use dedault large Staging Disk type.</p>
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    /// <p>Replication Configuration template EBS encryption.</p>
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    /// <p>Replication Configuration template EBS encryption key ARN.</p>
    public let ebsEncryptionKeyArn: String?
    /// <p>Replication Configuration template template ID.</p>
    public let replicationConfigurationTemplateID: String?
    /// <p>Replication Configuration template server instance type.</p>
    public let replicationServerInstanceType: String?
    /// <p>Replication Configuration template server Security Groups IDs.</p>
    public let replicationServersSecurityGroupsIDs: [String]?
    /// <p>Replication Configuration template Staging Area subnet ID.</p>
    public let stagingAreaSubnetId: String?
    /// <p>Replication Configuration template Staging Area Tags.</p>
    public let stagingAreaTags: [String:String]?
    /// <p>Replication Configuration template Tags.</p>
    public let tags: [String:String]?
    /// <p>Replication Configuration template use Dedicated Replication Server.</p>
    public let useDedicatedReplicationServer: Bool?

    public init (
        arn: String? = nil,
        associateDefaultSecurityGroup: Bool? = nil,
        bandwidthThrottling: Int = 0,
        createPublicIP: Bool? = nil,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: String? = nil,
        replicationConfigurationTemplateID: String? = nil,
        replicationServerInstanceType: String? = nil,
        replicationServersSecurityGroupsIDs: [String]? = nil,
        stagingAreaSubnetId: String? = nil,
        stagingAreaTags: [String:String]? = nil,
        tags: [String:String]? = nil,
        useDedicatedReplicationServer: Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct CreateReplicationConfigurationTemplateOutputResponseBody: Equatable {
    public let replicationConfigurationTemplateID: String?
    public let arn: String?
    public let stagingAreaSubnetId: String?
    public let associateDefaultSecurityGroup: Bool?
    public let replicationServersSecurityGroupsIDs: [String]?
    public let replicationServerInstanceType: String?
    public let useDedicatedReplicationServer: Bool?
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    public let ebsEncryptionKeyArn: String?
    public let bandwidthThrottling: Int
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    public let createPublicIP: Bool?
    public let stagingAreaTags: [String:String]?
    public let tags: [String:String]?
}

extension CreateReplicationConfigurationTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [String:String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DataReplicationError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case error
        case rawError
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error.rawValue, forKey: .error)
        }
        if let rawError = rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(DataReplicationErrorString.self, forKey: .error)
        error = errorDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension DataReplicationError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataReplicationError(error: \(String(describing: error)), rawError: \(String(describing: rawError)))"}
}

/// <p>Error in data replication.</p>
public struct DataReplicationError: Equatable {
    /// <p>Error in data replication.</p>
    public let error: DataReplicationErrorString?
    /// <p>Error in data replication.</p>
    public let rawError: String?

    public init (
        error: DataReplicationErrorString? = nil,
        rawError: String? = nil
    )
    {
        self.error = error
        self.rawError = rawError
    }
}

public enum DataReplicationErrorString {
    case agentNotSeen
    case failedToAttachStagingDisks
    case failedToAuthenticateWithService
    case failedToBootReplicationServer
    case failedToConnectAgentToReplicationServer
    case failedToCreateSecurityGroup
    case failedToCreateStagingDisks
    case failedToDownloadReplicationSoftware
    case failedToLaunchReplicationServer
    case failedToPairReplicationServerWithAgent
    case failedToStartDataTransfer
    case notConverging
    case snapshotsFailure
    case unstableNetwork
    case sdkUnknown(String)
}

extension DataReplicationErrorString : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataReplicationErrorString] {
        return [
            .agentNotSeen,
            .failedToAttachStagingDisks,
            .failedToAuthenticateWithService,
            .failedToBootReplicationServer,
            .failedToConnectAgentToReplicationServer,
            .failedToCreateSecurityGroup,
            .failedToCreateStagingDisks,
            .failedToDownloadReplicationSoftware,
            .failedToLaunchReplicationServer,
            .failedToPairReplicationServerWithAgent,
            .failedToStartDataTransfer,
            .notConverging,
            .snapshotsFailure,
            .unstableNetwork,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .agentNotSeen: return "AGENT_NOT_SEEN"
        case .failedToAttachStagingDisks: return "FAILED_TO_ATTACH_STAGING_DISKS"
        case .failedToAuthenticateWithService: return "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
        case .failedToBootReplicationServer: return "FAILED_TO_BOOT_REPLICATION_SERVER"
        case .failedToConnectAgentToReplicationServer: return "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
        case .failedToCreateSecurityGroup: return "FAILED_TO_CREATE_SECURITY_GROUP"
        case .failedToCreateStagingDisks: return "FAILED_TO_CREATE_STAGING_DISKS"
        case .failedToDownloadReplicationSoftware: return "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
        case .failedToLaunchReplicationServer: return "FAILED_TO_LAUNCH_REPLICATION_SERVER"
        case .failedToPairReplicationServerWithAgent: return "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
        case .failedToStartDataTransfer: return "FAILED_TO_START_DATA_TRANSFER"
        case .notConverging: return "NOT_CONVERGING"
        case .snapshotsFailure: return "SNAPSHOTS_FAILURE"
        case .unstableNetwork: return "UNSTABLE_NETWORK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataReplicationErrorString(rawValue: rawValue) ?? DataReplicationErrorString.sdkUnknown(rawValue)
    }
}

extension DataReplicationInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataReplicationError
        case dataReplicationInitiation
        case dataReplicationState
        case etaDateTime
        case lagDuration
        case replicatedDisks
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplicationError = dataReplicationError {
            try encodeContainer.encode(dataReplicationError, forKey: .dataReplicationError)
        }
        if let dataReplicationInitiation = dataReplicationInitiation {
            try encodeContainer.encode(dataReplicationInitiation, forKey: .dataReplicationInitiation)
        }
        if let dataReplicationState = dataReplicationState {
            try encodeContainer.encode(dataReplicationState.rawValue, forKey: .dataReplicationState)
        }
        if let etaDateTime = etaDateTime {
            try encodeContainer.encode(etaDateTime, forKey: .etaDateTime)
        }
        if let lagDuration = lagDuration {
            try encodeContainer.encode(lagDuration, forKey: .lagDuration)
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for datareplicationinforeplicateddisks0 in replicatedDisks {
                try replicatedDisksContainer.encode(datareplicationinforeplicateddisks0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagDurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lagDuration)
        lagDuration = lagDurationDecoded
        let etaDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .etaDateTime)
        etaDateTime = etaDateTimeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([DataReplicationInfoReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[DataReplicationInfoReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [DataReplicationInfoReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let dataReplicationStateDecoded = try containerValues.decodeIfPresent(DataReplicationState.self, forKey: .dataReplicationState)
        dataReplicationState = dataReplicationStateDecoded
        let dataReplicationInitiationDecoded = try containerValues.decodeIfPresent(DataReplicationInitiation.self, forKey: .dataReplicationInitiation)
        dataReplicationInitiation = dataReplicationInitiationDecoded
        let dataReplicationErrorDecoded = try containerValues.decodeIfPresent(DataReplicationError.self, forKey: .dataReplicationError)
        dataReplicationError = dataReplicationErrorDecoded
    }
}

extension DataReplicationInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataReplicationInfo(dataReplicationError: \(String(describing: dataReplicationError)), dataReplicationInitiation: \(String(describing: dataReplicationInitiation)), dataReplicationState: \(String(describing: dataReplicationState)), etaDateTime: \(String(describing: etaDateTime)), lagDuration: \(String(describing: lagDuration)), replicatedDisks: \(String(describing: replicatedDisks)))"}
}

/// <p>Request data replication info.</p>
public struct DataReplicationInfo: Equatable {
    /// <p>Error in obtaining data replication info.</p>
    public let dataReplicationError: DataReplicationError?
    /// <p>Request to query whether data replication has been initiated.</p>
    public let dataReplicationInitiation: DataReplicationInitiation?
    /// <p>Request to query the data replication state.</p>
    public let dataReplicationState: DataReplicationState?
    /// <p>Request to query the time when data replication will be complete.</p>
    public let etaDateTime: String?
    /// <p>Request to query data replication lag durating.</p>
    public let lagDuration: String?
    /// <p>Request to query disks replicated.</p>
    public let replicatedDisks: [DataReplicationInfoReplicatedDisk]?

    public init (
        dataReplicationError: DataReplicationError? = nil,
        dataReplicationInitiation: DataReplicationInitiation? = nil,
        dataReplicationState: DataReplicationState? = nil,
        etaDateTime: String? = nil,
        lagDuration: String? = nil,
        replicatedDisks: [DataReplicationInfoReplicatedDisk]? = nil
    )
    {
        self.dataReplicationError = dataReplicationError
        self.dataReplicationInitiation = dataReplicationInitiation
        self.dataReplicationState = dataReplicationState
        self.etaDateTime = etaDateTime
        self.lagDuration = lagDuration
        self.replicatedDisks = replicatedDisks
    }
}

extension DataReplicationInfoReplicatedDisk: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backloggedStorageBytes
        case deviceName
        case replicatedStorageBytes
        case rescannedStorageBytes
        case totalStorageBytes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if backloggedStorageBytes != 0 {
            try encodeContainer.encode(backloggedStorageBytes, forKey: .backloggedStorageBytes)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if replicatedStorageBytes != 0 {
            try encodeContainer.encode(replicatedStorageBytes, forKey: .replicatedStorageBytes)
        }
        if rescannedStorageBytes != 0 {
            try encodeContainer.encode(rescannedStorageBytes, forKey: .rescannedStorageBytes)
        }
        if totalStorageBytes != 0 {
            try encodeContainer.encode(totalStorageBytes, forKey: .totalStorageBytes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let totalStorageBytesDecoded = try containerValues.decode(Int.self, forKey: .totalStorageBytes)
        totalStorageBytes = totalStorageBytesDecoded
        let replicatedStorageBytesDecoded = try containerValues.decode(Int.self, forKey: .replicatedStorageBytes)
        replicatedStorageBytes = replicatedStorageBytesDecoded
        let rescannedStorageBytesDecoded = try containerValues.decode(Int.self, forKey: .rescannedStorageBytes)
        rescannedStorageBytes = rescannedStorageBytesDecoded
        let backloggedStorageBytesDecoded = try containerValues.decode(Int.self, forKey: .backloggedStorageBytes)
        backloggedStorageBytes = backloggedStorageBytesDecoded
    }
}

extension DataReplicationInfoReplicatedDisk: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataReplicationInfoReplicatedDisk(backloggedStorageBytes: \(String(describing: backloggedStorageBytes)), deviceName: \(String(describing: deviceName)), replicatedStorageBytes: \(String(describing: replicatedStorageBytes)), rescannedStorageBytes: \(String(describing: rescannedStorageBytes)), totalStorageBytes: \(String(describing: totalStorageBytes)))"}
}

/// <p>Request to query disks replicated.</p>
public struct DataReplicationInfoReplicatedDisk: Equatable {
    /// <p>Request to query data replication backlog size in bytes.</p>
    public let backloggedStorageBytes: Int
    /// <p>Request to query device name.</p>
    public let deviceName: String?
    /// <p>Request to query amount of data replicated in bytes.</p>
    public let replicatedStorageBytes: Int
    /// <p>Request to query amount of data rescanned in bytes.</p>
    public let rescannedStorageBytes: Int
    /// <p>Request to query total amount of data replicated in bytes.</p>
    public let totalStorageBytes: Int

    public init (
        backloggedStorageBytes: Int = 0,
        deviceName: String? = nil,
        replicatedStorageBytes: Int = 0,
        rescannedStorageBytes: Int = 0,
        totalStorageBytes: Int = 0
    )
    {
        self.backloggedStorageBytes = backloggedStorageBytes
        self.deviceName = deviceName
        self.replicatedStorageBytes = replicatedStorageBytes
        self.rescannedStorageBytes = rescannedStorageBytes
        self.totalStorageBytes = totalStorageBytes
    }
}

extension DataReplicationInitiation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextAttemptDateTime
        case startDateTime
        case steps
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextAttemptDateTime = nextAttemptDateTime {
            try encodeContainer.encode(nextAttemptDateTime, forKey: .nextAttemptDateTime)
        }
        if let startDateTime = startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for datareplicationinitiationsteps0 in steps {
                try stepsContainer.encode(datareplicationinitiationsteps0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let nextAttemptDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextAttemptDateTime)
        nextAttemptDateTime = nextAttemptDateTimeDecoded
        let stepsContainer = try containerValues.decodeIfPresent([DataReplicationInitiationStep?].self, forKey: .steps)
        var stepsDecoded0:[DataReplicationInitiationStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [DataReplicationInitiationStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension DataReplicationInitiation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataReplicationInitiation(nextAttemptDateTime: \(String(describing: nextAttemptDateTime)), startDateTime: \(String(describing: startDateTime)), steps: \(String(describing: steps)))"}
}

/// <p>Data replication initiation.</p>
public struct DataReplicationInitiation: Equatable {
    /// <p>Request to query next data initiation date and time.</p>
    public let nextAttemptDateTime: String?
    /// <p>Request to query data initiation start date and time.</p>
    public let startDateTime: String?
    /// <p>Request to query data initiation steps.</p>
    public let steps: [DataReplicationInitiationStep]?

    public init (
        nextAttemptDateTime: String? = nil,
        startDateTime: String? = nil,
        steps: [DataReplicationInitiationStep]? = nil
    )
    {
        self.nextAttemptDateTime = nextAttemptDateTime
        self.startDateTime = startDateTime
        self.steps = steps
    }
}

extension DataReplicationInitiationStep: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(DataReplicationInitiationStepName.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DataReplicationInitiationStepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DataReplicationInitiationStep: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataReplicationInitiationStep(name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Data replication intiation step.</p>
public struct DataReplicationInitiationStep: Equatable {
    /// <p>Request to query data initiation step name.</p>
    public let name: DataReplicationInitiationStepName?
    /// <p>Request to query data initiation status.</p>
    public let status: DataReplicationInitiationStepStatus?

    public init (
        name: DataReplicationInitiationStepName? = nil,
        status: DataReplicationInitiationStepStatus? = nil
    )
    {
        self.name = name
        self.status = status
    }
}

public enum DataReplicationInitiationStepName {
    case attachStagingDisks
    case authenticateWithService
    case bootReplicationServer
    case connectAgentToReplicationServer
    case createSecurityGroup
    case createStagingDisks
    case downloadReplicationSoftware
    case launchReplicationServer
    case pairReplicationServerWithAgent
    case startDataTransfer
    case wait
    case sdkUnknown(String)
}

extension DataReplicationInitiationStepName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataReplicationInitiationStepName] {
        return [
            .attachStagingDisks,
            .authenticateWithService,
            .bootReplicationServer,
            .connectAgentToReplicationServer,
            .createSecurityGroup,
            .createStagingDisks,
            .downloadReplicationSoftware,
            .launchReplicationServer,
            .pairReplicationServerWithAgent,
            .startDataTransfer,
            .wait,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .attachStagingDisks: return "ATTACH_STAGING_DISKS"
        case .authenticateWithService: return "AUTHENTICATE_WITH_SERVICE"
        case .bootReplicationServer: return "BOOT_REPLICATION_SERVER"
        case .connectAgentToReplicationServer: return "CONNECT_AGENT_TO_REPLICATION_SERVER"
        case .createSecurityGroup: return "CREATE_SECURITY_GROUP"
        case .createStagingDisks: return "CREATE_STAGING_DISKS"
        case .downloadReplicationSoftware: return "DOWNLOAD_REPLICATION_SOFTWARE"
        case .launchReplicationServer: return "LAUNCH_REPLICATION_SERVER"
        case .pairReplicationServerWithAgent: return "PAIR_REPLICATION_SERVER_WITH_AGENT"
        case .startDataTransfer: return "START_DATA_TRANSFER"
        case .wait: return "WAIT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataReplicationInitiationStepName(rawValue: rawValue) ?? DataReplicationInitiationStepName.sdkUnknown(rawValue)
    }
}

public enum DataReplicationInitiationStepStatus {
    case failed
    case inProgress
    case notStarted
    case skipped
    case succeeded
    case sdkUnknown(String)
}

extension DataReplicationInitiationStepStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataReplicationInitiationStepStatus] {
        return [
            .failed,
            .inProgress,
            .notStarted,
            .skipped,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .notStarted: return "NOT_STARTED"
        case .skipped: return "SKIPPED"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataReplicationInitiationStepStatus(rawValue: rawValue) ?? DataReplicationInitiationStepStatus.sdkUnknown(rawValue)
    }
}

public enum DataReplicationState {
    case backlog
    case continuous
    case creatingSnapshot
    case disconnected
    case initialSync
    case initiating
    case paused
    case rescan
    case stalled
    case stopped
    case sdkUnknown(String)
}

extension DataReplicationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataReplicationState] {
        return [
            .backlog,
            .continuous,
            .creatingSnapshot,
            .disconnected,
            .initialSync,
            .initiating,
            .paused,
            .rescan,
            .stalled,
            .stopped,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .backlog: return "BACKLOG"
        case .continuous: return "CONTINUOUS"
        case .creatingSnapshot: return "CREATING_SNAPSHOT"
        case .disconnected: return "DISCONNECTED"
        case .initialSync: return "INITIAL_SYNC"
        case .initiating: return "INITIATING"
        case .paused: return "PAUSED"
        case .rescan: return "RESCAN"
        case .stalled: return "STALLED"
        case .stopped: return "STOPPED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataReplicationState(rawValue: rawValue) ?? DataReplicationState.sdkUnknown(rawValue)
    }
}

public struct DeleteJobInputBodyMiddleware: Middleware {
    public let id: String = "DeleteJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobInput>
    public typealias MOutput = OperationOutput<DeleteJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobOutputError>
}

extension DeleteJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobInput(jobID: \(String(describing: jobID)))"}
}

extension DeleteJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }
}

public struct DeleteJobInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobInput>
    public typealias MOutput = OperationOutput<DeleteJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobOutputError>
}

public struct DeleteJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobInput>
    public typealias MOutput = OperationOutput<DeleteJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobOutputError>
}

public struct DeleteJobInput: Equatable {
    /// <p>Request to delete Job from service by Job ID.</p>
    public let jobID: String?

    public init (
        jobID: String? = nil
    )
    {
        self.jobID = jobID
    }
}

struct DeleteJobInputBody: Equatable {
    public let jobID: String?
}

extension DeleteJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobID
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension DeleteJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteJobOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobOutputResponse()"}
}

extension DeleteJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteJobOutputResponse: Equatable {

    public init() {}
}

struct DeleteJobOutputResponseBody: Equatable {
}

extension DeleteJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteReplicationConfigurationTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteReplicationConfigurationTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<DeleteReplicationConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationConfigurationTemplateOutputError>
}

extension DeleteReplicationConfigurationTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationConfigurationTemplateInput(replicationConfigurationTemplateID: \(String(describing: replicationConfigurationTemplateID)))"}
}

extension DeleteReplicationConfigurationTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationConfigurationTemplateID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationConfigurationTemplateID = replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
    }
}

public struct DeleteReplicationConfigurationTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReplicationConfigurationTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<DeleteReplicationConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationConfigurationTemplateOutputError>
}

public struct DeleteReplicationConfigurationTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReplicationConfigurationTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<DeleteReplicationConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationConfigurationTemplateOutputError>
}

public struct DeleteReplicationConfigurationTemplateInput: Equatable {
    /// <p>Request to delete Replication Configuration Template from service by Replication Configuration Template ID.</p>
    public let replicationConfigurationTemplateID: String?

    public init (
        replicationConfigurationTemplateID: String? = nil
    )
    {
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
    }
}

struct DeleteReplicationConfigurationTemplateInputBody: Equatable {
    public let replicationConfigurationTemplateID: String?
}

extension DeleteReplicationConfigurationTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationConfigurationTemplateID
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
    }
}

extension DeleteReplicationConfigurationTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationConfigurationTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationConfigurationTemplateOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationConfigurationTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationConfigurationTemplateOutputResponse()"}
}

extension DeleteReplicationConfigurationTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReplicationConfigurationTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteReplicationConfigurationTemplateOutputResponseBody: Equatable {
}

extension DeleteReplicationConfigurationTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSourceServerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSourceServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSourceServerInput>
    public typealias MOutput = OperationOutput<DeleteSourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSourceServerOutputError>
}

extension DeleteSourceServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSourceServerInput(sourceServerID: \(String(describing: sourceServerID)))"}
}

extension DeleteSourceServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

public struct DeleteSourceServerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSourceServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSourceServerInput>
    public typealias MOutput = OperationOutput<DeleteSourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSourceServerOutputError>
}

public struct DeleteSourceServerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSourceServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSourceServerInput>
    public typealias MOutput = OperationOutput<DeleteSourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSourceServerOutputError>
}

public struct DeleteSourceServerInput: Equatable {
    /// <p>Request to delete Source Server from service by Server ID.</p>
    public let sourceServerID: String?

    public init (
        sourceServerID: String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct DeleteSourceServerInputBody: Equatable {
    public let sourceServerID: String?
}

extension DeleteSourceServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension DeleteSourceServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSourceServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSourceServerOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSourceServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSourceServerOutputResponse()"}
}

extension DeleteSourceServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSourceServerOutputResponse: Equatable {

    public init() {}
}

struct DeleteSourceServerOutputResponseBody: Equatable {
}

extension DeleteSourceServerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeJobLogItemsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeJobLogItemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobLogItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobLogItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobLogItemsInput>
    public typealias MOutput = OperationOutput<DescribeJobLogItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobLogItemsOutputError>
}

extension DescribeJobLogItemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobLogItemsInput(jobID: \(String(describing: jobID)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeJobLogItemsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobID
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeJobLogItemsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJobLogItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobLogItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobLogItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobLogItemsInput>
    public typealias MOutput = OperationOutput<DescribeJobLogItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobLogItemsOutputError>
}

public struct DescribeJobLogItemsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJobLogItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobLogItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobLogItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobLogItemsInput>
    public typealias MOutput = OperationOutput<DescribeJobLogItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobLogItemsOutputError>
}

public struct DescribeJobLogItemsInput: Equatable {
    /// <p>Request to describe Job log job ID.</p>
    public let jobID: String?
    /// <p>Request to describe Job log item maximum results.</p>
    public let maxResults: Int
    /// <p>Request to describe Job log next token.</p>
    public let nextToken: String?

    public init (
        jobID: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.jobID = jobID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeJobLogItemsInputBody: Equatable {
    public let jobID: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeJobLogItemsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobID
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobLogItemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobLogItemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobLogItemsOutputError: Equatable {
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobLogItemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobLogItemsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeJobLogItemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeJobLogItemsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeJobLogItemsOutputResponse: Equatable {
    /// <p>Request to describe Job log response items.</p>
    public let items: [JobLog]?
    /// <p>Request to describe Job log response next token.</p>
    public let nextToken: String?

    public init (
        items: [JobLog]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeJobLogItemsOutputResponseBody: Equatable {
    public let items: [JobLog]?
    public let nextToken: String?
}

extension DescribeJobLogItemsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([JobLog?].self, forKey: .items)
        var itemsDecoded0:[JobLog]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [JobLog]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeJobsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobsInput>
    public typealias MOutput = OperationOutput<DescribeJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobsOutputError>
}

extension DescribeJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeJobsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobsInput>
    public typealias MOutput = OperationOutput<DescribeJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobsOutputError>
}

public struct DescribeJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobsInput>
    public typealias MOutput = OperationOutput<DescribeJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobsOutputError>
}

public struct DescribeJobsInput: Equatable {
    /// <p>Request to describe Job log filters.</p>
    public let filters: DescribeJobsRequestFilters?
    /// <p>Request to describe Job log by max results.</p>
    public let maxResults: Int
    /// <p>Request to describe Job logby next token.</p>
    public let nextToken: String?

    public init (
        filters: DescribeJobsRequestFilters? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeJobsInputBody: Equatable {
    public let filters: DescribeJobsRequestFilters?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(DescribeJobsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobsOutputError: Equatable {
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeJobsOutputResponse: Equatable {
    /// <p>Request to describe Job log items.</p>
    public let items: [Job]?
    /// <p>Request to describe Job response by next token.</p>
    public let nextToken: String?

    public init (
        items: [Job]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeJobsOutputResponseBody: Equatable {
    public let items: [Job]?
    public let nextToken: String?
}

extension DescribeJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Job?].self, forKey: .items)
        var itemsDecoded0:[Job]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Job]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobsRequestFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromDate
        case jobIDs
        case toDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromDate = fromDate {
            try encodeContainer.encode(fromDate, forKey: .fromDate)
        }
        if let jobIDs = jobIDs {
            var jobIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobIDs)
            for describejobsrequestfiltersjobids0 in jobIDs {
                try jobIDsContainer.encode(describejobsrequestfiltersjobids0)
            }
        }
        if let toDate = toDate {
            try encodeContainer.encode(toDate, forKey: .toDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .jobIDs)
        var jobIDsDecoded0:[String]? = nil
        if let jobIDsContainer = jobIDsContainer {
            jobIDsDecoded0 = [String]()
            for string0 in jobIDsContainer {
                if let string0 = string0 {
                    jobIDsDecoded0?.append(string0)
                }
            }
        }
        jobIDs = jobIDsDecoded0
        let fromDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromDate)
        fromDate = fromDateDecoded
        let toDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .toDate)
        toDate = toDateDecoded
    }
}

extension DescribeJobsRequestFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobsRequestFilters(fromDate: \(String(describing: fromDate)), jobIDs: \(String(describing: jobIDs)), toDate: \(String(describing: toDate)))"}
}

/// <p>Request to describe Job log filters.</p>
public struct DescribeJobsRequestFilters: Equatable {
    /// <p>Request to describe Job log filters by date.</p>
    public let fromDate: String?
    /// <p>Request to describe Job log filters by job ID.</p>
    public let jobIDs: [String]?
    /// <p>Request to describe Job log by last date.</p>
    public let toDate: String?

    public init (
        fromDate: String? = nil,
        jobIDs: [String]? = nil,
        toDate: String? = nil
    )
    {
        self.fromDate = fromDate
        self.jobIDs = jobIDs
        self.toDate = toDate
    }
}

public struct DescribeReplicationConfigurationTemplatesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReplicationConfigurationTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationConfigurationTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationConfigurationTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationConfigurationTemplatesInput>
    public typealias MOutput = OperationOutput<DescribeReplicationConfigurationTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationConfigurationTemplatesOutputError>
}

extension DescribeReplicationConfigurationTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationConfigurationTemplatesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), replicationConfigurationTemplateIDs: \(String(describing: replicationConfigurationTemplateIDs)))"}
}

extension DescribeReplicationConfigurationTemplatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case replicationConfigurationTemplateIDs
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs {
            var replicationConfigurationTemplateIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationConfigurationTemplateIDs)
            for replicationconfigurationtemplateids0 in replicationConfigurationTemplateIDs {
                try replicationConfigurationTemplateIDsContainer.encode(replicationconfigurationtemplateids0)
            }
        }
    }
}

public struct DescribeReplicationConfigurationTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReplicationConfigurationTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationConfigurationTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationConfigurationTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationConfigurationTemplatesInput>
    public typealias MOutput = OperationOutput<DescribeReplicationConfigurationTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationConfigurationTemplatesOutputError>
}

public struct DescribeReplicationConfigurationTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReplicationConfigurationTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplicationConfigurationTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplicationConfigurationTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplicationConfigurationTemplatesInput>
    public typealias MOutput = OperationOutput<DescribeReplicationConfigurationTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplicationConfigurationTemplatesOutputError>
}

public struct DescribeReplicationConfigurationTemplatesInput: Equatable {
    /// <p>Request to describe Replication Configuration template by max results.</p>
    public let maxResults: Int
    /// <p>Request to describe Replication Configuration template by next token.</p>
    public let nextToken: String?
    /// <p>Request to describe Replication Configuration template by template IDs.</p>
    public let replicationConfigurationTemplateIDs: [String]?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        replicationConfigurationTemplateIDs: [String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs
    }
}

struct DescribeReplicationConfigurationTemplatesInputBody: Equatable {
    public let replicationConfigurationTemplateIDs: [String]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeReplicationConfigurationTemplatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case replicationConfigurationTemplateIDs
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationConfigurationTemplateIDs)
        var replicationConfigurationTemplateIDsDecoded0:[String]? = nil
        if let replicationConfigurationTemplateIDsContainer = replicationConfigurationTemplateIDsContainer {
            replicationConfigurationTemplateIDsDecoded0 = [String]()
            for string0 in replicationConfigurationTemplateIDsContainer {
                if let string0 = string0 {
                    replicationConfigurationTemplateIDsDecoded0?.append(string0)
                }
            }
        }
        replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDsDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReplicationConfigurationTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationConfigurationTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationConfigurationTemplatesOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationConfigurationTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplicationConfigurationTemplatesOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeReplicationConfigurationTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReplicationConfigurationTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeReplicationConfigurationTemplatesOutputResponse: Equatable {
    /// <p>Request to describe Replication Configuration template by items.</p>
    public let items: [ReplicationConfigurationTemplate]?
    /// <p>Request to describe Replication Configuration template by next token.</p>
    public let nextToken: String?

    public init (
        items: [ReplicationConfigurationTemplate]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeReplicationConfigurationTemplatesOutputResponseBody: Equatable {
    public let items: [ReplicationConfigurationTemplate]?
    public let nextToken: String?
}

extension DescribeReplicationConfigurationTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ReplicationConfigurationTemplate?].self, forKey: .items)
        var itemsDecoded0:[ReplicationConfigurationTemplate]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ReplicationConfigurationTemplate]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeSourceServersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSourceServersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSourceServersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSourceServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSourceServersInput>
    public typealias MOutput = OperationOutput<DescribeSourceServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSourceServersOutputError>
}

extension DescribeSourceServersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSourceServersInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeSourceServersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeSourceServersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSourceServersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSourceServersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSourceServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSourceServersInput>
    public typealias MOutput = OperationOutput<DescribeSourceServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSourceServersOutputError>
}

public struct DescribeSourceServersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSourceServersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSourceServersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSourceServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSourceServersInput>
    public typealias MOutput = OperationOutput<DescribeSourceServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSourceServersOutputError>
}

public struct DescribeSourceServersInput: Equatable {
    /// <p>Request to filter Source Servers list.</p>
    public let filters: DescribeSourceServersRequestFilters?
    /// <p>Request to filter Source Servers list by maximum results.</p>
    public let maxResults: Int
    /// <p>Request to filter Source Servers list by next token.</p>
    public let nextToken: String?

    public init (
        filters: DescribeSourceServersRequestFilters? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeSourceServersInputBody: Equatable {
    public let filters: DescribeSourceServersRequestFilters?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeSourceServersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(DescribeSourceServersRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSourceServersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSourceServersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSourceServersOutputError: Equatable {
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSourceServersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSourceServersOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeSourceServersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSourceServersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeSourceServersOutputResponse: Equatable {
    /// <p>Request to filter Source Servers list by item.</p>
    public let items: [SourceServer]?
    /// <p>Request to filter Source Servers next token.</p>
    public let nextToken: String?

    public init (
        items: [SourceServer]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeSourceServersOutputResponseBody: Equatable {
    public let items: [SourceServer]?
    public let nextToken: String?
}

extension DescribeSourceServersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([SourceServer?].self, forKey: .items)
        var itemsDecoded0:[SourceServer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [SourceServer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSourceServersRequestFilters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isArchived
        case sourceServerIDs
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isArchived = isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for describesourceserversrequestfiltersids0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(describesourceserversrequestfiltersids0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let isArchivedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
    }
}

extension DescribeSourceServersRequestFilters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSourceServersRequestFilters(isArchived: \(String(describing: isArchived)), sourceServerIDs: \(String(describing: sourceServerIDs)))"}
}

/// <p>Request to filter Source Servers list.</p>
public struct DescribeSourceServersRequestFilters: Equatable {
    /// <p>Request to filter Source Servers list by archived.</p>
    public let isArchived: Bool?
    /// <p>Request to filter Source Servers list by Source Server ID.</p>
    public let sourceServerIDs: [String]?

    public init (
        isArchived: Bool? = nil,
        sourceServerIDs: [String]? = nil
    )
    {
        self.isArchived = isArchived
        self.sourceServerIDs = sourceServerIDs
    }
}

public struct DisconnectFromServiceInputBodyMiddleware: Middleware {
    public let id: String = "DisconnectFromServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisconnectFromServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisconnectFromServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisconnectFromServiceInput>
    public typealias MOutput = OperationOutput<DisconnectFromServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisconnectFromServiceOutputError>
}

extension DisconnectFromServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisconnectFromServiceInput(sourceServerID: \(String(describing: sourceServerID)))"}
}

extension DisconnectFromServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

public struct DisconnectFromServiceInputHeadersMiddleware: Middleware {
    public let id: String = "DisconnectFromServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisconnectFromServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisconnectFromServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisconnectFromServiceInput>
    public typealias MOutput = OperationOutput<DisconnectFromServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisconnectFromServiceOutputError>
}

public struct DisconnectFromServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "DisconnectFromServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisconnectFromServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisconnectFromServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisconnectFromServiceInput>
    public typealias MOutput = OperationOutput<DisconnectFromServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisconnectFromServiceOutputError>
}

public struct DisconnectFromServiceInput: Equatable {
    /// <p>Request to disconnect Source Server from service by Server ID.</p>
    public let sourceServerID: String?

    public init (
        sourceServerID: String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct DisconnectFromServiceInputBody: Equatable {
    public let sourceServerID: String?
}

extension DisconnectFromServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension DisconnectFromServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisconnectFromServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisconnectFromServiceOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisconnectFromServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisconnectFromServiceOutputResponse(arn: \(String(describing: arn)), dataReplicationInfo: \(String(describing: dataReplicationInfo)), isArchived: \(String(describing: isArchived)), launchedInstance: \(String(describing: launchedInstance)), lifeCycle: \(String(describing: lifeCycle)), sourceProperties: \(String(describing: sourceProperties)), sourceServerID: \(String(describing: sourceServerID)), tags: \(String(describing: tags)))"}
}

extension DisconnectFromServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisconnectFromServiceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
        }
    }
}

public struct DisconnectFromServiceOutputResponse: Equatable {
    /// <p>Source server ARN.</p>
    public let arn: String?
    /// <p>Source server data replication info.</p>
    public let dataReplicationInfo: DataReplicationInfo?
    /// <p>Source server archived status.</p>
    public let isArchived: Bool?
    /// <p>Source server launched instance.</p>
    public let launchedInstance: LaunchedInstance?
    /// <p>Source server lifecycle state.</p>
    public let lifeCycle: LifeCycle?
    /// <p>Source server properties.</p>
    public let sourceProperties: SourceProperties?
    /// <p>Source server ID.</p>
    public let sourceServerID: String?
    /// <p>Source server Tags.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        dataReplicationInfo: DataReplicationInfo? = nil,
        isArchived: Bool? = nil,
        launchedInstance: LaunchedInstance? = nil,
        lifeCycle: LifeCycle? = nil,
        sourceProperties: SourceProperties? = nil,
        sourceServerID: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
    }
}

struct DisconnectFromServiceOutputResponseBody: Equatable {
    public let sourceServerID: String?
    public let arn: String?
    public let isArchived: Bool?
    public let tags: [String:String]?
    public let launchedInstance: LaunchedInstance?
    public let dataReplicationInfo: DataReplicationInfo?
    public let lifeCycle: LifeCycle?
    public let sourceProperties: SourceProperties?
}

extension DisconnectFromServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case sourceProperties
        case sourceServerID
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
    }
}

extension Disk: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bytes
        case deviceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytes != 0 {
            try encodeContainer.encode(bytes, forKey: .bytes)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let bytesDecoded = try containerValues.decode(Int.self, forKey: .bytes)
        bytes = bytesDecoded
    }
}

extension Disk: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Disk(bytes: \(String(describing: bytes)), deviceName: \(String(describing: deviceName)))"}
}

/// <p>The disk identifier.</p>
public struct Disk: Equatable {
    /// <p>The amount of storage on the disk in bytes.</p>
    public let bytes: Int
    /// <p>The disk or device name.</p>
    public let deviceName: String?

    public init (
        bytes: Int = 0,
        deviceName: String? = nil
    )
    {
        self.bytes = bytes
        self.deviceName = deviceName
    }
}

public struct FinalizeCutoverInputBodyMiddleware: Middleware {
    public let id: String = "FinalizeCutoverInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FinalizeCutoverInput>,
                  next: H) -> Swift.Result<OperationOutput<FinalizeCutoverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FinalizeCutoverInput>
    public typealias MOutput = OperationOutput<FinalizeCutoverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FinalizeCutoverOutputError>
}

extension FinalizeCutoverInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FinalizeCutoverInput(sourceServerID: \(String(describing: sourceServerID)))"}
}

extension FinalizeCutoverInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

public struct FinalizeCutoverInputHeadersMiddleware: Middleware {
    public let id: String = "FinalizeCutoverInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FinalizeCutoverInput>,
                  next: H) -> Swift.Result<OperationOutput<FinalizeCutoverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FinalizeCutoverInput>
    public typealias MOutput = OperationOutput<FinalizeCutoverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FinalizeCutoverOutputError>
}

public struct FinalizeCutoverInputQueryItemMiddleware: Middleware {
    public let id: String = "FinalizeCutoverInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FinalizeCutoverInput>,
                  next: H) -> Swift.Result<OperationOutput<FinalizeCutoverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FinalizeCutoverInput>
    public typealias MOutput = OperationOutput<FinalizeCutoverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FinalizeCutoverOutputError>
}

public struct FinalizeCutoverInput: Equatable {
    /// <p>Request to finalize Cutover by Soure Server ID.</p>
    public let sourceServerID: String?

    public init (
        sourceServerID: String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct FinalizeCutoverInputBody: Equatable {
    public let sourceServerID: String?
}

extension FinalizeCutoverInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension FinalizeCutoverOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension FinalizeCutoverOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FinalizeCutoverOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension FinalizeCutoverOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FinalizeCutoverOutputResponse(arn: \(String(describing: arn)), dataReplicationInfo: \(String(describing: dataReplicationInfo)), isArchived: \(String(describing: isArchived)), launchedInstance: \(String(describing: launchedInstance)), lifeCycle: \(String(describing: lifeCycle)), sourceProperties: \(String(describing: sourceProperties)), sourceServerID: \(String(describing: sourceServerID)), tags: \(String(describing: tags)))"}
}

extension FinalizeCutoverOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FinalizeCutoverOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
        }
    }
}

public struct FinalizeCutoverOutputResponse: Equatable {
    /// <p>Source server ARN.</p>
    public let arn: String?
    /// <p>Source server data replication info.</p>
    public let dataReplicationInfo: DataReplicationInfo?
    /// <p>Source server archived status.</p>
    public let isArchived: Bool?
    /// <p>Source server launched instance.</p>
    public let launchedInstance: LaunchedInstance?
    /// <p>Source server lifecycle state.</p>
    public let lifeCycle: LifeCycle?
    /// <p>Source server properties.</p>
    public let sourceProperties: SourceProperties?
    /// <p>Source server ID.</p>
    public let sourceServerID: String?
    /// <p>Source server Tags.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        dataReplicationInfo: DataReplicationInfo? = nil,
        isArchived: Bool? = nil,
        launchedInstance: LaunchedInstance? = nil,
        lifeCycle: LifeCycle? = nil,
        sourceProperties: SourceProperties? = nil,
        sourceServerID: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
    }
}

struct FinalizeCutoverOutputResponseBody: Equatable {
    public let sourceServerID: String?
    public let arn: String?
    public let isArchived: Bool?
    public let tags: [String:String]?
    public let launchedInstance: LaunchedInstance?
    public let dataReplicationInfo: DataReplicationInfo?
    public let lifeCycle: LifeCycle?
    public let sourceProperties: SourceProperties?
}

extension FinalizeCutoverOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case sourceProperties
        case sourceServerID
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
    }
}

public enum FirstBoot {
    case stopped
    case succeeded
    case unknown
    case waiting
    case sdkUnknown(String)
}

extension FirstBoot : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FirstBoot] {
        return [
            .stopped,
            .succeeded,
            .unknown,
            .waiting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .stopped: return "STOPPED"
        case .succeeded: return "SUCCEEDED"
        case .unknown: return "UNKNOWN"
        case .waiting: return "WAITING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FirstBoot(rawValue: rawValue) ?? FirstBoot.sdkUnknown(rawValue)
    }
}

public struct GetLaunchConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "GetLaunchConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<GetLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLaunchConfigurationOutputError>
}

extension GetLaunchConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLaunchConfigurationInput(sourceServerID: \(String(describing: sourceServerID)))"}
}

extension GetLaunchConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

public struct GetLaunchConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetLaunchConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<GetLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLaunchConfigurationOutputError>
}

public struct GetLaunchConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLaunchConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<GetLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLaunchConfigurationOutputError>
}

public struct GetLaunchConfigurationInput: Equatable {
    /// <p>Request to get Launch Configuration information by Source Server ID.</p>
    public let sourceServerID: String?

    public init (
        sourceServerID: String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct GetLaunchConfigurationInputBody: Equatable {
    public let sourceServerID: String?
}

extension GetLaunchConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension GetLaunchConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchConfigurationOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLaunchConfigurationOutputResponse(copyPrivateIp: \(String(describing: copyPrivateIp)), copyTags: \(String(describing: copyTags)), ec2LaunchTemplateID: \(String(describing: ec2LaunchTemplateID)), launchDisposition: \(String(describing: launchDisposition)), licensing: \(String(describing: licensing)), name: \(String(describing: name)), sourceServerID: \(String(describing: sourceServerID)), targetInstanceTypeRightSizingMethod: \(String(describing: targetInstanceTypeRightSizingMethod)))"}
}

extension GetLaunchConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLaunchConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.name = output.name
            self.sourceServerID = output.sourceServerID
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.name = nil
            self.sourceServerID = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct GetLaunchConfigurationOutputResponse: Equatable {
    /// <p>Copy Private IP during Launch Configuration.</p>
    public let copyPrivateIp: Bool?
    /// <p>Copy Tags during Launch Configuration.</p>
    public let copyTags: Bool?
    /// <p>Configure EC2 lauch configuration template ID.</p>
    public let ec2LaunchTemplateID: String?
    /// <p>Configure launch dispostion for launch configuration.</p>
    public let launchDisposition: LaunchDisposition?
    /// <p>Configure launch configuration OS licensing.</p>
    public let licensing: Licensing?
    /// <p>Configure launch configuration name.</p>
    public let name: String?
    /// <p>Configure launch configuration Source Server ID.</p>
    public let sourceServerID: String?
    /// <p>Configure launch configuration Target instance type right sizing method.</p>
    public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

    public init (
        copyPrivateIp: Bool? = nil,
        copyTags: Bool? = nil,
        ec2LaunchTemplateID: String? = nil,
        launchDisposition: LaunchDisposition? = nil,
        licensing: Licensing? = nil,
        name: String? = nil,
        sourceServerID: String? = nil,
        targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.name = name
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct GetLaunchConfigurationOutputResponseBody: Equatable {
    public let sourceServerID: String?
    public let name: String?
    public let ec2LaunchTemplateID: String?
    public let launchDisposition: LaunchDisposition?
    public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?
    public let copyPrivateIp: Bool?
    public let copyTags: Bool?
    public let licensing: Licensing?
}

extension GetLaunchConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case launchDisposition
        case licensing
        case name
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
    }
}

public struct GetReplicationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "GetReplicationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<GetReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReplicationConfigurationOutputError>
}

extension GetReplicationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReplicationConfigurationInput(sourceServerID: \(String(describing: sourceServerID)))"}
}

extension GetReplicationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

public struct GetReplicationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetReplicationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<GetReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReplicationConfigurationOutputError>
}

public struct GetReplicationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetReplicationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<GetReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReplicationConfigurationOutputError>
}

public struct GetReplicationConfigurationInput: Equatable {
    /// <p>Request to get Replication Configuaration by Source Server ID.</p>
    public let sourceServerID: String?

    public init (
        sourceServerID: String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct GetReplicationConfigurationInputBody: Equatable {
    public let sourceServerID: String?
}

extension GetReplicationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension GetReplicationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReplicationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReplicationConfigurationOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReplicationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReplicationConfigurationOutputResponse(associateDefaultSecurityGroup: \(String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(String(describing: bandwidthThrottling)), createPublicIP: \(String(describing: createPublicIP)), dataPlaneRouting: \(String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(String(describing: ebsEncryptionKeyArn)), name: \(String(describing: name)), replicatedDisks: \(String(describing: replicatedDisks)), replicationServerInstanceType: \(String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(String(describing: sourceServerID)), stagingAreaSubnetId: \(String(describing: stagingAreaSubnetId)), stagingAreaTags: \(String(describing: stagingAreaTags)), useDedicatedReplicationServer: \(String(describing: useDedicatedReplicationServer)))"}
}

extension GetReplicationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetReplicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.name = output.name
            self.replicatedDisks = output.replicatedDisks
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.sourceServerID = output.sourceServerID
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.name = nil
            self.replicatedDisks = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.sourceServerID = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct GetReplicationConfigurationOutputResponse: Equatable {
    /// <p>Replication Configuration associate default Application Migration Service Security Group.</p>
    public let associateDefaultSecurityGroup: Bool?
    /// <p>Replication Configuration set bandwidth throttling.</p>
    public let bandwidthThrottling: Int
    /// <p>Replication Configuration create Public IP.</p>
    public let createPublicIP: Bool?
    /// <p>Replication Configuration data plane routing.</p>
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    /// <p>Replication Configuration use default large Staging Disks.</p>
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    /// <p>Replication Configuration EBS encryption.</p>
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    /// <p>Replication Configuration EBS encryption key ARN.</p>
    public let ebsEncryptionKeyArn: String?
    /// <p>Replication Configuration name.</p>
    public let name: String?
    /// <p>Replication Configuration replicated disks.</p>
    public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
    /// <p>Replication Configuration Replication Server instance type.</p>
    public let replicationServerInstanceType: String?
    /// <p>Replication Configuration Replication Server Security Group IDs.</p>
    public let replicationServersSecurityGroupsIDs: [String]?
    /// <p>Replication Configuration Source Server ID.</p>
    public let sourceServerID: String?
    /// <p>Replication Configuration Staging Area subnet ID.</p>
    public let stagingAreaSubnetId: String?
    /// <p>Replication Configuration Staging Area tags.</p>
    public let stagingAreaTags: [String:String]?
    /// <p>Replication Configuration use Dedicated Replication Server.</p>
    public let useDedicatedReplicationServer: Bool?

    public init (
        associateDefaultSecurityGroup: Bool? = nil,
        bandwidthThrottling: Int = 0,
        createPublicIP: Bool? = nil,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: String? = nil,
        name: String? = nil,
        replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: String? = nil,
        replicationServersSecurityGroupsIDs: [String]? = nil,
        sourceServerID: String? = nil,
        stagingAreaSubnetId: String? = nil,
        stagingAreaTags: [String:String]? = nil,
        useDedicatedReplicationServer: Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct GetReplicationConfigurationOutputResponseBody: Equatable {
    public let sourceServerID: String?
    public let name: String?
    public let stagingAreaSubnetId: String?
    public let associateDefaultSecurityGroup: Bool?
    public let replicationServersSecurityGroupsIDs: [String]?
    public let replicationServerInstanceType: String?
    public let useDedicatedReplicationServer: Bool?
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    public let ebsEncryptionKeyArn: String?
    public let bandwidthThrottling: Int
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    public let createPublicIP: Bool?
    public let stagingAreaTags: [String:String]?
}

extension GetReplicationConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [String:String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
    }
}

extension IdentificationHints: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsInstanceID
        case fqdn
        case hostname
        case vmWareUuid
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsInstanceID = awsInstanceID {
            try encodeContainer.encode(awsInstanceID, forKey: .awsInstanceID)
        }
        if let fqdn = fqdn {
            try encodeContainer.encode(fqdn, forKey: .fqdn)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let vmWareUuid = vmWareUuid {
            try encodeContainer.encode(vmWareUuid, forKey: .vmWareUuid)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fqdnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fqdn)
        fqdn = fqdnDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let vmWareUuidDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vmWareUuid)
        vmWareUuid = vmWareUuidDecoded
        let awsInstanceIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsInstanceID)
        awsInstanceID = awsInstanceIDDecoded
    }
}

extension IdentificationHints: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentificationHints(awsInstanceID: \(String(describing: awsInstanceID)), fqdn: \(String(describing: fqdn)), hostname: \(String(describing: hostname)), vmWareUuid: \(String(describing: vmWareUuid)))"}
}

/// <p>Identification hints.</p>
public struct IdentificationHints: Equatable {
    /// <p>AWS Instance ID identification hint.</p>
    public let awsInstanceID: String?
    /// <p>FQDN address identification hint.</p>
    public let fqdn: String?
    /// <p>Hostname identification hint.</p>
    public let hostname: String?
    /// <p>vmWare UUID identification hint.</p>
    public let vmWareUuid: String?

    public init (
        awsInstanceID: String? = nil,
        fqdn: String? = nil,
        hostname: String? = nil,
        vmWareUuid: String? = nil
    )
    {
        self.awsInstanceID = awsInstanceID
        self.fqdn = fqdn
        self.hostname = hostname
        self.vmWareUuid = vmWareUuid
    }
}

extension InitializeServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitializeServiceInput()"}
}

extension InitializeServiceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct InitializeServiceInputHeadersMiddleware: Middleware {
    public let id: String = "InitializeServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitializeServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<InitializeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitializeServiceInput>
    public typealias MOutput = OperationOutput<InitializeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitializeServiceOutputError>
}

public struct InitializeServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "InitializeServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitializeServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<InitializeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitializeServiceInput>
    public typealias MOutput = OperationOutput<InitializeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitializeServiceOutputError>
}

public struct InitializeServiceInput: Equatable {

    public init() {}
}

struct InitializeServiceInputBody: Equatable {
}

extension InitializeServiceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension InitializeServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitializeServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitializeServiceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitializeServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitializeServiceOutputResponse()"}
}

extension InitializeServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct InitializeServiceOutputResponse: Equatable {

    public init() {}
}

struct InitializeServiceOutputResponseBody: Equatable {
}

extension InitializeServiceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum InitiatedBy {
    case diagnostic
    case startCutover
    case startTest
    case terminate
    case sdkUnknown(String)
}

extension InitiatedBy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InitiatedBy] {
        return [
            .diagnostic,
            .startCutover,
            .startTest,
            .terminate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .diagnostic: return "DIAGNOSTIC"
        case .startCutover: return "START_CUTOVER"
        case .startTest: return "START_TEST"
        case .terminate: return "TERMINATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InitiatedBy(rawValue: rawValue) ?? InitiatedBy.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The server encountered an unexpected condition that prevented it from fulfilling the request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    /// <p>The server encountered an unexpected condition that prevented it from fulfilling the request. The request will be retried again after x seconds.</p>
    public var retryAfterSeconds: Int

    public init (
        message: String? = nil,
        retryAfterSeconds: Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Job: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationDateTime
        case endDateTime
        case initiatedBy
        case jobID
        case participatingServers
        case status
        case tags
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let endDateTime = endDateTime {
            try encodeContainer.encode(endDateTime, forKey: .endDateTime)
        }
        if let initiatedBy = initiatedBy {
            try encodeContainer.encode(initiatedBy.rawValue, forKey: .initiatedBy)
        }
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if let participatingServers = participatingServers {
            var participatingServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participatingServers)
            for participatingservers0 in participatingServers {
                try participatingServersContainer.encode(participatingservers0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .type)
        type = typeDecoded
        let initiatedByDecoded = try containerValues.decodeIfPresent(InitiatedBy.self, forKey: .initiatedBy)
        initiatedBy = initiatedByDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let participatingServersContainer = try containerValues.decodeIfPresent([ParticipatingServer?].self, forKey: .participatingServers)
        var participatingServersDecoded0:[ParticipatingServer]? = nil
        if let participatingServersContainer = participatingServersContainer {
            participatingServersDecoded0 = [ParticipatingServer]()
            for structure0 in participatingServersContainer {
                if let structure0 = structure0 {
                    participatingServersDecoded0?.append(structure0)
                }
            }
        }
        participatingServers = participatingServersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Job: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Job(arn: \(String(describing: arn)), creationDateTime: \(String(describing: creationDateTime)), endDateTime: \(String(describing: endDateTime)), initiatedBy: \(String(describing: initiatedBy)), jobID: \(String(describing: jobID)), participatingServers: \(String(describing: participatingServers)), status: \(String(describing: status)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

/// <p>Job.</p>
public struct Job: Equatable {
    /// <p>the ARN of the specific Job.</p>
    public let arn: String?
    /// <p>Job creation time.</p>
    public let creationDateTime: String?
    /// <p>Job end time.</p>
    public let endDateTime: String?
    /// <p>Job initiated by field.</p>
    public let initiatedBy: InitiatedBy?
    /// <p>Job ID.</p>
    public let jobID: String?
    /// <p>Servers participating in a specific Job.</p>
    public let participatingServers: [ParticipatingServer]?
    /// <p>Job status.</p>
    public let status: JobStatus?
    /// <p>Tags associated with spcific Job.</p>
    public let tags: [String:String]?
    /// <p>Job type.</p>
    public let type: JobType?

    public init (
        arn: String? = nil,
        creationDateTime: String? = nil,
        endDateTime: String? = nil,
        initiatedBy: InitiatedBy? = nil,
        jobID: String? = nil,
        participatingServers: [ParticipatingServer]? = nil,
        status: JobStatus? = nil,
        tags: [String:String]? = nil,
        type: JobType? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.endDateTime = endDateTime
        self.initiatedBy = initiatedBy
        self.jobID = jobID
        self.participatingServers = participatingServers
        self.status = status
        self.tags = tags
        self.type = type
    }
}

extension JobLog: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case event
        case eventData
        case logDateTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let eventData = eventData {
            try encodeContainer.encode(eventData, forKey: .eventData)
        }
        if let logDateTime = logDateTime {
            try encodeContainer.encode(logDateTime, forKey: .logDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logDateTime)
        logDateTime = logDateTimeDecoded
        let eventDecoded = try containerValues.decodeIfPresent(JobLogEvent.self, forKey: .event)
        event = eventDecoded
        let eventDataDecoded = try containerValues.decodeIfPresent(JobLogEventData.self, forKey: .eventData)
        eventData = eventDataDecoded
    }
}

extension JobLog: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobLog(event: \(String(describing: event)), eventData: \(String(describing: eventData)), logDateTime: \(String(describing: logDateTime)))"}
}

/// <p>Job log.</p>
public struct JobLog: Equatable {
    /// <p>Job log event.</p>
    public let event: JobLogEvent?
    /// <p>Job event data</p>
    public let eventData: JobLogEventData?
    /// <p>Job log event date and time.</p>
    public let logDateTime: String?

    public init (
        event: JobLogEvent? = nil,
        eventData: JobLogEventData? = nil,
        logDateTime: String? = nil
    )
    {
        self.event = event
        self.eventData = eventData
        self.logDateTime = logDateTime
    }
}

public enum JobLogEvent {
    case cleanupEnd
    case cleanupFail
    case cleanupStart
    case conversionEnd
    case conversionFail
    case conversionStart
    case jobCancel
    case jobEnd
    case jobStart
    case launchFailed
    case launchStart
    case serverSkipped
    case snapshotEnd
    case snapshotFail
    case snapshotStart
    case usingPreviousSnapshot
    case sdkUnknown(String)
}

extension JobLogEvent : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobLogEvent] {
        return [
            .cleanupEnd,
            .cleanupFail,
            .cleanupStart,
            .conversionEnd,
            .conversionFail,
            .conversionStart,
            .jobCancel,
            .jobEnd,
            .jobStart,
            .launchFailed,
            .launchStart,
            .serverSkipped,
            .snapshotEnd,
            .snapshotFail,
            .snapshotStart,
            .usingPreviousSnapshot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cleanupEnd: return "CLEANUP_END"
        case .cleanupFail: return "CLEANUP_FAIL"
        case .cleanupStart: return "CLEANUP_START"
        case .conversionEnd: return "CONVERSION_END"
        case .conversionFail: return "CONVERSION_FAIL"
        case .conversionStart: return "CONVERSION_START"
        case .jobCancel: return "JOB_CANCEL"
        case .jobEnd: return "JOB_END"
        case .jobStart: return "JOB_START"
        case .launchFailed: return "LAUNCH_FAILED"
        case .launchStart: return "LAUNCH_START"
        case .serverSkipped: return "SERVER_SKIPPED"
        case .snapshotEnd: return "SNAPSHOT_END"
        case .snapshotFail: return "SNAPSHOT_FAIL"
        case .snapshotStart: return "SNAPSHOT_START"
        case .usingPreviousSnapshot: return "USING_PREVIOUS_SNAPSHOT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobLogEvent(rawValue: rawValue) ?? JobLogEvent.sdkUnknown(rawValue)
    }
}

extension JobLogEventData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conversionServerID
        case rawError
        case sourceServerID
        case targetInstanceID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversionServerID = conversionServerID {
            try encodeContainer.encode(conversionServerID, forKey: .conversionServerID)
        }
        if let rawError = rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let targetInstanceID = targetInstanceID {
            try encodeContainer.encode(targetInstanceID, forKey: .targetInstanceID)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let conversionServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conversionServerID)
        conversionServerID = conversionServerIDDecoded
        let targetInstanceIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetInstanceID)
        targetInstanceID = targetInstanceIDDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension JobLogEventData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobLogEventData(conversionServerID: \(String(describing: conversionServerID)), rawError: \(String(describing: rawError)), sourceServerID: \(String(describing: sourceServerID)), targetInstanceID: \(String(describing: targetInstanceID)))"}
}

/// <p>Job log data</p>
public struct JobLogEventData: Equatable {
    /// <p>Job Event conversion Server ID.</p>
    public let conversionServerID: String?
    /// <p>Job error.</p>
    public let rawError: String?
    /// <p>Job Event Source Server ID.</p>
    public let sourceServerID: String?
    /// <p>Job Event Target instance ID.</p>
    public let targetInstanceID: String?

    public init (
        conversionServerID: String? = nil,
        rawError: String? = nil,
        sourceServerID: String? = nil,
        targetInstanceID: String? = nil
    )
    {
        self.conversionServerID = conversionServerID
        self.rawError = rawError
        self.sourceServerID = sourceServerID
        self.targetInstanceID = targetInstanceID
    }
}

public enum JobStatus {
    case completed
    case pending
    case started
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .completed,
            .pending,
            .started,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .pending: return "PENDING"
        case .started: return "STARTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

public enum JobType {
    case launch
    case terminate
    case sdkUnknown(String)
}

extension JobType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobType] {
        return [
            .launch,
            .terminate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .launch: return "LAUNCH"
        case .terminate: return "TERMINATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
    }
}

public enum LaunchDisposition {
    case started
    case stopped
    case sdkUnknown(String)
}

extension LaunchDisposition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LaunchDisposition] {
        return [
            .started,
            .stopped,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .started: return "STARTED"
        case .stopped: return "STOPPED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LaunchDisposition(rawValue: rawValue) ?? LaunchDisposition.sdkUnknown(rawValue)
    }
}

public enum LaunchStatus {
    case failed
    case inProgress
    case launched
    case pending
    case terminated
    case sdkUnknown(String)
}

extension LaunchStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LaunchStatus] {
        return [
            .failed,
            .inProgress,
            .launched,
            .pending,
            .terminated,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .launched: return "LAUNCHED"
        case .pending: return "PENDING"
        case .terminated: return "TERMINATED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LaunchStatus(rawValue: rawValue) ?? LaunchStatus.sdkUnknown(rawValue)
    }
}

extension LaunchedInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ec2InstanceID
        case firstBoot
        case jobID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceID = ec2InstanceID {
            try encodeContainer.encode(ec2InstanceID, forKey: .ec2InstanceID)
        }
        if let firstBoot = firstBoot {
            try encodeContainer.encode(firstBoot.rawValue, forKey: .firstBoot)
        }
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2InstanceIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2InstanceID)
        ec2InstanceID = ec2InstanceIDDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let firstBootDecoded = try containerValues.decodeIfPresent(FirstBoot.self, forKey: .firstBoot)
        firstBoot = firstBootDecoded
    }
}

extension LaunchedInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchedInstance(ec2InstanceID: \(String(describing: ec2InstanceID)), firstBoot: \(String(describing: firstBoot)), jobID: \(String(describing: jobID)))"}
}

/// <p>Configure launced instance.</p>
public struct LaunchedInstance: Equatable {
    /// <p>Configure launced instance EC2 ID.</p>
    public let ec2InstanceID: String?
    /// <p>Configure launced instance first boot.</p>
    public let firstBoot: FirstBoot?
    /// <p>Configure launced instance Job ID.</p>
    public let jobID: String?

    public init (
        ec2InstanceID: String? = nil,
        firstBoot: FirstBoot? = nil,
        jobID: String? = nil
    )
    {
        self.ec2InstanceID = ec2InstanceID
        self.firstBoot = firstBoot
        self.jobID = jobID
    }
}

extension Licensing: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case osByol
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let osByol = osByol {
            try encodeContainer.encode(osByol, forKey: .osByol)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let osByolDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .osByol)
        osByol = osByolDecoded
    }
}

extension Licensing: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Licensing(osByol: \(String(describing: osByol)))"}
}

/// <p>Configure Licensing.</p>
public struct Licensing: Equatable {
    /// <p>Configure BYOL OS licensing.</p>
    public let osByol: Bool?

    public init (
        osByol: Bool? = nil
    )
    {
        self.osByol = osByol
    }
}

extension LifeCycle: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addedToServiceDateTime
        case elapsedReplicationDuration
        case firstByteDateTime
        case lastCutover
        case lastSeenByServiceDateTime
        case lastTest
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addedToServiceDateTime = addedToServiceDateTime {
            try encodeContainer.encode(addedToServiceDateTime, forKey: .addedToServiceDateTime)
        }
        if let elapsedReplicationDuration = elapsedReplicationDuration {
            try encodeContainer.encode(elapsedReplicationDuration, forKey: .elapsedReplicationDuration)
        }
        if let firstByteDateTime = firstByteDateTime {
            try encodeContainer.encode(firstByteDateTime, forKey: .firstByteDateTime)
        }
        if let lastCutover = lastCutover {
            try encodeContainer.encode(lastCutover, forKey: .lastCutover)
        }
        if let lastSeenByServiceDateTime = lastSeenByServiceDateTime {
            try encodeContainer.encode(lastSeenByServiceDateTime, forKey: .lastSeenByServiceDateTime)
        }
        if let lastTest = lastTest {
            try encodeContainer.encode(lastTest, forKey: .lastTest)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addedToServiceDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addedToServiceDateTime)
        addedToServiceDateTime = addedToServiceDateTimeDecoded
        let firstByteDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstByteDateTime)
        firstByteDateTime = firstByteDateTimeDecoded
        let elapsedReplicationDurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elapsedReplicationDuration)
        elapsedReplicationDuration = elapsedReplicationDurationDecoded
        let lastSeenByServiceDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastSeenByServiceDateTime)
        lastSeenByServiceDateTime = lastSeenByServiceDateTimeDecoded
        let lastTestDecoded = try containerValues.decodeIfPresent(LifeCycleLastTest.self, forKey: .lastTest)
        lastTest = lastTestDecoded
        let lastCutoverDecoded = try containerValues.decodeIfPresent(LifeCycleLastCutover.self, forKey: .lastCutover)
        lastCutover = lastCutoverDecoded
        let stateDecoded = try containerValues.decodeIfPresent(LifeCycleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension LifeCycle: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifeCycle(addedToServiceDateTime: \(String(describing: addedToServiceDateTime)), elapsedReplicationDuration: \(String(describing: elapsedReplicationDuration)), firstByteDateTime: \(String(describing: firstByteDateTime)), lastCutover: \(String(describing: lastCutover)), lastSeenByServiceDateTime: \(String(describing: lastSeenByServiceDateTime)), lastTest: \(String(describing: lastTest)), state: \(String(describing: state)))"}
}

/// <p>Lifecycle.</p>
public struct LifeCycle: Equatable {
    /// <p>Lifecycle added to service data and time.</p>
    public let addedToServiceDateTime: String?
    /// <p>Lifecycle elapsed time and duration.</p>
    public let elapsedReplicationDuration: String?
    /// <p>Lifecycle replication initiation date and time.</p>
    public let firstByteDateTime: String?
    /// <p>Lifecycle last Cutover.</p>
    public let lastCutover: LifeCycleLastCutover?
    /// <p>Lifecycle last seen date and time.</p>
    public let lastSeenByServiceDateTime: String?
    /// <p>Lifecycle last Test.</p>
    public let lastTest: LifeCycleLastTest?
    /// <p>Lifecycle state.</p>
    public let state: LifeCycleState?

    public init (
        addedToServiceDateTime: String? = nil,
        elapsedReplicationDuration: String? = nil,
        firstByteDateTime: String? = nil,
        lastCutover: LifeCycleLastCutover? = nil,
        lastSeenByServiceDateTime: String? = nil,
        lastTest: LifeCycleLastTest? = nil,
        state: LifeCycleState? = nil
    )
    {
        self.addedToServiceDateTime = addedToServiceDateTime
        self.elapsedReplicationDuration = elapsedReplicationDuration
        self.firstByteDateTime = firstByteDateTime
        self.lastCutover = lastCutover
        self.lastSeenByServiceDateTime = lastSeenByServiceDateTime
        self.lastTest = lastTest
        self.state = state
    }
}

extension LifeCycleLastCutover: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case finalized
        case initiated
        case reverted
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalized = finalized {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
        if let initiated = initiated {
            try encodeContainer.encode(initiated, forKey: .initiated)
        }
        if let reverted = reverted {
            try encodeContainer.encode(reverted, forKey: .reverted)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatedDecoded = try containerValues.decodeIfPresent(LifeCycleLastCutoverInitiated.self, forKey: .initiated)
        initiated = initiatedDecoded
        let revertedDecoded = try containerValues.decodeIfPresent(LifeCycleLastCutoverReverted.self, forKey: .reverted)
        reverted = revertedDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(LifeCycleLastCutoverFinalized.self, forKey: .finalized)
        finalized = finalizedDecoded
    }
}

extension LifeCycleLastCutover: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifeCycleLastCutover(finalized: \(String(describing: finalized)), initiated: \(String(describing: initiated)), reverted: \(String(describing: reverted)))"}
}

/// <p>Lifecycle last Cutover .</p>
public struct LifeCycleLastCutover: Equatable {
    /// <p>Lifecycle Cutover finalized date and time.</p>
    public let finalized: LifeCycleLastCutoverFinalized?
    /// <p>Lifecycle last Cutover initiated.</p>
    public let initiated: LifeCycleLastCutoverInitiated?
    /// <p>Lifecycle last Cutover reverted.</p>
    public let reverted: LifeCycleLastCutoverReverted?

    public init (
        finalized: LifeCycleLastCutoverFinalized? = nil,
        initiated: LifeCycleLastCutoverInitiated? = nil,
        reverted: LifeCycleLastCutoverReverted? = nil
    )
    {
        self.finalized = finalized
        self.initiated = initiated
        self.reverted = reverted
    }
}

extension LifeCycleLastCutoverFinalized: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension LifeCycleLastCutoverFinalized: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifeCycleLastCutoverFinalized(apiCallDateTime: \(String(describing: apiCallDateTime)))"}
}

/// <p>Lifecycle Cutover finalized</p>
public struct LifeCycleLastCutoverFinalized: Equatable {
    /// <p>Lifecycle Cutover finalized date and time.</p>
    public let apiCallDateTime: String?

    public init (
        apiCallDateTime: String? = nil
    )
    {
        self.apiCallDateTime = apiCallDateTime
    }
}

extension LifeCycleLastCutoverInitiated: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiCallDateTime
        case jobID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension LifeCycleLastCutoverInitiated: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifeCycleLastCutoverInitiated(apiCallDateTime: \(String(describing: apiCallDateTime)), jobID: \(String(describing: jobID)))"}
}

/// <p>Lifecycle last Cutover initiated.</p>
public struct LifeCycleLastCutoverInitiated: Equatable {
    /// <p/>
    public let apiCallDateTime: String?
    /// <p>Lifecycle last Cutover initiated by Job ID.</p>
    public let jobID: String?

    public init (
        apiCallDateTime: String? = nil,
        jobID: String? = nil
    )
    {
        self.apiCallDateTime = apiCallDateTime
        self.jobID = jobID
    }
}

extension LifeCycleLastCutoverReverted: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension LifeCycleLastCutoverReverted: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifeCycleLastCutoverReverted(apiCallDateTime: \(String(describing: apiCallDateTime)))"}
}

/// <p>Lifecycle last Cutover reverted.</p>
public struct LifeCycleLastCutoverReverted: Equatable {
    /// <p>Lifecycle last Cutover reverted API call date time.</p>
    public let apiCallDateTime: String?

    public init (
        apiCallDateTime: String? = nil
    )
    {
        self.apiCallDateTime = apiCallDateTime
    }
}

extension LifeCycleLastTest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case finalized
        case initiated
        case reverted
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalized = finalized {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
        if let initiated = initiated {
            try encodeContainer.encode(initiated, forKey: .initiated)
        }
        if let reverted = reverted {
            try encodeContainer.encode(reverted, forKey: .reverted)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatedDecoded = try containerValues.decodeIfPresent(LifeCycleLastTestInitiated.self, forKey: .initiated)
        initiated = initiatedDecoded
        let revertedDecoded = try containerValues.decodeIfPresent(LifeCycleLastTestReverted.self, forKey: .reverted)
        reverted = revertedDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(LifeCycleLastTestFinalized.self, forKey: .finalized)
        finalized = finalizedDecoded
    }
}

extension LifeCycleLastTest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifeCycleLastTest(finalized: \(String(describing: finalized)), initiated: \(String(describing: initiated)), reverted: \(String(describing: reverted)))"}
}

/// <p>Lifecycle last Test.</p>
public struct LifeCycleLastTest: Equatable {
    /// <p>Lifecycle last Test finlized.</p>
    public let finalized: LifeCycleLastTestFinalized?
    /// <p>Lifecycle last Test initiated.</p>
    public let initiated: LifeCycleLastTestInitiated?
    /// <p>Lifecycle last Test reverted.</p>
    public let reverted: LifeCycleLastTestReverted?

    public init (
        finalized: LifeCycleLastTestFinalized? = nil,
        initiated: LifeCycleLastTestInitiated? = nil,
        reverted: LifeCycleLastTestReverted? = nil
    )
    {
        self.finalized = finalized
        self.initiated = initiated
        self.reverted = reverted
    }
}

extension LifeCycleLastTestFinalized: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension LifeCycleLastTestFinalized: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifeCycleLastTestFinalized(apiCallDateTime: \(String(describing: apiCallDateTime)))"}
}

/// <p>Lifecycle last Test finlized.</p>
public struct LifeCycleLastTestFinalized: Equatable {
    /// <p>Lifecycle Test failed API call date and time.</p>
    public let apiCallDateTime: String?

    public init (
        apiCallDateTime: String? = nil
    )
    {
        self.apiCallDateTime = apiCallDateTime
    }
}

extension LifeCycleLastTestInitiated: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiCallDateTime
        case jobID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension LifeCycleLastTestInitiated: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifeCycleLastTestInitiated(apiCallDateTime: \(String(describing: apiCallDateTime)), jobID: \(String(describing: jobID)))"}
}

/// <p>Lifecycle last Test initiated.</p>
public struct LifeCycleLastTestInitiated: Equatable {
    /// <p>Lifecycle last Test initiated API call date and time.</p>
    public let apiCallDateTime: String?
    /// <p>Lifecycle last Test initiated Job ID.</p>
    public let jobID: String?

    public init (
        apiCallDateTime: String? = nil,
        jobID: String? = nil
    )
    {
        self.apiCallDateTime = apiCallDateTime
        self.jobID = jobID
    }
}

extension LifeCycleLastTestReverted: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension LifeCycleLastTestReverted: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifeCycleLastTestReverted(apiCallDateTime: \(String(describing: apiCallDateTime)))"}
}

/// <p>Lifecycle last Test reverted.</p>
public struct LifeCycleLastTestReverted: Equatable {
    /// <p>Lifecycle last Test reverted API call date and time.</p>
    public let apiCallDateTime: String?

    public init (
        apiCallDateTime: String? = nil
    )
    {
        self.apiCallDateTime = apiCallDateTime
    }
}

public enum LifeCycleState {
    case cutover
    case cuttingOver
    case disconnected
    case notReady
    case readyForCutover
    case readyForTest
    case stopped
    case testing
    case sdkUnknown(String)
}

extension LifeCycleState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LifeCycleState] {
        return [
            .cutover,
            .cuttingOver,
            .disconnected,
            .notReady,
            .readyForCutover,
            .readyForTest,
            .stopped,
            .testing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cutover: return "CUTOVER"
        case .cuttingOver: return "CUTTING_OVER"
        case .disconnected: return "DISCONNECTED"
        case .notReady: return "NOT_READY"
        case .readyForCutover: return "READY_FOR_CUTOVER"
        case .readyForTest: return "READY_FOR_TEST"
        case .stopped: return "STOPPED"
        case .testing: return "TESTING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LifeCycleState(rawValue: rawValue) ?? LifeCycleState.sdkUnknown(rawValue)
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>List tags for resource request by ARN.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>List tags for resource response.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct MarkAsArchivedInputBodyMiddleware: Middleware {
    public let id: String = "MarkAsArchivedInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MarkAsArchivedInput>,
                  next: H) -> Swift.Result<OperationOutput<MarkAsArchivedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MarkAsArchivedInput>
    public typealias MOutput = OperationOutput<MarkAsArchivedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MarkAsArchivedOutputError>
}

extension MarkAsArchivedInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MarkAsArchivedInput(sourceServerID: \(String(describing: sourceServerID)))"}
}

extension MarkAsArchivedInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

public struct MarkAsArchivedInputHeadersMiddleware: Middleware {
    public let id: String = "MarkAsArchivedInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MarkAsArchivedInput>,
                  next: H) -> Swift.Result<OperationOutput<MarkAsArchivedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MarkAsArchivedInput>
    public typealias MOutput = OperationOutput<MarkAsArchivedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MarkAsArchivedOutputError>
}

public struct MarkAsArchivedInputQueryItemMiddleware: Middleware {
    public let id: String = "MarkAsArchivedInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MarkAsArchivedInput>,
                  next: H) -> Swift.Result<OperationOutput<MarkAsArchivedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MarkAsArchivedInput>
    public typealias MOutput = OperationOutput<MarkAsArchivedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MarkAsArchivedOutputError>
}

public struct MarkAsArchivedInput: Equatable {
    /// <p>Mark as archived by Source Server ID.</p>
    public let sourceServerID: String?

    public init (
        sourceServerID: String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct MarkAsArchivedInputBody: Equatable {
    public let sourceServerID: String?
}

extension MarkAsArchivedInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension MarkAsArchivedOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MarkAsArchivedOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MarkAsArchivedOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MarkAsArchivedOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MarkAsArchivedOutputResponse(arn: \(String(describing: arn)), dataReplicationInfo: \(String(describing: dataReplicationInfo)), isArchived: \(String(describing: isArchived)), launchedInstance: \(String(describing: launchedInstance)), lifeCycle: \(String(describing: lifeCycle)), sourceProperties: \(String(describing: sourceProperties)), sourceServerID: \(String(describing: sourceServerID)), tags: \(String(describing: tags)))"}
}

extension MarkAsArchivedOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MarkAsArchivedOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
        }
    }
}

public struct MarkAsArchivedOutputResponse: Equatable {
    /// <p>Source server ARN.</p>
    public let arn: String?
    /// <p>Source server data replication info.</p>
    public let dataReplicationInfo: DataReplicationInfo?
    /// <p>Source server archived status.</p>
    public let isArchived: Bool?
    /// <p>Source server launched instance.</p>
    public let launchedInstance: LaunchedInstance?
    /// <p>Source server lifecycle state.</p>
    public let lifeCycle: LifeCycle?
    /// <p>Source server properties.</p>
    public let sourceProperties: SourceProperties?
    /// <p>Source server ID.</p>
    public let sourceServerID: String?
    /// <p>Source server Tags.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        dataReplicationInfo: DataReplicationInfo? = nil,
        isArchived: Bool? = nil,
        launchedInstance: LaunchedInstance? = nil,
        lifeCycle: LifeCycle? = nil,
        sourceProperties: SourceProperties? = nil,
        sourceServerID: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
    }
}

struct MarkAsArchivedOutputResponseBody: Equatable {
    public let sourceServerID: String?
    public let arn: String?
    public let isArchived: Bool?
    public let tags: [String:String]?
    public let launchedInstance: LaunchedInstance?
    public let dataReplicationInfo: DataReplicationInfo?
    public let lifeCycle: LifeCycle?
    public let sourceProperties: SourceProperties?
}

extension MarkAsArchivedOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case sourceProperties
        case sourceServerID
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
    }
}

extension NetworkInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ips
        case isPrimary
        case macAddress
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ips = ips {
            var ipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ips)
            for ipslist0 in ips {
                try ipsContainer.encode(ipslist0)
            }
        }
        if let isPrimary = isPrimary {
            try encodeContainer.encode(isPrimary, forKey: .isPrimary)
        }
        if let macAddress = macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let macAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let ipsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ips)
        var ipsDecoded0:[String]? = nil
        if let ipsContainer = ipsContainer {
            ipsDecoded0 = [String]()
            for string0 in ipsContainer {
                if let string0 = string0 {
                    ipsDecoded0?.append(string0)
                }
            }
        }
        ips = ipsDecoded0
        let isPrimaryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isPrimary)
        isPrimary = isPrimaryDecoded
    }
}

extension NetworkInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkInterface(ips: \(String(describing: ips)), isPrimary: \(String(describing: isPrimary)), macAddress: \(String(describing: macAddress)))"}
}

/// <p>Network interface.</p>
public struct NetworkInterface: Equatable {
    /// <p>Network interface IPs.</p>
    public let ips: [String]?
    /// <p>Network interface primary IP.</p>
    public let isPrimary: Bool?
    /// <p>Network interface Mac address.</p>
    public let macAddress: String?

    public init (
        ips: [String]? = nil,
        isPrimary: Bool? = nil,
        macAddress: String? = nil
    )
    {
        self.ips = ips
        self.isPrimary = isPrimary
        self.macAddress = macAddress
    }
}

extension OS: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fullString
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fullString = fullString {
            try encodeContainer.encode(fullString, forKey: .fullString)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fullString)
        fullString = fullStringDecoded
    }
}

extension OS: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OS(fullString: \(String(describing: fullString)))"}
}

/// <p>Operating System.</p>
public struct OS: Equatable {
    /// <p>OS full string.</p>
    public let fullString: String?

    public init (
        fullString: String? = nil
    )
    {
        self.fullString = fullString
    }
}

extension ParticipatingServer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case launchStatus
        case sourceServerID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchStatus = launchStatus {
            try encodeContainer.encode(launchStatus.rawValue, forKey: .launchStatus)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let launchStatusDecoded = try containerValues.decodeIfPresent(LaunchStatus.self, forKey: .launchStatus)
        launchStatus = launchStatusDecoded
    }
}

extension ParticipatingServer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParticipatingServer(launchStatus: \(String(describing: launchStatus)), sourceServerID: \(String(describing: sourceServerID)))"}
}

/// <p>Server participating in Job.</p>
public struct ParticipatingServer: Equatable {
    /// <p>Participating server launch status.</p>
    public let launchStatus: LaunchStatus?
    /// <p>Participating server Source Server ID.</p>
    public let sourceServerID: String?

    public init (
        launchStatus: LaunchStatus? = nil,
        sourceServerID: String? = nil
    )
    {
        self.launchStatus = launchStatus
        self.sourceServerID = sourceServerID
    }
}

public enum ReplicationConfigurationDataPlaneRouting {
    case privateIp
    case publicIp
    case sdkUnknown(String)
}

extension ReplicationConfigurationDataPlaneRouting : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationConfigurationDataPlaneRouting] {
        return [
            .privateIp,
            .publicIp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .privateIp: return "PRIVATE_IP"
        case .publicIp: return "PUBLIC_IP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationConfigurationDataPlaneRouting(rawValue: rawValue) ?? ReplicationConfigurationDataPlaneRouting.sdkUnknown(rawValue)
    }
}

public enum ReplicationConfigurationDefaultLargeStagingDiskType {
    case gp2
    case st1
    case sdkUnknown(String)
}

extension ReplicationConfigurationDefaultLargeStagingDiskType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationConfigurationDefaultLargeStagingDiskType] {
        return [
            .gp2,
            .st1,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .gp2: return "GP2"
        case .st1: return "ST1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationConfigurationDefaultLargeStagingDiskType(rawValue: rawValue) ?? ReplicationConfigurationDefaultLargeStagingDiskType.sdkUnknown(rawValue)
    }
}

public enum ReplicationConfigurationEbsEncryption {
    case custom
    case `default`
    case `none`
    case sdkUnknown(String)
}

extension ReplicationConfigurationEbsEncryption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationConfigurationEbsEncryption] {
        return [
            .custom,
            .default,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .custom: return "CUSTOM"
        case .default: return "DEFAULT"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationConfigurationEbsEncryption(rawValue: rawValue) ?? ReplicationConfigurationEbsEncryption.sdkUnknown(rawValue)
    }
}

extension ReplicationConfigurationReplicatedDisk: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceName
        case iops
        case isBootDisk
        case stagingDiskType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let isBootDisk = isBootDisk {
            try encodeContainer.encode(isBootDisk, forKey: .isBootDisk)
        }
        if let stagingDiskType = stagingDiskType {
            try encodeContainer.encode(stagingDiskType.rawValue, forKey: .stagingDiskType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let isBootDiskDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isBootDisk)
        isBootDisk = isBootDiskDecoded
        let stagingDiskTypeDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationReplicatedDiskStagingDiskType.self, forKey: .stagingDiskType)
        stagingDiskType = stagingDiskTypeDecoded
        let iopsDecoded = try containerValues.decode(Int.self, forKey: .iops)
        iops = iopsDecoded
    }
}

extension ReplicationConfigurationReplicatedDisk: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationConfigurationReplicatedDisk(deviceName: \(String(describing: deviceName)), iops: \(String(describing: iops)), isBootDisk: \(String(describing: isBootDisk)), stagingDiskType: \(String(describing: stagingDiskType)))"}
}

/// <p>Replication Configuration replicated disk.</p>
public struct ReplicationConfigurationReplicatedDisk: Equatable {
    /// <p>Replication Configuration replicated disk device name.</p>
    public let deviceName: String?
    /// <p>Replication Configuration replicated disk IOPs.</p>
    public let iops: Int
    /// <p>Replication Configuration replicated disk boot disk.</p>
    public let isBootDisk: Bool?
    /// <p>Replication Configuration replicated disk staging disk type.</p>
    public let stagingDiskType: ReplicationConfigurationReplicatedDiskStagingDiskType?

    public init (
        deviceName: String? = nil,
        iops: Int = 0,
        isBootDisk: Bool? = nil,
        stagingDiskType: ReplicationConfigurationReplicatedDiskStagingDiskType? = nil
    )
    {
        self.deviceName = deviceName
        self.iops = iops
        self.isBootDisk = isBootDisk
        self.stagingDiskType = stagingDiskType
    }
}

public enum ReplicationConfigurationReplicatedDiskStagingDiskType {
    case auto
    case gp2
    case io1
    case sc1
    case st1
    case standard
    case sdkUnknown(String)
}

extension ReplicationConfigurationReplicatedDiskStagingDiskType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationConfigurationReplicatedDiskStagingDiskType] {
        return [
            .auto,
            .gp2,
            .io1,
            .sc1,
            .st1,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .auto: return "AUTO"
        case .gp2: return "GP2"
        case .io1: return "IO1"
        case .sc1: return "SC1"
        case .st1: return "ST1"
        case .standard: return "STANDARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationConfigurationReplicatedDiskStagingDiskType(rawValue: rawValue) ?? ReplicationConfigurationReplicatedDiskStagingDiskType.sdkUnknown(rawValue)
    }
}

extension ReplicationConfigurationTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associateDefaultSecurityGroup = associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let replicationConfigurationTemplateID = replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
        if let replicationServerInstanceType = replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for replicationserverssecuritygroupsids0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(replicationserverssecuritygroupsids0)
            }
        }
        if let stagingAreaSubnetId = stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsmap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [String:String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ReplicationConfigurationTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationConfigurationTemplate(arn: \(String(describing: arn)), associateDefaultSecurityGroup: \(String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(String(describing: bandwidthThrottling)), createPublicIP: \(String(describing: createPublicIP)), dataPlaneRouting: \(String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(String(describing: stagingAreaSubnetId)), stagingAreaTags: \(String(describing: stagingAreaTags)), tags: \(String(describing: tags)), useDedicatedReplicationServer: \(String(describing: useDedicatedReplicationServer)))"}
}

public struct ReplicationConfigurationTemplate: Equatable {
    /// <p>Replication Configuration template ARN.</p>
    public let arn: String?
    /// <p>Replication Configuration template associate default Application Migration Service Security group.</p>
    public let associateDefaultSecurityGroup: Bool?
    /// <p>Replication Configuration template bandwidth throtting.</p>
    public let bandwidthThrottling: Int
    /// <p>Replication Configuration template create Public IP.</p>
    public let createPublicIP: Bool?
    /// <p>Replication Configuration template data plane routing.</p>
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    /// <p>Replication Configuration template use dedault large Staging Disk type.</p>
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    /// <p>Replication Configuration template EBS encryption.</p>
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    /// <p>Replication Configuration template EBS encryption key ARN.</p>
    public let ebsEncryptionKeyArn: String?
    /// <p>Replication Configuration template template ID.</p>
    public let replicationConfigurationTemplateID: String?
    /// <p>Replication Configuration template server instance type.</p>
    public let replicationServerInstanceType: String?
    /// <p>Replication Configuration template server Security Groups IDs.</p>
    public let replicationServersSecurityGroupsIDs: [String]?
    /// <p>Replication Configuration template Staging Area subnet ID.</p>
    public let stagingAreaSubnetId: String?
    /// <p>Replication Configuration template Staging Area Tags.</p>
    public let stagingAreaTags: [String:String]?
    /// <p>Replication Configuration template Tags.</p>
    public let tags: [String:String]?
    /// <p>Replication Configuration template use Dedicated Replication Server.</p>
    public let useDedicatedReplicationServer: Bool?

    public init (
        arn: String? = nil,
        associateDefaultSecurityGroup: Bool? = nil,
        bandwidthThrottling: Int = 0,
        createPublicIP: Bool? = nil,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: String? = nil,
        replicationConfigurationTemplateID: String? = nil,
        replicationServerInstanceType: String? = nil,
        replicationServersSecurityGroupsIDs: [String]? = nil,
        stagingAreaSubnetId: String? = nil,
        stagingAreaTags: [String:String]? = nil,
        tags: [String:String]? = nil,
        useDedicatedReplicationServer: Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(code: \(String(describing: code)), message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.code = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Resource not found exception.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?
    /// <p>Resource ID not found error.</p>
    public var resourceId: String?
    /// <p>Resource type not found error.</p>
    public var resourceType: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let code: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct RetryDataReplicationInputBodyMiddleware: Middleware {
    public let id: String = "RetryDataReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetryDataReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<RetryDataReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetryDataReplicationInput>
    public typealias MOutput = OperationOutput<RetryDataReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetryDataReplicationOutputError>
}

extension RetryDataReplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetryDataReplicationInput(sourceServerID: \(String(describing: sourceServerID)))"}
}

extension RetryDataReplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

public struct RetryDataReplicationInputHeadersMiddleware: Middleware {
    public let id: String = "RetryDataReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetryDataReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<RetryDataReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetryDataReplicationInput>
    public typealias MOutput = OperationOutput<RetryDataReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetryDataReplicationOutputError>
}

public struct RetryDataReplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "RetryDataReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetryDataReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<RetryDataReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetryDataReplicationInput>
    public typealias MOutput = OperationOutput<RetryDataReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetryDataReplicationOutputError>
}

public struct RetryDataReplicationInput: Equatable {
    /// <p>Retry data replication for Source Server ID.</p>
    public let sourceServerID: String?

    public init (
        sourceServerID: String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct RetryDataReplicationInputBody: Equatable {
    public let sourceServerID: String?
}

extension RetryDataReplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceServerID
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension RetryDataReplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetryDataReplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetryDataReplicationOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetryDataReplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetryDataReplicationOutputResponse(arn: \(String(describing: arn)), dataReplicationInfo: \(String(describing: dataReplicationInfo)), isArchived: \(String(describing: isArchived)), launchedInstance: \(String(describing: launchedInstance)), lifeCycle: \(String(describing: lifeCycle)), sourceProperties: \(String(describing: sourceProperties)), sourceServerID: \(String(describing: sourceServerID)), tags: \(String(describing: tags)))"}
}

extension RetryDataReplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RetryDataReplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
        }
    }
}

public struct RetryDataReplicationOutputResponse: Equatable {
    /// <p>Source server ARN.</p>
    public let arn: String?
    /// <p>Source server data replication info.</p>
    public let dataReplicationInfo: DataReplicationInfo?
    /// <p>Source server archived status.</p>
    public let isArchived: Bool?
    /// <p>Source server launched instance.</p>
    public let launchedInstance: LaunchedInstance?
    /// <p>Source server lifecycle state.</p>
    public let lifeCycle: LifeCycle?
    /// <p>Source server properties.</p>
    public let sourceProperties: SourceProperties?
    /// <p>Source server ID.</p>
    public let sourceServerID: String?
    /// <p>Source server Tags.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        dataReplicationInfo: DataReplicationInfo? = nil,
        isArchived: Bool? = nil,
        launchedInstance: LaunchedInstance? = nil,
        lifeCycle: LifeCycle? = nil,
        sourceProperties: SourceProperties? = nil,
        sourceServerID: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
    }
}

struct RetryDataReplicationOutputResponseBody: Equatable {
    public let sourceServerID: String?
    public let arn: String?
    public let isArchived: Bool?
    public let tags: [String:String]?
    public let launchedInstance: LaunchedInstance?
    public let dataReplicationInfo: DataReplicationInfo?
    public let lifeCycle: LifeCycle?
    public let sourceProperties: SourceProperties?
}

extension RetryDataReplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case sourceProperties
        case sourceServerID
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
    }
}

extension SourceProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cpus
        case disks
        case identificationHints
        case lastUpdatedDateTime
        case networkInterfaces
        case os
        case ramBytes
        case recommendedInstanceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpus = cpus {
            var cpusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cpus)
            for cpus0 in cpus {
                try cpusContainer.encode(cpus0)
            }
        }
        if let disks = disks {
            var disksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .disks)
            for disks0 in disks {
                try disksContainer.encode(disks0)
            }
        }
        if let identificationHints = identificationHints {
            try encodeContainer.encode(identificationHints, forKey: .identificationHints)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime, forKey: .lastUpdatedDateTime)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterfaces0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterfaces0)
            }
        }
        if let os = os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if ramBytes != 0 {
            try encodeContainer.encode(ramBytes, forKey: .ramBytes)
        }
        if let recommendedInstanceType = recommendedInstanceType {
            try encodeContainer.encode(recommendedInstanceType, forKey: .recommendedInstanceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let recommendedInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendedInstanceType)
        recommendedInstanceType = recommendedInstanceTypeDecoded
        let identificationHintsDecoded = try containerValues.decodeIfPresent(IdentificationHints.self, forKey: .identificationHints)
        identificationHints = identificationHintsDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let disksContainer = try containerValues.decodeIfPresent([Disk?].self, forKey: .disks)
        var disksDecoded0:[Disk]? = nil
        if let disksContainer = disksContainer {
            disksDecoded0 = [Disk]()
            for structure0 in disksContainer {
                if let structure0 = structure0 {
                    disksDecoded0?.append(structure0)
                }
            }
        }
        disks = disksDecoded0
        let cpusContainer = try containerValues.decodeIfPresent([CPU?].self, forKey: .cpus)
        var cpusDecoded0:[CPU]? = nil
        if let cpusContainer = cpusContainer {
            cpusDecoded0 = [CPU]()
            for structure0 in cpusContainer {
                if let structure0 = structure0 {
                    cpusDecoded0?.append(structure0)
                }
            }
        }
        cpus = cpusDecoded0
        let ramBytesDecoded = try containerValues.decode(Int.self, forKey: .ramBytes)
        ramBytes = ramBytesDecoded
        let osDecoded = try containerValues.decodeIfPresent(OS.self, forKey: .os)
        os = osDecoded
    }
}

extension SourceProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceProperties(cpus: \(String(describing: cpus)), disks: \(String(describing: disks)), identificationHints: \(String(describing: identificationHints)), lastUpdatedDateTime: \(String(describing: lastUpdatedDateTime)), networkInterfaces: \(String(describing: networkInterfaces)), os: \(String(describing: os)), ramBytes: \(String(describing: ramBytes)), recommendedInstanceType: \(String(describing: recommendedInstanceType)))"}
}

/// <p>Source server properties.</p>
public struct SourceProperties: Equatable {
    /// <p>Source Server CPUs.</p>
    public let cpus: [CPU]?
    /// <p>Source Server disks.</p>
    public let disks: [Disk]?
    /// <p>Source server identification hints.</p>
    public let identificationHints: IdentificationHints?
    /// <p>Source server last update date and time.</p>
    public let lastUpdatedDateTime: String?
    /// <p>Source server network interfaces.</p>
    public let networkInterfaces: [NetworkInterface]?
    /// <p>Source server OS.</p>
    public let os: OS?
    /// <p>Source server RAM in bytes.</p>
    public let ramBytes: Int
    /// <p>Source server recommended instance type.</p>
    public let recommendedInstanceType: String?

    public init (
        cpus: [CPU]? = nil,
        disks: [Disk]? = nil,
        identificationHints: IdentificationHints? = nil,
        lastUpdatedDateTime: String? = nil,
        networkInterfaces: [NetworkInterface]? = nil,
        os: OS? = nil,
        ramBytes: Int = 0,
        recommendedInstanceType: String? = nil
    )
    {
        self.cpus = cpus
        self.disks = disks
        self.identificationHints = identificationHints
        self.lastUpdatedDateTime = lastUpdatedDateTime
        self.networkInterfaces = networkInterfaces
        self.os = os
        self.ramBytes = ramBytes
        self.recommendedInstanceType = recommendedInstanceType
    }
}

extension SourceServer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case sourceProperties
        case sourceServerID
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataReplicationInfo = dataReplicationInfo {
            try encodeContainer.encode(dataReplicationInfo, forKey: .dataReplicationInfo)
        }
        if let isArchived = isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let launchedInstance = launchedInstance {
            try encodeContainer.encode(launchedInstance, forKey: .launchedInstance)
        }
        if let lifeCycle = lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let sourceProperties = sourceProperties {
            try encodeContainer.encode(sourceProperties, forKey: .sourceProperties)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
    }
}

extension SourceServer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceServer(arn: \(String(describing: arn)), dataReplicationInfo: \(String(describing: dataReplicationInfo)), isArchived: \(String(describing: isArchived)), launchedInstance: \(String(describing: launchedInstance)), lifeCycle: \(String(describing: lifeCycle)), sourceProperties: \(String(describing: sourceProperties)), sourceServerID: \(String(describing: sourceServerID)), tags: \(String(describing: tags)))"}
}

public struct SourceServer: Equatable {
    /// <p>Source server ARN.</p>
    public let arn: String?
    /// <p>Source server data replication info.</p>
    public let dataReplicationInfo: DataReplicationInfo?
    /// <p>Source server archived status.</p>
    public let isArchived: Bool?
    /// <p>Source server launched instance.</p>
    public let launchedInstance: LaunchedInstance?
    /// <p>Source server lifecycle state.</p>
    public let lifeCycle: LifeCycle?
    /// <p>Source server properties.</p>
    public let sourceProperties: SourceProperties?
    /// <p>Source server ID.</p>
    public let sourceServerID: String?
    /// <p>Source server Tags.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        dataReplicationInfo: DataReplicationInfo? = nil,
        isArchived: Bool? = nil,
        launchedInstance: LaunchedInstance? = nil,
        lifeCycle: LifeCycle? = nil,
        sourceProperties: SourceProperties? = nil,
        sourceServerID: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
    }
}

public struct StartCutoverInputBodyMiddleware: Middleware {
    public let id: String = "StartCutoverInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCutoverInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCutoverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCutoverInput>
    public typealias MOutput = OperationOutput<StartCutoverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCutoverOutputError>
}

extension StartCutoverInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCutoverInput(sourceServerIDs: \(String(describing: sourceServerIDs)), tags: \(String(describing: tags)))"}
}

extension StartCutoverInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceServerIDs
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for startcutoverrequestsourceserverids0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(startcutoverrequestsourceserverids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartCutoverInputHeadersMiddleware: Middleware {
    public let id: String = "StartCutoverInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCutoverInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCutoverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCutoverInput>
    public typealias MOutput = OperationOutput<StartCutoverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCutoverOutputError>
}

public struct StartCutoverInputQueryItemMiddleware: Middleware {
    public let id: String = "StartCutoverInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCutoverInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCutoverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCutoverInput>
    public typealias MOutput = OperationOutput<StartCutoverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCutoverOutputError>
}

public struct StartCutoverInput: Equatable {
    /// <p>Start Cutover by Source Server IDs.</p>
    public let sourceServerIDs: [String]?
    /// <p>Start Cutover by Tags.</p>
    public let tags: [String:String]?

    public init (
        sourceServerIDs: [String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

struct StartCutoverInputBody: Equatable {
    public let sourceServerIDs: [String]?
    public let tags: [String:String]?
}

extension StartCutoverInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceServerIDs
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartCutoverOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCutoverOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartCutoverOutputError: Equatable {
    case conflictException(ConflictException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCutoverOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCutoverOutputResponse(job: \(String(describing: job)))"}
}

extension StartCutoverOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartCutoverOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartCutoverOutputResponse: Equatable {
    /// <p>Start Cutover Job response.</p>
    public let job: Job?

    public init (
        job: Job? = nil
    )
    {
        self.job = job
    }
}

struct StartCutoverOutputResponseBody: Equatable {
    public let job: Job?
}

extension StartCutoverOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Job.self, forKey: .job)
        job = jobDecoded
    }
}

public struct StartTestInputBodyMiddleware: Middleware {
    public let id: String = "StartTestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTestInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTestInput>
    public typealias MOutput = OperationOutput<StartTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTestOutputError>
}

extension StartTestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTestInput(sourceServerIDs: \(String(describing: sourceServerIDs)), tags: \(String(describing: tags)))"}
}

extension StartTestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceServerIDs
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for starttestrequestsourceserverids0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(starttestrequestsourceserverids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartTestInputHeadersMiddleware: Middleware {
    public let id: String = "StartTestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTestInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTestInput>
    public typealias MOutput = OperationOutput<StartTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTestOutputError>
}

public struct StartTestInputQueryItemMiddleware: Middleware {
    public let id: String = "StartTestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTestInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTestInput>
    public typealias MOutput = OperationOutput<StartTestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTestOutputError>
}

public struct StartTestInput: Equatable {
    /// <p>Start Test for Source Server IDs.</p>
    public let sourceServerIDs: [String]?
    /// <p>Start Test by Tags.</p>
    public let tags: [String:String]?

    public init (
        sourceServerIDs: [String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

struct StartTestInputBody: Equatable {
    public let sourceServerIDs: [String]?
    public let tags: [String:String]?
}

extension StartTestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceServerIDs
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartTestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartTestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartTestOutputError: Equatable {
    case conflictException(ConflictException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartTestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTestOutputResponse(job: \(String(describing: job)))"}
}

extension StartTestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartTestOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartTestOutputResponse: Equatable {
    /// <p>Start Test Job response.</p>
    public let job: Job?

    public init (
        job: Job? = nil
    )
    {
        self.job = job
    }
}

struct StartTestOutputResponseBody: Equatable {
    public let job: Job?
}

extension StartTestOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Job.self, forKey: .job)
        job = jobDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>Tag resource by ARN.</p>
    public let resourceArn: String?
    /// <p>Tag resource by Tags.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum TargetInstanceTypeRightSizingMethod {
    case basic
    case `none`
    case sdkUnknown(String)
}

extension TargetInstanceTypeRightSizingMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetInstanceTypeRightSizingMethod] {
        return [
            .basic,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .basic: return "BASIC"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetInstanceTypeRightSizingMethod(rawValue: rawValue) ?? TargetInstanceTypeRightSizingMethod.sdkUnknown(rawValue)
    }
}

public struct TerminateTargetInstancesInputBodyMiddleware: Middleware {
    public let id: String = "TerminateTargetInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateTargetInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateTargetInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateTargetInstancesInput>
    public typealias MOutput = OperationOutput<TerminateTargetInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateTargetInstancesOutputError>
}

extension TerminateTargetInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateTargetInstancesInput(sourceServerIDs: \(String(describing: sourceServerIDs)), tags: \(String(describing: tags)))"}
}

extension TerminateTargetInstancesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceServerIDs
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for terminatetargetinstancesrequestsourceserverids0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(terminatetargetinstancesrequestsourceserverids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TerminateTargetInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "TerminateTargetInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateTargetInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateTargetInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateTargetInstancesInput>
    public typealias MOutput = OperationOutput<TerminateTargetInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateTargetInstancesOutputError>
}

public struct TerminateTargetInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "TerminateTargetInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateTargetInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateTargetInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateTargetInstancesInput>
    public typealias MOutput = OperationOutput<TerminateTargetInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateTargetInstancesOutputError>
}

public struct TerminateTargetInstancesInput: Equatable {
    /// <p>Terminate Target instance by Source Server IDs.</p>
    public let sourceServerIDs: [String]?
    /// <p>Terminate Target instance by Tags.</p>
    public let tags: [String:String]?

    public init (
        sourceServerIDs: [String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

struct TerminateTargetInstancesInputBody: Equatable {
    public let sourceServerIDs: [String]?
    public let tags: [String:String]?
}

extension TerminateTargetInstancesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sourceServerIDs
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TerminateTargetInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateTargetInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TerminateTargetInstancesOutputError: Equatable {
    case conflictException(ConflictException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateTargetInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateTargetInstancesOutputResponse(job: \(String(describing: job)))"}
}

extension TerminateTargetInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TerminateTargetInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct TerminateTargetInstancesOutputResponse: Equatable {
    /// <p>Terminate Target instance Job response.</p>
    public let job: Job?

    public init (
        job: Job? = nil
    )
    {
        self.job = job
    }
}

struct TerminateTargetInstancesOutputResponseBody: Equatable {
    public let job: Job?
}

extension TerminateTargetInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), retryAfterSeconds: \(String(describing: retryAfterSeconds)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Reached throttling quota exception.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>Reached throttling quota exception.</p>
    public var quotaCode: String?
    /// <p>Reached throttling quota exception will retry after x seconds.</p>
    public var retryAfterSeconds: String?
    /// <p>Reached throttling quota exception service code.</p>
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        retryAfterSeconds: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
    public let serviceCode: String?
    public let quotaCode: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UninitializedAccountException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UninitializedAccountException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension UninitializedAccountException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UninitializedAccountExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unitialized account exception.</p>
public struct UninitializedAccountException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UninitializedAccountExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension UninitializedAccountExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>Untag resource by ARN.</p>
    public let resourceArn: String?
    /// <p>Untag resource by Keys.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLaunchConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLaunchConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLaunchConfigurationOutputError>
}

extension UpdateLaunchConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLaunchConfigurationInput(copyPrivateIp: \(String(describing: copyPrivateIp)), copyTags: \(String(describing: copyTags)), launchDisposition: \(String(describing: launchDisposition)), licensing: \(String(describing: licensing)), name: \(String(describing: name)), sourceServerID: \(String(describing: sourceServerID)), targetInstanceTypeRightSizingMethod: \(String(describing: targetInstanceTypeRightSizingMethod)))"}
}

extension UpdateLaunchConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case copyPrivateIp
        case copyTags
        case launchDisposition
        case licensing
        case name
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyPrivateIp = copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let launchDisposition = launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }
}

public struct UpdateLaunchConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLaunchConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLaunchConfigurationOutputError>
}

public struct UpdateLaunchConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLaunchConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLaunchConfigurationOutputError>
}

public struct UpdateLaunchConfigurationInput: Equatable {
    /// <p>Update Launch configuration copy Private IP request.</p>
    public let copyPrivateIp: Bool?
    /// <p>Update Launch configuration copy Tags request.</p>
    public let copyTags: Bool?
    /// <p>Update Launch configuration launch disposition request.</p>
    public let launchDisposition: LaunchDisposition?
    /// <p>Update Launch configuration licensing request.</p>
    public let licensing: Licensing?
    /// <p>Update Launch configuration name request.</p>
    public let name: String?
    /// <p>Update Launch configuration by Source Server ID request.</p>
    public let sourceServerID: String?
    /// <p>Update Launch configuration Target instance right sizing request.</p>
    public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

    public init (
        copyPrivateIp: Bool? = nil,
        copyTags: Bool? = nil,
        launchDisposition: LaunchDisposition? = nil,
        licensing: Licensing? = nil,
        name: String? = nil,
        sourceServerID: String? = nil,
        targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.name = name
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationInputBody: Equatable {
    public let sourceServerID: String?
    public let name: String?
    public let launchDisposition: LaunchDisposition?
    public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?
    public let copyPrivateIp: Bool?
    public let copyTags: Bool?
    public let licensing: Licensing?
}

extension UpdateLaunchConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case copyPrivateIp
        case copyTags
        case launchDisposition
        case licensing
        case name
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
    }
}

extension UpdateLaunchConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLaunchConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLaunchConfigurationOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLaunchConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLaunchConfigurationOutputResponse(copyPrivateIp: \(String(describing: copyPrivateIp)), copyTags: \(String(describing: copyTags)), ec2LaunchTemplateID: \(String(describing: ec2LaunchTemplateID)), launchDisposition: \(String(describing: launchDisposition)), licensing: \(String(describing: licensing)), name: \(String(describing: name)), sourceServerID: \(String(describing: sourceServerID)), targetInstanceTypeRightSizingMethod: \(String(describing: targetInstanceTypeRightSizingMethod)))"}
}

extension UpdateLaunchConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateLaunchConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.name = output.name
            self.sourceServerID = output.sourceServerID
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.name = nil
            self.sourceServerID = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct UpdateLaunchConfigurationOutputResponse: Equatable {
    /// <p>Copy Private IP during Launch Configuration.</p>
    public let copyPrivateIp: Bool?
    /// <p>Copy Tags during Launch Configuration.</p>
    public let copyTags: Bool?
    /// <p>Configure EC2 lauch configuration template ID.</p>
    public let ec2LaunchTemplateID: String?
    /// <p>Configure launch dispostion for launch configuration.</p>
    public let launchDisposition: LaunchDisposition?
    /// <p>Configure launch configuration OS licensing.</p>
    public let licensing: Licensing?
    /// <p>Configure launch configuration name.</p>
    public let name: String?
    /// <p>Configure launch configuration Source Server ID.</p>
    public let sourceServerID: String?
    /// <p>Configure launch configuration Target instance type right sizing method.</p>
    public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?

    public init (
        copyPrivateIp: Bool? = nil,
        copyTags: Bool? = nil,
        ec2LaunchTemplateID: String? = nil,
        launchDisposition: LaunchDisposition? = nil,
        licensing: Licensing? = nil,
        name: String? = nil,
        sourceServerID: String? = nil,
        targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.name = name
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationOutputResponseBody: Equatable {
    public let sourceServerID: String?
    public let name: String?
    public let ec2LaunchTemplateID: String?
    public let launchDisposition: LaunchDisposition?
    public let targetInstanceTypeRightSizingMethod: TargetInstanceTypeRightSizingMethod?
    public let copyPrivateIp: Bool?
    public let copyTags: Bool?
    public let licensing: Licensing?
}

extension UpdateLaunchConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case launchDisposition
        case licensing
        case name
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
    }
}

public struct UpdateReplicationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateReplicationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReplicationConfigurationOutputError>
}

extension UpdateReplicationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReplicationConfigurationInput(associateDefaultSecurityGroup: \(String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(String(describing: bandwidthThrottling)), createPublicIP: \(String(describing: createPublicIP)), dataPlaneRouting: \(String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(String(describing: ebsEncryptionKeyArn)), name: \(String(describing: name)), replicatedDisks: \(String(describing: replicatedDisks)), replicationServerInstanceType: \(String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(String(describing: sourceServerID)), stagingAreaSubnetId: \(String(describing: stagingAreaSubnetId)), stagingAreaTags: \(String(describing: stagingAreaTags)), useDedicatedReplicationServer: \(String(describing: useDedicatedReplicationServer)))"}
}

extension UpdateReplicationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associateDefaultSecurityGroup = associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for replicationconfigurationreplicateddisks0 in replicatedDisks {
                try replicatedDisksContainer.encode(replicationconfigurationreplicateddisks0)
            }
        }
        if let replicationServerInstanceType = replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for replicationserverssecuritygroupsids0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(replicationserverssecuritygroupsids0)
            }
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let stagingAreaSubnetId = stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsmap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

public struct UpdateReplicationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateReplicationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReplicationConfigurationOutputError>
}

public struct UpdateReplicationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateReplicationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReplicationConfigurationOutputError>
}

public struct UpdateReplicationConfigurationInput: Equatable {
    /// <p>Update replication configuration associate default Application Migration Service Security group request.</p>
    public let associateDefaultSecurityGroup: Bool?
    /// <p>Update replication configuration bandwidth throttling request.</p>
    public let bandwidthThrottling: Int
    /// <p>Update replication configuration create Public IP request.</p>
    public let createPublicIP: Bool?
    /// <p>Update replication configuration data plane routing request.</p>
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    /// <p>Update replication configuration use default large Staging Disk type request.</p>
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    /// <p>Update replication configuration EBS encryption request.</p>
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    /// <p>Update replication configuration EBS encryption key ARN request.</p>
    public let ebsEncryptionKeyArn: String?
    /// <p>Update replication configuration name request.</p>
    public let name: String?
    /// <p>Update replication configuration replicated disks request.</p>
    public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
    /// <p>Update replication configuration Replication Server instance type request.</p>
    public let replicationServerInstanceType: String?
    /// <p>Update replication configuration Replication Server Security Groups IDs request.</p>
    public let replicationServersSecurityGroupsIDs: [String]?
    /// <p>Update replication configuration Source Server ID request.</p>
    public let sourceServerID: String?
    /// <p>Update replication configuration Staging Area subnet request.</p>
    public let stagingAreaSubnetId: String?
    /// <p>Update replication configuration Staging Area Tags request.</p>
    public let stagingAreaTags: [String:String]?
    /// <p>Update replication configuration use dedicated Replication Server request.</p>
    public let useDedicatedReplicationServer: Bool?

    public init (
        associateDefaultSecurityGroup: Bool? = nil,
        bandwidthThrottling: Int = 0,
        createPublicIP: Bool? = nil,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: String? = nil,
        name: String? = nil,
        replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: String? = nil,
        replicationServersSecurityGroupsIDs: [String]? = nil,
        sourceServerID: String? = nil,
        stagingAreaSubnetId: String? = nil,
        stagingAreaTags: [String:String]? = nil,
        useDedicatedReplicationServer: Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationInputBody: Equatable {
    public let sourceServerID: String?
    public let name: String?
    public let stagingAreaSubnetId: String?
    public let associateDefaultSecurityGroup: Bool?
    public let replicationServersSecurityGroupsIDs: [String]?
    public let replicationServerInstanceType: String?
    public let useDedicatedReplicationServer: Bool?
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    public let ebsEncryptionKeyArn: String?
    public let bandwidthThrottling: Int
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    public let createPublicIP: Bool?
    public let stagingAreaTags: [String:String]?
}

extension UpdateReplicationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [String:String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
    }
}

extension UpdateReplicationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReplicationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReplicationConfigurationOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReplicationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReplicationConfigurationOutputResponse(associateDefaultSecurityGroup: \(String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(String(describing: bandwidthThrottling)), createPublicIP: \(String(describing: createPublicIP)), dataPlaneRouting: \(String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(String(describing: ebsEncryptionKeyArn)), name: \(String(describing: name)), replicatedDisks: \(String(describing: replicatedDisks)), replicationServerInstanceType: \(String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(String(describing: sourceServerID)), stagingAreaSubnetId: \(String(describing: stagingAreaSubnetId)), stagingAreaTags: \(String(describing: stagingAreaTags)), useDedicatedReplicationServer: \(String(describing: useDedicatedReplicationServer)))"}
}

extension UpdateReplicationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateReplicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.name = output.name
            self.replicatedDisks = output.replicatedDisks
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.sourceServerID = output.sourceServerID
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.name = nil
            self.replicatedDisks = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.sourceServerID = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct UpdateReplicationConfigurationOutputResponse: Equatable {
    /// <p>Replication Configuration associate default Application Migration Service Security Group.</p>
    public let associateDefaultSecurityGroup: Bool?
    /// <p>Replication Configuration set bandwidth throttling.</p>
    public let bandwidthThrottling: Int
    /// <p>Replication Configuration create Public IP.</p>
    public let createPublicIP: Bool?
    /// <p>Replication Configuration data plane routing.</p>
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    /// <p>Replication Configuration use default large Staging Disks.</p>
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    /// <p>Replication Configuration EBS encryption.</p>
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    /// <p>Replication Configuration EBS encryption key ARN.</p>
    public let ebsEncryptionKeyArn: String?
    /// <p>Replication Configuration name.</p>
    public let name: String?
    /// <p>Replication Configuration replicated disks.</p>
    public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
    /// <p>Replication Configuration Replication Server instance type.</p>
    public let replicationServerInstanceType: String?
    /// <p>Replication Configuration Replication Server Security Group IDs.</p>
    public let replicationServersSecurityGroupsIDs: [String]?
    /// <p>Replication Configuration Source Server ID.</p>
    public let sourceServerID: String?
    /// <p>Replication Configuration Staging Area subnet ID.</p>
    public let stagingAreaSubnetId: String?
    /// <p>Replication Configuration Staging Area tags.</p>
    public let stagingAreaTags: [String:String]?
    /// <p>Replication Configuration use Dedicated Replication Server.</p>
    public let useDedicatedReplicationServer: Bool?

    public init (
        associateDefaultSecurityGroup: Bool? = nil,
        bandwidthThrottling: Int = 0,
        createPublicIP: Bool? = nil,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: String? = nil,
        name: String? = nil,
        replicatedDisks: [ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: String? = nil,
        replicationServersSecurityGroupsIDs: [String]? = nil,
        sourceServerID: String? = nil,
        stagingAreaSubnetId: String? = nil,
        stagingAreaTags: [String:String]? = nil,
        useDedicatedReplicationServer: Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationOutputResponseBody: Equatable {
    public let sourceServerID: String?
    public let name: String?
    public let stagingAreaSubnetId: String?
    public let associateDefaultSecurityGroup: Bool?
    public let replicationServersSecurityGroupsIDs: [String]?
    public let replicationServerInstanceType: String?
    public let useDedicatedReplicationServer: Bool?
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    public let replicatedDisks: [ReplicationConfigurationReplicatedDisk]?
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    public let ebsEncryptionKeyArn: String?
    public let bandwidthThrottling: Int
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    public let createPublicIP: Bool?
    public let stagingAreaTags: [String:String]?
}

extension UpdateReplicationConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [String:String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
    }
}

public struct UpdateReplicationConfigurationTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateReplicationConfigurationTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReplicationConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReplicationConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReplicationConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<UpdateReplicationConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReplicationConfigurationTemplateOutputError>
}

extension UpdateReplicationConfigurationTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReplicationConfigurationTemplateInput(arn: \(String(describing: arn)), associateDefaultSecurityGroup: \(String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(String(describing: bandwidthThrottling)), createPublicIP: \(String(describing: createPublicIP)), dataPlaneRouting: \(String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(String(describing: stagingAreaSubnetId)), stagingAreaTags: \(String(describing: stagingAreaTags)), useDedicatedReplicationServer: \(String(describing: useDedicatedReplicationServer)))"}
}

extension UpdateReplicationConfigurationTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associateDefaultSecurityGroup = associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let replicationConfigurationTemplateID = replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
        if let replicationServerInstanceType = replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for replicationserverssecuritygroupsids0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(replicationserverssecuritygroupsids0)
            }
        }
        if let stagingAreaSubnetId = stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsmap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

public struct UpdateReplicationConfigurationTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateReplicationConfigurationTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReplicationConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReplicationConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReplicationConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<UpdateReplicationConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReplicationConfigurationTemplateOutputError>
}

public struct UpdateReplicationConfigurationTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateReplicationConfigurationTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReplicationConfigurationTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReplicationConfigurationTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReplicationConfigurationTemplateInput>
    public typealias MOutput = OperationOutput<UpdateReplicationConfigurationTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReplicationConfigurationTemplateOutputError>
}

public struct UpdateReplicationConfigurationTemplateInput: Equatable {
    /// <p>Update replication configuration template ARN request.</p>
    public let arn: String?
    /// <p>Update replication configuration template associate default Application Migration Service Security group request.</p>
    public let associateDefaultSecurityGroup: Bool?
    /// <p>Update replication configuration template bandwidth throttling request.</p>
    public let bandwidthThrottling: Int
    /// <p>Update replication configuration template create Public IP request.</p>
    public let createPublicIP: Bool?
    /// <p>Update replication configuration template data plane routing request.</p>
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    /// <p>Update replication configuration template use default large Staging Disk type request.</p>
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    /// <p>Update replication configuration template EBS encryption request.</p>
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    /// <p>Update replication configuration template EBS encryption key ARN request.</p>
    public let ebsEncryptionKeyArn: String?
    /// <p>Update replication configuration template template ID request.</p>
    public let replicationConfigurationTemplateID: String?
    /// <p>Update replication configuration template Replication Server instance type request.</p>
    public let replicationServerInstanceType: String?
    /// <p>Update replication configuration template Replication Server Security groups IDs request.</p>
    public let replicationServersSecurityGroupsIDs: [String]?
    /// <p>Update replication configuration template Staging Area subnet ID request.</p>
    public let stagingAreaSubnetId: String?
    /// <p>Update replication configuration template Staging Area Tags request.</p>
    public let stagingAreaTags: [String:String]?
    /// <p>Update replication configuration template use dedicated Replication Server request.</p>
    public let useDedicatedReplicationServer: Bool?

    public init (
        arn: String? = nil,
        associateDefaultSecurityGroup: Bool? = nil,
        bandwidthThrottling: Int = 0,
        createPublicIP: Bool? = nil,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: String? = nil,
        replicationConfigurationTemplateID: String? = nil,
        replicationServerInstanceType: String? = nil,
        replicationServersSecurityGroupsIDs: [String]? = nil,
        stagingAreaSubnetId: String? = nil,
        stagingAreaTags: [String:String]? = nil,
        useDedicatedReplicationServer: Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationTemplateInputBody: Equatable {
    public let replicationConfigurationTemplateID: String?
    public let arn: String?
    public let stagingAreaSubnetId: String?
    public let associateDefaultSecurityGroup: Bool?
    public let replicationServersSecurityGroupsIDs: [String]?
    public let replicationServerInstanceType: String?
    public let useDedicatedReplicationServer: Bool?
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    public let ebsEncryptionKeyArn: String?
    public let bandwidthThrottling: Int
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    public let createPublicIP: Bool?
    public let stagingAreaTags: [String:String]?
}

extension UpdateReplicationConfigurationTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [String:String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
    }
}

extension UpdateReplicationConfigurationTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReplicationConfigurationTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReplicationConfigurationTemplateOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReplicationConfigurationTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReplicationConfigurationTemplateOutputResponse(arn: \(String(describing: arn)), associateDefaultSecurityGroup: \(String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(String(describing: bandwidthThrottling)), createPublicIP: \(String(describing: createPublicIP)), dataPlaneRouting: \(String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(String(describing: stagingAreaSubnetId)), stagingAreaTags: \(String(describing: stagingAreaTags)), tags: \(String(describing: tags)), useDedicatedReplicationServer: \(String(describing: useDedicatedReplicationServer)))"}
}

extension UpdateReplicationConfigurationTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateReplicationConfigurationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = output.replicationConfigurationTemplateID
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.tags = output.tags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.arn = nil
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.replicationConfigurationTemplateID = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.tags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct UpdateReplicationConfigurationTemplateOutputResponse: Equatable {
    /// <p>Replication Configuration template ARN.</p>
    public let arn: String?
    /// <p>Replication Configuration template associate default Application Migration Service Security group.</p>
    public let associateDefaultSecurityGroup: Bool?
    /// <p>Replication Configuration template bandwidth throtting.</p>
    public let bandwidthThrottling: Int
    /// <p>Replication Configuration template create Public IP.</p>
    public let createPublicIP: Bool?
    /// <p>Replication Configuration template data plane routing.</p>
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    /// <p>Replication Configuration template use dedault large Staging Disk type.</p>
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    /// <p>Replication Configuration template EBS encryption.</p>
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    /// <p>Replication Configuration template EBS encryption key ARN.</p>
    public let ebsEncryptionKeyArn: String?
    /// <p>Replication Configuration template template ID.</p>
    public let replicationConfigurationTemplateID: String?
    /// <p>Replication Configuration template server instance type.</p>
    public let replicationServerInstanceType: String?
    /// <p>Replication Configuration template server Security Groups IDs.</p>
    public let replicationServersSecurityGroupsIDs: [String]?
    /// <p>Replication Configuration template Staging Area subnet ID.</p>
    public let stagingAreaSubnetId: String?
    /// <p>Replication Configuration template Staging Area Tags.</p>
    public let stagingAreaTags: [String:String]?
    /// <p>Replication Configuration template Tags.</p>
    public let tags: [String:String]?
    /// <p>Replication Configuration template use Dedicated Replication Server.</p>
    public let useDedicatedReplicationServer: Bool?

    public init (
        arn: String? = nil,
        associateDefaultSecurityGroup: Bool? = nil,
        bandwidthThrottling: Int = 0,
        createPublicIP: Bool? = nil,
        dataPlaneRouting: ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: String? = nil,
        replicationConfigurationTemplateID: String? = nil,
        replicationServerInstanceType: String? = nil,
        replicationServersSecurityGroupsIDs: [String]? = nil,
        stagingAreaSubnetId: String? = nil,
        stagingAreaTags: [String:String]? = nil,
        tags: [String:String]? = nil,
        useDedicatedReplicationServer: Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationTemplateOutputResponseBody: Equatable {
    public let replicationConfigurationTemplateID: String?
    public let arn: String?
    public let stagingAreaSubnetId: String?
    public let associateDefaultSecurityGroup: Bool?
    public let replicationServersSecurityGroupsIDs: [String]?
    public let replicationServerInstanceType: String?
    public let useDedicatedReplicationServer: Bool?
    public let defaultLargeStagingDiskType: ReplicationConfigurationDefaultLargeStagingDiskType?
    public let ebsEncryption: ReplicationConfigurationEbsEncryption?
    public let ebsEncryptionKeyArn: String?
    public let bandwidthThrottling: Int
    public let dataPlaneRouting: ReplicationConfigurationDataPlaneRouting?
    public let createPublicIP: Bool?
    public let stagingAreaTags: [String:String]?
    public let tags: [String:String]?
}

extension UpdateReplicationConfigurationTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [String:String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(code: \(String(describing: code)), fieldList: \(String(describing: fieldList)), message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.code = nil
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Validate exception.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    /// <p>Validate exception field list.</p>
    public var fieldList: [ValidationExceptionField]?
    public var message: String?
    /// <p>Validate exception reason.</p>
    public var reason: ValidationExceptionReason?

    public init (
        code: String? = nil,
        fieldList: [ValidationExceptionField]? = nil,
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.code = code
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let code: String?
    public let reason: ValidationExceptionReason?
    public let fieldList: [ValidationExceptionField]?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension ValidationExceptionField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationExceptionField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationExceptionField(message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>Validate exception field.</p>
public struct ValidationExceptionField: Equatable {
    /// <p>Validate exception field message.</p>
    public let message: String?
    /// <p>Validate exception field name.</p>
    public let name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

public enum ValidationExceptionReason {
    case cannotParse
    case fieldValidationFailed
    case other
    case unknownOperation
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .cannotParse,
            .fieldValidationFailed,
            .other,
            .unknownOperation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cannotParse: return "cannotParse"
        case .fieldValidationFailed: return "fieldValidationFailed"
        case .other: return "other"
        case .unknownOperation: return "unknownOperation"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}
