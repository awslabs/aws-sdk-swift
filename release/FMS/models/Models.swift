// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AccountRoleStatus {
    case creating
    case deleted
    case deleting
    case pendingdeletion
    case ready
    case sdkUnknown(String)
}

extension AccountRoleStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccountRoleStatus] {
        return [
            .creating,
            .deleted,
            .deleting,
            .pendingdeletion,
            .ready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creating: return "CREATING"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case .pendingdeletion: return "PENDING_DELETION"
        case .ready: return "READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccountRoleStatus(rawValue: rawValue) ?? AccountRoleStatus.sdkUnknown(rawValue)
    }
}

extension App: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appName = "AppName"
        case port = "Port"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appName = appName {
            try encodeContainer.encode(appName, forKey: .appName)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appName)
        appName = appNameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
    }
}

extension App: CustomDebugStringConvertible {
    public var debugDescription: String {
        "App(appName: \(String(describing: appName)), port: \(String(describing: port)), protocol: \(String(describing: `protocol`)))"}
}

/// <p>An individual AWS Firewall Manager application.</p>
public struct App: Equatable {
    /// <p>The IP protocol name or number. The name can be one of <code>tcp</code>, <code>udp</code>, or <code>icmp</code>. For information on possible numbers, see <a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>.</p>
    public let `protocol`: String?
    /// <p>The application's name.</p>
    public let appName: String?
    /// <p>The application's port number, for example <code>80</code>.</p>
    public let port: Int?

    public init (
        `protocol`: String? = nil,
        appName: String? = nil,
        port: Int? = nil
    )
    {
        self.`protocol` = `protocol`
        self.appName = appName
        self.port = port
    }
}

extension AppsListData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appsList = "AppsList"
        case createTime = "CreateTime"
        case lastUpdateTime = "LastUpdateTime"
        case listId = "ListId"
        case listName = "ListName"
        case listUpdateToken = "ListUpdateToken"
        case previousAppsList = "PreviousAppsList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsList = appsList {
            var appsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appsList)
            for appslist0 in appsList {
                try appsListContainer.encode(appslist0)
            }
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
        if let listName = listName {
            try encodeContainer.encode(listName, forKey: .listName)
        }
        if let listUpdateToken = listUpdateToken {
            try encodeContainer.encode(listUpdateToken, forKey: .listUpdateToken)
        }
        if let previousAppsList = previousAppsList {
            var previousAppsListContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .previousAppsList)
            for (dictKey0, previousappslist0) in previousAppsList {
                try previousAppsListContainer.encode(previousappslist0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listId)
        listId = listIdDecoded
        let listNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listName)
        listName = listNameDecoded
        let listUpdateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listUpdateToken)
        listUpdateToken = listUpdateTokenDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let appsListContainer = try containerValues.decodeIfPresent([App?].self, forKey: .appsList)
        var appsListDecoded0:[App]? = nil
        if let appsListContainer = appsListContainer {
            appsListDecoded0 = [App]()
            for structure0 in appsListContainer {
                if let structure0 = structure0 {
                    appsListDecoded0?.append(structure0)
                }
            }
        }
        appsList = appsListDecoded0
        let previousAppsListContainer = try containerValues.decodeIfPresent([String: [App?]?].self, forKey: .previousAppsList)
        var previousAppsListDecoded0: [String:[App]]? = nil
        if let previousAppsListContainer = previousAppsListContainer {
            previousAppsListDecoded0 = [String:[App]]()
            for (key0, appslist0) in previousAppsListContainer {
                var appslist0Decoded0: [App]? = nil
                if let appslist0 = appslist0 {
                    appslist0Decoded0 = [App]()
                    for structure1 in appslist0 {
                        if let structure1 = structure1 {
                            appslist0Decoded0?.append(structure1)
                        }
                    }
                }
                previousAppsListDecoded0?[key0] = appslist0Decoded0
            }
        }
        previousAppsList = previousAppsListDecoded0
    }
}

extension AppsListData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AppsListData(appsList: \(String(describing: appsList)), createTime: \(String(describing: createTime)), lastUpdateTime: \(String(describing: lastUpdateTime)), listId: \(String(describing: listId)), listName: \(String(describing: listName)), listUpdateToken: \(String(describing: listUpdateToken)), previousAppsList: \(String(describing: previousAppsList)))"}
}

/// <p>An AWS Firewall Manager applications list.</p>
public struct AppsListData: Equatable {
    /// <p>An array of applications in the AWS Firewall Manager applications list.</p>
    public let appsList: [App]?
    /// <p>The time that the AWS Firewall Manager applications list was created.</p>
    public let createTime: Date?
    /// <p>The time that the AWS Firewall Manager applications list was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The ID of the AWS Firewall Manager applications list.</p>
    public let listId: String?
    /// <p>The name of the AWS Firewall Manager applications list.</p>
    public let listName: String?
    /// <p>A unique identifier for each update to the list. When you update
    ///         the list, the update token must match the token of the current version of the application list.
    ///         You can retrieve the update token by getting the list. </p>
    public let listUpdateToken: String?
    /// <p>A map of previous version numbers to their corresponding <code>App</code> object arrays.</p>
    public let previousAppsList: [String:[App]]?

    public init (
        appsList: [App]? = nil,
        createTime: Date? = nil,
        lastUpdateTime: Date? = nil,
        listId: String? = nil,
        listName: String? = nil,
        listUpdateToken: String? = nil,
        previousAppsList: [String:[App]]? = nil
    )
    {
        self.appsList = appsList
        self.createTime = createTime
        self.lastUpdateTime = lastUpdateTime
        self.listId = listId
        self.listName = listName
        self.listUpdateToken = listUpdateToken
        self.previousAppsList = previousAppsList
    }
}

extension AppsListDataSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appsList = "AppsList"
        case listArn = "ListArn"
        case listId = "ListId"
        case listName = "ListName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsList = appsList {
            var appsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appsList)
            for appslist0 in appsList {
                try appsListContainer.encode(appslist0)
            }
        }
        if let listArn = listArn {
            try encodeContainer.encode(listArn, forKey: .listArn)
        }
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
        if let listName = listName {
            try encodeContainer.encode(listName, forKey: .listName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listArn)
        listArn = listArnDecoded
        let listIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listId)
        listId = listIdDecoded
        let listNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listName)
        listName = listNameDecoded
        let appsListContainer = try containerValues.decodeIfPresent([App?].self, forKey: .appsList)
        var appsListDecoded0:[App]? = nil
        if let appsListContainer = appsListContainer {
            appsListDecoded0 = [App]()
            for structure0 in appsListContainer {
                if let structure0 = structure0 {
                    appsListDecoded0?.append(structure0)
                }
            }
        }
        appsList = appsListDecoded0
    }
}

extension AppsListDataSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AppsListDataSummary(appsList: \(String(describing: appsList)), listArn: \(String(describing: listArn)), listId: \(String(describing: listId)), listName: \(String(describing: listName)))"}
}

/// <p>Details of the AWS Firewall Manager applications list.</p>
public struct AppsListDataSummary: Equatable {
    /// <p>An array of <code>App</code> objects in the AWS Firewall Manager applications list.</p>
    public let appsList: [App]?
    /// <p>The Amazon Resource Name (ARN) of the applications list.</p>
    public let listArn: String?
    /// <p>The ID of the applications list.</p>
    public let listId: String?
    /// <p>The name of the applications list.</p>
    public let listName: String?

    public init (
        appsList: [App]? = nil,
        listArn: String? = nil,
        listId: String? = nil,
        listName: String? = nil
    )
    {
        self.appsList = appsList
        self.listArn = listArn
        self.listId = listId
        self.listName = listName
    }
}

public struct AssociateAdminAccountInputBodyMiddleware: Middleware {
    public let id: String = "AssociateAdminAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAdminAccountInput>
    public typealias MOutput = OperationOutput<AssociateAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAdminAccountOutputError>
}

extension AssociateAdminAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateAdminAccountInput(adminAccount: \(String(describing: adminAccount)))"}
}

extension AssociateAdminAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminAccount = "AdminAccount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccount = adminAccount {
            try encodeContainer.encode(adminAccount, forKey: .adminAccount)
        }
    }
}

public struct AssociateAdminAccountInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateAdminAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAdminAccountInput>
    public typealias MOutput = OperationOutput<AssociateAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAdminAccountOutputError>
}

public struct AssociateAdminAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateAdminAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAdminAccountInput>
    public typealias MOutput = OperationOutput<AssociateAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAdminAccountOutputError>
}

public struct AssociateAdminAccountInput: Equatable {
    /// <p>The AWS account ID to associate with AWS Firewall Manager as the AWS Firewall Manager
    ///       administrator account. This can be an AWS Organizations master account or a member account.
    ///         For more information about AWS Organizations and master accounts, see
    ///         <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_accounts.html">Managing the AWS Accounts in Your Organization</a>.  </p>
    public let adminAccount: String?

    public init (
        adminAccount: String? = nil
    )
    {
        self.adminAccount = adminAccount
    }
}

struct AssociateAdminAccountInputBody: Equatable {
    public let adminAccount: String?
}

extension AssociateAdminAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccount = "AdminAccount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccount)
        adminAccount = adminAccountDecoded
    }
}

extension AssociateAdminAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAdminAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateAdminAccountOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAdminAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateAdminAccountOutputResponse()"}
}

extension AssociateAdminAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateAdminAccountOutputResponse: Equatable {

    public init() {}
}

struct AssociateAdminAccountOutputResponseBody: Equatable {
}

extension AssociateAdminAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AwsEc2InstanceViolation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsEc2NetworkInterfaceViolations = "AwsEc2NetworkInterfaceViolations"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsEc2NetworkInterfaceViolations = awsEc2NetworkInterfaceViolations {
            var awsEc2NetworkInterfaceViolationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsEc2NetworkInterfaceViolations)
            for awsec2networkinterfaceviolations0 in awsEc2NetworkInterfaceViolations {
                try awsEc2NetworkInterfaceViolationsContainer.encode(awsec2networkinterfaceviolations0)
            }
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let awsEc2NetworkInterfaceViolationsContainer = try containerValues.decodeIfPresent([AwsEc2NetworkInterfaceViolation?].self, forKey: .awsEc2NetworkInterfaceViolations)
        var awsEc2NetworkInterfaceViolationsDecoded0:[AwsEc2NetworkInterfaceViolation]? = nil
        if let awsEc2NetworkInterfaceViolationsContainer = awsEc2NetworkInterfaceViolationsContainer {
            awsEc2NetworkInterfaceViolationsDecoded0 = [AwsEc2NetworkInterfaceViolation]()
            for structure0 in awsEc2NetworkInterfaceViolationsContainer {
                if let structure0 = structure0 {
                    awsEc2NetworkInterfaceViolationsDecoded0?.append(structure0)
                }
            }
        }
        awsEc2NetworkInterfaceViolations = awsEc2NetworkInterfaceViolationsDecoded0
    }
}

extension AwsEc2InstanceViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2InstanceViolation(awsEc2NetworkInterfaceViolations: \(String(describing: awsEc2NetworkInterfaceViolations)), violationTarget: \(String(describing: violationTarget)))"}
}

/// <p>Violations for an EC2 instance resource.</p>
public struct AwsEc2InstanceViolation: Equatable {
    /// <p>Violations for network interfaces associated with the EC2 instance.</p>
    public let awsEc2NetworkInterfaceViolations: [AwsEc2NetworkInterfaceViolation]?
    /// <p>The resource ID of the EC2 instance.</p>
    public let violationTarget: String?

    public init (
        awsEc2NetworkInterfaceViolations: [AwsEc2NetworkInterfaceViolation]? = nil,
        violationTarget: String? = nil
    )
    {
        self.awsEc2NetworkInterfaceViolations = awsEc2NetworkInterfaceViolations
        self.violationTarget = violationTarget
    }
}

extension AwsEc2NetworkInterfaceViolation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case violatingSecurityGroups = "ViolatingSecurityGroups"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let violatingSecurityGroups = violatingSecurityGroups {
            var violatingSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violatingSecurityGroups)
            for resourceidlist0 in violatingSecurityGroups {
                try violatingSecurityGroupsContainer.encode(resourceidlist0)
            }
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violatingSecurityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .violatingSecurityGroups)
        var violatingSecurityGroupsDecoded0:[String]? = nil
        if let violatingSecurityGroupsContainer = violatingSecurityGroupsContainer {
            violatingSecurityGroupsDecoded0 = [String]()
            for string0 in violatingSecurityGroupsContainer {
                if let string0 = string0 {
                    violatingSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        violatingSecurityGroups = violatingSecurityGroupsDecoded0
    }
}

extension AwsEc2NetworkInterfaceViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsEc2NetworkInterfaceViolation(violatingSecurityGroups: \(String(describing: violatingSecurityGroups)), violationTarget: \(String(describing: violationTarget)))"}
}

/// <p>Violations for network interfaces associated with an EC2 instance.</p>
public struct AwsEc2NetworkInterfaceViolation: Equatable {
    /// <p>List of security groups that violate the rules specified in the master security group of the AWS Firewall Manager policy.</p>
    public let violatingSecurityGroups: [String]?
    /// <p>The resource ID of the network interface.</p>
    public let violationTarget: String?

    public init (
        violatingSecurityGroups: [String]? = nil,
        violationTarget: String? = nil
    )
    {
        self.violatingSecurityGroups = violatingSecurityGroups
        self.violationTarget = violationTarget
    }
}

extension AwsVPCSecurityGroupViolation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case partialMatches = "PartialMatches"
        case possibleSecurityGroupRemediationActions = "PossibleSecurityGroupRemediationActions"
        case violationTarget = "ViolationTarget"
        case violationTargetDescription = "ViolationTargetDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let partialMatches = partialMatches {
            var partialMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partialMatches)
            for partialmatches0 in partialMatches {
                try partialMatchesContainer.encode(partialmatches0)
            }
        }
        if let possibleSecurityGroupRemediationActions = possibleSecurityGroupRemediationActions {
            var possibleSecurityGroupRemediationActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .possibleSecurityGroupRemediationActions)
            for securitygroupremediationactions0 in possibleSecurityGroupRemediationActions {
                try possibleSecurityGroupRemediationActionsContainer.encode(securitygroupremediationactions0)
            }
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let violationTargetDescription = violationTargetDescription {
            try encodeContainer.encode(violationTargetDescription, forKey: .violationTargetDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violationTargetDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTargetDescription)
        violationTargetDescription = violationTargetDescriptionDecoded
        let partialMatchesContainer = try containerValues.decodeIfPresent([PartialMatch?].self, forKey: .partialMatches)
        var partialMatchesDecoded0:[PartialMatch]? = nil
        if let partialMatchesContainer = partialMatchesContainer {
            partialMatchesDecoded0 = [PartialMatch]()
            for structure0 in partialMatchesContainer {
                if let structure0 = structure0 {
                    partialMatchesDecoded0?.append(structure0)
                }
            }
        }
        partialMatches = partialMatchesDecoded0
        let possibleSecurityGroupRemediationActionsContainer = try containerValues.decodeIfPresent([SecurityGroupRemediationAction?].self, forKey: .possibleSecurityGroupRemediationActions)
        var possibleSecurityGroupRemediationActionsDecoded0:[SecurityGroupRemediationAction]? = nil
        if let possibleSecurityGroupRemediationActionsContainer = possibleSecurityGroupRemediationActionsContainer {
            possibleSecurityGroupRemediationActionsDecoded0 = [SecurityGroupRemediationAction]()
            for structure0 in possibleSecurityGroupRemediationActionsContainer {
                if let structure0 = structure0 {
                    possibleSecurityGroupRemediationActionsDecoded0?.append(structure0)
                }
            }
        }
        possibleSecurityGroupRemediationActions = possibleSecurityGroupRemediationActionsDecoded0
    }
}

extension AwsVPCSecurityGroupViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsVPCSecurityGroupViolation(partialMatches: \(String(describing: partialMatches)), possibleSecurityGroupRemediationActions: \(String(describing: possibleSecurityGroupRemediationActions)), violationTarget: \(String(describing: violationTarget)), violationTargetDescription: \(String(describing: violationTargetDescription)))"}
}

/// <p>Details of the rule violation in a security group when compared to the master security group of the AWS Firewall Manager policy.</p>
public struct AwsVPCSecurityGroupViolation: Equatable {
    /// <p>List of rules specified in the security group of the AWS Firewall Manager policy that partially match the <code>ViolationTarget</code> rule.</p>
    public let partialMatches: [PartialMatch]?
    /// <p>Remediation options for the rule specified in the <code>ViolationTarget</code>.</p>
    public let possibleSecurityGroupRemediationActions: [SecurityGroupRemediationAction]?
    /// <p>The security group rule that is being evaluated.</p>
    public let violationTarget: String?
    /// <p>A description of the security group that violates the policy.</p>
    public let violationTargetDescription: String?

    public init (
        partialMatches: [PartialMatch]? = nil,
        possibleSecurityGroupRemediationActions: [SecurityGroupRemediationAction]? = nil,
        violationTarget: String? = nil,
        violationTargetDescription: String? = nil
    )
    {
        self.partialMatches = partialMatches
        self.possibleSecurityGroupRemediationActions = possibleSecurityGroupRemediationActions
        self.violationTarget = violationTarget
        self.violationTargetDescription = violationTargetDescription
    }
}

extension ComplianceViolator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case violationReason = "ViolationReason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let violationReason = violationReason {
            try encodeContainer.encode(violationReason.rawValue, forKey: .violationReason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let violationReasonDecoded = try containerValues.decodeIfPresent(ViolationReason.self, forKey: .violationReason)
        violationReason = violationReasonDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ComplianceViolator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceViolator(resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), violationReason: \(String(describing: violationReason)))"}
}

/// <p>Details of the resource that is not protected by the policy.</p>
public struct ComplianceViolator: Equatable {
    /// <p>The resource ID.</p>
    public let resourceId: String?
    /// <p>The resource type. This is in the format shown in the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a>. For example:
    ///         <code>AWS::ElasticLoadBalancingV2::LoadBalancer</code>,
    ///         <code>AWS::CloudFront::Distribution</code>, or
    ///         <code>AWS::NetworkFirewall::FirewallPolicy</code>.</p>
    public let resourceType: String?
    /// <p>The reason that the resource is not protected by the policy.</p>
    public let violationReason: ViolationReason?

    public init (
        resourceId: String? = nil,
        resourceType: String? = nil,
        violationReason: ViolationReason? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.violationReason = violationReason
    }
}

public enum CustomerPolicyScopeIdType {
    case account
    case orgUnit
    case sdkUnknown(String)
}

extension CustomerPolicyScopeIdType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomerPolicyScopeIdType] {
        return [
            .account,
            .orgUnit,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .account: return "ACCOUNT"
        case .orgUnit: return "ORG_UNIT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomerPolicyScopeIdType(rawValue: rawValue) ?? CustomerPolicyScopeIdType.sdkUnknown(rawValue)
    }
}

public struct DeleteAppsListInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAppsListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppsListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppsListInput>
    public typealias MOutput = OperationOutput<DeleteAppsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppsListOutputError>
}

extension DeleteAppsListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppsListInput(listId: \(String(describing: listId)))"}
}

extension DeleteAppsListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listId = "ListId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
    }
}

public struct DeleteAppsListInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAppsListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppsListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppsListInput>
    public typealias MOutput = OperationOutput<DeleteAppsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppsListOutputError>
}

public struct DeleteAppsListInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAppsListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppsListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppsListInput>
    public typealias MOutput = OperationOutput<DeleteAppsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppsListOutputError>
}

public struct DeleteAppsListInput: Equatable {
    /// <p>The ID of the applications list that you want to delete. You can retrieve this ID from
    ///       <code>PutAppsList</code>, <code>ListAppsLists</code>, and <code>GetAppsList</code>.</p>
    public let listId: String?

    public init (
        listId: String? = nil
    )
    {
        self.listId = listId
    }
}

struct DeleteAppsListInputBody: Equatable {
    public let listId: String?
}

extension DeleteAppsListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listId = "ListId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listId)
        listId = listIdDecoded
    }
}

extension DeleteAppsListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppsListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppsListOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppsListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppsListOutputResponse()"}
}

extension DeleteAppsListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppsListOutputResponse: Equatable {

    public init() {}
}

struct DeleteAppsListOutputResponseBody: Equatable {
}

extension DeleteAppsListOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteNotificationChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNotificationChannelInput()"}
}

extension DeleteNotificationChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteNotificationChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteNotificationChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNotificationChannelInput>
    public typealias MOutput = OperationOutput<DeleteNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNotificationChannelOutputError>
}

public struct DeleteNotificationChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteNotificationChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNotificationChannelInput>
    public typealias MOutput = OperationOutput<DeleteNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNotificationChannelOutputError>
}

public struct DeleteNotificationChannelInput: Equatable {

    public init() {}
}

struct DeleteNotificationChannelInputBody: Equatable {
}

extension DeleteNotificationChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteNotificationChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNotificationChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNotificationChannelOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNotificationChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNotificationChannelOutputResponse()"}
}

extension DeleteNotificationChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNotificationChannelOutputResponse: Equatable {

    public init() {}
}

struct DeleteNotificationChannelOutputResponseBody: Equatable {
}

extension DeleteNotificationChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeletePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyOutputError>
}

extension DeletePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePolicyInput(deleteAllPolicyResources: \(String(describing: deleteAllPolicyResources)), policyId: \(String(describing: policyId)))"}
}

extension DeletePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteAllPolicyResources = "DeleteAllPolicyResources"
        case policyId = "PolicyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteAllPolicyResources != false {
            try encodeContainer.encode(deleteAllPolicyResources, forKey: .deleteAllPolicyResources)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }
}

public struct DeletePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyOutputError>
}

public struct DeletePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePolicyOutputError>
}

public struct DeletePolicyInput: Equatable {
    /// <p>If <code>True</code>, the request performs cleanup according to the policy type. </p>
    ///          <p>For AWS WAF and Shield Advanced policies, the cleanup does the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Deletes rule groups created by AWS Firewall Manager</p>
    ///             </li>
    ///             <li>
    ///                <p>Removes web ACLs from in-scope resources</p>
    ///             </li>
    ///             <li>
    ///                <p>Deletes web ACLs that contain no rules or rule groups</p>
    ///             </li>
    ///          </ul>
    ///          <p>For security group policies, the cleanup does the following for each security group in
    ///       the policy:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Disassociates the security group from in-scope resources </p>
    ///             </li>
    ///             <li>
    ///                <p>Deletes the security group if it was created through Firewall Manager and if it's
    ///           no longer associated with any resources through another policy</p>
    ///             </li>
    ///          </ul>
    ///          <p>After the cleanup, in-scope resources are no longer protected by web ACLs in this policy.
    ///       Protection of out-of-scope resources remains unchanged. Scope is determined by tags that you
    ///       create and accounts that you associate with the policy. When creating the policy, if you
    ///       specify that only resources in specific accounts or with specific tags are in scope of the
    ///       policy, those accounts and resources are handled by the policy. All others are out of scope.
    ///       If you don't specify tags or accounts, all resources are in scope. </p>
    public let deleteAllPolicyResources: Bool
    /// <p>The ID of the policy that you want to delete. You can retrieve this ID from
    ///         <code>PutPolicy</code> and <code>ListPolicies</code>.</p>
    public let policyId: String?

    public init (
        deleteAllPolicyResources: Bool = false,
        policyId: String? = nil
    )
    {
        self.deleteAllPolicyResources = deleteAllPolicyResources
        self.policyId = policyId
    }
}

struct DeletePolicyInputBody: Equatable {
    public let policyId: String?
    public let deleteAllPolicyResources: Bool
}

extension DeletePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deleteAllPolicyResources = "DeleteAllPolicyResources"
        case policyId = "PolicyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let deleteAllPolicyResourcesDecoded = try containerValues.decode(Bool.self, forKey: .deleteAllPolicyResources)
        deleteAllPolicyResources = deleteAllPolicyResourcesDecoded
    }
}

extension DeletePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePolicyOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePolicyOutputResponse()"}
}

extension DeletePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeletePolicyOutputResponseBody: Equatable {
}

extension DeletePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteProtocolsListInputBodyMiddleware: Middleware {
    public let id: String = "DeleteProtocolsListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProtocolsListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProtocolsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProtocolsListInput>
    public typealias MOutput = OperationOutput<DeleteProtocolsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProtocolsListOutputError>
}

extension DeleteProtocolsListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProtocolsListInput(listId: \(String(describing: listId)))"}
}

extension DeleteProtocolsListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listId = "ListId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
    }
}

public struct DeleteProtocolsListInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProtocolsListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProtocolsListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProtocolsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProtocolsListInput>
    public typealias MOutput = OperationOutput<DeleteProtocolsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProtocolsListOutputError>
}

public struct DeleteProtocolsListInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProtocolsListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProtocolsListInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProtocolsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProtocolsListInput>
    public typealias MOutput = OperationOutput<DeleteProtocolsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProtocolsListOutputError>
}

public struct DeleteProtocolsListInput: Equatable {
    /// <p>The ID of the protocols list that you want to delete. You can retrieve this ID from
    ///       <code>PutProtocolsList</code>, <code>ListProtocolsLists</code>, and <code>GetProtocolsLost</code>.</p>
    public let listId: String?

    public init (
        listId: String? = nil
    )
    {
        self.listId = listId
    }
}

struct DeleteProtocolsListInputBody: Equatable {
    public let listId: String?
}

extension DeleteProtocolsListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listId = "ListId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listId)
        listId = listIdDecoded
    }
}

extension DeleteProtocolsListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProtocolsListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProtocolsListOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProtocolsListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProtocolsListOutputResponse()"}
}

extension DeleteProtocolsListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProtocolsListOutputResponse: Equatable {

    public init() {}
}

struct DeleteProtocolsListOutputResponseBody: Equatable {
}

extension DeleteProtocolsListOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum DependentServiceName {
    case awsconfig
    case awsshieldadvanced
    case awsvirtualprivatecloud
    case awswaf
    case sdkUnknown(String)
}

extension DependentServiceName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DependentServiceName] {
        return [
            .awsconfig,
            .awsshieldadvanced,
            .awsvirtualprivatecloud,
            .awswaf,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsconfig: return "AWSCONFIG"
        case .awsshieldadvanced: return "AWSSHIELD_ADVANCED"
        case .awsvirtualprivatecloud: return "AWSVPC"
        case .awswaf: return "AWSWAF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DependentServiceName(rawValue: rawValue) ?? DependentServiceName.sdkUnknown(rawValue)
    }
}

extension DisassociateAdminAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateAdminAccountInput()"}
}

extension DisassociateAdminAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateAdminAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateAdminAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateAdminAccountInput>
    public typealias MOutput = OperationOutput<DisassociateAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateAdminAccountOutputError>
}

public struct DisassociateAdminAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateAdminAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateAdminAccountInput>
    public typealias MOutput = OperationOutput<DisassociateAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateAdminAccountOutputError>
}

public struct DisassociateAdminAccountInput: Equatable {

    public init() {}
}

struct DisassociateAdminAccountInputBody: Equatable {
}

extension DisassociateAdminAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateAdminAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAdminAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateAdminAccountOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAdminAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateAdminAccountOutputResponse()"}
}

extension DisassociateAdminAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateAdminAccountOutputResponse: Equatable {

    public init() {}
}

struct DisassociateAdminAccountOutputResponseBody: Equatable {
}

extension DisassociateAdminAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DnsDuplicateRuleGroupViolation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case violationTarget = "ViolationTarget"
        case violationTargetDescription = "ViolationTargetDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let violationTargetDescription = violationTargetDescription {
            try encodeContainer.encode(violationTargetDescription, forKey: .violationTargetDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violationTargetDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTargetDescription)
        violationTargetDescription = violationTargetDescriptionDecoded
    }
}

extension DnsDuplicateRuleGroupViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DnsDuplicateRuleGroupViolation(violationTarget: \(String(describing: violationTarget)), violationTargetDescription: \(String(describing: violationTargetDescription)))"}
}

/// <p>A DNS Firewall rule group that Firewall Manager
///        tried to associate with a VPC is already associated with the VPC and can't be associated again. </p>
public struct DnsDuplicateRuleGroupViolation: Equatable {
    /// <p>The ID of the VPC. </p>
    public let violationTarget: String?
    /// <p>A description of the violation that specifies the rule group and VPC.</p>
    public let violationTargetDescription: String?

    public init (
        violationTarget: String? = nil,
        violationTargetDescription: String? = nil
    )
    {
        self.violationTarget = violationTarget
        self.violationTargetDescription = violationTargetDescription
    }
}

extension DnsRuleGroupLimitExceededViolation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case numberOfRuleGroupsAlreadyAssociated = "NumberOfRuleGroupsAlreadyAssociated"
        case violationTarget = "ViolationTarget"
        case violationTargetDescription = "ViolationTargetDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfRuleGroupsAlreadyAssociated != 0 {
            try encodeContainer.encode(numberOfRuleGroupsAlreadyAssociated, forKey: .numberOfRuleGroupsAlreadyAssociated)
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let violationTargetDescription = violationTargetDescription {
            try encodeContainer.encode(violationTargetDescription, forKey: .violationTargetDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violationTargetDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTargetDescription)
        violationTargetDescription = violationTargetDescriptionDecoded
        let numberOfRuleGroupsAlreadyAssociatedDecoded = try containerValues.decode(Int.self, forKey: .numberOfRuleGroupsAlreadyAssociated)
        numberOfRuleGroupsAlreadyAssociated = numberOfRuleGroupsAlreadyAssociatedDecoded
    }
}

extension DnsRuleGroupLimitExceededViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DnsRuleGroupLimitExceededViolation(numberOfRuleGroupsAlreadyAssociated: \(String(describing: numberOfRuleGroupsAlreadyAssociated)), violationTarget: \(String(describing: violationTarget)), violationTargetDescription: \(String(describing: violationTargetDescription)))"}
}

/// <p>The VPC that Firewall Manager was applying a DNS Fireall policy to reached the limit for associated DNS Firewall rule groups. Firewall Manager tried to associate another rule group with the VPC and failed due to the limit. </p>
public struct DnsRuleGroupLimitExceededViolation: Equatable {
    /// <p>The number of rule groups currently associated with the VPC.  </p>
    public let numberOfRuleGroupsAlreadyAssociated: Int
    /// <p>The ID of the VPC. </p>
    public let violationTarget: String?
    /// <p>A description of the violation that specifies the rule group and VPC.</p>
    public let violationTargetDescription: String?

    public init (
        numberOfRuleGroupsAlreadyAssociated: Int = 0,
        violationTarget: String? = nil,
        violationTargetDescription: String? = nil
    )
    {
        self.numberOfRuleGroupsAlreadyAssociated = numberOfRuleGroupsAlreadyAssociated
        self.violationTarget = violationTarget
        self.violationTargetDescription = violationTargetDescription
    }
}

extension DnsRuleGroupPriorityConflictViolation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conflictingPolicyId = "ConflictingPolicyId"
        case conflictingPriority = "ConflictingPriority"
        case unavailablePriorities = "UnavailablePriorities"
        case violationTarget = "ViolationTarget"
        case violationTargetDescription = "ViolationTargetDescription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictingPolicyId = conflictingPolicyId {
            try encodeContainer.encode(conflictingPolicyId, forKey: .conflictingPolicyId)
        }
        if conflictingPriority != 0 {
            try encodeContainer.encode(conflictingPriority, forKey: .conflictingPriority)
        }
        if let unavailablePriorities = unavailablePriorities {
            var unavailablePrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .unavailablePriorities)
            for dnsrulegrouppriorities0 in unavailablePriorities {
                try unavailablePrioritiesContainer.encode(dnsrulegrouppriorities0)
            }
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
        if let violationTargetDescription = violationTargetDescription {
            try encodeContainer.encode(violationTargetDescription, forKey: .violationTargetDescription)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let violationTargetDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTargetDescription)
        violationTargetDescription = violationTargetDescriptionDecoded
        let conflictingPriorityDecoded = try containerValues.decode(Int.self, forKey: .conflictingPriority)
        conflictingPriority = conflictingPriorityDecoded
        let conflictingPolicyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conflictingPolicyId)
        conflictingPolicyId = conflictingPolicyIdDecoded
        let unavailablePrioritiesContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .unavailablePriorities)
        var unavailablePrioritiesDecoded0:[Int]? = nil
        if let unavailablePrioritiesContainer = unavailablePrioritiesContainer {
            unavailablePrioritiesDecoded0 = [Int]()
            for integer0 in unavailablePrioritiesContainer {
                if let integer0 = integer0 {
                    unavailablePrioritiesDecoded0?.append(integer0)
                }
            }
        }
        unavailablePriorities = unavailablePrioritiesDecoded0
    }
}

extension DnsRuleGroupPriorityConflictViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DnsRuleGroupPriorityConflictViolation(conflictingPolicyId: \(String(describing: conflictingPolicyId)), conflictingPriority: \(String(describing: conflictingPriority)), unavailablePriorities: \(String(describing: unavailablePriorities)), violationTarget: \(String(describing: violationTarget)), violationTargetDescription: \(String(describing: violationTargetDescription)))"}
}

/// <p>A rule group that Firewall Manager
///        tried to associate with a VPC has the same priority as a rule group that's already associated. </p>
public struct DnsRuleGroupPriorityConflictViolation: Equatable {
    /// <p>The ID of the Firewall Manager DNS Firewall policy that was already applied to the VPC.
    ///        This policy contains the rule group that's already associated with the VPC. </p>
    public let conflictingPolicyId: String?
    /// <p>The priority setting of the two conflicting rule groups.</p>
    public let conflictingPriority: Int
    /// <p>The priorities of rule groups that are already associated with the VPC. To retry your operation,
    ///        choose priority settings that aren't in this list for the rule groups in your new DNS Firewall policy. </p>
    public let unavailablePriorities: [Int]?
    /// <p>The ID of the VPC. </p>
    public let violationTarget: String?
    /// <p>A description of the violation that specifies the VPC and the rule group that's already associated with it.</p>
    public let violationTargetDescription: String?

    public init (
        conflictingPolicyId: String? = nil,
        conflictingPriority: Int = 0,
        unavailablePriorities: [Int]? = nil,
        violationTarget: String? = nil,
        violationTargetDescription: String? = nil
    )
    {
        self.conflictingPolicyId = conflictingPolicyId
        self.conflictingPriority = conflictingPriority
        self.unavailablePriorities = unavailablePriorities
        self.violationTarget = violationTarget
        self.violationTargetDescription = violationTargetDescription
    }
}

extension EvaluationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceStatus = "ComplianceStatus"
        case evaluationLimitExceeded = "EvaluationLimitExceeded"
        case violatorCount = "ViolatorCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceStatus = complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if evaluationLimitExceeded != false {
            try encodeContainer.encode(evaluationLimitExceeded, forKey: .evaluationLimitExceeded)
        }
        if violatorCount != 0 {
            try encodeContainer.encode(violatorCount, forKey: .violatorCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceStatusDecoded = try containerValues.decodeIfPresent(PolicyComplianceStatusType.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let violatorCountDecoded = try containerValues.decode(Int.self, forKey: .violatorCount)
        violatorCount = violatorCountDecoded
        let evaluationLimitExceededDecoded = try containerValues.decode(Bool.self, forKey: .evaluationLimitExceeded)
        evaluationLimitExceeded = evaluationLimitExceededDecoded
    }
}

extension EvaluationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EvaluationResult(complianceStatus: \(String(describing: complianceStatus)), evaluationLimitExceeded: \(String(describing: evaluationLimitExceeded)), violatorCount: \(String(describing: violatorCount)))"}
}

/// <p>Describes the compliance status for the account. An account is considered noncompliant if
///       it includes resources that are not protected by the specified policy or that don't comply with
///       the policy.</p>
public struct EvaluationResult: Equatable {
    /// <p>Describes an AWS account's compliance with the AWS Firewall Manager policy.</p>
    public let complianceStatus: PolicyComplianceStatusType?
    /// <p>Indicates that over 100 resources are noncompliant with the AWS Firewall Manager
    ///       policy.</p>
    public let evaluationLimitExceeded: Bool
    /// <p>The number of resources that are noncompliant with the specified policy. For AWS WAF and
    ///       Shield Advanced policies, a resource is considered noncompliant if it is not associated with
    ///       the policy. For security group policies, a resource is considered noncompliant if it doesn't
    ///       comply with the rules of the policy and remediation is disabled or not possible.</p>
    public let violatorCount: Int

    public init (
        complianceStatus: PolicyComplianceStatusType? = nil,
        evaluationLimitExceeded: Bool = false,
        violatorCount: Int = 0
    )
    {
        self.complianceStatus = complianceStatus
        self.evaluationLimitExceeded = evaluationLimitExceeded
        self.violatorCount = violatorCount
    }
}

extension GetAdminAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAdminAccountInput()"}
}

extension GetAdminAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAdminAccountInputHeadersMiddleware: Middleware {
    public let id: String = "GetAdminAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAdminAccountInput>
    public typealias MOutput = OperationOutput<GetAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAdminAccountOutputError>
}

public struct GetAdminAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAdminAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAdminAccountInput>
    public typealias MOutput = OperationOutput<GetAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAdminAccountOutputError>
}

public struct GetAdminAccountInput: Equatable {

    public init() {}
}

struct GetAdminAccountInputBody: Equatable {
}

extension GetAdminAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAdminAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAdminAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAdminAccountOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAdminAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAdminAccountOutputResponse(adminAccount: \(String(describing: adminAccount)), roleStatus: \(String(describing: roleStatus)))"}
}

extension GetAdminAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAdminAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.adminAccount = output.adminAccount
            self.roleStatus = output.roleStatus
        } else {
            self.adminAccount = nil
            self.roleStatus = nil
        }
    }
}

public struct GetAdminAccountOutputResponse: Equatable {
    /// <p>The AWS account that is set as the AWS Firewall Manager administrator.</p>
    public let adminAccount: String?
    /// <p>The status of the AWS account that you set as the AWS Firewall Manager
    ///       administrator.</p>
    public let roleStatus: AccountRoleStatus?

    public init (
        adminAccount: String? = nil,
        roleStatus: AccountRoleStatus? = nil
    )
    {
        self.adminAccount = adminAccount
        self.roleStatus = roleStatus
    }
}

struct GetAdminAccountOutputResponseBody: Equatable {
    public let adminAccount: String?
    public let roleStatus: AccountRoleStatus?
}

extension GetAdminAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccount = "AdminAccount"
        case roleStatus = "RoleStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccount)
        adminAccount = adminAccountDecoded
        let roleStatusDecoded = try containerValues.decodeIfPresent(AccountRoleStatus.self, forKey: .roleStatus)
        roleStatus = roleStatusDecoded
    }
}

public struct GetAppsListInputBodyMiddleware: Middleware {
    public let id: String = "GetAppsListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppsListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppsListInput>
    public typealias MOutput = OperationOutput<GetAppsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppsListOutputError>
}

extension GetAppsListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppsListInput(defaultList: \(String(describing: defaultList)), listId: \(String(describing: listId)))"}
}

extension GetAppsListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultList = "DefaultList"
        case listId = "ListId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultList != false {
            try encodeContainer.encode(defaultList, forKey: .defaultList)
        }
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
    }
}

public struct GetAppsListInputHeadersMiddleware: Middleware {
    public let id: String = "GetAppsListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppsListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppsListInput>
    public typealias MOutput = OperationOutput<GetAppsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppsListOutputError>
}

public struct GetAppsListInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAppsListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppsListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppsListInput>
    public typealias MOutput = OperationOutput<GetAppsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppsListOutputError>
}

public struct GetAppsListInput: Equatable {
    /// <p>Specifies whether the list to retrieve is a default list owned by AWS Firewall Manager.</p>
    public let defaultList: Bool
    /// <p>The ID of the AWS Firewall Manager applications list that you want the details for.</p>
    public let listId: String?

    public init (
        defaultList: Bool = false,
        listId: String? = nil
    )
    {
        self.defaultList = defaultList
        self.listId = listId
    }
}

struct GetAppsListInputBody: Equatable {
    public let listId: String?
    public let defaultList: Bool
}

extension GetAppsListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultList = "DefaultList"
        case listId = "ListId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listId)
        listId = listIdDecoded
        let defaultListDecoded = try containerValues.decode(Bool.self, forKey: .defaultList)
        defaultList = defaultListDecoded
    }
}

extension GetAppsListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppsListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppsListOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppsListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppsListOutputResponse(appsList: \(String(describing: appsList)), appsListArn: \(String(describing: appsListArn)))"}
}

extension GetAppsListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAppsListOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appsList = output.appsList
            self.appsListArn = output.appsListArn
        } else {
            self.appsList = nil
            self.appsListArn = nil
        }
    }
}

public struct GetAppsListOutputResponse: Equatable {
    /// <p>Information about the specified AWS Firewall Manager applications list.</p>
    public let appsList: AppsListData?
    /// <p>The Amazon Resource Name (ARN) of the applications list.</p>
    public let appsListArn: String?

    public init (
        appsList: AppsListData? = nil,
        appsListArn: String? = nil
    )
    {
        self.appsList = appsList
        self.appsListArn = appsListArn
    }
}

struct GetAppsListOutputResponseBody: Equatable {
    public let appsList: AppsListData?
    public let appsListArn: String?
}

extension GetAppsListOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appsList = "AppsList"
        case appsListArn = "AppsListArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsListDecoded = try containerValues.decodeIfPresent(AppsListData.self, forKey: .appsList)
        appsList = appsListDecoded
        let appsListArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appsListArn)
        appsListArn = appsListArnDecoded
    }
}

public struct GetComplianceDetailInputBodyMiddleware: Middleware {
    public let id: String = "GetComplianceDetailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceDetailInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceDetailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceDetailInput>
    public typealias MOutput = OperationOutput<GetComplianceDetailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceDetailOutputError>
}

extension GetComplianceDetailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComplianceDetailInput(memberAccount: \(String(describing: memberAccount)), policyId: \(String(describing: policyId)))"}
}

extension GetComplianceDetailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccount = memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }
}

public struct GetComplianceDetailInputHeadersMiddleware: Middleware {
    public let id: String = "GetComplianceDetailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceDetailInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceDetailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceDetailInput>
    public typealias MOutput = OperationOutput<GetComplianceDetailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceDetailOutputError>
}

public struct GetComplianceDetailInputQueryItemMiddleware: Middleware {
    public let id: String = "GetComplianceDetailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComplianceDetailInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComplianceDetailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComplianceDetailInput>
    public typealias MOutput = OperationOutput<GetComplianceDetailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComplianceDetailOutputError>
}

public struct GetComplianceDetailInput: Equatable {
    /// <p>The AWS account that owns the resources that you want to get the details for.</p>
    public let memberAccount: String?
    /// <p>The ID of the policy that you want to get the details for. <code>PolicyId</code> is
    ///       returned by <code>PutPolicy</code> and by <code>ListPolicies</code>.</p>
    public let policyId: String?

    public init (
        memberAccount: String? = nil,
        policyId: String? = nil
    )
    {
        self.memberAccount = memberAccount
        self.policyId = policyId
    }
}

struct GetComplianceDetailInputBody: Equatable {
    public let policyId: String?
    public let memberAccount: String?
}

extension GetComplianceDetailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
    }
}

extension GetComplianceDetailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComplianceDetailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComplianceDetailOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComplianceDetailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComplianceDetailOutputResponse(policyComplianceDetail: \(String(describing: policyComplianceDetail)))"}
}

extension GetComplianceDetailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetComplianceDetailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyComplianceDetail = output.policyComplianceDetail
        } else {
            self.policyComplianceDetail = nil
        }
    }
}

public struct GetComplianceDetailOutputResponse: Equatable {
    /// <p>Information about the resources and the policy that you specified in the
    ///         <code>GetComplianceDetail</code> request.</p>
    public let policyComplianceDetail: PolicyComplianceDetail?

    public init (
        policyComplianceDetail: PolicyComplianceDetail? = nil
    )
    {
        self.policyComplianceDetail = policyComplianceDetail
    }
}

struct GetComplianceDetailOutputResponseBody: Equatable {
    public let policyComplianceDetail: PolicyComplianceDetail?
}

extension GetComplianceDetailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyComplianceDetail = "PolicyComplianceDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyComplianceDetailDecoded = try containerValues.decodeIfPresent(PolicyComplianceDetail.self, forKey: .policyComplianceDetail)
        policyComplianceDetail = policyComplianceDetailDecoded
    }
}

extension GetNotificationChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNotificationChannelInput()"}
}

extension GetNotificationChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetNotificationChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetNotificationChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNotificationChannelInput>
    public typealias MOutput = OperationOutput<GetNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNotificationChannelOutputError>
}

public struct GetNotificationChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetNotificationChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNotificationChannelInput>
    public typealias MOutput = OperationOutput<GetNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNotificationChannelOutputError>
}

public struct GetNotificationChannelInput: Equatable {

    public init() {}
}

struct GetNotificationChannelInputBody: Equatable {
}

extension GetNotificationChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetNotificationChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNotificationChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNotificationChannelOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNotificationChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNotificationChannelOutputResponse(snsRoleName: \(String(describing: snsRoleName)), snsTopicArn: \(String(describing: snsTopicArn)))"}
}

extension GetNotificationChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetNotificationChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.snsRoleName = output.snsRoleName
            self.snsTopicArn = output.snsTopicArn
        } else {
            self.snsRoleName = nil
            self.snsTopicArn = nil
        }
    }
}

public struct GetNotificationChannelOutputResponse: Equatable {
    /// <p>The IAM role that is used by AWS Firewall Manager to record activity to SNS.</p>
    public let snsRoleName: String?
    /// <p>The SNS topic that records AWS Firewall Manager activity. </p>
    public let snsTopicArn: String?

    public init (
        snsRoleName: String? = nil,
        snsTopicArn: String? = nil
    )
    {
        self.snsRoleName = snsRoleName
        self.snsTopicArn = snsTopicArn
    }
}

struct GetNotificationChannelOutputResponseBody: Equatable {
    public let snsTopicArn: String?
    public let snsRoleName: String?
}

extension GetNotificationChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snsRoleName = "SnsRoleName"
        case snsTopicArn = "SnsTopicArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsRoleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsRoleName)
        snsRoleName = snsRoleNameDecoded
    }
}

public struct GetPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

extension GetPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyInput(policyId: \(String(describing: policyId)))"}
}

extension GetPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyId = "PolicyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }
}

public struct GetPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

public struct GetPolicyInput: Equatable {
    /// <p>The ID of the AWS Firewall Manager policy that you want the details for.</p>
    public let policyId: String?

    public init (
        policyId: String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct GetPolicyInputBody: Equatable {
    public let policyId: String?
}

extension GetPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyId = "PolicyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

extension GetPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidTypeException(InvalidTypeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyOutputResponse(policy: \(String(describing: policy)), policyArn: \(String(describing: policyArn)))"}
}

extension GetPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.policyArn = output.policyArn
        } else {
            self.policy = nil
            self.policyArn = nil
        }
    }
}

public struct GetPolicyOutputResponse: Equatable {
    /// <p>Information about the specified AWS Firewall Manager policy.</p>
    public let policy: Policy?
    /// <p>The Amazon Resource Name (ARN) of the specified policy.</p>
    public let policyArn: String?

    public init (
        policy: Policy? = nil,
        policyArn: String? = nil
    )
    {
        self.policy = policy
        self.policyArn = policyArn
    }
}

struct GetPolicyOutputResponseBody: Equatable {
    public let policy: Policy?
    public let policyArn: String?
}

extension GetPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Policy.self, forKey: .policy)
        policy = policyDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

public struct GetProtectionStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetProtectionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProtectionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProtectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProtectionStatusInput>
    public typealias MOutput = OperationOutput<GetProtectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProtectionStatusOutputError>
}

extension GetProtectionStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProtectionStatusInput(endTime: \(String(describing: endTime)), maxResults: \(String(describing: maxResults)), memberAccountId: \(String(describing: memberAccountId)), nextToken: \(String(describing: nextToken)), policyId: \(String(describing: policyId)), startTime: \(String(describing: startTime)))"}
}

extension GetProtectionStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case memberAccountId = "MemberAccountId"
        case nextToken = "NextToken"
        case policyId = "PolicyId"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let memberAccountId = memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct GetProtectionStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetProtectionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProtectionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProtectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProtectionStatusInput>
    public typealias MOutput = OperationOutput<GetProtectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProtectionStatusOutputError>
}

public struct GetProtectionStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetProtectionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProtectionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProtectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProtectionStatusInput>
    public typealias MOutput = OperationOutput<GetProtectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProtectionStatusOutputError>
}

public struct GetProtectionStatusInput: Equatable {
    /// <p>The end of the time period to query for the attacks. This is a <code>timestamp</code> type. The
    ///          request syntax listing indicates a <code>number</code> type because the default used by AWS Firewall
    ///          Manager is Unix time in seconds. However, any valid <code>timestamp</code> format is
    ///          allowed.</p>
    public let endTime: Date?
    /// <p>Specifies the number of objects that you want AWS Firewall Manager to return for this request. If you have more
    ///         objects than the number that you specify for <code>MaxResults</code>, the response includes a
    ///          <code>NextToken</code> value that you can use to get another batch of objects.</p>
    public let maxResults: Int?
    /// <p>The AWS account that is in scope of the policy that you want to get the details
    ///          for.</p>
    public let memberAccountId: String?
    /// <p>If you specify a value for <code>MaxResults</code> and you have more objects than the number that you specify
    ///          for <code>MaxResults</code>, AWS Firewall Manager returns a <code>NextToken</code> value in the response, which you can use to retrieve another group of
    ///          objects. For the second and subsequent <code>GetProtectionStatus</code> requests, specify the value of <code>NextToken</code>
    ///          from the previous response to get information about another batch of objects.</p>
    public let nextToken: String?
    /// <p>The ID of the policy for which you want to get the attack information.</p>
    public let policyId: String?
    /// <p>The start of the time period to query for the attacks. This is a <code>timestamp</code> type. The
    ///           request syntax listing indicates a <code>number</code> type because the default used by AWS Firewall
    ///          Manager is Unix time in seconds. However, any valid <code>timestamp</code> format is
    ///          allowed.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        maxResults: Int? = nil,
        memberAccountId: String? = nil,
        nextToken: String? = nil,
        policyId: String? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.memberAccountId = memberAccountId
        self.nextToken = nextToken
        self.policyId = policyId
        self.startTime = startTime
    }
}

struct GetProtectionStatusInputBody: Equatable {
    public let policyId: String?
    public let memberAccountId: String?
    public let startTime: Date?
    public let endTime: Date?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetProtectionStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case memberAccountId = "MemberAccountId"
        case nextToken = "NextToken"
        case policyId = "PolicyId"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetProtectionStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProtectionStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProtectionStatusOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProtectionStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProtectionStatusOutputResponse(adminAccountId: \(String(describing: adminAccountId)), data: \(String(describing: data)), nextToken: \(String(describing: nextToken)), serviceType: \(String(describing: serviceType)))"}
}

extension GetProtectionStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetProtectionStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.adminAccountId = output.adminAccountId
            self.data = output.data
            self.nextToken = output.nextToken
            self.serviceType = output.serviceType
        } else {
            self.adminAccountId = nil
            self.data = nil
            self.nextToken = nil
            self.serviceType = nil
        }
    }
}

public struct GetProtectionStatusOutputResponse: Equatable {
    /// <p>The ID of the AWS Firewall administrator account for this policy.</p>
    public let adminAccountId: String?
    /// <p>Details about the attack, including the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Attack type</p>
    ///             </li>
    ///             <li>
    ///                <p>Account ID</p>
    ///             </li>
    ///             <li>
    ///                <p>ARN of the resource attacked</p>
    ///             </li>
    ///             <li>
    ///                <p>Start time of the attack</p>
    ///             </li>
    ///             <li>
    ///                <p>End time of the attack (ongoing attacks will not have an end time)</p>
    ///             </li>
    ///          </ul>
    ///          <p>The details are in JSON format. </p>
    public let data: String?
    /// <p>If you have more objects than the number that you specified for <code>MaxResults</code> in the request,
    ///          the response includes a <code>NextToken</code> value. To list more objects, submit another
    ///          <code>GetProtectionStatus</code> request, and specify the <code>NextToken</code> value from the response in the
    ///          <code>NextToken</code> value in the next request.</p>
    ///          <p>AWS SDKs provide auto-pagination that identify <code>NextToken</code> in a response and
    ///          make subsequent request calls automatically on your behalf. However, this feature is not
    ///          supported by <code>GetProtectionStatus</code>. You must submit subsequent requests with
    ///             <code>NextToken</code> using your own processes. </p>
    public let nextToken: String?
    /// <p>The service type that is protected by the policy. Currently, this is always
    ///             <code>SHIELD_ADVANCED</code>.</p>
    public let serviceType: SecurityServiceType?

    public init (
        adminAccountId: String? = nil,
        data: String? = nil,
        nextToken: String? = nil,
        serviceType: SecurityServiceType? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.data = data
        self.nextToken = nextToken
        self.serviceType = serviceType
    }
}

struct GetProtectionStatusOutputResponseBody: Equatable {
    public let adminAccountId: String?
    public let serviceType: SecurityServiceType?
    public let data: String?
    public let nextToken: String?
}

extension GetProtectionStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccountId = "AdminAccountId"
        case data = "Data"
        case nextToken = "NextToken"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(SecurityServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetProtocolsListInputBodyMiddleware: Middleware {
    public let id: String = "GetProtocolsListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProtocolsListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProtocolsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProtocolsListInput>
    public typealias MOutput = OperationOutput<GetProtocolsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProtocolsListOutputError>
}

extension GetProtocolsListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProtocolsListInput(defaultList: \(String(describing: defaultList)), listId: \(String(describing: listId)))"}
}

extension GetProtocolsListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultList = "DefaultList"
        case listId = "ListId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultList != false {
            try encodeContainer.encode(defaultList, forKey: .defaultList)
        }
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
    }
}

public struct GetProtocolsListInputHeadersMiddleware: Middleware {
    public let id: String = "GetProtocolsListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProtocolsListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProtocolsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProtocolsListInput>
    public typealias MOutput = OperationOutput<GetProtocolsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProtocolsListOutputError>
}

public struct GetProtocolsListInputQueryItemMiddleware: Middleware {
    public let id: String = "GetProtocolsListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProtocolsListInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProtocolsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProtocolsListInput>
    public typealias MOutput = OperationOutput<GetProtocolsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProtocolsListOutputError>
}

public struct GetProtocolsListInput: Equatable {
    /// <p>Specifies whether the list to retrieve is a default list owned by AWS Firewall Manager.</p>
    public let defaultList: Bool
    /// <p>The ID of the AWS Firewall Manager protocols list that you want the details for.</p>
    public let listId: String?

    public init (
        defaultList: Bool = false,
        listId: String? = nil
    )
    {
        self.defaultList = defaultList
        self.listId = listId
    }
}

struct GetProtocolsListInputBody: Equatable {
    public let listId: String?
    public let defaultList: Bool
}

extension GetProtocolsListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultList = "DefaultList"
        case listId = "ListId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listId)
        listId = listIdDecoded
        let defaultListDecoded = try containerValues.decode(Bool.self, forKey: .defaultList)
        defaultList = defaultListDecoded
    }
}

extension GetProtocolsListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProtocolsListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProtocolsListOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProtocolsListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProtocolsListOutputResponse(protocolsList: \(String(describing: protocolsList)), protocolsListArn: \(String(describing: protocolsListArn)))"}
}

extension GetProtocolsListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetProtocolsListOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.protocolsList = output.protocolsList
            self.protocolsListArn = output.protocolsListArn
        } else {
            self.protocolsList = nil
            self.protocolsListArn = nil
        }
    }
}

public struct GetProtocolsListOutputResponse: Equatable {
    /// <p>Information about the specified AWS Firewall Manager protocols list.</p>
    public let protocolsList: ProtocolsListData?
    /// <p>The Amazon Resource Name (ARN) of the specified protocols list.</p>
    public let protocolsListArn: String?

    public init (
        protocolsList: ProtocolsListData? = nil,
        protocolsListArn: String? = nil
    )
    {
        self.protocolsList = protocolsList
        self.protocolsListArn = protocolsListArn
    }
}

struct GetProtocolsListOutputResponseBody: Equatable {
    public let protocolsList: ProtocolsListData?
    public let protocolsListArn: String?
}

extension GetProtocolsListOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case protocolsList = "ProtocolsList"
        case protocolsListArn = "ProtocolsListArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsListDecoded = try containerValues.decodeIfPresent(ProtocolsListData.self, forKey: .protocolsList)
        protocolsList = protocolsListDecoded
        let protocolsListArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocolsListArn)
        protocolsListArn = protocolsListArnDecoded
    }
}

public struct GetViolationDetailsInputBodyMiddleware: Middleware {
    public let id: String = "GetViolationDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetViolationDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetViolationDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetViolationDetailsInput>
    public typealias MOutput = OperationOutput<GetViolationDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetViolationDetailsOutputError>
}

extension GetViolationDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetViolationDetailsInput(memberAccount: \(String(describing: memberAccount)), policyId: \(String(describing: policyId)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension GetViolationDetailsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccount = memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct GetViolationDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "GetViolationDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetViolationDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetViolationDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetViolationDetailsInput>
    public typealias MOutput = OperationOutput<GetViolationDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetViolationDetailsOutputError>
}

public struct GetViolationDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetViolationDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetViolationDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetViolationDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetViolationDetailsInput>
    public typealias MOutput = OperationOutput<GetViolationDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetViolationDetailsOutputError>
}

public struct GetViolationDetailsInput: Equatable {
    /// <p>The AWS account ID that you want the details for.</p>
    public let memberAccount: String?
    /// <p>The ID of the AWS Firewall Manager policy that you want the details for. This currently only supports security group content audit policies.</p>
    public let policyId: String?
    /// <p>The ID of the resource that has violations.</p>
    public let resourceId: String?
    /// <p>The resource type. This is in the format shown in the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a>.
    ///       Supported resource types are:
    ///       <code>AWS::EC2::Instance</code>,
    ///       <code>AWS::EC2::NetworkInterface</code>,
    ///       <code>AWS::EC2::SecurityGroup</code>,
    ///       <code>AWS::NetworkFirewall::FirewallPolicy</code>, and
    ///       <code>AWS::EC2::Subnet</code>.
    ///    </p>
    public let resourceType: String?

    public init (
        memberAccount: String? = nil,
        policyId: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.memberAccount = memberAccount
        self.policyId = policyId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct GetViolationDetailsInputBody: Equatable {
    public let policyId: String?
    public let memberAccount: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension GetViolationDetailsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension GetViolationDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetViolationDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetViolationDetailsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetViolationDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetViolationDetailsOutputResponse(violationDetail: \(String(describing: violationDetail)))"}
}

extension GetViolationDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetViolationDetailsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.violationDetail = output.violationDetail
        } else {
            self.violationDetail = nil
        }
    }
}

public struct GetViolationDetailsOutputResponse: Equatable {
    /// <p>Violation detail for a resource.</p>
    public let violationDetail: ViolationDetail?

    public init (
        violationDetail: ViolationDetail? = nil
    )
    {
        self.violationDetail = violationDetail
    }
}

struct GetViolationDetailsOutputResponseBody: Equatable {
    public let violationDetail: ViolationDetail?
}

extension GetViolationDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case violationDetail = "ViolationDetail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationDetailDecoded = try containerValues.decodeIfPresent(ViolationDetail.self, forKey: .violationDetail)
        violationDetail = violationDetailDecoded
    }
}

extension InternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalErrorException(message: \(String(describing: message)))"}
}

extension InternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because of a system problem, even though the request was valid. Retry
///       your request.</p>
public struct InternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parameters of the request were invalid.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOperationException(message: \(String(describing: message)))"}
}

extension InvalidOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because there was nothing to do or the operation wasn't possible. For example, you might have
///         submitted an <code>AssociateAdminAccount</code> request for an account ID that
///             was already set as the AWS Firewall Manager administrator. Or you might have tried to access a Region
///   that's disabled by default, and that you need to enable for the Firewall Manager
///   administrator account and for AWS Organizations before you can access it.</p>
public struct InvalidOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTypeException(message: \(String(describing: message)))"}
}

extension InvalidTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTypeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value of the <code>Type</code> parameter is invalid.</p>
public struct InvalidTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTypeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation exceeds a resource limit, for example, the maximum number of
///         <code>policy</code> objects that you can create for an AWS account. For more information,
///       see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/fms-limits.html">Firewall
///         Manager Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAppsListsInputBodyMiddleware: Middleware {
    public let id: String = "ListAppsListsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAppsListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAppsListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAppsListsInput>
    public typealias MOutput = OperationOutput<ListAppsListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAppsListsOutputError>
}

extension ListAppsListsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAppsListsInput(defaultLists: \(String(describing: defaultLists)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAppsListsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultLists = "DefaultLists"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultLists != false {
            try encodeContainer.encode(defaultLists, forKey: .defaultLists)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAppsListsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAppsListsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAppsListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAppsListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAppsListsInput>
    public typealias MOutput = OperationOutput<ListAppsListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAppsListsOutputError>
}

public struct ListAppsListsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAppsListsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAppsListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAppsListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAppsListsInput>
    public typealias MOutput = OperationOutput<ListAppsListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAppsListsOutputError>
}

public struct ListAppsListsInput: Equatable {
    /// <p>Specifies whether the lists to retrieve are default lists owned by AWS Firewall Manager.</p>
    public let defaultLists: Bool
    /// <p>The maximum number of objects that you want AWS Firewall Manager to return for this request. If more
    ///             objects are available, in the response, AWS Firewall Manager provides a
    ///            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    ///          <p>If you don't specify this, AWS Firewall Manager returns all available objects.</p>
    public let maxResults: Int?
    /// <p>If you specify a value for <code>MaxResults</code> in your list request, and you have more objects than the maximum,
    ///         AWS Firewall Manager returns this token in the response. For all but the first request, you provide the token returned by the prior request
    ///         in the request parameters, to retrieve the next batch of objects.</p>
    public let nextToken: String?

    public init (
        defaultLists: Bool = false,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.defaultLists = defaultLists
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppsListsInputBody: Equatable {
    public let defaultLists: Bool
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAppsListsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultLists = "DefaultLists"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultListsDecoded = try containerValues.decode(Bool.self, forKey: .defaultLists)
        defaultLists = defaultListsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppsListsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppsListsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppsListsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppsListsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAppsListsOutputResponse(appsLists: \(String(describing: appsLists)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAppsListsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAppsListsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appsLists = output.appsLists
            self.nextToken = output.nextToken
        } else {
            self.appsLists = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppsListsOutputResponse: Equatable {
    /// <p>An array of <code>AppsListDataSummary</code> objects.</p>
    public let appsLists: [AppsListDataSummary]?
    /// <p>If you specify a value for <code>MaxResults</code> in your list request, and you have more objects than the maximum,
    ///         AWS Firewall Manager returns this token in the response. You can use this token in subsequent requests to retrieve the next batch of objects.</p>
    public let nextToken: String?

    public init (
        appsLists: [AppsListDataSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.appsLists = appsLists
        self.nextToken = nextToken
    }
}

struct ListAppsListsOutputResponseBody: Equatable {
    public let appsLists: [AppsListDataSummary]?
    public let nextToken: String?
}

extension ListAppsListsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appsLists = "AppsLists"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsListsContainer = try containerValues.decodeIfPresent([AppsListDataSummary?].self, forKey: .appsLists)
        var appsListsDecoded0:[AppsListDataSummary]? = nil
        if let appsListsContainer = appsListsContainer {
            appsListsDecoded0 = [AppsListDataSummary]()
            for structure0 in appsListsContainer {
                if let structure0 = structure0 {
                    appsListsDecoded0?.append(structure0)
                }
            }
        }
        appsLists = appsListsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListComplianceStatusInputBodyMiddleware: Middleware {
    public let id: String = "ListComplianceStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComplianceStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComplianceStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComplianceStatusInput>
    public typealias MOutput = OperationOutput<ListComplianceStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComplianceStatusOutputError>
}

extension ListComplianceStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComplianceStatusInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), policyId: \(String(describing: policyId)))"}
}

extension ListComplianceStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyId = "PolicyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
    }
}

public struct ListComplianceStatusInputHeadersMiddleware: Middleware {
    public let id: String = "ListComplianceStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComplianceStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComplianceStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComplianceStatusInput>
    public typealias MOutput = OperationOutput<ListComplianceStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComplianceStatusOutputError>
}

public struct ListComplianceStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "ListComplianceStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComplianceStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComplianceStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComplianceStatusInput>
    public typealias MOutput = OperationOutput<ListComplianceStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComplianceStatusOutputError>
}

public struct ListComplianceStatusInput: Equatable {
    /// <p>Specifies the number of <code>PolicyComplianceStatus</code> objects that you want AWS
    ///       Firewall Manager to return for this request. If you have more
    ///         <code>PolicyComplianceStatus</code> objects than the number that you specify for
    ///         <code>MaxResults</code>, the response includes a <code>NextToken</code> value that you can
    ///       use to get another batch of <code>PolicyComplianceStatus</code> objects.</p>
    public let maxResults: Int?
    /// <p>If you specify a value for <code>MaxResults</code> and you have more
    ///         <code>PolicyComplianceStatus</code> objects than the number that you specify for
    ///         <code>MaxResults</code>, AWS Firewall Manager returns a <code>NextToken</code> value in the
    ///       response that allows you to list another group of <code>PolicyComplianceStatus</code> objects.
    ///       For the second and subsequent <code>ListComplianceStatus</code> requests, specify the value of
    ///         <code>NextToken</code> from the previous response to get information about another batch of
    ///         <code>PolicyComplianceStatus</code> objects.</p>
    public let nextToken: String?
    /// <p>The ID of the AWS Firewall Manager policy that you want the details for.</p>
    public let policyId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        policyId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyId = policyId
    }
}

struct ListComplianceStatusInputBody: Equatable {
    public let policyId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListComplianceStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyId = "PolicyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComplianceStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComplianceStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComplianceStatusOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComplianceStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComplianceStatusOutputResponse(nextToken: \(String(describing: nextToken)), policyComplianceStatusList: \(String(describing: policyComplianceStatusList)))"}
}

extension ListComplianceStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListComplianceStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.policyComplianceStatusList = output.policyComplianceStatusList
        } else {
            self.nextToken = nil
            self.policyComplianceStatusList = nil
        }
    }
}

public struct ListComplianceStatusOutputResponse: Equatable {
    /// <p>If you have more <code>PolicyComplianceStatus</code> objects than the number that you
    ///       specified for <code>MaxResults</code> in the request, the response includes a
    ///         <code>NextToken</code> value. To list more <code>PolicyComplianceStatus</code> objects,
    ///       submit another <code>ListComplianceStatus</code> request, and specify the
    ///         <code>NextToken</code> value from the response in the <code>NextToken</code> value in the
    ///       next request.</p>
    public let nextToken: String?
    /// <p>An array of <code>PolicyComplianceStatus</code> objects.</p>
    public let policyComplianceStatusList: [PolicyComplianceStatus]?

    public init (
        nextToken: String? = nil,
        policyComplianceStatusList: [PolicyComplianceStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyComplianceStatusList = policyComplianceStatusList
    }
}

struct ListComplianceStatusOutputResponseBody: Equatable {
    public let policyComplianceStatusList: [PolicyComplianceStatus]?
    public let nextToken: String?
}

extension ListComplianceStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case policyComplianceStatusList = "PolicyComplianceStatusList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyComplianceStatusListContainer = try containerValues.decodeIfPresent([PolicyComplianceStatus?].self, forKey: .policyComplianceStatusList)
        var policyComplianceStatusListDecoded0:[PolicyComplianceStatus]? = nil
        if let policyComplianceStatusListContainer = policyComplianceStatusListContainer {
            policyComplianceStatusListDecoded0 = [PolicyComplianceStatus]()
            for structure0 in policyComplianceStatusListContainer {
                if let structure0 = structure0 {
                    policyComplianceStatusListDecoded0?.append(structure0)
                }
            }
        }
        policyComplianceStatusList = policyComplianceStatusListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMemberAccountsInputBodyMiddleware: Middleware {
    public let id: String = "ListMemberAccountsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMemberAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMemberAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMemberAccountsInput>
    public typealias MOutput = OperationOutput<ListMemberAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMemberAccountsOutputError>
}

extension ListMemberAccountsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMemberAccountsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMemberAccountsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListMemberAccountsInputHeadersMiddleware: Middleware {
    public let id: String = "ListMemberAccountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMemberAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMemberAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMemberAccountsInput>
    public typealias MOutput = OperationOutput<ListMemberAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMemberAccountsOutputError>
}

public struct ListMemberAccountsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMemberAccountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMemberAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMemberAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMemberAccountsInput>
    public typealias MOutput = OperationOutput<ListMemberAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMemberAccountsOutputError>
}

public struct ListMemberAccountsInput: Equatable {
    /// <p>Specifies the number of member account IDs that you want AWS Firewall Manager to return
    ///       for this request. If you have more IDs than the number that you specify for
    ///         <code>MaxResults</code>, the response includes a <code>NextToken</code> value that you can
    ///       use to get another batch of member account IDs.</p>
    public let maxResults: Int?
    /// <p>If you specify a value for <code>MaxResults</code> and you have more account IDs than the
    ///       number that you specify for <code>MaxResults</code>, AWS Firewall Manager returns a
    ///         <code>NextToken</code> value in the response that allows you to list another group of IDs.
    ///       For the second and subsequent <code>ListMemberAccountsRequest</code> requests, specify the
    ///       value of <code>NextToken</code> from the previous response to get information about another
    ///       batch of member account IDs.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMemberAccountsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListMemberAccountsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMemberAccountsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMemberAccountsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMemberAccountsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMemberAccountsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMemberAccountsOutputResponse(memberAccounts: \(String(describing: memberAccounts)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMemberAccountsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMemberAccountsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.memberAccounts = output.memberAccounts
            self.nextToken = output.nextToken
        } else {
            self.memberAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListMemberAccountsOutputResponse: Equatable {
    /// <p>An array of account IDs.</p>
    public let memberAccounts: [String]?
    /// <p>If you have more member account IDs than the number that you specified for
    ///         <code>MaxResults</code> in the request, the response includes a <code>NextToken</code>
    ///       value. To list more IDs, submit another <code>ListMemberAccounts</code> request, and specify
    ///       the <code>NextToken</code> value from the response in the <code>NextToken</code> value in the
    ///       next request.</p>
    public let nextToken: String?

    public init (
        memberAccounts: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.memberAccounts = memberAccounts
        self.nextToken = nextToken
    }
}

struct ListMemberAccountsOutputResponseBody: Equatable {
    public let memberAccounts: [String]?
    public let nextToken: String?
}

extension ListMemberAccountsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberAccounts = "MemberAccounts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .memberAccounts)
        var memberAccountsDecoded0:[String]? = nil
        if let memberAccountsContainer = memberAccountsContainer {
            memberAccountsDecoded0 = [String]()
            for string0 in memberAccountsContainer {
                if let string0 = string0 {
                    memberAccountsDecoded0?.append(string0)
                }
            }
        }
        memberAccounts = memberAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPoliciesInput>
    public typealias MOutput = OperationOutput<ListPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPoliciesOutputError>
}

extension ListPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPoliciesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPoliciesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPoliciesInput>
    public typealias MOutput = OperationOutput<ListPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPoliciesOutputError>
}

public struct ListPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPoliciesInput>
    public typealias MOutput = OperationOutput<ListPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPoliciesOutputError>
}

public struct ListPoliciesInput: Equatable {
    /// <p>Specifies the number of <code>PolicySummary</code> objects that you want AWS Firewall
    ///       Manager to return for this request. If you have more <code>PolicySummary</code> objects than
    ///       the number that you specify for <code>MaxResults</code>, the response includes a
    ///         <code>NextToken</code> value that you can use to get another batch of
    ///         <code>PolicySummary</code> objects.</p>
    public let maxResults: Int?
    /// <p>If you specify a value for <code>MaxResults</code> and you have more
    ///         <code>PolicySummary</code> objects than the number that you specify for
    ///         <code>MaxResults</code>, AWS Firewall Manager returns a <code>NextToken</code> value in the
    ///       response that allows you to list another group of <code>PolicySummary</code> objects. For the
    ///       second and subsequent <code>ListPolicies</code> requests, specify the value of
    ///         <code>NextToken</code> from the previous response to get information about another batch of
    ///         <code>PolicySummary</code> objects.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPoliciesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPoliciesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPoliciesOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPoliciesOutputResponse(nextToken: \(String(describing: nextToken)), policyList: \(String(describing: policyList)))"}
}

extension ListPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.policyList = output.policyList
        } else {
            self.nextToken = nil
            self.policyList = nil
        }
    }
}

public struct ListPoliciesOutputResponse: Equatable {
    /// <p>If you have more <code>PolicySummary</code> objects than the number that you specified for
    ///         <code>MaxResults</code> in the request, the response includes a <code>NextToken</code>
    ///       value. To list more <code>PolicySummary</code> objects, submit another
    ///         <code>ListPolicies</code> request, and specify the <code>NextToken</code> value from the
    ///       response in the <code>NextToken</code> value in the next request.</p>
    public let nextToken: String?
    /// <p>An array of <code>PolicySummary</code> objects.</p>
    public let policyList: [PolicySummary]?

    public init (
        nextToken: String? = nil,
        policyList: [PolicySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyList = policyList
    }
}

struct ListPoliciesOutputResponseBody: Equatable {
    public let policyList: [PolicySummary]?
    public let nextToken: String?
}

extension ListPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case policyList = "PolicyList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyListContainer = try containerValues.decodeIfPresent([PolicySummary?].self, forKey: .policyList)
        var policyListDecoded0:[PolicySummary]? = nil
        if let policyListContainer = policyListContainer {
            policyListDecoded0 = [PolicySummary]()
            for structure0 in policyListContainer {
                if let structure0 = structure0 {
                    policyListDecoded0?.append(structure0)
                }
            }
        }
        policyList = policyListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListProtocolsListsInputBodyMiddleware: Middleware {
    public let id: String = "ListProtocolsListsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProtocolsListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProtocolsListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProtocolsListsInput>
    public typealias MOutput = OperationOutput<ListProtocolsListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProtocolsListsOutputError>
}

extension ListProtocolsListsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProtocolsListsInput(defaultLists: \(String(describing: defaultLists)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProtocolsListsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultLists = "DefaultLists"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultLists != false {
            try encodeContainer.encode(defaultLists, forKey: .defaultLists)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListProtocolsListsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProtocolsListsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProtocolsListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProtocolsListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProtocolsListsInput>
    public typealias MOutput = OperationOutput<ListProtocolsListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProtocolsListsOutputError>
}

public struct ListProtocolsListsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProtocolsListsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProtocolsListsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProtocolsListsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProtocolsListsInput>
    public typealias MOutput = OperationOutput<ListProtocolsListsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProtocolsListsOutputError>
}

public struct ListProtocolsListsInput: Equatable {
    /// <p>Specifies whether the lists to retrieve are default lists owned by AWS Firewall Manager.</p>
    public let defaultLists: Bool
    /// <p>The maximum number of objects that you want AWS Firewall Manager to return for this request. If more
    ///             objects are available, in the response, AWS Firewall Manager provides a
    ///            <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    ///          <p>If you don't specify this, AWS Firewall Manager returns all available objects.</p>
    public let maxResults: Int?
    /// <p>If you specify a value for <code>MaxResults</code> in your list request, and you have more objects than the maximum,
    ///         AWS Firewall Manager returns this token in the response. For all but the first request, you provide the token returned by the prior request
    ///         in the request parameters, to retrieve the next batch of objects.</p>
    public let nextToken: String?

    public init (
        defaultLists: Bool = false,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.defaultLists = defaultLists
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtocolsListsInputBody: Equatable {
    public let defaultLists: Bool
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListProtocolsListsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultLists = "DefaultLists"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultListsDecoded = try containerValues.decode(Bool.self, forKey: .defaultLists)
        defaultLists = defaultListsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProtocolsListsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProtocolsListsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProtocolsListsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProtocolsListsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProtocolsListsOutputResponse(nextToken: \(String(describing: nextToken)), protocolsLists: \(String(describing: protocolsLists)))"}
}

extension ListProtocolsListsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProtocolsListsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.protocolsLists = output.protocolsLists
        } else {
            self.nextToken = nil
            self.protocolsLists = nil
        }
    }
}

public struct ListProtocolsListsOutputResponse: Equatable {
    /// <p>If you specify a value for <code>MaxResults</code> in your list request, and you have more objects than the maximum,
    ///         AWS Firewall Manager returns this token in the response. You can use this token in subsequent requests to retrieve the next batch of objects.</p>
    public let nextToken: String?
    /// <p>An array of <code>ProtocolsListDataSummary</code> objects.</p>
    public let protocolsLists: [ProtocolsListDataSummary]?

    public init (
        nextToken: String? = nil,
        protocolsLists: [ProtocolsListDataSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.protocolsLists = protocolsLists
    }
}

struct ListProtocolsListsOutputResponseBody: Equatable {
    public let protocolsLists: [ProtocolsListDataSummary]?
    public let nextToken: String?
}

extension ListProtocolsListsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case protocolsLists = "ProtocolsLists"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsListsContainer = try containerValues.decodeIfPresent([ProtocolsListDataSummary?].self, forKey: .protocolsLists)
        var protocolsListsDecoded0:[ProtocolsListDataSummary]? = nil
        if let protocolsListsContainer = protocolsListsContainer {
            protocolsListsDecoded0 = [ProtocolsListDataSummary]()
            for structure0 in protocolsListsContainer {
                if let structure0 = structure0 {
                    protocolsListsDecoded0?.append(structure0)
                }
            }
        }
        protocolsLists = protocolsListsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to return tags for. The AWS Firewall Manager resources that support tagging are policies, applications lists, and protocols lists. </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tagList: \(String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags associated with the resource.</p>
    public let tagList: [Tag]?

    public init (
        tagList: [Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tagList: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension NetworkFirewallMissingExpectedRTViolation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case currentRouteTable = "CurrentRouteTable"
        case expectedRouteTable = "ExpectedRouteTable"
        case vPC = "VPC"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let currentRouteTable = currentRouteTable {
            try encodeContainer.encode(currentRouteTable, forKey: .currentRouteTable)
        }
        if let expectedRouteTable = expectedRouteTable {
            try encodeContainer.encode(expectedRouteTable, forKey: .expectedRouteTable)
        }
        if let vPC = vPC {
            try encodeContainer.encode(vPC, forKey: .vPC)
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let vPCDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vPC)
        vPC = vPCDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let currentRouteTableDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentRouteTable)
        currentRouteTable = currentRouteTableDecoded
        let expectedRouteTableDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expectedRouteTable)
        expectedRouteTable = expectedRouteTableDecoded
    }
}

extension NetworkFirewallMissingExpectedRTViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkFirewallMissingExpectedRTViolation(availabilityZone: \(String(describing: availabilityZone)), currentRouteTable: \(String(describing: currentRouteTable)), expectedRouteTable: \(String(describing: expectedRouteTable)), vPC: \(String(describing: vPC)), violationTarget: \(String(describing: violationTarget)))"}
}

/// <p>Violation details for AWS Network Firewall for a subnet that's not associated to the expected
///        Firewall Manager managed route table.</p>
public struct NetworkFirewallMissingExpectedRTViolation: Equatable {
    /// <p>The Availability Zone of a violating subnet. </p>
    public let availabilityZone: String?
    /// <p>The resource ID of the current route table that's associated with the subnet, if one is available.</p>
    public let currentRouteTable: String?
    /// <p>The resource ID of the route table that should be associated with the subnet.</p>
    public let expectedRouteTable: String?
    /// <p>The resource ID of the VPC associated with a violating subnet.</p>
    public let vPC: String?
    /// <p>The ID of the AWS Network Firewall or VPC resource that's in violation.</p>
    public let violationTarget: String?

    public init (
        availabilityZone: String? = nil,
        currentRouteTable: String? = nil,
        expectedRouteTable: String? = nil,
        vPC: String? = nil,
        violationTarget: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.currentRouteTable = currentRouteTable
        self.expectedRouteTable = expectedRouteTable
        self.vPC = vPC
        self.violationTarget = violationTarget
    }
}

extension NetworkFirewallMissingFirewallViolation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case targetViolationReason = "TargetViolationReason"
        case vPC = "VPC"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let targetViolationReason = targetViolationReason {
            try encodeContainer.encode(targetViolationReason, forKey: .targetViolationReason)
        }
        if let vPC = vPC {
            try encodeContainer.encode(vPC, forKey: .vPC)
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let vPCDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vPC)
        vPC = vPCDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let targetViolationReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetViolationReason)
        targetViolationReason = targetViolationReasonDecoded
    }
}

extension NetworkFirewallMissingFirewallViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkFirewallMissingFirewallViolation(availabilityZone: \(String(describing: availabilityZone)), targetViolationReason: \(String(describing: targetViolationReason)), vPC: \(String(describing: vPC)), violationTarget: \(String(describing: violationTarget)))"}
}

/// <p>Violation details for AWS Network Firewall for a subnet that doesn't have a
///        Firewall Manager managed firewall in its VPC. </p>
public struct NetworkFirewallMissingFirewallViolation: Equatable {
    /// <p>The Availability Zone of a violating subnet. </p>
    public let availabilityZone: String?
    /// <p>The reason the resource has this violation, if one is available. </p>
    public let targetViolationReason: String?
    /// <p>The resource ID of the VPC associated with a violating subnet.</p>
    public let vPC: String?
    /// <p>The ID of the AWS Network Firewall or VPC resource that's in violation.</p>
    public let violationTarget: String?

    public init (
        availabilityZone: String? = nil,
        targetViolationReason: String? = nil,
        vPC: String? = nil,
        violationTarget: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.targetViolationReason = targetViolationReason
        self.vPC = vPC
        self.violationTarget = violationTarget
    }
}

extension NetworkFirewallMissingSubnetViolation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case targetViolationReason = "TargetViolationReason"
        case vPC = "VPC"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let targetViolationReason = targetViolationReason {
            try encodeContainer.encode(targetViolationReason, forKey: .targetViolationReason)
        }
        if let vPC = vPC {
            try encodeContainer.encode(vPC, forKey: .vPC)
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let vPCDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vPC)
        vPC = vPCDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let targetViolationReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetViolationReason)
        targetViolationReason = targetViolationReasonDecoded
    }
}

extension NetworkFirewallMissingSubnetViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkFirewallMissingSubnetViolation(availabilityZone: \(String(describing: availabilityZone)), targetViolationReason: \(String(describing: targetViolationReason)), vPC: \(String(describing: vPC)), violationTarget: \(String(describing: violationTarget)))"}
}

/// <p>Violation details for AWS Network Firewall for an Availability Zone that's
///        missing the expected Firewall Manager managed subnet.</p>
public struct NetworkFirewallMissingSubnetViolation: Equatable {
    /// <p>The Availability Zone of a violating subnet. </p>
    public let availabilityZone: String?
    /// <p>The reason the resource has this violation, if one is available. </p>
    public let targetViolationReason: String?
    /// <p>The resource ID of the VPC associated with a violating subnet.</p>
    public let vPC: String?
    /// <p>The ID of the AWS Network Firewall or VPC resource that's in violation.</p>
    public let violationTarget: String?

    public init (
        availabilityZone: String? = nil,
        targetViolationReason: String? = nil,
        vPC: String? = nil,
        violationTarget: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.targetViolationReason = targetViolationReason
        self.vPC = vPC
        self.violationTarget = violationTarget
    }
}

extension NetworkFirewallPolicyDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statefulRuleGroups = "StatefulRuleGroups"
        case statelessCustomActions = "StatelessCustomActions"
        case statelessDefaultActions = "StatelessDefaultActions"
        case statelessFragmentDefaultActions = "StatelessFragmentDefaultActions"
        case statelessRuleGroups = "StatelessRuleGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statefulRuleGroups = statefulRuleGroups {
            var statefulRuleGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statefulRuleGroups)
            for statefulrulegrouplist0 in statefulRuleGroups {
                try statefulRuleGroupsContainer.encode(statefulrulegrouplist0)
            }
        }
        if let statelessCustomActions = statelessCustomActions {
            var statelessCustomActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessCustomActions)
            for networkfirewallactionlist0 in statelessCustomActions {
                try statelessCustomActionsContainer.encode(networkfirewallactionlist0)
            }
        }
        if let statelessDefaultActions = statelessDefaultActions {
            var statelessDefaultActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessDefaultActions)
            for networkfirewallactionlist0 in statelessDefaultActions {
                try statelessDefaultActionsContainer.encode(networkfirewallactionlist0)
            }
        }
        if let statelessFragmentDefaultActions = statelessFragmentDefaultActions {
            var statelessFragmentDefaultActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessFragmentDefaultActions)
            for networkfirewallactionlist0 in statelessFragmentDefaultActions {
                try statelessFragmentDefaultActionsContainer.encode(networkfirewallactionlist0)
            }
        }
        if let statelessRuleGroups = statelessRuleGroups {
            var statelessRuleGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessRuleGroups)
            for statelessrulegrouplist0 in statelessRuleGroups {
                try statelessRuleGroupsContainer.encode(statelessrulegrouplist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statelessRuleGroupsContainer = try containerValues.decodeIfPresent([StatelessRuleGroup?].self, forKey: .statelessRuleGroups)
        var statelessRuleGroupsDecoded0:[StatelessRuleGroup]? = nil
        if let statelessRuleGroupsContainer = statelessRuleGroupsContainer {
            statelessRuleGroupsDecoded0 = [StatelessRuleGroup]()
            for structure0 in statelessRuleGroupsContainer {
                if let structure0 = structure0 {
                    statelessRuleGroupsDecoded0?.append(structure0)
                }
            }
        }
        statelessRuleGroups = statelessRuleGroupsDecoded0
        let statelessDefaultActionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .statelessDefaultActions)
        var statelessDefaultActionsDecoded0:[String]? = nil
        if let statelessDefaultActionsContainer = statelessDefaultActionsContainer {
            statelessDefaultActionsDecoded0 = [String]()
            for string0 in statelessDefaultActionsContainer {
                if let string0 = string0 {
                    statelessDefaultActionsDecoded0?.append(string0)
                }
            }
        }
        statelessDefaultActions = statelessDefaultActionsDecoded0
        let statelessFragmentDefaultActionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .statelessFragmentDefaultActions)
        var statelessFragmentDefaultActionsDecoded0:[String]? = nil
        if let statelessFragmentDefaultActionsContainer = statelessFragmentDefaultActionsContainer {
            statelessFragmentDefaultActionsDecoded0 = [String]()
            for string0 in statelessFragmentDefaultActionsContainer {
                if let string0 = string0 {
                    statelessFragmentDefaultActionsDecoded0?.append(string0)
                }
            }
        }
        statelessFragmentDefaultActions = statelessFragmentDefaultActionsDecoded0
        let statelessCustomActionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .statelessCustomActions)
        var statelessCustomActionsDecoded0:[String]? = nil
        if let statelessCustomActionsContainer = statelessCustomActionsContainer {
            statelessCustomActionsDecoded0 = [String]()
            for string0 in statelessCustomActionsContainer {
                if let string0 = string0 {
                    statelessCustomActionsDecoded0?.append(string0)
                }
            }
        }
        statelessCustomActions = statelessCustomActionsDecoded0
        let statefulRuleGroupsContainer = try containerValues.decodeIfPresent([StatefulRuleGroup?].self, forKey: .statefulRuleGroups)
        var statefulRuleGroupsDecoded0:[StatefulRuleGroup]? = nil
        if let statefulRuleGroupsContainer = statefulRuleGroupsContainer {
            statefulRuleGroupsDecoded0 = [StatefulRuleGroup]()
            for structure0 in statefulRuleGroupsContainer {
                if let structure0 = structure0 {
                    statefulRuleGroupsDecoded0?.append(structure0)
                }
            }
        }
        statefulRuleGroups = statefulRuleGroupsDecoded0
    }
}

extension NetworkFirewallPolicyDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkFirewallPolicyDescription(statefulRuleGroups: \(String(describing: statefulRuleGroups)), statelessCustomActions: \(String(describing: statelessCustomActions)), statelessDefaultActions: \(String(describing: statelessDefaultActions)), statelessFragmentDefaultActions: \(String(describing: statelessFragmentDefaultActions)), statelessRuleGroups: \(String(describing: statelessRuleGroups)))"}
}

/// <p>The definition of the AWS Network Firewall firewall policy.</p>
public struct NetworkFirewallPolicyDescription: Equatable {
    /// <p>The stateful rule groups that are used in the Network Firewall firewall policy. </p>
    public let statefulRuleGroups: [StatefulRuleGroup]?
    /// <p>Names of custom actions that are available for use in the stateless default actions settings.</p>
    public let statelessCustomActions: [String]?
    /// <p>The actions to take on packets that don't match any of the stateless rule groups. </p>
    public let statelessDefaultActions: [String]?
    /// <p>The actions to take on packet fragments that don't match any of the stateless rule groups. </p>
    public let statelessFragmentDefaultActions: [String]?
    /// <p>The stateless rule groups that are used in the Network Firewall firewall policy. </p>
    public let statelessRuleGroups: [StatelessRuleGroup]?

    public init (
        statefulRuleGroups: [StatefulRuleGroup]? = nil,
        statelessCustomActions: [String]? = nil,
        statelessDefaultActions: [String]? = nil,
        statelessFragmentDefaultActions: [String]? = nil,
        statelessRuleGroups: [StatelessRuleGroup]? = nil
    )
    {
        self.statefulRuleGroups = statefulRuleGroups
        self.statelessCustomActions = statelessCustomActions
        self.statelessDefaultActions = statelessDefaultActions
        self.statelessFragmentDefaultActions = statelessFragmentDefaultActions
        self.statelessRuleGroups = statelessRuleGroups
    }
}

extension NetworkFirewallPolicyModifiedViolation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentPolicyDescription = "CurrentPolicyDescription"
        case expectedPolicyDescription = "ExpectedPolicyDescription"
        case violationTarget = "ViolationTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentPolicyDescription = currentPolicyDescription {
            try encodeContainer.encode(currentPolicyDescription, forKey: .currentPolicyDescription)
        }
        if let expectedPolicyDescription = expectedPolicyDescription {
            try encodeContainer.encode(expectedPolicyDescription, forKey: .expectedPolicyDescription)
        }
        if let violationTarget = violationTarget {
            try encodeContainer.encode(violationTarget, forKey: .violationTarget)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let violationTargetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .violationTarget)
        violationTarget = violationTargetDecoded
        let currentPolicyDescriptionDecoded = try containerValues.decodeIfPresent(NetworkFirewallPolicyDescription.self, forKey: .currentPolicyDescription)
        currentPolicyDescription = currentPolicyDescriptionDecoded
        let expectedPolicyDescriptionDecoded = try containerValues.decodeIfPresent(NetworkFirewallPolicyDescription.self, forKey: .expectedPolicyDescription)
        expectedPolicyDescription = expectedPolicyDescriptionDecoded
    }
}

extension NetworkFirewallPolicyModifiedViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkFirewallPolicyModifiedViolation(currentPolicyDescription: \(String(describing: currentPolicyDescription)), expectedPolicyDescription: \(String(describing: expectedPolicyDescription)), violationTarget: \(String(describing: violationTarget)))"}
}

/// <p>Violation details for AWS Network Firewall for a firewall policy that has a different
///        <a>NetworkFirewallPolicyDescription</a> than is required by the Firewall Manager policy. </p>
public struct NetworkFirewallPolicyModifiedViolation: Equatable {
    /// <p>The policy that's currently in use in the individual account. </p>
    public let currentPolicyDescription: NetworkFirewallPolicyDescription?
    /// <p>The policy that should be in use in the individual account in order to be compliant. </p>
    public let expectedPolicyDescription: NetworkFirewallPolicyDescription?
    /// <p>The ID of the AWS Network Firewall or VPC resource that's in violation.</p>
    public let violationTarget: String?

    public init (
        currentPolicyDescription: NetworkFirewallPolicyDescription? = nil,
        expectedPolicyDescription: NetworkFirewallPolicyDescription? = nil,
        violationTarget: String? = nil
    )
    {
        self.currentPolicyDescription = currentPolicyDescription
        self.expectedPolicyDescription = expectedPolicyDescription
        self.violationTarget = violationTarget
    }
}

extension PartialMatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reference = "Reference"
        case targetViolationReasons = "TargetViolationReasons"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reference = reference {
            try encodeContainer.encode(reference, forKey: .reference)
        }
        if let targetViolationReasons = targetViolationReasons {
            var targetViolationReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetViolationReasons)
            for targetviolationreasons0 in targetViolationReasons {
                try targetViolationReasonsContainer.encode(targetviolationreasons0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reference)
        reference = referenceDecoded
        let targetViolationReasonsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetViolationReasons)
        var targetViolationReasonsDecoded0:[String]? = nil
        if let targetViolationReasonsContainer = targetViolationReasonsContainer {
            targetViolationReasonsDecoded0 = [String]()
            for string0 in targetViolationReasonsContainer {
                if let string0 = string0 {
                    targetViolationReasonsDecoded0?.append(string0)
                }
            }
        }
        targetViolationReasons = targetViolationReasonsDecoded0
    }
}

extension PartialMatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PartialMatch(reference: \(String(describing: reference)), targetViolationReasons: \(String(describing: targetViolationReasons)))"}
}

/// <p>The reference rule that partially matches the <code>ViolationTarget</code> rule and violation reason.</p>
public struct PartialMatch: Equatable {
    /// <p>The reference rule from the master security group of the AWS Firewall Manager policy.</p>
    public let reference: String?
    /// <p>The violation reason.</p>
    public let targetViolationReasons: [String]?

    public init (
        reference: String? = nil,
        targetViolationReasons: [String]? = nil
    )
    {
        self.reference = reference
        self.targetViolationReasons = targetViolationReasons
    }
}

extension Policy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludeMap = "ExcludeMap"
        case excludeResourceTags = "ExcludeResourceTags"
        case includeMap = "IncludeMap"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case policyUpdateToken = "PolicyUpdateToken"
        case remediationEnabled = "RemediationEnabled"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case resourceTypeList = "ResourceTypeList"
        case securityServicePolicyData = "SecurityServicePolicyData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludeMap = excludeMap {
            var excludeMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .excludeMap)
            for (dictKey0, customerpolicyscopemap0) in excludeMap {
                try excludeMapContainer.encode(customerpolicyscopemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if excludeResourceTags != false {
            try encodeContainer.encode(excludeResourceTags, forKey: .excludeResourceTags)
        }
        if let includeMap = includeMap {
            var includeMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .includeMap)
            for (dictKey0, customerpolicyscopemap0) in includeMap {
                try includeMapContainer.encode(customerpolicyscopemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyUpdateToken = policyUpdateToken {
            try encodeContainer.encode(policyUpdateToken, forKey: .policyUpdateToken)
        }
        if remediationEnabled != false {
            try encodeContainer.encode(remediationEnabled, forKey: .remediationEnabled)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetags0 in resourceTags {
                try resourceTagsContainer.encode(resourcetags0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let resourceTypeList = resourceTypeList {
            var resourceTypeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypeList)
            for resourcetypelist0 in resourceTypeList {
                try resourceTypeListContainer.encode(resourcetypelist0)
            }
        }
        if let securityServicePolicyData = securityServicePolicyData {
            try encodeContainer.encode(securityServicePolicyData, forKey: .securityServicePolicyData)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyUpdateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyUpdateToken)
        policyUpdateToken = policyUpdateTokenDecoded
        let securityServicePolicyDataDecoded = try containerValues.decodeIfPresent(SecurityServicePolicyData.self, forKey: .securityServicePolicyData)
        securityServicePolicyData = securityServicePolicyDataDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceTypeListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceTypeList)
        var resourceTypeListDecoded0:[String]? = nil
        if let resourceTypeListContainer = resourceTypeListContainer {
            resourceTypeListDecoded0 = [String]()
            for string0 in resourceTypeListContainer {
                if let string0 = string0 {
                    resourceTypeListDecoded0?.append(string0)
                }
            }
        }
        resourceTypeList = resourceTypeListDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let excludeResourceTagsDecoded = try containerValues.decode(Bool.self, forKey: .excludeResourceTags)
        excludeResourceTags = excludeResourceTagsDecoded
        let remediationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .remediationEnabled)
        remediationEnabled = remediationEnabledDecoded
        let includeMapContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .includeMap)
        var includeMapDecoded0: [String:[String]]? = nil
        if let includeMapContainer = includeMapContainer {
            includeMapDecoded0 = [String:[String]]()
            for (key0, customerpolicyscopeidlist0) in includeMapContainer {
                var customerpolicyscopeidlist0Decoded0: [String]? = nil
                if let customerpolicyscopeidlist0 = customerpolicyscopeidlist0 {
                    customerpolicyscopeidlist0Decoded0 = [String]()
                    for string1 in customerpolicyscopeidlist0 {
                        if let string1 = string1 {
                            customerpolicyscopeidlist0Decoded0?.append(string1)
                        }
                    }
                }
                includeMapDecoded0?[key0] = customerpolicyscopeidlist0Decoded0
            }
        }
        includeMap = includeMapDecoded0
        let excludeMapContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .excludeMap)
        var excludeMapDecoded0: [String:[String]]? = nil
        if let excludeMapContainer = excludeMapContainer {
            excludeMapDecoded0 = [String:[String]]()
            for (key0, customerpolicyscopeidlist0) in excludeMapContainer {
                var customerpolicyscopeidlist0Decoded0: [String]? = nil
                if let customerpolicyscopeidlist0 = customerpolicyscopeidlist0 {
                    customerpolicyscopeidlist0Decoded0 = [String]()
                    for string1 in customerpolicyscopeidlist0 {
                        if let string1 = string1 {
                            customerpolicyscopeidlist0Decoded0?.append(string1)
                        }
                    }
                }
                excludeMapDecoded0?[key0] = customerpolicyscopeidlist0Decoded0
            }
        }
        excludeMap = excludeMapDecoded0
    }
}

extension Policy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Policy(excludeMap: \(String(describing: excludeMap)), excludeResourceTags: \(String(describing: excludeResourceTags)), includeMap: \(String(describing: includeMap)), policyId: \(String(describing: policyId)), policyName: \(String(describing: policyName)), policyUpdateToken: \(String(describing: policyUpdateToken)), remediationEnabled: \(String(describing: remediationEnabled)), resourceTags: \(String(describing: resourceTags)), resourceType: \(String(describing: resourceType)), resourceTypeList: \(String(describing: resourceTypeList)), securityServicePolicyData: \(String(describing: securityServicePolicyData)))"}
}

/// <p>An AWS Firewall Manager policy.</p>
public struct Policy: Equatable {
    /// <p>Specifies the AWS account IDs and AWS Organizations organizational units (OUs) to exclude from the policy.
    ///           Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.</p>
    ///               <p>You can specify inclusions or exclusions, but not both. If you specify an <code>IncludeMap</code>, AWS Firewall Manager
    ///           applies the policy to all accounts specified by the <code>IncludeMap</code>, and
    ///           does not evaluate any <code>ExcludeMap</code> specifications. If you do not specify an <code>IncludeMap</code>, then Firewall Manager
    ///             applies the policy to all accounts except for those specified by the <code>ExcludeMap</code>.</p>
    ///          <p>You can specify account IDs, OUs, or a combination: </p>
    ///          <ul>
    ///             <li>
    ///                <p>Specify account IDs by setting the key to <code>ACCOUNT</code>. For example, the following is a valid map:
    ///       <code>{“ACCOUNT” : [“accountID1”, “accountID2”]}</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Specify OUs by setting the key to <code>ORG_UNIT</code>. For example, the following is a valid map:
    ///   <code>{“ORG_UNIT” : [“ouid111”, “ouid112”]}</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Specify accounts and OUs together in a single map, separated with a comma. For example, the following is a valid map:
    ///       <code>{“ACCOUNT” : [“accountID1”, “accountID2”], “ORG_UNIT” : [“ouid111”, “ouid112”]}</code>.</p>
    ///             </li>
    ///          </ul>
    public let excludeMap: [String:[String]]?
    /// <p>If set to <code>True</code>, resources with the tags that are specified in the
    ///         <code>ResourceTag</code> array are not in scope of the policy. If set to <code>False</code>,
    ///       and the <code>ResourceTag</code> array is not null, only resources with the specified tags are
    ///       in scope of the policy.</p>
    public let excludeResourceTags: Bool
    /// <p>Specifies the AWS account IDs and AWS Organizations organizational units (OUs) to include in the policy.
    ///           Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time.</p>
    ///               <p>You can specify inclusions or exclusions, but not both. If you specify an <code>IncludeMap</code>, AWS Firewall Manager
    ///           applies the policy to all accounts specified by the <code>IncludeMap</code>, and
    ///           does not evaluate any <code>ExcludeMap</code> specifications. If you do not specify an <code>IncludeMap</code>, then Firewall Manager
    ///             applies the policy to all accounts except for those specified by the <code>ExcludeMap</code>.</p>
    ///          <p>You can specify account IDs, OUs, or a combination: </p>
    ///          <ul>
    ///             <li>
    ///                <p>Specify account IDs by setting the key to <code>ACCOUNT</code>. For example, the following is a valid map:
    ///       <code>{“ACCOUNT” : [“accountID1”, “accountID2”]}</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Specify OUs by setting the key to <code>ORG_UNIT</code>. For example, the following is a valid map:
    ///   <code>{“ORG_UNIT” : [“ouid111”, “ouid112”]}</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Specify accounts and OUs together in a single map, separated with a comma. For example, the following is a valid map:
    ///       <code>{“ACCOUNT” : [“accountID1”, “accountID2”], “ORG_UNIT” : [“ouid111”, “ouid112”]}</code>.</p>
    ///             </li>
    ///          </ul>
    public let includeMap: [String:[String]]?
    /// <p>The ID of the AWS Firewall Manager policy.</p>
    public let policyId: String?
    /// <p>The name of the AWS Firewall Manager policy.</p>
    public let policyName: String?
    /// <p>A unique identifier for each update to the policy. When issuing a <code>PutPolicy</code>
    ///       request, the <code>PolicyUpdateToken</code> in the request must match the
    ///         <code>PolicyUpdateToken</code> of the current policy version. To get the
    ///         <code>PolicyUpdateToken</code> of the current policy version, use a <code>GetPolicy</code>
    ///       request.</p>
    public let policyUpdateToken: String?
    /// <p>Indicates if the policy should be automatically applied to new resources.</p>
    public let remediationEnabled: Bool
    /// <p>An array of <code>ResourceTag</code> objects.</p>
    public let resourceTags: [ResourceTag]?
    /// <p>The type of resource protected by or in scope of the policy. This is in the format shown
    ///         in the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a>.
    ///             For AWS WAF and Shield Advanced, examples include
    ///         <code>AWS::ElasticLoadBalancingV2::LoadBalancer</code> and
    ///         <code>AWS::CloudFront::Distribution</code>. For a security group common policy, valid values
    ///       are <code>AWS::EC2::NetworkInterface</code> and <code>AWS::EC2::Instance</code>. For a
    ///       security group content audit policy, valid values are <code>AWS::EC2::SecurityGroup</code>,
    ///         <code>AWS::EC2::NetworkInterface</code>, and <code>AWS::EC2::Instance</code>. For a security
    ///             group usage audit policy, the value is <code>AWS::EC2::SecurityGroup</code>. For an AWS Network Firewall policy,
    ///                 the value is <code>AWS::EC2::VPC</code>.</p>
    public let resourceType: String?
    /// <p>An array of <code>ResourceType</code>.</p>
    public let resourceTypeList: [String]?
    /// <p>Details about the security service that is being used to protect the resources.</p>
    public let securityServicePolicyData: SecurityServicePolicyData?

    public init (
        excludeMap: [String:[String]]? = nil,
        excludeResourceTags: Bool = false,
        includeMap: [String:[String]]? = nil,
        policyId: String? = nil,
        policyName: String? = nil,
        policyUpdateToken: String? = nil,
        remediationEnabled: Bool = false,
        resourceTags: [ResourceTag]? = nil,
        resourceType: String? = nil,
        resourceTypeList: [String]? = nil,
        securityServicePolicyData: SecurityServicePolicyData? = nil
    )
    {
        self.excludeMap = excludeMap
        self.excludeResourceTags = excludeResourceTags
        self.includeMap = includeMap
        self.policyId = policyId
        self.policyName = policyName
        self.policyUpdateToken = policyUpdateToken
        self.remediationEnabled = remediationEnabled
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.resourceTypeList = resourceTypeList
        self.securityServicePolicyData = securityServicePolicyData
    }
}

extension PolicyComplianceDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evaluationLimitExceeded = "EvaluationLimitExceeded"
        case expiredAt = "ExpiredAt"
        case issueInfoMap = "IssueInfoMap"
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case policyOwner = "PolicyOwner"
        case violators = "Violators"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if evaluationLimitExceeded != false {
            try encodeContainer.encode(evaluationLimitExceeded, forKey: .evaluationLimitExceeded)
        }
        if let expiredAt = expiredAt {
            try encodeContainer.encode(expiredAt.timeIntervalSince1970, forKey: .expiredAt)
        }
        if let issueInfoMap = issueInfoMap {
            var issueInfoMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .issueInfoMap)
            for (dictKey0, issueinfomap0) in issueInfoMap {
                try issueInfoMapContainer.encode(issueinfomap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let memberAccount = memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyOwner = policyOwner {
            try encodeContainer.encode(policyOwner, forKey: .policyOwner)
        }
        if let violators = violators {
            var violatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .violators)
            for complianceviolators0 in violators {
                try violatorsContainer.encode(complianceviolators0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyOwner)
        policyOwner = policyOwnerDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
        let violatorsContainer = try containerValues.decodeIfPresent([ComplianceViolator?].self, forKey: .violators)
        var violatorsDecoded0:[ComplianceViolator]? = nil
        if let violatorsContainer = violatorsContainer {
            violatorsDecoded0 = [ComplianceViolator]()
            for structure0 in violatorsContainer {
                if let structure0 = structure0 {
                    violatorsDecoded0?.append(structure0)
                }
            }
        }
        violators = violatorsDecoded0
        let evaluationLimitExceededDecoded = try containerValues.decode(Bool.self, forKey: .evaluationLimitExceeded)
        evaluationLimitExceeded = evaluationLimitExceededDecoded
        let expiredAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiredAt)
        expiredAt = expiredAtDecoded
        let issueInfoMapContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .issueInfoMap)
        var issueInfoMapDecoded0: [String:String]? = nil
        if let issueInfoMapContainer = issueInfoMapContainer {
            issueInfoMapDecoded0 = [String:String]()
            for (key0, detailedinfo0) in issueInfoMapContainer {
                if let detailedinfo0 = detailedinfo0 {
                    issueInfoMapDecoded0?[key0] = detailedinfo0
                }
            }
        }
        issueInfoMap = issueInfoMapDecoded0
    }
}

extension PolicyComplianceDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyComplianceDetail(evaluationLimitExceeded: \(String(describing: evaluationLimitExceeded)), expiredAt: \(String(describing: expiredAt)), issueInfoMap: \(String(describing: issueInfoMap)), memberAccount: \(String(describing: memberAccount)), policyId: \(String(describing: policyId)), policyOwner: \(String(describing: policyOwner)), violators: \(String(describing: violators)))"}
}

/// <p>Describes
///       the noncompliant resources in a member account for a specific AWS Firewall
///       Manager policy. A maximum of 100 entries are displayed. If more than 100 resources are
///       noncompliant, <code>EvaluationLimitExceeded</code> is set to <code>True</code>.</p>
public struct PolicyComplianceDetail: Equatable {
    /// <p>Indicates if over 100 resources are noncompliant with the AWS Firewall Manager
    ///       policy.</p>
    public let evaluationLimitExceeded: Bool
    /// <p>A timestamp that indicates when the returned information should be considered out of
    ///       date.</p>
    public let expiredAt: Date?
    /// <p>Details about problems with dependent services, such as AWS WAF or AWS Config, that are
    ///       causing a resource to be noncompliant. The details include the name of the dependent service
    ///       and the error message received that indicates the problem with the service.</p>
    public let issueInfoMap: [String:String]?
    /// <p>The AWS account ID.</p>
    public let memberAccount: String?
    /// <p>The ID of the AWS Firewall Manager policy.</p>
    public let policyId: String?
    /// <p>The AWS account that created the AWS Firewall Manager policy.</p>
    public let policyOwner: String?
    /// <p>An array of resources that aren't protected by the AWS WAF or Shield Advanced policy or
    ///       that aren't in compliance with the security group policy.</p>
    public let violators: [ComplianceViolator]?

    public init (
        evaluationLimitExceeded: Bool = false,
        expiredAt: Date? = nil,
        issueInfoMap: [String:String]? = nil,
        memberAccount: String? = nil,
        policyId: String? = nil,
        policyOwner: String? = nil,
        violators: [ComplianceViolator]? = nil
    )
    {
        self.evaluationLimitExceeded = evaluationLimitExceeded
        self.expiredAt = expiredAt
        self.issueInfoMap = issueInfoMap
        self.memberAccount = memberAccount
        self.policyId = policyId
        self.policyOwner = policyOwner
        self.violators = violators
    }
}

extension PolicyComplianceStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evaluationResults = "EvaluationResults"
        case issueInfoMap = "IssueInfoMap"
        case lastUpdated = "LastUpdated"
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case policyOwner = "PolicyOwner"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationResults = evaluationResults {
            var evaluationResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evaluationResults)
            for evaluationresults0 in evaluationResults {
                try evaluationResultsContainer.encode(evaluationresults0)
            }
        }
        if let issueInfoMap = issueInfoMap {
            var issueInfoMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .issueInfoMap)
            for (dictKey0, issueinfomap0) in issueInfoMap {
                try issueInfoMapContainer.encode(issueinfomap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let memberAccount = memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyOwner = policyOwner {
            try encodeContainer.encode(policyOwner, forKey: .policyOwner)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyOwner)
        policyOwner = policyOwnerDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
        let evaluationResultsContainer = try containerValues.decodeIfPresent([EvaluationResult?].self, forKey: .evaluationResults)
        var evaluationResultsDecoded0:[EvaluationResult]? = nil
        if let evaluationResultsContainer = evaluationResultsContainer {
            evaluationResultsDecoded0 = [EvaluationResult]()
            for structure0 in evaluationResultsContainer {
                if let structure0 = structure0 {
                    evaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        evaluationResults = evaluationResultsDecoded0
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let issueInfoMapContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .issueInfoMap)
        var issueInfoMapDecoded0: [String:String]? = nil
        if let issueInfoMapContainer = issueInfoMapContainer {
            issueInfoMapDecoded0 = [String:String]()
            for (key0, detailedinfo0) in issueInfoMapContainer {
                if let detailedinfo0 = detailedinfo0 {
                    issueInfoMapDecoded0?[key0] = detailedinfo0
                }
            }
        }
        issueInfoMap = issueInfoMapDecoded0
    }
}

extension PolicyComplianceStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyComplianceStatus(evaluationResults: \(String(describing: evaluationResults)), issueInfoMap: \(String(describing: issueInfoMap)), lastUpdated: \(String(describing: lastUpdated)), memberAccount: \(String(describing: memberAccount)), policyId: \(String(describing: policyId)), policyName: \(String(describing: policyName)), policyOwner: \(String(describing: policyOwner)))"}
}

/// <p>Indicates whether the account is compliant with the specified policy. An account is
///       considered noncompliant if it includes resources that are not protected by the policy, for AWS
///       WAF and Shield Advanced policies, or that are noncompliant with the policy, for security group
///       policies.</p>
public struct PolicyComplianceStatus: Equatable {
    /// <p>An array of <code>EvaluationResult</code> objects.</p>
    public let evaluationResults: [EvaluationResult]?
    /// <p>Details about problems with dependent services, such as AWS WAF or AWS Config, that are
    ///       causing a resource to be noncompliant. The details include the name of the dependent service
    ///       and the error message received that indicates the problem with the service.</p>
    public let issueInfoMap: [String:String]?
    /// <p>Timestamp of the last update to the <code>EvaluationResult</code> objects.</p>
    public let lastUpdated: Date?
    /// <p>The member account ID.</p>
    public let memberAccount: String?
    /// <p>The ID of the AWS Firewall Manager policy.</p>
    public let policyId: String?
    /// <p>The name of the AWS Firewall Manager policy.</p>
    public let policyName: String?
    /// <p>The AWS account that created the AWS Firewall Manager policy.</p>
    public let policyOwner: String?

    public init (
        evaluationResults: [EvaluationResult]? = nil,
        issueInfoMap: [String:String]? = nil,
        lastUpdated: Date? = nil,
        memberAccount: String? = nil,
        policyId: String? = nil,
        policyName: String? = nil,
        policyOwner: String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.issueInfoMap = issueInfoMap
        self.lastUpdated = lastUpdated
        self.memberAccount = memberAccount
        self.policyId = policyId
        self.policyName = policyName
        self.policyOwner = policyOwner
    }
}

public enum PolicyComplianceStatusType {
    case compliant
    case noncompliant
    case sdkUnknown(String)
}

extension PolicyComplianceStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PolicyComplianceStatusType] {
        return [
            .compliant,
            .noncompliant,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .compliant: return "COMPLIANT"
        case .noncompliant: return "NON_COMPLIANT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PolicyComplianceStatusType(rawValue: rawValue) ?? PolicyComplianceStatusType.sdkUnknown(rawValue)
    }
}

extension PolicySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyArn = "PolicyArn"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case remediationEnabled = "RemediationEnabled"
        case resourceType = "ResourceType"
        case securityServiceType = "SecurityServiceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyName = policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if remediationEnabled != false {
            try encodeContainer.encode(remediationEnabled, forKey: .remediationEnabled)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let securityServiceType = securityServiceType {
            try encodeContainer.encode(securityServiceType.rawValue, forKey: .securityServiceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let securityServiceTypeDecoded = try containerValues.decodeIfPresent(SecurityServiceType.self, forKey: .securityServiceType)
        securityServiceType = securityServiceTypeDecoded
        let remediationEnabledDecoded = try containerValues.decode(Bool.self, forKey: .remediationEnabled)
        remediationEnabled = remediationEnabledDecoded
    }
}

extension PolicySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicySummary(policyArn: \(String(describing: policyArn)), policyId: \(String(describing: policyId)), policyName: \(String(describing: policyName)), remediationEnabled: \(String(describing: remediationEnabled)), resourceType: \(String(describing: resourceType)), securityServiceType: \(String(describing: securityServiceType)))"}
}

/// <p>Details of the AWS Firewall Manager policy. </p>
public struct PolicySummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the specified policy.</p>
    public let policyArn: String?
    /// <p>The ID of the specified policy.</p>
    public let policyId: String?
    /// <p>The name of the specified policy.</p>
    public let policyName: String?
    /// <p>Indicates if the policy should be automatically applied to new resources.</p>
    public let remediationEnabled: Bool
    /// <p>The type of resource protected by or in scope of the policy. This is in the format shown
    ///         in the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a>.
    ///             For AWS WAF and Shield Advanced, examples include
    ///         <code>AWS::ElasticLoadBalancingV2::LoadBalancer</code> and
    ///         <code>AWS::CloudFront::Distribution</code>. For a security group common policy, valid values
    ///       are <code>AWS::EC2::NetworkInterface</code> and <code>AWS::EC2::Instance</code>. For a
    ///       security group content audit policy, valid values are <code>AWS::EC2::SecurityGroup</code>,
    ///         <code>AWS::EC2::NetworkInterface</code>, and <code>AWS::EC2::Instance</code>. For a security
    ///       group usage audit policy, the value is <code>AWS::EC2::SecurityGroup</code>. For an AWS Network Firewall policy,
    ///           the value is <code>AWS::EC2::VPC</code>.</p>
    public let resourceType: String?
    /// <p>The service that the policy is using to protect the resources. This specifies the type of
    ///       policy that is created, either an AWS WAF policy, a Shield Advanced policy, or a security
    ///       group policy.</p>
    public let securityServiceType: SecurityServiceType?

    public init (
        policyArn: String? = nil,
        policyId: String? = nil,
        policyName: String? = nil,
        remediationEnabled: Bool = false,
        resourceType: String? = nil,
        securityServiceType: SecurityServiceType? = nil
    )
    {
        self.policyArn = policyArn
        self.policyId = policyId
        self.policyName = policyName
        self.remediationEnabled = remediationEnabled
        self.resourceType = resourceType
        self.securityServiceType = securityServiceType
    }
}

extension ProtocolsListData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createTime = "CreateTime"
        case lastUpdateTime = "LastUpdateTime"
        case listId = "ListId"
        case listName = "ListName"
        case listUpdateToken = "ListUpdateToken"
        case previousProtocolsList = "PreviousProtocolsList"
        case protocolsList = "ProtocolsList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
        if let listName = listName {
            try encodeContainer.encode(listName, forKey: .listName)
        }
        if let listUpdateToken = listUpdateToken {
            try encodeContainer.encode(listUpdateToken, forKey: .listUpdateToken)
        }
        if let previousProtocolsList = previousProtocolsList {
            var previousProtocolsListContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .previousProtocolsList)
            for (dictKey0, previousprotocolslist0) in previousProtocolsList {
                try previousProtocolsListContainer.encode(previousprotocolslist0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let protocolsList = protocolsList {
            var protocolsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocolsList)
            for protocolslist0 in protocolsList {
                try protocolsListContainer.encode(protocolslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listId)
        listId = listIdDecoded
        let listNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listName)
        listName = listNameDecoded
        let listUpdateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listUpdateToken)
        listUpdateToken = listUpdateTokenDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let protocolsListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .protocolsList)
        var protocolsListDecoded0:[String]? = nil
        if let protocolsListContainer = protocolsListContainer {
            protocolsListDecoded0 = [String]()
            for string0 in protocolsListContainer {
                if let string0 = string0 {
                    protocolsListDecoded0?.append(string0)
                }
            }
        }
        protocolsList = protocolsListDecoded0
        let previousProtocolsListContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .previousProtocolsList)
        var previousProtocolsListDecoded0: [String:[String]]? = nil
        if let previousProtocolsListContainer = previousProtocolsListContainer {
            previousProtocolsListDecoded0 = [String:[String]]()
            for (key0, protocolslist0) in previousProtocolsListContainer {
                var protocolslist0Decoded0: [String]? = nil
                if let protocolslist0 = protocolslist0 {
                    protocolslist0Decoded0 = [String]()
                    for string1 in protocolslist0 {
                        if let string1 = string1 {
                            protocolslist0Decoded0?.append(string1)
                        }
                    }
                }
                previousProtocolsListDecoded0?[key0] = protocolslist0Decoded0
            }
        }
        previousProtocolsList = previousProtocolsListDecoded0
    }
}

extension ProtocolsListData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProtocolsListData(createTime: \(String(describing: createTime)), lastUpdateTime: \(String(describing: lastUpdateTime)), listId: \(String(describing: listId)), listName: \(String(describing: listName)), listUpdateToken: \(String(describing: listUpdateToken)), previousProtocolsList: \(String(describing: previousProtocolsList)), protocolsList: \(String(describing: protocolsList)))"}
}

/// <p>An AWS Firewall Manager protocols list.</p>
public struct ProtocolsListData: Equatable {
    /// <p>The time that the AWS Firewall Manager protocols list was created.</p>
    public let createTime: Date?
    /// <p>The time that the AWS Firewall Manager protocols list was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p>The ID of the AWS Firewall Manager protocols list.</p>
    public let listId: String?
    /// <p>The name of the AWS Firewall Manager protocols list.</p>
    public let listName: String?
    /// <p>A unique identifier for each update to the list. When you update
    ///         the list, the update token must match the token of the current version of the application list.
    ///         You can retrieve the update token by getting the list. </p>
    public let listUpdateToken: String?
    /// <p>A map of previous version numbers to their corresponding protocol arrays.</p>
    public let previousProtocolsList: [String:[String]]?
    /// <p>An array of protocols in the AWS Firewall Manager protocols list.</p>
    public let protocolsList: [String]?

    public init (
        createTime: Date? = nil,
        lastUpdateTime: Date? = nil,
        listId: String? = nil,
        listName: String? = nil,
        listUpdateToken: String? = nil,
        previousProtocolsList: [String:[String]]? = nil,
        protocolsList: [String]? = nil
    )
    {
        self.createTime = createTime
        self.lastUpdateTime = lastUpdateTime
        self.listId = listId
        self.listName = listName
        self.listUpdateToken = listUpdateToken
        self.previousProtocolsList = previousProtocolsList
        self.protocolsList = protocolsList
    }
}

extension ProtocolsListDataSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listArn = "ListArn"
        case listId = "ListId"
        case listName = "ListName"
        case protocolsList = "ProtocolsList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listArn = listArn {
            try encodeContainer.encode(listArn, forKey: .listArn)
        }
        if let listId = listId {
            try encodeContainer.encode(listId, forKey: .listId)
        }
        if let listName = listName {
            try encodeContainer.encode(listName, forKey: .listName)
        }
        if let protocolsList = protocolsList {
            var protocolsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocolsList)
            for protocolslist0 in protocolsList {
                try protocolsListContainer.encode(protocolslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listArn)
        listArn = listArnDecoded
        let listIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listId)
        listId = listIdDecoded
        let listNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listName)
        listName = listNameDecoded
        let protocolsListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .protocolsList)
        var protocolsListDecoded0:[String]? = nil
        if let protocolsListContainer = protocolsListContainer {
            protocolsListDecoded0 = [String]()
            for string0 in protocolsListContainer {
                if let string0 = string0 {
                    protocolsListDecoded0?.append(string0)
                }
            }
        }
        protocolsList = protocolsListDecoded0
    }
}

extension ProtocolsListDataSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProtocolsListDataSummary(listArn: \(String(describing: listArn)), listId: \(String(describing: listId)), listName: \(String(describing: listName)), protocolsList: \(String(describing: protocolsList)))"}
}

/// <p>Details of the AWS Firewall Manager protocols list.</p>
public struct ProtocolsListDataSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the specified protocols list.</p>
    public let listArn: String?
    /// <p>The ID of the specified protocols list.</p>
    public let listId: String?
    /// <p>The name of the specified protocols list.</p>
    public let listName: String?
    /// <p>An array of protocols in the AWS Firewall Manager protocols list.</p>
    public let protocolsList: [String]?

    public init (
        listArn: String? = nil,
        listId: String? = nil,
        listName: String? = nil,
        protocolsList: [String]? = nil
    )
    {
        self.listArn = listArn
        self.listId = listId
        self.listName = listName
        self.protocolsList = protocolsList
    }
}

public struct PutAppsListInputBodyMiddleware: Middleware {
    public let id: String = "PutAppsListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAppsListInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAppsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAppsListInput>
    public typealias MOutput = OperationOutput<PutAppsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAppsListOutputError>
}

extension PutAppsListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAppsListInput(appsList: \(String(describing: appsList)), tagList: \(String(describing: tagList)))"}
}

extension PutAppsListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appsList = "AppsList"
        case tagList = "TagList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsList = appsList {
            try encodeContainer.encode(appsList, forKey: .appsList)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

public struct PutAppsListInputHeadersMiddleware: Middleware {
    public let id: String = "PutAppsListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAppsListInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAppsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAppsListInput>
    public typealias MOutput = OperationOutput<PutAppsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAppsListOutputError>
}

public struct PutAppsListInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAppsListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAppsListInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAppsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAppsListInput>
    public typealias MOutput = OperationOutput<PutAppsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAppsListOutputError>
}

public struct PutAppsListInput: Equatable {
    /// <p>The details of the AWS Firewall Manager applications list to be created.</p>
    public let appsList: AppsListData?
    /// <p>The tags associated with the resource.</p>
    public let tagList: [Tag]?

    public init (
        appsList: AppsListData? = nil,
        tagList: [Tag]? = nil
    )
    {
        self.appsList = appsList
        self.tagList = tagList
    }
}

struct PutAppsListInputBody: Equatable {
    public let appsList: AppsListData?
    public let tagList: [Tag]?
}

extension PutAppsListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appsList = "AppsList"
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsListDecoded = try containerValues.decodeIfPresent(AppsListData.self, forKey: .appsList)
        appsList = appsListDecoded
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension PutAppsListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAppsListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAppsListOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAppsListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAppsListOutputResponse(appsList: \(String(describing: appsList)), appsListArn: \(String(describing: appsListArn)))"}
}

extension PutAppsListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutAppsListOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appsList = output.appsList
            self.appsListArn = output.appsListArn
        } else {
            self.appsList = nil
            self.appsListArn = nil
        }
    }
}

public struct PutAppsListOutputResponse: Equatable {
    /// <p>The details of the AWS Firewall Manager applications list.</p>
    public let appsList: AppsListData?
    /// <p>The Amazon Resource Name (ARN) of the applications list.</p>
    public let appsListArn: String?

    public init (
        appsList: AppsListData? = nil,
        appsListArn: String? = nil
    )
    {
        self.appsList = appsList
        self.appsListArn = appsListArn
    }
}

struct PutAppsListOutputResponseBody: Equatable {
    public let appsList: AppsListData?
    public let appsListArn: String?
}

extension PutAppsListOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appsList = "AppsList"
        case appsListArn = "AppsListArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsListDecoded = try containerValues.decodeIfPresent(AppsListData.self, forKey: .appsList)
        appsList = appsListDecoded
        let appsListArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appsListArn)
        appsListArn = appsListArnDecoded
    }
}

public struct PutNotificationChannelInputBodyMiddleware: Middleware {
    public let id: String = "PutNotificationChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutNotificationChannelInput>
    public typealias MOutput = OperationOutput<PutNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutNotificationChannelOutputError>
}

extension PutNotificationChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutNotificationChannelInput(snsRoleName: \(String(describing: snsRoleName)), snsTopicArn: \(String(describing: snsTopicArn)))"}
}

extension PutNotificationChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case snsRoleName = "SnsRoleName"
        case snsTopicArn = "SnsTopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snsRoleName = snsRoleName {
            try encodeContainer.encode(snsRoleName, forKey: .snsRoleName)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }
}

public struct PutNotificationChannelInputHeadersMiddleware: Middleware {
    public let id: String = "PutNotificationChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutNotificationChannelInput>
    public typealias MOutput = OperationOutput<PutNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutNotificationChannelOutputError>
}

public struct PutNotificationChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "PutNotificationChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutNotificationChannelInput>
    public typealias MOutput = OperationOutput<PutNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutNotificationChannelOutputError>
}

public struct PutNotificationChannelInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM role that allows Amazon SNS to record AWS
    ///       Firewall Manager activity. </p>
    public let snsRoleName: String?
    /// <p>The Amazon Resource Name (ARN) of the SNS topic that collects notifications from AWS
    ///       Firewall Manager.</p>
    public let snsTopicArn: String?

    public init (
        snsRoleName: String? = nil,
        snsTopicArn: String? = nil
    )
    {
        self.snsRoleName = snsRoleName
        self.snsTopicArn = snsTopicArn
    }
}

struct PutNotificationChannelInputBody: Equatable {
    public let snsTopicArn: String?
    public let snsRoleName: String?
}

extension PutNotificationChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snsRoleName = "SnsRoleName"
        case snsTopicArn = "SnsTopicArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsRoleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsRoleName)
        snsRoleName = snsRoleNameDecoded
    }
}

extension PutNotificationChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutNotificationChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutNotificationChannelOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutNotificationChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutNotificationChannelOutputResponse()"}
}

extension PutNotificationChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutNotificationChannelOutputResponse: Equatable {

    public init() {}
}

struct PutNotificationChannelOutputResponseBody: Equatable {
}

extension PutNotificationChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPolicyInput>
    public typealias MOutput = OperationOutput<PutPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPolicyOutputError>
}

extension PutPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPolicyInput(policy: \(String(describing: policy)), tagList: \(String(describing: tagList)))"}
}

extension PutPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case tagList = "TagList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

public struct PutPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPolicyInput>
    public typealias MOutput = OperationOutput<PutPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPolicyOutputError>
}

public struct PutPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPolicyInput>
    public typealias MOutput = OperationOutput<PutPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPolicyOutputError>
}

public struct PutPolicyInput: Equatable {
    /// <p>The details of the AWS Firewall Manager policy to be created.</p>
    public let policy: Policy?
    /// <p>The tags to add to the AWS resource.</p>
    public let tagList: [Tag]?

    public init (
        policy: Policy? = nil,
        tagList: [Tag]? = nil
    )
    {
        self.policy = policy
        self.tagList = tagList
    }
}

struct PutPolicyInputBody: Equatable {
    public let policy: Policy?
    public let tagList: [Tag]?
}

extension PutPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Policy.self, forKey: .policy)
        policy = policyDecoded
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension PutPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPolicyOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPolicyOutputResponse(policy: \(String(describing: policy)), policyArn: \(String(describing: policyArn)))"}
}

extension PutPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.policyArn = output.policyArn
        } else {
            self.policy = nil
            self.policyArn = nil
        }
    }
}

public struct PutPolicyOutputResponse: Equatable {
    /// <p>The details of the AWS Firewall Manager policy.</p>
    public let policy: Policy?
    /// <p>The Amazon Resource Name (ARN) of the policy.</p>
    public let policyArn: String?

    public init (
        policy: Policy? = nil,
        policyArn: String? = nil
    )
    {
        self.policy = policy
        self.policyArn = policyArn
    }
}

struct PutPolicyOutputResponseBody: Equatable {
    public let policy: Policy?
    public let policyArn: String?
}

extension PutPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case policyArn = "PolicyArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Policy.self, forKey: .policy)
        policy = policyDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

public struct PutProtocolsListInputBodyMiddleware: Middleware {
    public let id: String = "PutProtocolsListInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutProtocolsListInput>,
                  next: H) -> Swift.Result<OperationOutput<PutProtocolsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutProtocolsListInput>
    public typealias MOutput = OperationOutput<PutProtocolsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutProtocolsListOutputError>
}

extension PutProtocolsListInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutProtocolsListInput(protocolsList: \(String(describing: protocolsList)), tagList: \(String(describing: tagList)))"}
}

extension PutProtocolsListInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case protocolsList = "ProtocolsList"
        case tagList = "TagList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protocolsList = protocolsList {
            try encodeContainer.encode(protocolsList, forKey: .protocolsList)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

public struct PutProtocolsListInputHeadersMiddleware: Middleware {
    public let id: String = "PutProtocolsListInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutProtocolsListInput>,
                  next: H) -> Swift.Result<OperationOutput<PutProtocolsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutProtocolsListInput>
    public typealias MOutput = OperationOutput<PutProtocolsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutProtocolsListOutputError>
}

public struct PutProtocolsListInputQueryItemMiddleware: Middleware {
    public let id: String = "PutProtocolsListInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutProtocolsListInput>,
                  next: H) -> Swift.Result<OperationOutput<PutProtocolsListOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutProtocolsListInput>
    public typealias MOutput = OperationOutput<PutProtocolsListOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutProtocolsListOutputError>
}

public struct PutProtocolsListInput: Equatable {
    /// <p>The details of the AWS Firewall Manager protocols list to be created.</p>
    public let protocolsList: ProtocolsListData?
    /// <p>The tags associated with the resource.</p>
    public let tagList: [Tag]?

    public init (
        protocolsList: ProtocolsListData? = nil,
        tagList: [Tag]? = nil
    )
    {
        self.protocolsList = protocolsList
        self.tagList = tagList
    }
}

struct PutProtocolsListInputBody: Equatable {
    public let protocolsList: ProtocolsListData?
    public let tagList: [Tag]?
}

extension PutProtocolsListInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case protocolsList = "ProtocolsList"
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsListDecoded = try containerValues.decodeIfPresent(ProtocolsListData.self, forKey: .protocolsList)
        protocolsList = protocolsListDecoded
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension PutProtocolsListOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutProtocolsListOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutProtocolsListOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutProtocolsListOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutProtocolsListOutputResponse(protocolsList: \(String(describing: protocolsList)), protocolsListArn: \(String(describing: protocolsListArn)))"}
}

extension PutProtocolsListOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutProtocolsListOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.protocolsList = output.protocolsList
            self.protocolsListArn = output.protocolsListArn
        } else {
            self.protocolsList = nil
            self.protocolsListArn = nil
        }
    }
}

public struct PutProtocolsListOutputResponse: Equatable {
    /// <p>The details of the AWS Firewall Manager protocols list.</p>
    public let protocolsList: ProtocolsListData?
    /// <p>The Amazon Resource Name (ARN) of the protocols list.</p>
    public let protocolsListArn: String?

    public init (
        protocolsList: ProtocolsListData? = nil,
        protocolsListArn: String? = nil
    )
    {
        self.protocolsList = protocolsList
        self.protocolsListArn = protocolsListArn
    }
}

struct PutProtocolsListOutputResponseBody: Equatable {
    public let protocolsList: ProtocolsListData?
    public let protocolsListArn: String?
}

extension PutProtocolsListOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case protocolsList = "ProtocolsList"
        case protocolsListArn = "ProtocolsListArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsListDecoded = try containerValues.decodeIfPresent(ProtocolsListData.self, forKey: .protocolsList)
        protocolsList = protocolsListDecoded
        let protocolsListArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocolsListArn)
        protocolsListArn = protocolsListArnDecoded
    }
}

public enum RemediationActionType {
    case modify
    case remove
    case sdkUnknown(String)
}

extension RemediationActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RemediationActionType] {
        return [
            .modify,
            .remove,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .modify: return "MODIFY"
        case .remove: return "REMOVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RemediationActionType(rawValue: rawValue) ?? RemediationActionType.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ResourceTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceTag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The resource tags that AWS Firewall Manager uses to determine if a particular resource
///       should be included or excluded from the AWS Firewall Manager policy. Tags enable you to
///       categorize your AWS resources in different ways, for example, by purpose, owner, or
///       environment. Each tag consists of a key and an optional value. Firewall Manager combines the
///       tags with "AND" so that, if you add more than one tag to a policy scope, a resource must have
///         all the specified tags to be included or excluded. For more information, see
///     <a href="https://docs.aws.amazon.com/awsconsolehelpdocs/latest/gsg/tag-editor.html">Working with Tag Editor</a>.</p>
public struct ResourceTag: Equatable {
    /// <p>The resource tag key.</p>
    public let key: String?
    /// <p>The resource tag value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension ResourceViolation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsEc2InstanceViolation = "AwsEc2InstanceViolation"
        case awsEc2NetworkInterfaceViolation = "AwsEc2NetworkInterfaceViolation"
        case awsVPCSecurityGroupViolation = "AwsVPCSecurityGroupViolation"
        case dnsDuplicateRuleGroupViolation = "DnsDuplicateRuleGroupViolation"
        case dnsRuleGroupLimitExceededViolation = "DnsRuleGroupLimitExceededViolation"
        case dnsRuleGroupPriorityConflictViolation = "DnsRuleGroupPriorityConflictViolation"
        case networkFirewallMissingExpectedRTViolation = "NetworkFirewallMissingExpectedRTViolation"
        case networkFirewallMissingFirewallViolation = "NetworkFirewallMissingFirewallViolation"
        case networkFirewallMissingSubnetViolation = "NetworkFirewallMissingSubnetViolation"
        case networkFirewallPolicyModifiedViolation = "NetworkFirewallPolicyModifiedViolation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsEc2InstanceViolation = awsEc2InstanceViolation {
            try encodeContainer.encode(awsEc2InstanceViolation, forKey: .awsEc2InstanceViolation)
        }
        if let awsEc2NetworkInterfaceViolation = awsEc2NetworkInterfaceViolation {
            try encodeContainer.encode(awsEc2NetworkInterfaceViolation, forKey: .awsEc2NetworkInterfaceViolation)
        }
        if let awsVPCSecurityGroupViolation = awsVPCSecurityGroupViolation {
            try encodeContainer.encode(awsVPCSecurityGroupViolation, forKey: .awsVPCSecurityGroupViolation)
        }
        if let dnsDuplicateRuleGroupViolation = dnsDuplicateRuleGroupViolation {
            try encodeContainer.encode(dnsDuplicateRuleGroupViolation, forKey: .dnsDuplicateRuleGroupViolation)
        }
        if let dnsRuleGroupLimitExceededViolation = dnsRuleGroupLimitExceededViolation {
            try encodeContainer.encode(dnsRuleGroupLimitExceededViolation, forKey: .dnsRuleGroupLimitExceededViolation)
        }
        if let dnsRuleGroupPriorityConflictViolation = dnsRuleGroupPriorityConflictViolation {
            try encodeContainer.encode(dnsRuleGroupPriorityConflictViolation, forKey: .dnsRuleGroupPriorityConflictViolation)
        }
        if let networkFirewallMissingExpectedRTViolation = networkFirewallMissingExpectedRTViolation {
            try encodeContainer.encode(networkFirewallMissingExpectedRTViolation, forKey: .networkFirewallMissingExpectedRTViolation)
        }
        if let networkFirewallMissingFirewallViolation = networkFirewallMissingFirewallViolation {
            try encodeContainer.encode(networkFirewallMissingFirewallViolation, forKey: .networkFirewallMissingFirewallViolation)
        }
        if let networkFirewallMissingSubnetViolation = networkFirewallMissingSubnetViolation {
            try encodeContainer.encode(networkFirewallMissingSubnetViolation, forKey: .networkFirewallMissingSubnetViolation)
        }
        if let networkFirewallPolicyModifiedViolation = networkFirewallPolicyModifiedViolation {
            try encodeContainer.encode(networkFirewallPolicyModifiedViolation, forKey: .networkFirewallPolicyModifiedViolation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsVPCSecurityGroupViolationDecoded = try containerValues.decodeIfPresent(AwsVPCSecurityGroupViolation.self, forKey: .awsVPCSecurityGroupViolation)
        awsVPCSecurityGroupViolation = awsVPCSecurityGroupViolationDecoded
        let awsEc2NetworkInterfaceViolationDecoded = try containerValues.decodeIfPresent(AwsEc2NetworkInterfaceViolation.self, forKey: .awsEc2NetworkInterfaceViolation)
        awsEc2NetworkInterfaceViolation = awsEc2NetworkInterfaceViolationDecoded
        let awsEc2InstanceViolationDecoded = try containerValues.decodeIfPresent(AwsEc2InstanceViolation.self, forKey: .awsEc2InstanceViolation)
        awsEc2InstanceViolation = awsEc2InstanceViolationDecoded
        let networkFirewallMissingFirewallViolationDecoded = try containerValues.decodeIfPresent(NetworkFirewallMissingFirewallViolation.self, forKey: .networkFirewallMissingFirewallViolation)
        networkFirewallMissingFirewallViolation = networkFirewallMissingFirewallViolationDecoded
        let networkFirewallMissingSubnetViolationDecoded = try containerValues.decodeIfPresent(NetworkFirewallMissingSubnetViolation.self, forKey: .networkFirewallMissingSubnetViolation)
        networkFirewallMissingSubnetViolation = networkFirewallMissingSubnetViolationDecoded
        let networkFirewallMissingExpectedRTViolationDecoded = try containerValues.decodeIfPresent(NetworkFirewallMissingExpectedRTViolation.self, forKey: .networkFirewallMissingExpectedRTViolation)
        networkFirewallMissingExpectedRTViolation = networkFirewallMissingExpectedRTViolationDecoded
        let networkFirewallPolicyModifiedViolationDecoded = try containerValues.decodeIfPresent(NetworkFirewallPolicyModifiedViolation.self, forKey: .networkFirewallPolicyModifiedViolation)
        networkFirewallPolicyModifiedViolation = networkFirewallPolicyModifiedViolationDecoded
        let dnsRuleGroupPriorityConflictViolationDecoded = try containerValues.decodeIfPresent(DnsRuleGroupPriorityConflictViolation.self, forKey: .dnsRuleGroupPriorityConflictViolation)
        dnsRuleGroupPriorityConflictViolation = dnsRuleGroupPriorityConflictViolationDecoded
        let dnsDuplicateRuleGroupViolationDecoded = try containerValues.decodeIfPresent(DnsDuplicateRuleGroupViolation.self, forKey: .dnsDuplicateRuleGroupViolation)
        dnsDuplicateRuleGroupViolation = dnsDuplicateRuleGroupViolationDecoded
        let dnsRuleGroupLimitExceededViolationDecoded = try containerValues.decodeIfPresent(DnsRuleGroupLimitExceededViolation.self, forKey: .dnsRuleGroupLimitExceededViolation)
        dnsRuleGroupLimitExceededViolation = dnsRuleGroupLimitExceededViolationDecoded
    }
}

extension ResourceViolation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceViolation(awsEc2InstanceViolation: \(String(describing: awsEc2InstanceViolation)), awsEc2NetworkInterfaceViolation: \(String(describing: awsEc2NetworkInterfaceViolation)), awsVPCSecurityGroupViolation: \(String(describing: awsVPCSecurityGroupViolation)), dnsDuplicateRuleGroupViolation: \(String(describing: dnsDuplicateRuleGroupViolation)), dnsRuleGroupLimitExceededViolation: \(String(describing: dnsRuleGroupLimitExceededViolation)), dnsRuleGroupPriorityConflictViolation: \(String(describing: dnsRuleGroupPriorityConflictViolation)), networkFirewallMissingExpectedRTViolation: \(String(describing: networkFirewallMissingExpectedRTViolation)), networkFirewallMissingFirewallViolation: \(String(describing: networkFirewallMissingFirewallViolation)), networkFirewallMissingSubnetViolation: \(String(describing: networkFirewallMissingSubnetViolation)), networkFirewallPolicyModifiedViolation: \(String(describing: networkFirewallPolicyModifiedViolation)))"}
}

/// <p>Violation detail based on resource type.</p>
public struct ResourceViolation: Equatable {
    /// <p>Violation details for an EC2 instance.</p>
    public let awsEc2InstanceViolation: AwsEc2InstanceViolation?
    /// <p>Violation details for network interface.</p>
    public let awsEc2NetworkInterfaceViolation: AwsEc2NetworkInterfaceViolation?
    /// <p>Violation details for security groups.</p>
    public let awsVPCSecurityGroupViolation: AwsVPCSecurityGroupViolation?
    /// <p>Violation detail for a DNS Firewall policy that indicates that a rule group that Firewall Manager
    ///        tried to associate with a VPC is already associated with the VPC and can't be associated again. </p>
    public let dnsDuplicateRuleGroupViolation: DnsDuplicateRuleGroupViolation?
    /// <p>Violation details for a DNS Firewall policy that indicates that the VPC reached the limit for associated DNS Firewall rule groups. Firewall Manager tried to associate another rule group with the VPC and failed. </p>
    public let dnsRuleGroupLimitExceededViolation: DnsRuleGroupLimitExceededViolation?
    /// <p>Violation detail for a DNS Firewall policy that indicates that a rule group that Firewall Manager
    ///        tried to associate with a VPC has the same priority as a rule group that's already associated. </p>
    public let dnsRuleGroupPriorityConflictViolation: DnsRuleGroupPriorityConflictViolation?
    /// <p>Violation detail for an Network Firewall policy that indicates that a subnet
    ///       is not associated with the expected Firewall Manager managed route table. </p>
    public let networkFirewallMissingExpectedRTViolation: NetworkFirewallMissingExpectedRTViolation?
    /// <p>Violation detail for an Network Firewall policy that indicates that a subnet has no Firewall Manager
    ///         managed firewall in its VPC. </p>
    public let networkFirewallMissingFirewallViolation: NetworkFirewallMissingFirewallViolation?
    /// <p>Violation detail for an Network Firewall policy that indicates that an Availability Zone is
    ///        missing the expected Firewall Manager managed subnet.</p>
    public let networkFirewallMissingSubnetViolation: NetworkFirewallMissingSubnetViolation?
    /// <p>Violation detail for an Network Firewall policy that indicates that a firewall policy
    ///        in an individual account has been modified in a way that makes it noncompliant.
    ///        For example, the individual account owner might have deleted a rule group,
    ///        changed the priority of a stateless rule group, or changed a policy default action.</p>
    public let networkFirewallPolicyModifiedViolation: NetworkFirewallPolicyModifiedViolation?

    public init (
        awsEc2InstanceViolation: AwsEc2InstanceViolation? = nil,
        awsEc2NetworkInterfaceViolation: AwsEc2NetworkInterfaceViolation? = nil,
        awsVPCSecurityGroupViolation: AwsVPCSecurityGroupViolation? = nil,
        dnsDuplicateRuleGroupViolation: DnsDuplicateRuleGroupViolation? = nil,
        dnsRuleGroupLimitExceededViolation: DnsRuleGroupLimitExceededViolation? = nil,
        dnsRuleGroupPriorityConflictViolation: DnsRuleGroupPriorityConflictViolation? = nil,
        networkFirewallMissingExpectedRTViolation: NetworkFirewallMissingExpectedRTViolation? = nil,
        networkFirewallMissingFirewallViolation: NetworkFirewallMissingFirewallViolation? = nil,
        networkFirewallMissingSubnetViolation: NetworkFirewallMissingSubnetViolation? = nil,
        networkFirewallPolicyModifiedViolation: NetworkFirewallPolicyModifiedViolation? = nil
    )
    {
        self.awsEc2InstanceViolation = awsEc2InstanceViolation
        self.awsEc2NetworkInterfaceViolation = awsEc2NetworkInterfaceViolation
        self.awsVPCSecurityGroupViolation = awsVPCSecurityGroupViolation
        self.dnsDuplicateRuleGroupViolation = dnsDuplicateRuleGroupViolation
        self.dnsRuleGroupLimitExceededViolation = dnsRuleGroupLimitExceededViolation
        self.dnsRuleGroupPriorityConflictViolation = dnsRuleGroupPriorityConflictViolation
        self.networkFirewallMissingExpectedRTViolation = networkFirewallMissingExpectedRTViolation
        self.networkFirewallMissingFirewallViolation = networkFirewallMissingFirewallViolation
        self.networkFirewallMissingSubnetViolation = networkFirewallMissingSubnetViolation
        self.networkFirewallPolicyModifiedViolation = networkFirewallPolicyModifiedViolation
    }
}

extension SecurityGroupRemediationAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case isDefaultAction = "IsDefaultAction"
        case remediationActionType = "RemediationActionType"
        case remediationResult = "RemediationResult"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isDefaultAction != false {
            try encodeContainer.encode(isDefaultAction, forKey: .isDefaultAction)
        }
        if let remediationActionType = remediationActionType {
            try encodeContainer.encode(remediationActionType.rawValue, forKey: .remediationActionType)
        }
        if let remediationResult = remediationResult {
            try encodeContainer.encode(remediationResult, forKey: .remediationResult)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remediationActionTypeDecoded = try containerValues.decodeIfPresent(RemediationActionType.self, forKey: .remediationActionType)
        remediationActionType = remediationActionTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let remediationResultDecoded = try containerValues.decodeIfPresent(SecurityGroupRuleDescription.self, forKey: .remediationResult)
        remediationResult = remediationResultDecoded
        let isDefaultActionDecoded = try containerValues.decode(Bool.self, forKey: .isDefaultAction)
        isDefaultAction = isDefaultActionDecoded
    }
}

extension SecurityGroupRemediationAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityGroupRemediationAction(description: \(String(describing: description)), isDefaultAction: \(String(describing: isDefaultAction)), remediationActionType: \(String(describing: remediationActionType)), remediationResult: \(String(describing: remediationResult)))"}
}

/// <p>Remediation option for the rule specified in the <code>ViolationTarget</code>.</p>
public struct SecurityGroupRemediationAction: Equatable {
    /// <p>Brief description of the action that will be performed.</p>
    public let description: String?
    /// <p>Indicates if the current action is the default action.</p>
    public let isDefaultAction: Bool
    /// <p>The remediation action that will be performed.</p>
    public let remediationActionType: RemediationActionType?
    /// <p>The final state of the rule specified in the <code>ViolationTarget</code> after it is remediated.</p>
    public let remediationResult: SecurityGroupRuleDescription?

    public init (
        description: String? = nil,
        isDefaultAction: Bool = false,
        remediationActionType: RemediationActionType? = nil,
        remediationResult: SecurityGroupRuleDescription? = nil
    )
    {
        self.description = description
        self.isDefaultAction = isDefaultAction
        self.remediationActionType = remediationActionType
        self.remediationResult = remediationResult
    }
}

extension SecurityGroupRuleDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromPort = "FromPort"
        case iPV4Range = "IPV4Range"
        case iPV6Range = "IPV6Range"
        case prefixListId = "PrefixListId"
        case `protocol` = "Protocol"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let iPV4Range = iPV4Range {
            try encodeContainer.encode(iPV4Range, forKey: .iPV4Range)
        }
        if let iPV6Range = iPV6Range {
            try encodeContainer.encode(iPV6Range, forKey: .iPV6Range)
        }
        if let prefixListId = prefixListId {
            try encodeContainer.encode(prefixListId, forKey: .prefixListId)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let toPort = toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iPV4RangeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iPV4Range)
        iPV4Range = iPV4RangeDecoded
        let iPV6RangeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iPV6Range)
        iPV6Range = iPV6RangeDecoded
        let prefixListIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefixListId)
        prefixListId = prefixListIdDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let fromPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .toPort)
        toPort = toPortDecoded
    }
}

extension SecurityGroupRuleDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityGroupRuleDescription(fromPort: \(String(describing: fromPort)), iPV4Range: \(String(describing: iPV4Range)), iPV6Range: \(String(describing: iPV6Range)), prefixListId: \(String(describing: prefixListId)), protocol: \(String(describing: `protocol`)), toPort: \(String(describing: toPort)))"}
}

/// <p>Describes a set of permissions for a security group rule.</p>
public struct SecurityGroupRuleDescription: Equatable {
    /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>icmpv6</code>) or number.</p>
    public let `protocol`: String?
    /// <p>The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of <code>-1</code> indicates all ICMP/ICMPv6 types.</p>
    public let fromPort: Int?
    /// <p>The IPv4 ranges for the security group rule.</p>
    public let iPV4Range: String?
    /// <p>The IPv6 ranges for the security group rule.</p>
    public let iPV6Range: String?
    /// <p>The ID of the prefix list for the security group rule.</p>
    public let prefixListId: String?
    /// <p>The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of <code>-1</code> indicates all ICMP/ICMPv6 codes.</p>
    public let toPort: Int?

    public init (
        `protocol`: String? = nil,
        fromPort: Int? = nil,
        iPV4Range: String? = nil,
        iPV6Range: String? = nil,
        prefixListId: String? = nil,
        toPort: Int? = nil
    )
    {
        self.`protocol` = `protocol`
        self.fromPort = fromPort
        self.iPV4Range = iPV4Range
        self.iPV6Range = iPV6Range
        self.prefixListId = prefixListId
        self.toPort = toPort
    }
}

extension SecurityServicePolicyData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case managedServiceData = "ManagedServiceData"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let managedServiceData = managedServiceData {
            try encodeContainer.encode(managedServiceData, forKey: .managedServiceData)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SecurityServiceType.self, forKey: .type)
        type = typeDecoded
        let managedServiceDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .managedServiceData)
        managedServiceData = managedServiceDataDecoded
    }
}

extension SecurityServicePolicyData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityServicePolicyData(managedServiceData: \(String(describing: managedServiceData)), type: \(String(describing: type)))"}
}

/// <p>Details about the security service that is being used to protect the resources.</p>
public struct SecurityServicePolicyData: Equatable {
    /// <p>Details about the service that are specific to the service type, in JSON format. For
    ///       service type <code>SHIELD_ADVANCED</code>, this is an empty string.</p>
    ///          <ul>
    ///             <li>
    ///                <p>Example: <code>NETWORK_FIREWALL</code>
    ///                </p>
    ///                <p>
    ///                   <code>"{\"type\":\"NETWORK_FIREWALL\",\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-west-1:1234567891011:stateless-rulegroup/rulegroup2\",\"priority\":10}],\"networkFirewallStatelessDefaultActions\":[\"aws:pass\",\"custom1\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"custom2\",\"aws:pass\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"custom1\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"dimension1\"}]}}},{\"actionName\":\"custom2\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"dimension2\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-west-1:1234567891011:stateful-rulegroup/rulegroup1\"}],\"networkFirewallOrchestrationConfig\":{\"singleFirewallEndpointPerVPC\":true,\"allowedIPV4CidrList\":[\"10.24.34.0/28\"]} }"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Example: <code>WAFV2</code>
    ///                </p>
    ///                <p>
    ///                   <code>"{\"type\":\"WAFV2\",\"preProcessRuleGroups\":[{\"ruleGroupArn\":null,\"overrideAction\":{\"type\":\"NONE\"},\"managedRuleGroupIdentifier\":{\"version\":null,\"vendorName\":\"AWS\",\"managedRuleGroupName\":\"AWSManagedRulesAmazonIpReputationList\"},\"ruleGroupType\":\"ManagedRuleGroup\",\"excludeRules\":[]}],\"postProcessRuleGroups\":[],\"defaultAction\":{\"type\":\"ALLOW\"},\"overrideCustomerWebACLAssociation\":false,\"loggingConfiguration\":{\"logDestinationConfigs\":[\"arn:aws:firehose:us-west-2:12345678912:deliverystream/aws-waf-logs-fms-admin-destination\"],\"redactedFields\":[{\"redactedFieldType\":\"SingleHeader\",\"redactedFieldValue\":\"Cookies\"},{\"redactedFieldType\":\"Method\"}]}}"</code>
    ///                </p>
    ///                <p>In the <code>loggingConfiguration</code>, you can specify one <code>logDestinationConfigs</code>, you can optionally provide up to 20 <code>redactedFields</code>, and the <code>RedactedFieldType</code> must be one of <code>URI</code>, <code>QUERY_STRING</code>, <code>HEADER</code>, or <code>METHOD</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Example: <code>WAF Classic</code>
    ///                </p>
    ///                <p>
    ///                   <code>"{\"type\": \"WAF\", \"ruleGroups\": [{\"id\":\"12345678-1bcd-9012-efga-0987654321ab\", \"overrideAction\" : {\"type\": \"COUNT\"}}], \"defaultAction\": {\"type\": \"BLOCK\"}}"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Example: <code>SECURITY_GROUPS_COMMON</code>
    ///                </p>
    ///                <p>
    ///                   <code>"{\"type\":\"SECURITY_GROUPS_COMMON\",\"revertManualSecurityGroupChanges\":false,\"exclusiveResourceSecurityGroupManagement\":false, \"applyToAllEC2InstanceENIs\":false,\"securityGroups\":[{\"id\":\" sg-000e55995d61a06bd\"}]}"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Example: <code>SECURITY_GROUPS_CONTENT_AUDIT</code>
    ///                </p>
    ///                <p>
    ///                   <code>"{\"type\":\"SECURITY_GROUPS_CONTENT_AUDIT\",\"securityGroups\":[{\"id\":\"sg-000e55995d61a06bd\"}],\"securityGroupAction\":{\"type\":\"ALLOW\"}}"</code>
    ///                </p>
    ///                <p>The security group action for content audit can be <code>ALLOW</code> or
    ///             <code>DENY</code>. For <code>ALLOW</code>, all in-scope security group rules must be
    ///           within the allowed range of the policy's security group rules. For <code>DENY</code>, all
    ///           in-scope security group rules must not contain a value or a range that matches a rule
    ///           value or range in the policy security group.</p>
    ///             </li>
    ///             <li>
    ///                <p>Example: <code>SECURITY_GROUPS_USAGE_AUDIT</code>
    ///                </p>
    ///                <p>
    ///                   <code>"{\"type\":\"SECURITY_GROUPS_USAGE_AUDIT\",\"deleteUnusedSecurityGroups\":true,\"coalesceRedundantSecurityGroups\":true}"</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let managedServiceData: String?
    /// <p>The service that the policy is using to protect the resources. This specifies the type of
    ///       policy that is created, either an AWS WAF policy, a Shield Advanced policy, or a security
    ///       group policy. For security group policies, Firewall Manager supports one security group for
    ///       each common policy and for each content audit policy. This is an adjustable limit that you can
    ///       increase by contacting AWS Support.</p>
    public let type: SecurityServiceType?

    public init (
        managedServiceData: String? = nil,
        type: SecurityServiceType? = nil
    )
    {
        self.managedServiceData = managedServiceData
        self.type = type
    }
}

public enum SecurityServiceType {
    case dnsFirewall
    case networkFirewall
    case securityGroupsCommon
    case securityGroupsContentAudit
    case securityGroupsUsageAudit
    case shieldAdvanced
    case waf
    case wafv2
    case sdkUnknown(String)
}

extension SecurityServiceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SecurityServiceType] {
        return [
            .dnsFirewall,
            .networkFirewall,
            .securityGroupsCommon,
            .securityGroupsContentAudit,
            .securityGroupsUsageAudit,
            .shieldAdvanced,
            .waf,
            .wafv2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dnsFirewall: return "DNS_FIREWALL"
        case .networkFirewall: return "NETWORK_FIREWALL"
        case .securityGroupsCommon: return "SECURITY_GROUPS_COMMON"
        case .securityGroupsContentAudit: return "SECURITY_GROUPS_CONTENT_AUDIT"
        case .securityGroupsUsageAudit: return "SECURITY_GROUPS_USAGE_AUDIT"
        case .shieldAdvanced: return "SHIELD_ADVANCED"
        case .waf: return "WAF"
        case .wafv2: return "WAFV2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SecurityServiceType(rawValue: rawValue) ?? SecurityServiceType.sdkUnknown(rawValue)
    }
}

extension StatefulRuleGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case ruleGroupName = "RuleGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let ruleGroupName = ruleGroupName {
            try encodeContainer.encode(ruleGroupName, forKey: .ruleGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupName)
        ruleGroupName = ruleGroupNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension StatefulRuleGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatefulRuleGroup(resourceId: \(String(describing: resourceId)), ruleGroupName: \(String(describing: ruleGroupName)))"}
}

/// <p>AWS Network Firewall stateful rule group, used in a <a>NetworkFirewallPolicyDescription</a>. </p>
public struct StatefulRuleGroup: Equatable {
    /// <p>The resource ID of the rule group.</p>
    public let resourceId: String?
    /// <p>The name of the rule group.</p>
    public let ruleGroupName: String?

    public init (
        resourceId: String? = nil,
        ruleGroupName: String? = nil
    )
    {
        self.resourceId = resourceId
        self.ruleGroupName = ruleGroupName
    }
}

extension StatelessRuleGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case priority = "Priority"
        case resourceId = "ResourceId"
        case ruleGroupName = "RuleGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let ruleGroupName = ruleGroupName {
            try encodeContainer.encode(ruleGroupName, forKey: .ruleGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupName)
        ruleGroupName = ruleGroupNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension StatelessRuleGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatelessRuleGroup(priority: \(String(describing: priority)), resourceId: \(String(describing: resourceId)), ruleGroupName: \(String(describing: ruleGroupName)))"}
}

/// <p>AWS Network Firewall stateless rule group, used in a <a>NetworkFirewallPolicyDescription</a>. </p>
public struct StatelessRuleGroup: Equatable {
    /// <p>The priority of the rule group. AWS Network Firewall evaluates the stateless rule groups in a firewall policy starting from the lowest priority setting. </p>
    public let priority: Int
    /// <p>The resource ID of the rule group.</p>
    public let resourceId: String?
    /// <p>The name of the rule group.</p>
    public let ruleGroupName: String?

    public init (
        priority: Int = 0,
        resourceId: String? = nil,
        ruleGroupName: String? = nil
    )
    {
        self.priority = priority
        self.resourceId = resourceId
        self.ruleGroupName = ruleGroupName
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A collection of key:value pairs associated with an AWS resource. The key:value pair can be anything you define. Typically, the tag key represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50 tags to each AWS resource.  </p>
public struct Tag: Equatable {
    /// <p>Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.</p>
    public let key: String?
    /// <p>Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.  </p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tagList: \(String(describing: tagList)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to return tags for. The AWS Firewall Manager resources that support tagging are policies, applications lists, and protocols lists. </p>
    public let resourceArn: String?
    /// <p>The tags to add to the resource.</p>
    public let tagList: [Tag]?

    public init (
        resourceArn: String? = nil,
        tagList: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagList = tagList
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagList: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to return tags for. The AWS Firewall Manager resources that support tagging are policies, applications lists, and protocols lists. </p>
    public let resourceArn: String?
    /// <p>The keys of the tags to remove from the resource. </p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidInputException(InvalidInputException)
    case invalidOperationException(InvalidOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ViolationDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case memberAccount = "MemberAccount"
        case policyId = "PolicyId"
        case resourceDescription = "ResourceDescription"
        case resourceId = "ResourceId"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case resourceViolations = "ResourceViolations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccount = memberAccount {
            try encodeContainer.encode(memberAccount, forKey: .memberAccount)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let resourceDescription = resourceDescription {
            try encodeContainer.encode(resourceDescription, forKey: .resourceDescription)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for taglist0 in resourceTags {
                try resourceTagsContainer.encode(taglist0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let resourceViolations = resourceViolations {
            var resourceViolationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceViolations)
            for resourceviolations0 in resourceViolations {
                try resourceViolationsContainer.encode(resourceviolations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let memberAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberAccount)
        memberAccount = memberAccountDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceViolationsContainer = try containerValues.decodeIfPresent([ResourceViolation?].self, forKey: .resourceViolations)
        var resourceViolationsDecoded0:[ResourceViolation]? = nil
        if let resourceViolationsContainer = resourceViolationsContainer {
            resourceViolationsDecoded0 = [ResourceViolation]()
            for structure0 in resourceViolationsContainer {
                if let structure0 = structure0 {
                    resourceViolationsDecoded0?.append(structure0)
                }
            }
        }
        resourceViolations = resourceViolationsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[Tag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Tag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let resourceDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceDescription)
        resourceDescription = resourceDescriptionDecoded
    }
}

extension ViolationDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ViolationDetail(memberAccount: \(String(describing: memberAccount)), policyId: \(String(describing: policyId)), resourceDescription: \(String(describing: resourceDescription)), resourceId: \(String(describing: resourceId)), resourceTags: \(String(describing: resourceTags)), resourceType: \(String(describing: resourceType)), resourceViolations: \(String(describing: resourceViolations)))"}
}

/// <p>Violations for a resource based on the specified AWS Firewall Manager policy and AWS account.</p>
public struct ViolationDetail: Equatable {
    /// <p>The AWS account that the violation details were requested for.</p>
    public let memberAccount: String?
    /// <p>The ID of the AWS Firewall Manager policy that the violation details were requested for.</p>
    public let policyId: String?
    /// <p>Brief description for the requested resource.</p>
    public let resourceDescription: String?
    /// <p>The resource ID that the violation details were requested for.</p>
    public let resourceId: String?
    /// <p>The <code>ResourceTag</code> objects associated with the resource.</p>
    public let resourceTags: [Tag]?
    /// <p>The resource type that the violation details were requested for.</p>
    public let resourceType: String?
    /// <p>List of violations for the requested resource.</p>
    public let resourceViolations: [ResourceViolation]?

    public init (
        memberAccount: String? = nil,
        policyId: String? = nil,
        resourceDescription: String? = nil,
        resourceId: String? = nil,
        resourceTags: [Tag]? = nil,
        resourceType: String? = nil,
        resourceViolations: [ResourceViolation]? = nil
    )
    {
        self.memberAccount = memberAccount
        self.policyId = policyId
        self.resourceDescription = resourceDescription
        self.resourceId = resourceId
        self.resourceTags = resourceTags
        self.resourceType = resourceType
        self.resourceViolations = resourceViolations
    }
}

public enum ViolationReason {
    case fmscreatedsecuritygroupedited
    case missingexpectedroutetable
    case missingfirewall
    case missingfirewallsubnetinaz
    case networkfirewallpolicymodified
    case resourceincorrectwebacl
    case resourcemissingdnsfirewall
    case resourcemissingsecuritygroup
    case resourcemissingshieldprotection
    case resourcemissingwebacl
    case resourcemissingwebaclorshieldprotection
    case resourceviolatesauditsecuritygroup
    case securitygroupredundant
    case securitygroupunused
    case webaclmissingrulegroup
    case sdkUnknown(String)
}

extension ViolationReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ViolationReason] {
        return [
            .fmscreatedsecuritygroupedited,
            .missingexpectedroutetable,
            .missingfirewall,
            .missingfirewallsubnetinaz,
            .networkfirewallpolicymodified,
            .resourceincorrectwebacl,
            .resourcemissingdnsfirewall,
            .resourcemissingsecuritygroup,
            .resourcemissingshieldprotection,
            .resourcemissingwebacl,
            .resourcemissingwebaclorshieldprotection,
            .resourceviolatesauditsecuritygroup,
            .securitygroupredundant,
            .securitygroupunused,
            .webaclmissingrulegroup,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fmscreatedsecuritygroupedited: return "FMS_CREATED_SECURITY_GROUP_EDITED"
        case .missingexpectedroutetable: return "MISSING_EXPECTED_ROUTE_TABLE"
        case .missingfirewall: return "MISSING_FIREWALL"
        case .missingfirewallsubnetinaz: return "MISSING_FIREWALL_SUBNET_IN_AZ"
        case .networkfirewallpolicymodified: return "NETWORK_FIREWALL_POLICY_MODIFIED"
        case .resourceincorrectwebacl: return "RESOURCE_INCORRECT_WEB_ACL"
        case .resourcemissingdnsfirewall: return "RESOURCE_MISSING_DNS_FIREWALL"
        case .resourcemissingsecuritygroup: return "RESOURCE_MISSING_SECURITY_GROUP"
        case .resourcemissingshieldprotection: return "RESOURCE_MISSING_SHIELD_PROTECTION"
        case .resourcemissingwebacl: return "RESOURCE_MISSING_WEB_ACL"
        case .resourcemissingwebaclorshieldprotection: return "RESOURCE_MISSING_WEB_ACL_OR_SHIELD_PROTECTION"
        case .resourceviolatesauditsecuritygroup: return "RESOURCE_VIOLATES_AUDIT_SECURITY_GROUP"
        case .securitygroupredundant: return "SECURITY_GROUP_REDUNDANT"
        case .securitygroupunused: return "SECURITY_GROUP_UNUSED"
        case .webaclmissingrulegroup: return "WEB_ACL_MISSING_RULE_GROUP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ViolationReason(rawValue: rawValue) ?? ViolationReason.sdkUnknown(rawValue)
    }
}
