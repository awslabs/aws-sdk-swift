// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AbortTransactionRequest: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension AbortTransactionRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortTransactionRequest()"}
}

/// <p>Contains the details of the transaction to abort.</p>
public struct AbortTransactionRequest: Equatable {

    public init() {}
}

extension AbortTransactionResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timingInformationDecoded = try containerValues.decodeIfPresent(TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
    }
}

extension AbortTransactionResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortTransactionResult(timingInformation: \(String(describing: timingInformation)))"}
}

/// <p>Contains the details of the aborted transaction.</p>
public struct AbortTransactionResult: Equatable {
    /// <p>Contains server-side performance information for the command.</p>
    public let timingInformation: TimingInformation?

    public init (
        timingInformation: TimingInformation? = nil
    )
    {
        self.timingInformation = timingInformation
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the request is malformed or contains an error such as an invalid parameter
///          value or a missing required parameter.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CapacityExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CapacityExceededException(message: \(String(describing: message)))"}
}

extension CapacityExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CapacityExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned when the request exceeds the processing capacity of the ledger.</p>
public struct CapacityExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CapacityExceededExceptionBody: Equatable {
    public let message: String?
}

extension CapacityExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitTransactionRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commitDigest = "CommitDigest"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitDigest = commitDigest {
            try encodeContainer.encode(commitDigest.base64EncodedString(), forKey: .commitDigest)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let commitDigestDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .commitDigest)
        commitDigest = commitDigestDecoded
    }
}

extension CommitTransactionRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommitTransactionRequest(commitDigest: \(String(describing: commitDigest)), transactionId: \(String(describing: transactionId)))"}
}

/// <p>Contains the details of the transaction to commit.</p>
public struct CommitTransactionRequest: Equatable {
    /// <p>Specifies the commit digest for the transaction to commit. For every active transaction,
    ///          the commit digest must be passed. QLDB validates <code>CommitDigest</code> and rejects
    ///          the commit with an error if the digest computed on the client does not match the digest
    ///          computed by QLDB.</p>
    ///          <p>The purpose of the <code>CommitDigest</code> parameter is to ensure that QLDB commits
    ///          a transaction if and only if the server has processed the exact set of statements sent by
    ///          the client, in the same order that client sent them, and with no duplicates.</p>
    public let commitDigest: Data?
    /// <p>Specifies the transaction ID of the transaction to commit.</p>
    public let transactionId: String?

    public init (
        commitDigest: Data? = nil,
        transactionId: String? = nil
    )
    {
        self.commitDigest = commitDigest
        self.transactionId = transactionId
    }
}

extension CommitTransactionResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commitDigest = "CommitDigest"
        case consumedIOs = "ConsumedIOs"
        case timingInformation = "TimingInformation"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitDigest = commitDigest {
            try encodeContainer.encode(commitDigest.base64EncodedString(), forKey: .commitDigest)
        }
        if let consumedIOs = consumedIOs {
            try encodeContainer.encode(consumedIOs, forKey: .consumedIOs)
        }
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let commitDigestDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .commitDigest)
        commitDigest = commitDigestDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
        let consumedIOsDecoded = try containerValues.decodeIfPresent(IOUsage.self, forKey: .consumedIOs)
        consumedIOs = consumedIOsDecoded
    }
}

extension CommitTransactionResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommitTransactionResult(commitDigest: \(String(describing: commitDigest)), consumedIOs: \(String(describing: consumedIOs)), timingInformation: \(String(describing: timingInformation)), transactionId: \(String(describing: transactionId)))"}
}

/// <p>Contains the details of the committed transaction.</p>
public struct CommitTransactionResult: Equatable {
    /// <p>The commit digest of the committed transaction.</p>
    public let commitDigest: Data?
    /// <p>Contains metrics about the number of I/O requests that were consumed.</p>
    public let consumedIOs: IOUsage?
    /// <p>Contains server-side performance information for the command.</p>
    public let timingInformation: TimingInformation?
    /// <p>The transaction ID of the committed transaction.</p>
    public let transactionId: String?

    public init (
        commitDigest: Data? = nil,
        consumedIOs: IOUsage? = nil,
        timingInformation: TimingInformation? = nil,
        transactionId: String? = nil
    )
    {
        self.commitDigest = commitDigest
        self.consumedIOs = consumedIOs
        self.timingInformation = timingInformation
        self.transactionId = transactionId
    }
}

extension EndSessionRequest: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension EndSessionRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndSessionRequest()"}
}

/// <p>Specifies a request to end the session.</p>
public struct EndSessionRequest: Equatable {

    public init() {}
}

extension EndSessionResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timingInformationDecoded = try containerValues.decodeIfPresent(TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
    }
}

extension EndSessionResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndSessionResult(timingInformation: \(String(describing: timingInformation)))"}
}

/// <p>Contains the details of the ended session.</p>
public struct EndSessionResult: Equatable {
    /// <p>Contains server-side performance information for the command.</p>
    public let timingInformation: TimingInformation?

    public init (
        timingInformation: TimingInformation? = nil
    )
    {
        self.timingInformation = timingInformation
    }
}

extension ExecuteStatementRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameters = "Parameters"
        case statement = "Statement"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for statementparameters0 in parameters {
                try parametersContainer.encode(statementparameters0)
            }
        }
        if let statement = statement {
            try encodeContainer.encode(statement, forKey: .statement)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let statementDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statement)
        statement = statementDecoded
        let parametersContainer = try containerValues.decodeIfPresent([ValueHolder?].self, forKey: .parameters)
        var parametersDecoded0:[ValueHolder]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ValueHolder]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension ExecuteStatementRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteStatementRequest(parameters: \(String(describing: parameters)), statement: \(String(describing: statement)), transactionId: \(String(describing: transactionId)))"}
}

/// <p>Specifies a request to execute a statement.</p>
public struct ExecuteStatementRequest: Equatable {
    /// <p>Specifies the parameters for the parameterized statement in the request.</p>
    public let parameters: [ValueHolder]?
    /// <p>Specifies the statement of the request.</p>
    public let statement: String?
    /// <p>Specifies the transaction ID of the request.</p>
    public let transactionId: String?

    public init (
        parameters: [ValueHolder]? = nil,
        statement: String? = nil,
        transactionId: String? = nil
    )
    {
        self.parameters = parameters
        self.statement = statement
        self.transactionId = transactionId
    }
}

extension ExecuteStatementResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consumedIOs = "ConsumedIOs"
        case firstPage = "FirstPage"
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumedIOs = consumedIOs {
            try encodeContainer.encode(consumedIOs, forKey: .consumedIOs)
        }
        if let firstPage = firstPage {
            try encodeContainer.encode(firstPage, forKey: .firstPage)
        }
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firstPageDecoded = try containerValues.decodeIfPresent(Page.self, forKey: .firstPage)
        firstPage = firstPageDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
        let consumedIOsDecoded = try containerValues.decodeIfPresent(IOUsage.self, forKey: .consumedIOs)
        consumedIOs = consumedIOsDecoded
    }
}

extension ExecuteStatementResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteStatementResult(consumedIOs: \(String(describing: consumedIOs)), firstPage: \(String(describing: firstPage)), timingInformation: \(String(describing: timingInformation)))"}
}

/// <p>Contains the details of the executed statement.</p>
public struct ExecuteStatementResult: Equatable {
    /// <p>Contains metrics about the number of I/O requests that were consumed.</p>
    public let consumedIOs: IOUsage?
    /// <p>Contains the details of the first fetched page.</p>
    public let firstPage: Page?
    /// <p>Contains server-side performance information for the command.</p>
    public let timingInformation: TimingInformation?

    public init (
        consumedIOs: IOUsage? = nil,
        firstPage: Page? = nil,
        timingInformation: TimingInformation? = nil
    )
    {
        self.consumedIOs = consumedIOs
        self.firstPage = firstPage
        self.timingInformation = timingInformation
    }
}

extension FetchPageRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension FetchPageRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FetchPageRequest(nextPageToken: \(String(describing: nextPageToken)), transactionId: \(String(describing: transactionId)))"}
}

/// <p>Specifies the details of the page to be fetched.</p>
public struct FetchPageRequest: Equatable {
    /// <p>Specifies the next page token of the page to be fetched.</p>
    public let nextPageToken: String?
    /// <p>Specifies the transaction ID of the page to be fetched.</p>
    public let transactionId: String?

    public init (
        nextPageToken: String? = nil,
        transactionId: String? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.transactionId = transactionId
    }
}

extension FetchPageResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consumedIOs = "ConsumedIOs"
        case page = "Page"
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumedIOs = consumedIOs {
            try encodeContainer.encode(consumedIOs, forKey: .consumedIOs)
        }
        if let page = page {
            try encodeContainer.encode(page, forKey: .page)
        }
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageDecoded = try containerValues.decodeIfPresent(Page.self, forKey: .page)
        page = pageDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
        let consumedIOsDecoded = try containerValues.decodeIfPresent(IOUsage.self, forKey: .consumedIOs)
        consumedIOs = consumedIOsDecoded
    }
}

extension FetchPageResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FetchPageResult(consumedIOs: \(String(describing: consumedIOs)), page: \(String(describing: page)), timingInformation: \(String(describing: timingInformation)))"}
}

/// <p>Contains the page that was fetched.</p>
public struct FetchPageResult: Equatable {
    /// <p>Contains metrics about the number of I/O requests that were consumed.</p>
    public let consumedIOs: IOUsage?
    /// <p>Contains details of the fetched page.</p>
    public let page: Page?
    /// <p>Contains server-side performance information for the command.</p>
    public let timingInformation: TimingInformation?

    public init (
        consumedIOs: IOUsage? = nil,
        page: Page? = nil,
        timingInformation: TimingInformation? = nil
    )
    {
        self.consumedIOs = consumedIOs
        self.page = page
        self.timingInformation = timingInformation
    }
}

extension IOUsage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case readIOs = "ReadIOs"
        case writeIOs = "WriteIOs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if readIOs != 0 {
            try encodeContainer.encode(readIOs, forKey: .readIOs)
        }
        if writeIOs != 0 {
            try encodeContainer.encode(writeIOs, forKey: .writeIOs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readIOsDecoded = try containerValues.decode(Int.self, forKey: .readIOs)
        readIOs = readIOsDecoded
        let writeIOsDecoded = try containerValues.decode(Int.self, forKey: .writeIOs)
        writeIOs = writeIOsDecoded
    }
}

extension IOUsage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IOUsage(readIOs: \(String(describing: readIOs)), writeIOs: \(String(describing: writeIOs)))"}
}

/// <p>Contains I/O usage metrics for a command that was invoked.</p>
public struct IOUsage: Equatable {
    /// <p>The number of read I/O requests that the command made.</p>
    public let readIOs: Int
    /// <p>The number of write I/O requests that the command made.</p>
    public let writeIOs: Int

    public init (
        readIOs: Int = 0,
        writeIOs: Int = 0
    )
    {
        self.readIOs = readIOs
        self.writeIOs = writeIOs
    }
}

extension InvalidSessionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSessionException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension InvalidSessionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSessionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the session doesn't exist anymore because it timed out or expired.</p>
public struct InvalidSessionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidSessionExceptionBody: Equatable {
    public let message: String?
    public let code: String?
}

extension InvalidSessionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if a resource limit such as number of active sessions is exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OccConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OccConflictException(message: \(String(describing: message)))"}
}

extension OccConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OccConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned when a transaction cannot be written to the journal due to a failure in the
///          verification phase of <i>optimistic concurrency control</i> (OCC).</p>
public struct OccConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OccConflictExceptionBody: Equatable {
    public let message: String?
}

extension OccConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Page: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for valueholders0 in values {
                try valuesContainer.encode(valueholders0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([ValueHolder?].self, forKey: .values)
        var valuesDecoded0:[ValueHolder]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [ValueHolder]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension Page: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Page(nextPageToken: \(String(describing: nextPageToken)), values: \(String(describing: values)))"}
}

/// <p>Contains details of the fetched page.</p>
public struct Page: Equatable {
    /// <p>The token of the next page.</p>
    public let nextPageToken: String?
    /// <p>A structure that contains values in multiple encoding formats.</p>
    public let values: [ValueHolder]?

    public init (
        nextPageToken: String? = nil,
        values: [ValueHolder]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.values = values
    }
}

extension RateExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RateExceededException(message: \(String(describing: message)))"}
}

extension RateExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RateExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned when the rate of requests exceeds the allowed throughput.</p>
public struct RateExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RateExceededExceptionBody: Equatable {
    public let message: String?
}

extension RateExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SendCommandInputBodyMiddleware: Middleware {
    public let id: String = "SendCommandInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendCommandInput>,
                  next: H) -> Swift.Result<OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendCommandInput>
    public typealias MOutput = OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendCommandOutputError>
}

extension SendCommandInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendCommandInput(abortTransaction: \(String(describing: abortTransaction)), commitTransaction: \(String(describing: commitTransaction)), endSession: \(String(describing: endSession)), executeStatement: \(String(describing: executeStatement)), fetchPage: \(String(describing: fetchPage)), sessionToken: \(String(describing: sessionToken)), startSession: \(String(describing: startSession)), startTransaction: \(String(describing: startTransaction)))"}
}

extension SendCommandInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case abortTransaction = "AbortTransaction"
        case commitTransaction = "CommitTransaction"
        case endSession = "EndSession"
        case executeStatement = "ExecuteStatement"
        case fetchPage = "FetchPage"
        case sessionToken = "SessionToken"
        case startSession = "StartSession"
        case startTransaction = "StartTransaction"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortTransaction = abortTransaction {
            try encodeContainer.encode(abortTransaction, forKey: .abortTransaction)
        }
        if let commitTransaction = commitTransaction {
            try encodeContainer.encode(commitTransaction, forKey: .commitTransaction)
        }
        if let endSession = endSession {
            try encodeContainer.encode(endSession, forKey: .endSession)
        }
        if let executeStatement = executeStatement {
            try encodeContainer.encode(executeStatement, forKey: .executeStatement)
        }
        if let fetchPage = fetchPage {
            try encodeContainer.encode(fetchPage, forKey: .fetchPage)
        }
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
        if let startSession = startSession {
            try encodeContainer.encode(startSession, forKey: .startSession)
        }
        if let startTransaction = startTransaction {
            try encodeContainer.encode(startTransaction, forKey: .startTransaction)
        }
    }
}

public struct SendCommandInputHeadersMiddleware: Middleware {
    public let id: String = "SendCommandInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendCommandInput>,
                  next: H) -> Swift.Result<OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendCommandInput>
    public typealias MOutput = OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendCommandOutputError>
}

public struct SendCommandInputQueryItemMiddleware: Middleware {
    public let id: String = "SendCommandInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendCommandInput>,
                  next: H) -> Swift.Result<OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendCommandInput>
    public typealias MOutput = OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendCommandOutputError>
}

public struct SendCommandInput: Equatable {
    /// <p>Command to abort the current transaction.</p>
    public let abortTransaction: AbortTransactionRequest?
    /// <p>Command to commit the specified transaction.</p>
    public let commitTransaction: CommitTransactionRequest?
    /// <p>Command to end the current session.</p>
    public let endSession: EndSessionRequest?
    /// <p>Command to execute a statement in the specified transaction.</p>
    public let executeStatement: ExecuteStatementRequest?
    /// <p>Command to fetch a page.</p>
    public let fetchPage: FetchPageRequest?
    /// <p>Specifies the session token for the current command. A session token is constant
    ///          throughout the life of the session.</p>
    ///          <p>To obtain a session token, run the <code>StartSession</code> command. This
    ///             <code>SessionToken</code> is required for every subsequent command that is issued during
    ///          the current session.</p>
    public let sessionToken: String?
    /// <p>Command to start a new session. A session token is obtained as part of the
    ///          response.</p>
    public let startSession: StartSessionRequest?
    /// <p>Command to start a new transaction.</p>
    public let startTransaction: StartTransactionRequest?

    public init (
        abortTransaction: AbortTransactionRequest? = nil,
        commitTransaction: CommitTransactionRequest? = nil,
        endSession: EndSessionRequest? = nil,
        executeStatement: ExecuteStatementRequest? = nil,
        fetchPage: FetchPageRequest? = nil,
        sessionToken: String? = nil,
        startSession: StartSessionRequest? = nil,
        startTransaction: StartTransactionRequest? = nil
    )
    {
        self.abortTransaction = abortTransaction
        self.commitTransaction = commitTransaction
        self.endSession = endSession
        self.executeStatement = executeStatement
        self.fetchPage = fetchPage
        self.sessionToken = sessionToken
        self.startSession = startSession
        self.startTransaction = startTransaction
    }
}

struct SendCommandInputBody: Equatable {
    public let sessionToken: String?
    public let startSession: StartSessionRequest?
    public let startTransaction: StartTransactionRequest?
    public let endSession: EndSessionRequest?
    public let commitTransaction: CommitTransactionRequest?
    public let abortTransaction: AbortTransactionRequest?
    public let executeStatement: ExecuteStatementRequest?
    public let fetchPage: FetchPageRequest?
}

extension SendCommandInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case abortTransaction = "AbortTransaction"
        case commitTransaction = "CommitTransaction"
        case endSession = "EndSession"
        case executeStatement = "ExecuteStatement"
        case fetchPage = "FetchPage"
        case sessionToken = "SessionToken"
        case startSession = "StartSession"
        case startTransaction = "StartTransaction"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let startSessionDecoded = try containerValues.decodeIfPresent(StartSessionRequest.self, forKey: .startSession)
        startSession = startSessionDecoded
        let startTransactionDecoded = try containerValues.decodeIfPresent(StartTransactionRequest.self, forKey: .startTransaction)
        startTransaction = startTransactionDecoded
        let endSessionDecoded = try containerValues.decodeIfPresent(EndSessionRequest.self, forKey: .endSession)
        endSession = endSessionDecoded
        let commitTransactionDecoded = try containerValues.decodeIfPresent(CommitTransactionRequest.self, forKey: .commitTransaction)
        commitTransaction = commitTransactionDecoded
        let abortTransactionDecoded = try containerValues.decodeIfPresent(AbortTransactionRequest.self, forKey: .abortTransaction)
        abortTransaction = abortTransactionDecoded
        let executeStatementDecoded = try containerValues.decodeIfPresent(ExecuteStatementRequest.self, forKey: .executeStatement)
        executeStatement = executeStatementDecoded
        let fetchPageDecoded = try containerValues.decodeIfPresent(FetchPageRequest.self, forKey: .fetchPage)
        fetchPage = fetchPageDecoded
    }
}

extension SendCommandOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendCommandOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CapacityExceededException" : self = .capacityExceededException(try CapacityExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSessionException" : self = .invalidSessionException(try InvalidSessionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OccConflictException" : self = .occConflictException(try OccConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateExceededException" : self = .rateExceededException(try RateExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendCommandOutputError: Equatable {
    case badRequestException(BadRequestException)
    case capacityExceededException(CapacityExceededException)
    case invalidSessionException(InvalidSessionException)
    case limitExceededException(LimitExceededException)
    case occConflictException(OccConflictException)
    case rateExceededException(RateExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendCommandOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendCommandOutputResponse(abortTransaction: \(String(describing: abortTransaction)), commitTransaction: \(String(describing: commitTransaction)), endSession: \(String(describing: endSession)), executeStatement: \(String(describing: executeStatement)), fetchPage: \(String(describing: fetchPage)), startSession: \(String(describing: startSession)), startTransaction: \(String(describing: startTransaction)))"}
}

extension SendCommandOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendCommandOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.abortTransaction = output.abortTransaction
            self.commitTransaction = output.commitTransaction
            self.endSession = output.endSession
            self.executeStatement = output.executeStatement
            self.fetchPage = output.fetchPage
            self.startSession = output.startSession
            self.startTransaction = output.startTransaction
        } else {
            self.abortTransaction = nil
            self.commitTransaction = nil
            self.endSession = nil
            self.executeStatement = nil
            self.fetchPage = nil
            self.startSession = nil
            self.startTransaction = nil
        }
    }
}

public struct SendCommandOutputResponse: Equatable {
    /// <p>Contains the details of the aborted transaction.</p>
    public let abortTransaction: AbortTransactionResult?
    /// <p>Contains the details of the committed transaction.</p>
    public let commitTransaction: CommitTransactionResult?
    /// <p>Contains the details of the ended session.</p>
    public let endSession: EndSessionResult?
    /// <p>Contains the details of the executed statement.</p>
    public let executeStatement: ExecuteStatementResult?
    /// <p>Contains the details of the fetched page.</p>
    public let fetchPage: FetchPageResult?
    /// <p>Contains the details of the started session that includes a session token. This
    ///             <code>SessionToken</code> is required for every subsequent command that is issued during
    ///          the current session.</p>
    public let startSession: StartSessionResult?
    /// <p>Contains the details of the started transaction.</p>
    public let startTransaction: StartTransactionResult?

    public init (
        abortTransaction: AbortTransactionResult? = nil,
        commitTransaction: CommitTransactionResult? = nil,
        endSession: EndSessionResult? = nil,
        executeStatement: ExecuteStatementResult? = nil,
        fetchPage: FetchPageResult? = nil,
        startSession: StartSessionResult? = nil,
        startTransaction: StartTransactionResult? = nil
    )
    {
        self.abortTransaction = abortTransaction
        self.commitTransaction = commitTransaction
        self.endSession = endSession
        self.executeStatement = executeStatement
        self.fetchPage = fetchPage
        self.startSession = startSession
        self.startTransaction = startTransaction
    }
}

struct SendCommandOutputResponseBody: Equatable {
    public let startSession: StartSessionResult?
    public let startTransaction: StartTransactionResult?
    public let endSession: EndSessionResult?
    public let commitTransaction: CommitTransactionResult?
    public let abortTransaction: AbortTransactionResult?
    public let executeStatement: ExecuteStatementResult?
    public let fetchPage: FetchPageResult?
}

extension SendCommandOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case abortTransaction = "AbortTransaction"
        case commitTransaction = "CommitTransaction"
        case endSession = "EndSession"
        case executeStatement = "ExecuteStatement"
        case fetchPage = "FetchPage"
        case startSession = "StartSession"
        case startTransaction = "StartTransaction"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startSessionDecoded = try containerValues.decodeIfPresent(StartSessionResult.self, forKey: .startSession)
        startSession = startSessionDecoded
        let startTransactionDecoded = try containerValues.decodeIfPresent(StartTransactionResult.self, forKey: .startTransaction)
        startTransaction = startTransactionDecoded
        let endSessionDecoded = try containerValues.decodeIfPresent(EndSessionResult.self, forKey: .endSession)
        endSession = endSessionDecoded
        let commitTransactionDecoded = try containerValues.decodeIfPresent(CommitTransactionResult.self, forKey: .commitTransaction)
        commitTransaction = commitTransactionDecoded
        let abortTransactionDecoded = try containerValues.decodeIfPresent(AbortTransactionResult.self, forKey: .abortTransaction)
        abortTransaction = abortTransactionDecoded
        let executeStatementDecoded = try containerValues.decodeIfPresent(ExecuteStatementResult.self, forKey: .executeStatement)
        executeStatement = executeStatementDecoded
        let fetchPageDecoded = try containerValues.decodeIfPresent(FetchPageResult.self, forKey: .fetchPage)
        fetchPage = fetchPageDecoded
    }
}

extension StartSessionRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ledgerName = "LedgerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ledgerName = ledgerName {
            try encodeContainer.encode(ledgerName, forKey: .ledgerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ledgerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ledgerName)
        ledgerName = ledgerNameDecoded
    }
}

extension StartSessionRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSessionRequest(ledgerName: \(String(describing: ledgerName)))"}
}

/// <p>Specifies a request to start a new session.</p>
public struct StartSessionRequest: Equatable {
    /// <p>The name of the ledger to start a new session against.</p>
    public let ledgerName: String?

    public init (
        ledgerName: String? = nil
    )
    {
        self.ledgerName = ledgerName
    }
}

extension StartSessionResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sessionToken = "SessionToken"
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
    }
}

extension StartSessionResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSessionResult(sessionToken: \(String(describing: sessionToken)), timingInformation: \(String(describing: timingInformation)))"}
}

/// <p>Contains the details of the started session.</p>
public struct StartSessionResult: Equatable {
    /// <p>Session token of the started session. This <code>SessionToken</code> is required for
    ///          every subsequent command that is issued during the current session.</p>
    public let sessionToken: String?
    /// <p>Contains server-side performance information for the command.</p>
    public let timingInformation: TimingInformation?

    public init (
        sessionToken: String? = nil,
        timingInformation: TimingInformation? = nil
    )
    {
        self.sessionToken = sessionToken
        self.timingInformation = timingInformation
    }
}

extension StartTransactionRequest: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension StartTransactionRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTransactionRequest()"}
}

/// <p>Specifies a request to start a transaction.</p>
public struct StartTransactionRequest: Equatable {

    public init() {}
}

extension StartTransactionResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timingInformation = "TimingInformation"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
    }
}

extension StartTransactionResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTransactionResult(timingInformation: \(String(describing: timingInformation)), transactionId: \(String(describing: transactionId)))"}
}

/// <p>Contains the details of the started transaction.</p>
public struct StartTransactionResult: Equatable {
    /// <p>Contains server-side performance information for the command.</p>
    public let timingInformation: TimingInformation?
    /// <p>The transaction ID of the started transaction.</p>
    public let transactionId: String?

    public init (
        timingInformation: TimingInformation? = nil,
        transactionId: String? = nil
    )
    {
        self.timingInformation = timingInformation
        self.transactionId = transactionId
    }
}

extension TimingInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case processingTimeMilliseconds = "ProcessingTimeMilliseconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if processingTimeMilliseconds != 0 {
            try encodeContainer.encode(processingTimeMilliseconds, forKey: .processingTimeMilliseconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processingTimeMillisecondsDecoded = try containerValues.decode(Int.self, forKey: .processingTimeMilliseconds)
        processingTimeMilliseconds = processingTimeMillisecondsDecoded
    }
}

extension TimingInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimingInformation(processingTimeMilliseconds: \(String(describing: processingTimeMilliseconds)))"}
}

/// <p>Contains server-side performance information for a command. Amazon QLDB captures timing
///          information between the times when it receives the request and when it sends the
///          corresponding response.</p>
public struct TimingInformation: Equatable {
    /// <p>The amount of time that QLDB spent on processing the command, measured in
    ///          milliseconds.</p>
    public let processingTimeMilliseconds: Int

    public init (
        processingTimeMilliseconds: Int = 0
    )
    {
        self.processingTimeMilliseconds = processingTimeMilliseconds
    }
}

extension ValueHolder: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ionBinary = "IonBinary"
        case ionText = "IonText"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ionBinary = ionBinary {
            try encodeContainer.encode(ionBinary.base64EncodedString(), forKey: .ionBinary)
        }
        if let ionText = ionText {
            try encodeContainer.encode(ionText, forKey: .ionText)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ionBinaryDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .ionBinary)
        ionBinary = ionBinaryDecoded
        let ionTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ionText)
        ionText = ionTextDecoded
    }
}

extension ValueHolder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValueHolder(ionBinary: \(String(describing: ionBinary)), ionText: \(String(describing: ionText)))"}
}

/// <p>A structure that can contain a value in multiple encoding formats.</p>
public struct ValueHolder: Equatable {
    /// <p>An Amazon Ion binary value contained in a <code>ValueHolder</code> structure.</p>
    public let ionBinary: Data?
    /// <p>An Amazon Ion plaintext value contained in a <code>ValueHolder</code> structure.</p>
    public let ionText: String?

    public init (
        ionBinary: Data? = nil,
        ionText: String? = nil
    )
    {
        self.ionBinary = ionBinary
        self.ionText = ionText
    }
}
