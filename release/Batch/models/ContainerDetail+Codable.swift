// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ContainerDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case command
        case containerInstanceArn
        case environment
        case executionRoleArn
        case exitCode
        case fargatePlatformConfiguration
        case image
        case instanceType
        case jobRoleArn
        case linuxParameters
        case logConfiguration
        case logStreamName
        case memory
        case mountPoints
        case networkConfiguration
        case networkInterfaces
        case privileged
        case readonlyRootFilesystem
        case reason
        case resourceRequirements
        case secrets
        case taskArn
        case ulimits
        case user
        case vcpus
        case volumes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = command {
            var commandContainer = encodeContainer.nestedUnkeyedContainer(forKey: .command)
            for stringlist0 in command {
                try commandContainer.encode(stringlist0)
            }
        }
        if let containerInstanceArn = containerInstanceArn {
            try encodeContainer.encode(containerInstanceArn, forKey: .containerInstanceArn)
        }
        if let environment = environment {
            var environmentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environment)
            for environmentvariables0 in environment {
                try environmentContainer.encode(environmentvariables0)
            }
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if exitCode != 0 {
            try encodeContainer.encode(exitCode, forKey: .exitCode)
        }
        if let fargatePlatformConfiguration = fargatePlatformConfiguration {
            try encodeContainer.encode(fargatePlatformConfiguration, forKey: .fargatePlatformConfiguration)
        }
        if let image = image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let jobRoleArn = jobRoleArn {
            try encodeContainer.encode(jobRoleArn, forKey: .jobRoleArn)
        }
        if let linuxParameters = linuxParameters {
            try encodeContainer.encode(linuxParameters, forKey: .linuxParameters)
        }
        if let logConfiguration = logConfiguration {
            try encodeContainer.encode(logConfiguration, forKey: .logConfiguration)
        }
        if let logStreamName = logStreamName {
            try encodeContainer.encode(logStreamName, forKey: .logStreamName)
        }
        if memory != 0 {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let mountPoints = mountPoints {
            var mountPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mountPoints)
            for mountpoints0 in mountPoints {
                try mountPointsContainer.encode(mountpoints0)
            }
        }
        if let networkConfiguration = networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterfacelist0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterfacelist0)
            }
        }
        if privileged != false {
            try encodeContainer.encode(privileged, forKey: .privileged)
        }
        if readonlyRootFilesystem != false {
            try encodeContainer.encode(readonlyRootFilesystem, forKey: .readonlyRootFilesystem)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let resourceRequirements = resourceRequirements {
            var resourceRequirementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceRequirements)
            for resourcerequirements0 in resourceRequirements {
                try resourceRequirementsContainer.encode(resourcerequirements0)
            }
        }
        if let secrets = secrets {
            var secretsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secrets)
            for secretlist0 in secrets {
                try secretsContainer.encode(secretlist0)
            }
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let ulimits = ulimits {
            var ulimitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ulimits)
            for ulimits0 in ulimits {
                try ulimitsContainer.encode(ulimits0)
            }
        }
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
        if vcpus != 0 {
            try encodeContainer.encode(vcpus, forKey: .vcpus)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for volumes0 in volumes {
                try volumesContainer.encode(volumes0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .image)
        image = imageDecoded
        let vcpusDecoded = try containerValues.decode(Int.self, forKey: .vcpus)
        vcpus = vcpusDecoded
        let memoryDecoded = try containerValues.decode(Int.self, forKey: .memory)
        memory = memoryDecoded
        let commandContainer = try containerValues.decodeIfPresent([String?].self, forKey: .command)
        var commandDecoded0:[String]? = nil
        if let commandContainer = commandContainer {
            commandDecoded0 = [String]()
            for string0 in commandContainer {
                if let string0 = string0 {
                    commandDecoded0?.append(string0)
                }
            }
        }
        command = commandDecoded0
        let jobRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobRoleArn)
        jobRoleArn = jobRoleArnDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let volumesContainer = try containerValues.decodeIfPresent([Volume?].self, forKey: .volumes)
        var volumesDecoded0:[Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
        let environmentContainer = try containerValues.decodeIfPresent([KeyValuePair?].self, forKey: .environment)
        var environmentDecoded0:[KeyValuePair]? = nil
        if let environmentContainer = environmentContainer {
            environmentDecoded0 = [KeyValuePair]()
            for structure0 in environmentContainer {
                if let structure0 = structure0 {
                    environmentDecoded0?.append(structure0)
                }
            }
        }
        environment = environmentDecoded0
        let mountPointsContainer = try containerValues.decodeIfPresent([MountPoint?].self, forKey: .mountPoints)
        var mountPointsDecoded0:[MountPoint]? = nil
        if let mountPointsContainer = mountPointsContainer {
            mountPointsDecoded0 = [MountPoint]()
            for structure0 in mountPointsContainer {
                if let structure0 = structure0 {
                    mountPointsDecoded0?.append(structure0)
                }
            }
        }
        mountPoints = mountPointsDecoded0
        let readonlyRootFilesystemDecoded = try containerValues.decode(Bool.self, forKey: .readonlyRootFilesystem)
        readonlyRootFilesystem = readonlyRootFilesystemDecoded
        let ulimitsContainer = try containerValues.decodeIfPresent([Ulimit?].self, forKey: .ulimits)
        var ulimitsDecoded0:[Ulimit]? = nil
        if let ulimitsContainer = ulimitsContainer {
            ulimitsDecoded0 = [Ulimit]()
            for structure0 in ulimitsContainer {
                if let structure0 = structure0 {
                    ulimitsDecoded0?.append(structure0)
                }
            }
        }
        ulimits = ulimitsDecoded0
        let privilegedDecoded = try containerValues.decode(Bool.self, forKey: .privileged)
        privileged = privilegedDecoded
        let userDecoded = try containerValues.decodeIfPresent(String.self, forKey: .user)
        user = userDecoded
        let exitCodeDecoded = try containerValues.decode(Int.self, forKey: .exitCode)
        exitCode = exitCodeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
        let containerInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerInstanceArn)
        containerInstanceArn = containerInstanceArnDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let logStreamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logStreamName)
        logStreamName = logStreamNameDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let resourceRequirementsContainer = try containerValues.decodeIfPresent([ResourceRequirement?].self, forKey: .resourceRequirements)
        var resourceRequirementsDecoded0:[ResourceRequirement]? = nil
        if let resourceRequirementsContainer = resourceRequirementsContainer {
            resourceRequirementsDecoded0 = [ResourceRequirement]()
            for structure0 in resourceRequirementsContainer {
                if let structure0 = structure0 {
                    resourceRequirementsDecoded0?.append(structure0)
                }
            }
        }
        resourceRequirements = resourceRequirementsDecoded0
        let linuxParametersDecoded = try containerValues.decodeIfPresent(LinuxParameters.self, forKey: .linuxParameters)
        linuxParameters = linuxParametersDecoded
        let logConfigurationDecoded = try containerValues.decodeIfPresent(LogConfiguration.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
        let secretsContainer = try containerValues.decodeIfPresent([Secret?].self, forKey: .secrets)
        var secretsDecoded0:[Secret]? = nil
        if let secretsContainer = secretsContainer {
            secretsDecoded0 = [Secret]()
            for structure0 in secretsContainer {
                if let structure0 = structure0 {
                    secretsDecoded0?.append(structure0)
                }
            }
        }
        secrets = secretsDecoded0
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let fargatePlatformConfigurationDecoded = try containerValues.decodeIfPresent(FargatePlatformConfiguration.self, forKey: .fargatePlatformConfiguration)
        fargatePlatformConfiguration = fargatePlatformConfigurationDecoded
    }
}
