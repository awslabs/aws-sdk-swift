// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension JobDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arrayProperties
        case attempts
        case container
        case createdAt
        case dependsOn
        case jobArn
        case jobDefinition
        case jobId
        case jobName
        case jobQueue
        case nodeDetails
        case nodeProperties
        case parameters
        case platformCapabilities
        case propagateTags
        case retryStrategy
        case startedAt
        case status
        case statusReason
        case stoppedAt
        case tags
        case timeout
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arrayProperties = arrayProperties {
            try encodeContainer.encode(arrayProperties, forKey: .arrayProperties)
        }
        if let attempts = attempts {
            var attemptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attempts)
            for attemptdetails0 in attempts {
                try attemptsContainer.encode(attemptdetails0)
            }
        }
        if let container = container {
            try encodeContainer.encode(container, forKey: .container)
        }
        if createdAt != 0 {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let dependsOn = dependsOn {
            var dependsOnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dependsOn)
            for jobdependencylist0 in dependsOn {
                try dependsOnContainer.encode(jobdependencylist0)
            }
        }
        if let jobArn = jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobDefinition = jobDefinition {
            try encodeContainer.encode(jobDefinition, forKey: .jobDefinition)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobQueue = jobQueue {
            try encodeContainer.encode(jobQueue, forKey: .jobQueue)
        }
        if let nodeDetails = nodeDetails {
            try encodeContainer.encode(nodeDetails, forKey: .nodeDetails)
        }
        if let nodeProperties = nodeProperties {
            try encodeContainer.encode(nodeProperties, forKey: .nodeProperties)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let platformCapabilities = platformCapabilities {
            var platformCapabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platformCapabilities)
            for platformcapabilitylist0 in platformCapabilities {
                try platformCapabilitiesContainer.encode(platformcapabilitylist0.rawValue)
            }
        }
        if propagateTags != false {
            try encodeContainer.encode(propagateTags, forKey: .propagateTags)
        }
        if let retryStrategy = retryStrategy {
            try encodeContainer.encode(retryStrategy, forKey: .retryStrategy)
        }
        if startedAt != 0 {
            try encodeContainer.encode(startedAt, forKey: .startedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if stoppedAt != 0 {
            try encodeContainer.encode(stoppedAt, forKey: .stoppedAt)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagristagsmap0) in tags {
                try tagsContainer.encode(tagristagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobQueueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobQueue)
        jobQueue = jobQueueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let attemptsContainer = try containerValues.decodeIfPresent([AttemptDetail?].self, forKey: .attempts)
        var attemptsDecoded0:[AttemptDetail]? = nil
        if let attemptsContainer = attemptsContainer {
            attemptsDecoded0 = [AttemptDetail]()
            for structure0 in attemptsContainer {
                if let structure0 = structure0 {
                    attemptsDecoded0?.append(structure0)
                }
            }
        }
        attempts = attemptsDecoded0
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createdAtDecoded = try containerValues.decode(Int.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let retryStrategyDecoded = try containerValues.decodeIfPresent(RetryStrategy.self, forKey: .retryStrategy)
        retryStrategy = retryStrategyDecoded
        let startedAtDecoded = try containerValues.decode(Int.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let stoppedAtDecoded = try containerValues.decode(Int.self, forKey: .stoppedAt)
        stoppedAt = stoppedAtDecoded
        let dependsOnContainer = try containerValues.decodeIfPresent([JobDependency?].self, forKey: .dependsOn)
        var dependsOnDecoded0:[JobDependency]? = nil
        if let dependsOnContainer = dependsOnContainer {
            dependsOnDecoded0 = [JobDependency]()
            for structure0 in dependsOnContainer {
                if let structure0 = structure0 {
                    dependsOnDecoded0?.append(structure0)
                }
            }
        }
        dependsOn = dependsOnDecoded0
        let jobDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobDefinition)
        jobDefinition = jobDefinitionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, string0) in parametersContainer {
                if let string0 = string0 {
                    parametersDecoded0?[key0] = string0
                }
            }
        }
        parameters = parametersDecoded0
        let containerDecoded = try containerValues.decodeIfPresent(ContainerDetail.self, forKey: .container)
        container = containerDecoded
        let nodeDetailsDecoded = try containerValues.decodeIfPresent(NodeDetails.self, forKey: .nodeDetails)
        nodeDetails = nodeDetailsDecoded
        let nodePropertiesDecoded = try containerValues.decodeIfPresent(NodeProperties.self, forKey: .nodeProperties)
        nodeProperties = nodePropertiesDecoded
        let arrayPropertiesDecoded = try containerValues.decodeIfPresent(ArrayPropertiesDetail.self, forKey: .arrayProperties)
        arrayProperties = arrayPropertiesDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(JobTimeout.self, forKey: .timeout)
        timeout = timeoutDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let propagateTagsDecoded = try containerValues.decode(Bool.self, forKey: .propagateTags)
        propagateTags = propagateTagsDecoded
        let platformCapabilitiesContainer = try containerValues.decodeIfPresent([PlatformCapability?].self, forKey: .platformCapabilities)
        var platformCapabilitiesDecoded0:[PlatformCapability]? = nil
        if let platformCapabilitiesContainer = platformCapabilitiesContainer {
            platformCapabilitiesDecoded0 = [PlatformCapability]()
            for string0 in platformCapabilitiesContainer {
                if let string0 = string0 {
                    platformCapabilitiesDecoded0?.append(string0)
                }
            }
        }
        platformCapabilities = platformCapabilitiesDecoded0
    }
}
