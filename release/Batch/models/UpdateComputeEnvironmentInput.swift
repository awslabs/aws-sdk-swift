// Code generated by smithy-swift-codegen. DO NOT EDIT!



/// <p>Contains the parameters for <code>UpdateComputeEnvironment</code>.</p>
public struct UpdateComputeEnvironmentInput: Equatable {
    /// <p>The name or full Amazon Resource Name (ARN) of the compute environment to update.</p>
    public let computeEnvironment: String?
    /// <p>Details of the compute resources managed by the compute environment. Required for a managed compute environment.
    ///    For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/compute_environments.html">Compute
    ///     Environments</a> in the <i>AWS Batch User Guide</i>.</p>
    public let computeResources: ComputeResourceUpdate?
    /// <p>The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch to make calls to other AWS services on your behalf. For
    ///    more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/service_IAM_role.html">AWS Batch service IAM
    ///     role</a> in the <i>AWS Batch User Guide</i>.</p>
    ///          <important>
    ///             <p>If the compute environment has a service-linked role, it cannot be changed to use a regular IAM role. If the
    ///     compute environment has a regular IAM role, it cannot be changed to use a service-linked role.</p>
    ///          </important>
    ///
    ///          <p>If your specified role has a path other than <code>/</code>, then you must either specify the full role ARN
    ///    (this is recommended) or prefix the role name with the path.</p>
    ///          <note>
    ///             <p>Depending on how you created your AWS Batch service role, its ARN might contain the <code>service-role</code>
    ///     path prefix. When you only specify the name of the service role, AWS Batch assumes that your ARN doesn't use the
    ///      <code>service-role</code> path prefix. Because of this, we recommend that you specify the full ARN of your service
    ///     role when you create compute environments.</p>
    ///          </note>
    public let serviceRole: String?
    /// <p>The state of the compute environment. Compute environments in the <code>ENABLED</code> state can accept jobs
    ///    from a queue and scale in or out automatically based on the workload demand of its associated queues.</p>
    ///          <p>If the state is <code>ENABLED</code>, then the AWS Batch scheduler can attempt to place jobs from an associated
    ///    job queue on the compute resources within the environment. If the compute environment is managed, then it can scale
    ///    its instances out or in automatically, based on the job queue demand.</p>
    ///          <p>If the state is <code>DISABLED</code>, then the AWS Batch scheduler doesn't attempt to place jobs within the
    ///    environment. Jobs in a <code>STARTING</code> or <code>RUNNING</code> state continue to progress normally. Managed
    ///    compute environments in the <code>DISABLED</code> state don't scale out. However, they scale in to
    ///     <code>minvCpus</code> value after instances become idle.</p>
    public let state: CEState?

    public init (
        computeEnvironment: String? = nil,
        computeResources: ComputeResourceUpdate? = nil,
        serviceRole: String? = nil,
        state: CEState? = nil
    )
    {
        self.computeEnvironment = computeEnvironment
        self.computeResources = computeResources
        self.serviceRole = serviceRole
        self.state = state
    }
}

extension UpdateComputeEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateComputeEnvironmentInput(computeEnvironment: \(String(describing: computeEnvironment)), computeResources: \(String(describing: computeResources)), serviceRole: \(String(describing: serviceRole)), state: \(String(describing: state)))"}
}
