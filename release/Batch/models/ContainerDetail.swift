// Code generated by smithy-swift-codegen. DO NOT EDIT!



/// <p>An object representing the details of a container that's part of a job.</p>
public struct ContainerDetail: Equatable {
    /// <p>The command that's passed to the container.</p>
    public let command: [String]?
    /// <p>The Amazon Resource Name (ARN) of the container instance that the container is running on.</p>
    public let containerInstanceArn: String?
    /// <p>The environment variables to pass to a container.</p>
    ///          <note>
    ///             <p>Environment variables must not start with <code>AWS_BATCH</code>; this naming
    ///  convention is reserved for variables that are set by the AWS Batch service.</p>
    ///          </note>
    public let environment: [KeyValuePair]?
    /// <p>The Amazon Resource Name (ARN) of the
    ///    execution
    ///    role that AWS Batch can assume. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/execution-IAM-role.html">AWS Batch execution IAM role</a> in the
    ///     <i>AWS Batch User Guide</i>.</p>
    public let executionRoleArn: String?
    /// <p>The exit code to return upon completion.</p>
    public let exitCode: Int
    /// <p>The platform configuration for jobs running on Fargate resources. Jobs running on EC2 resources must not
    ///    specify this parameter.</p>
    public let fargatePlatformConfiguration: FargatePlatformConfiguration?
    /// <p>The image used to start the container.</p>
    public let image: String?
    /// <p>The instance type of the underlying host infrastructure of a multi-node parallel job.</p>
    ///          <note>
    ///             <p>This parameter isn't applicable to jobs running on Fargate resources.</p>
    ///          </note>
    public let instanceType: String?
    /// <p>The Amazon Resource Name (ARN) associated with the job upon execution.</p>
    public let jobRoleArn: String?
    /// <p>Linux-specific modifications that are applied to the container, such as details for device mappings.</p>
    public let linuxParameters: LinuxParameters?
    /// <p>The log configuration specification for the container.</p>
    ///          <p>This parameter maps to <code>LogConfig</code> in the <a href="https://docs.docker.com/engine/api/v1.23/#create-a-container">Create a container</a> section of the
    ///    <a href="https://docs.docker.com/engine/api/v1.23/">Docker Remote API</a> and the <code>--log-driver</code> option to <a href="https://docs.docker.com/engine/reference/run/">docker run</a>.
    ///    By default, containers use the same logging driver that the Docker daemon uses. However, the container might use a
    ///    different logging driver than the Docker daemon by specifying a log driver with this parameter in the container
    ///    definition. To use a different logging driver for a container, the log system must be configured properly on the
    ///    container instance. Or, alternatively, it must be configured on a different log server for remote logging options.
    ///    For more information on the options for different supported log drivers, see <a href="https://docs.docker.com/engine/admin/logging/overview/">Configure logging drivers</a> in the Docker
    ///    documentation.</p>
    ///          <note>
    ///             <p>AWS Batch currently supports a subset of the logging drivers available to the Docker daemon (shown in the <a>LogConfiguration</a> data type). Additional log drivers might be available in future releases of the Amazon ECS
    ///     container agent.</p>
    ///          </note>
    ///          <p>This parameter requires version 1.18 of the Docker Remote API or greater on your
    ///  container instance. To check the Docker Remote API version on your container instance, log into your
    ///  container instance and run the following command: <code>sudo docker version | grep "Server API version"</code>
    ///          </p>
    ///          <note>
    ///             <p>The Amazon ECS container agent running on a container instance must register the logging drivers available on that
    ///     instance with the <code>ECS_AVAILABLE_LOGGING_DRIVERS</code> environment variable before containers placed on that
    ///     instance can use these log configuration options. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html">Amazon ECS Container Agent Configuration</a> in the
    ///      <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    ///          </note>
    public let logConfiguration: LogConfiguration?
    /// <p>The name of the CloudWatch Logs log stream associated with the container. The log group for AWS Batch jobs is
    ///     <code>/aws/batch/job</code>. Each container attempt receives a log stream name when they reach the
    ///     <code>RUNNING</code> status.</p>
    public let logStreamName: String?
    /// <p>For jobs run on EC2 resources that didn't specify memory requirements using <code>ResourceRequirement</code>,
    ///    the number of MiB of memory reserved for the job. For other jobs, including all run on Fargate resources, see
    ///     <code>resourceRequirements</code>.</p>
    public let memory: Int
    /// <p>The mount points for data volumes in your container.</p>
    public let mountPoints: [MountPoint]?
    /// <p>The network configuration for jobs running on Fargate resources. Jobs running on EC2 resources must not
    ///    specify this parameter.</p>
    public let networkConfiguration: NetworkConfiguration?
    /// <p>The network interfaces associated with the job.</p>
    public let networkInterfaces: [NetworkInterface]?
    /// <p>When this parameter is true, the container is given elevated permissions on the host container instance (similar
    ///    to the <code>root</code> user). The default value is false.</p>
    ///          <note>
    ///             <p>This parameter isn't applicable to jobs running on Fargate resources and shouldn't be provided, or specified
    ///     as false.</p>
    ///          </note>
    public let privileged: Bool
    /// <p>When this parameter is true, the container is given read-only access to its root file system. This parameter
    ///    maps to <code>ReadonlyRootfs</code> in the <a href="https://docs.docker.com/engine/api/v1.23/#create-a-container">Create a container</a> section of the <a href="https://docs.docker.com/engine/api/v1.23/">Docker Remote API</a> and
    ///    the <code>--read-only</code> option to <a href="https://docs.docker.com/engine/reference/commandline/run/">
    ///                <code>docker run</code>
    ///             </a>.</p>
    public let readonlyRootFilesystem: Bool
    /// <p>A short (255 max characters) human-readable string to provide additional details about a running or stopped
    ///    container.</p>
    public let reason: String?
    /// <p>The type and amount of resources to assign to a container. The supported resources include <code>GPU</code>,
    ///     <code>MEMORY</code>, and <code>VCPU</code>.</p>
    public let resourceRequirements: [ResourceRequirement]?
    /// <p>The secrets to pass to the container. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/specifying-sensitive-data.html">Specifying sensitive data</a> in the
    ///     <i>AWS Batch User Guide</i>.</p>
    public let secrets: [Secret]?
    /// <p>The Amazon Resource Name (ARN) of the Amazon ECS task that's associated with the container job. Each container attempt receives a task
    ///    ARN when they reach the <code>STARTING</code> status.</p>
    public let taskArn: String?
    /// <p>A list of <code>ulimit</code> values to set in the container. This parameter maps to <code>Ulimits</code> in the
    ///    <a href="https://docs.docker.com/engine/api/v1.23/#create-a-container">Create a container</a> section of the <a href="https://docs.docker.com/engine/api/v1.23/">Docker Remote API</a> and the <code>--ulimit</code> option to <a href="https://docs.docker.com/engine/reference/run/">docker run</a>.</p>
    ///          <note>
    ///             <p>This parameter isn't applicable to jobs running on Fargate resources.</p>
    ///          </note>
    public let ulimits: [Ulimit]?
    /// <p>The user name to use inside the container. This parameter maps to <code>User</code> in the
    ///    <a href="https://docs.docker.com/engine/api/v1.23/#create-a-container">Create a container</a> section of the <a href="https://docs.docker.com/engine/api/v1.23/">Docker Remote API</a> and the <code>--user</code> option to <a href="https://docs.docker.com/engine/reference/run/">docker run</a>.</p>
    public let user: String?
    /// <p>The number of vCPUs reserved for the container. For jobs that run on EC2 resources, you can specify the vCPU
    ///    requirement for the job using <code>resourceRequirements</code>, but you can't specify the vCPU requirements in both
    ///    the <code>vcpus</code> and <code>resourceRequirement</code> object. This parameter maps to <code>CpuShares</code> in
    ///    the <a href="https://docs.docker.com/engine/api/v1.23/#create-a-container">Create a container</a> section of the <a href="https://docs.docker.com/engine/api/v1.23/">Docker Remote API</a> and the <code>--cpu-shares</code> option to
    ///     <a href="https://docs.docker.com/engine/reference/run/">docker run</a>. Each vCPU is equivalent to 1,024 CPU shares. You must
    ///    specify at least one vCPU. This is required but can be specified in several places. It must be specified for each
    ///    node at least once.</p>
    ///          <note>
    ///             <p>This parameter isn't applicable to jobs that run on Fargate resources. For jobs that run on Fargate
    ///     resources, you must specify the vCPU requirement for the job using <code>resourceRequirements</code>.</p>
    ///          </note>
    public let vcpus: Int
    /// <p>A list of volumes associated with the job.</p>
    public let volumes: [Volume]?

    public init (
        command: [String]? = nil,
        containerInstanceArn: String? = nil,
        environment: [KeyValuePair]? = nil,
        executionRoleArn: String? = nil,
        exitCode: Int = 0,
        fargatePlatformConfiguration: FargatePlatformConfiguration? = nil,
        image: String? = nil,
        instanceType: String? = nil,
        jobRoleArn: String? = nil,
        linuxParameters: LinuxParameters? = nil,
        logConfiguration: LogConfiguration? = nil,
        logStreamName: String? = nil,
        memory: Int = 0,
        mountPoints: [MountPoint]? = nil,
        networkConfiguration: NetworkConfiguration? = nil,
        networkInterfaces: [NetworkInterface]? = nil,
        privileged: Bool = false,
        readonlyRootFilesystem: Bool = false,
        reason: String? = nil,
        resourceRequirements: [ResourceRequirement]? = nil,
        secrets: [Secret]? = nil,
        taskArn: String? = nil,
        ulimits: [Ulimit]? = nil,
        user: String? = nil,
        vcpus: Int = 0,
        volumes: [Volume]? = nil
    )
    {
        self.command = command
        self.containerInstanceArn = containerInstanceArn
        self.environment = environment
        self.executionRoleArn = executionRoleArn
        self.exitCode = exitCode
        self.fargatePlatformConfiguration = fargatePlatformConfiguration
        self.image = image
        self.instanceType = instanceType
        self.jobRoleArn = jobRoleArn
        self.linuxParameters = linuxParameters
        self.logConfiguration = logConfiguration
        self.logStreamName = logStreamName
        self.memory = memory
        self.mountPoints = mountPoints
        self.networkConfiguration = networkConfiguration
        self.networkInterfaces = networkInterfaces
        self.privileged = privileged
        self.readonlyRootFilesystem = readonlyRootFilesystem
        self.reason = reason
        self.resourceRequirements = resourceRequirements
        self.secrets = secrets
        self.taskArn = taskArn
        self.ulimits = ulimits
        self.user = user
        self.vcpus = vcpus
        self.volumes = volumes
    }
}

extension ContainerDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContainerDetail(command: \(String(describing: command)), containerInstanceArn: \(String(describing: containerInstanceArn)), environment: \(String(describing: environment)), executionRoleArn: \(String(describing: executionRoleArn)), exitCode: \(String(describing: exitCode)), fargatePlatformConfiguration: \(String(describing: fargatePlatformConfiguration)), image: \(String(describing: image)), instanceType: \(String(describing: instanceType)), jobRoleArn: \(String(describing: jobRoleArn)), linuxParameters: \(String(describing: linuxParameters)), logConfiguration: \(String(describing: logConfiguration)), logStreamName: \(String(describing: logStreamName)), memory: \(String(describing: memory)), mountPoints: \(String(describing: mountPoints)), networkConfiguration: \(String(describing: networkConfiguration)), networkInterfaces: \(String(describing: networkInterfaces)), privileged: \(String(describing: privileged)), readonlyRootFilesystem: \(String(describing: readonlyRootFilesystem)), reason: \(String(describing: reason)), resourceRequirements: \(String(describing: resourceRequirements)), secrets: \(String(describing: secrets)), taskArn: \(String(describing: taskArn)), ulimits: \(String(describing: ulimits)), user: \(String(describing: user)), vcpus: \(String(describing: vcpus)), volumes: \(String(describing: volumes)))"}
}
