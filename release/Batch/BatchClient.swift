// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class BatchClient {
    let client: SdkHttpClient
    let config: BatchClientConfiguration
    let serviceName = "Batch"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: BatchClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class BatchClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> BatchClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try BatchClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension BatchClient: BatchClientProtocol {
    /// <p>Cancels a job in an AWS Batch job queue. Jobs that are in the <code>SUBMITTED</code>, <code>PENDING</code>, or
    ///     <code>RUNNABLE</code> state are canceled. Jobs that have progressed to <code>STARTING</code> or <code>RUNNING</code>
    ///    aren't canceled, but the API operation still succeeds, even if no job is canceled. These jobs must be terminated with
    ///    the <a>TerminateJob</a> operation.</p>
    public func cancelJob(input: CancelJobInput, completion: @escaping (SdkResult<CancelJobOutputResponse, CancelJobOutputError>) -> Void)
    {
        let urlPath = "/v1/canceljob"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelJobInput, CancelJobOutputResponse, CancelJobOutputError>(id: "cancelJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelJobInput, CancelJobOutputResponse, CancelJobOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CancelJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an AWS Batch compute environment. You can create <code>MANAGED</code> or <code>UNMANAGED</code> compute
    ///    environments. <code>MANAGED</code> compute environments can use Amazon EC2 or AWS Fargate resources.
    ///     <code>UNMANAGED</code> compute environments can only use EC2 resources.</p>
    ///          <p>In a managed compute environment, AWS Batch manages the capacity and instance types of the compute resources
    ///    within the environment. This is based on the compute resource specification that you define or the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html">launch template</a> that you
    ///    specify when you create the compute environment. Either, you can choose to use EC2 On-Demand Instances and EC2 Spot
    ///    Instances. Or, you can use Fargate and Fargate Spot capacity in your managed compute environment. You can
    ///    optionally set a maximum price so that Spot Instances only launch
    ///    when
    ///    the Spot Instance price is less than a specified percentage of the On-Demand price.</p>
    ///
    ///          <note>
    ///             <p>Multi-node parallel jobs aren't supported on Spot Instances.</p>
    ///          </note>
    ///          <p>In an unmanaged compute environment, you can manage your own EC2 compute resources and have a lot of flexibility
    ///    with how you configure your compute resources. For example, you can use custom AMIs. However, you must verify that
    ///    each of your AMIs meet the Amazon ECS container instance AMI specification. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/container_instance_AMIs.html">container instance AMIs</a> in the
    ///     <i>Amazon Elastic Container Service Developer Guide</i>. After you created your unmanaged compute environment, you can use the <a>DescribeComputeEnvironments</a> operation to find the Amazon ECS cluster that's associated with it. Then, launch
    ///    your container instances into that Amazon ECS cluster. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_container_instance.html">Launching an Amazon ECS container instance</a> in the
    ///     <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    ///          <note>
    ///             <p>AWS Batch doesn't upgrade the AMIs in a compute environment after the environment is created. For example, it
    ///     doesn't update the AMIs when a newer version of the Amazon ECS optimized AMI is available. Therefore, you're responsible
    ///     for managing the guest operating system (including its updates and security patches) and any additional application
    ///     software or utilities that you install on the compute resources. To use a new AMI for your AWS Batch jobs, complete
    ///     these steps:</p>
    ///             <ol>
    ///                <li>
    ///                   <p>Create a new compute environment with the new AMI.</p>
    ///                </li>
    ///                <li>
    ///                   <p>Add the compute environment to an existing job queue.</p>
    ///                </li>
    ///                <li>
    ///                   <p>Remove the earlier compute environment from your job queue.</p>
    ///                </li>
    ///                <li>
    ///                   <p>Delete the earlier compute environment.</p>
    ///                </li>
    ///             </ol>
    ///          </note>
    public func createComputeEnvironment(input: CreateComputeEnvironmentInput, completion: @escaping (SdkResult<CreateComputeEnvironmentOutputResponse, CreateComputeEnvironmentOutputError>) -> Void)
    {
        let urlPath = "/v1/createcomputeenvironment"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createComputeEnvironment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateComputeEnvironmentInput, CreateComputeEnvironmentOutputResponse, CreateComputeEnvironmentOutputError>(id: "createComputeEnvironment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateComputeEnvironmentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateComputeEnvironmentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateComputeEnvironmentInput, CreateComputeEnvironmentOutputResponse, CreateComputeEnvironmentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateComputeEnvironmentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an AWS Batch job queue. When you create a job queue, you associate one or more compute environments to the
    ///    queue and assign an order of preference for the compute environments.</p>
    ///          <p>You also set a priority to the job queue that determines the order that the AWS Batch scheduler places jobs onto
    ///    its associated compute environments. For example, if a compute environment is associated with more than one job
    ///    queue, the job queue with a higher priority is given preference for scheduling jobs to that compute
    ///    environment.</p>
    public func createJobQueue(input: CreateJobQueueInput, completion: @escaping (SdkResult<CreateJobQueueOutputResponse, CreateJobQueueOutputError>) -> Void)
    {
        let urlPath = "/v1/createjobqueue"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createJobQueue")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateJobQueueInput, CreateJobQueueOutputResponse, CreateJobQueueOutputError>(id: "createJobQueue")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateJobQueueInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateJobQueueInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateJobQueueInput, CreateJobQueueOutputResponse, CreateJobQueueOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateJobQueueInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an AWS Batch compute environment.</p>
    ///          <p>Before you can delete a compute environment, you must set its state to <code>DISABLED</code> with the <a>UpdateComputeEnvironment</a> API operation and disassociate it from any job queues with the <a>UpdateJobQueue</a> API operation. Compute environments that use AWS Fargate resources must terminate all
    ///    active jobs on that compute environment before deleting the compute environment. If this isn't done, the compute
    ///    environment enters an invalid state.</p>
    public func deleteComputeEnvironment(input: DeleteComputeEnvironmentInput, completion: @escaping (SdkResult<DeleteComputeEnvironmentOutputResponse, DeleteComputeEnvironmentOutputError>) -> Void)
    {
        let urlPath = "/v1/deletecomputeenvironment"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteComputeEnvironment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteComputeEnvironmentInput, DeleteComputeEnvironmentOutputResponse, DeleteComputeEnvironmentOutputError>(id: "deleteComputeEnvironment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteComputeEnvironmentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteComputeEnvironmentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteComputeEnvironmentInput, DeleteComputeEnvironmentOutputResponse, DeleteComputeEnvironmentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteComputeEnvironmentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified job queue. You must first disable submissions for a queue with the <a>UpdateJobQueue</a> operation. All jobs in the queue are eventually terminated when you delete a job queue.
    ///    The jobs are terminated at a rate of about 16 jobs each second.</p>
    ///          <p>It's not necessary to disassociate compute environments from a queue before submitting a
    ///     <code>DeleteJobQueue</code> request.</p>
    public func deleteJobQueue(input: DeleteJobQueueInput, completion: @escaping (SdkResult<DeleteJobQueueOutputResponse, DeleteJobQueueOutputError>) -> Void)
    {
        let urlPath = "/v1/deletejobqueue"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteJobQueue")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteJobQueueInput, DeleteJobQueueOutputResponse, DeleteJobQueueOutputError>(id: "deleteJobQueue")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteJobQueueInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteJobQueueInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteJobQueueInput, DeleteJobQueueOutputResponse, DeleteJobQueueOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteJobQueueInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deregisters an AWS Batch job definition. Job definitions are permanently deleted after 180 days.</p>
    public func deregisterJobDefinition(input: DeregisterJobDefinitionInput, completion: @escaping (SdkResult<DeregisterJobDefinitionOutputResponse, DeregisterJobDefinitionOutputError>) -> Void)
    {
        let urlPath = "/v1/deregisterjobdefinition"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deregisterJobDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeregisterJobDefinitionInput, DeregisterJobDefinitionOutputResponse, DeregisterJobDefinitionOutputError>(id: "deregisterJobDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeregisterJobDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeregisterJobDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeregisterJobDefinitionInput, DeregisterJobDefinitionOutputResponse, DeregisterJobDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DeregisterJobDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes one or more of your compute environments.</p>
    ///          <p>If you're using an unmanaged compute environment, you can use the <code>DescribeComputeEnvironment</code>
    ///    operation to determine the <code>ecsClusterArn</code> that you should launch your Amazon ECS container instances
    ///    into.</p>
    public func describeComputeEnvironments(input: DescribeComputeEnvironmentsInput, completion: @escaping (SdkResult<DescribeComputeEnvironmentsOutputResponse, DescribeComputeEnvironmentsOutputError>) -> Void)
    {
        let urlPath = "/v1/describecomputeenvironments"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeComputeEnvironments")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeComputeEnvironmentsInput, DescribeComputeEnvironmentsOutputResponse, DescribeComputeEnvironmentsOutputError>(id: "describeComputeEnvironments")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeComputeEnvironmentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeComputeEnvironmentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeComputeEnvironmentsInput, DescribeComputeEnvironmentsOutputResponse, DescribeComputeEnvironmentsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeComputeEnvironmentsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes a list of job definitions. You can specify a <code>status</code> (such as <code>ACTIVE</code>) to only
    ///    return job definitions that match that status.</p>
    public func describeJobDefinitions(input: DescribeJobDefinitionsInput, completion: @escaping (SdkResult<DescribeJobDefinitionsOutputResponse, DescribeJobDefinitionsOutputError>) -> Void)
    {
        let urlPath = "/v1/describejobdefinitions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeJobDefinitions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeJobDefinitionsInput, DescribeJobDefinitionsOutputResponse, DescribeJobDefinitionsOutputError>(id: "describeJobDefinitions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobDefinitionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobDefinitionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeJobDefinitionsInput, DescribeJobDefinitionsOutputResponse, DescribeJobDefinitionsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobDefinitionsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes one or more of your job queues.</p>
    public func describeJobQueues(input: DescribeJobQueuesInput, completion: @escaping (SdkResult<DescribeJobQueuesOutputResponse, DescribeJobQueuesOutputError>) -> Void)
    {
        let urlPath = "/v1/describejobqueues"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeJobQueues")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeJobQueuesInput, DescribeJobQueuesOutputResponse, DescribeJobQueuesOutputError>(id: "describeJobQueues")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobQueuesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobQueuesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeJobQueuesInput, DescribeJobQueuesOutputResponse, DescribeJobQueuesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobQueuesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes a list of AWS Batch jobs.</p>
    public func describeJobs(input: DescribeJobsInput, completion: @escaping (SdkResult<DescribeJobsOutputResponse, DescribeJobsOutputError>) -> Void)
    {
        let urlPath = "/v1/describejobs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeJobs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeJobsInput, DescribeJobsOutputResponse, DescribeJobsOutputError>(id: "describeJobs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeJobsInput, DescribeJobsOutputResponse, DescribeJobsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of AWS Batch jobs.</p>
    ///          <p>You must specify only one of the following items:</p>
    ///          <ul>
    ///             <li>
    ///                <p>A job queue ID to return a list of jobs in that job queue</p>
    ///             </li>
    ///             <li>
    ///                <p>A multi-node parallel job ID to return a list of nodes for that job</p>
    ///             </li>
    ///             <li>
    ///                <p>An array job ID to return a list of the children for that job</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can filter the results by job status with the <code>jobStatus</code> parameter. If you don't specify a
    ///    status, only <code>RUNNING</code> jobs are returned.</p>
    public func listJobs(input: ListJobsInput, completion: @escaping (SdkResult<ListJobsOutputResponse, ListJobsOutputError>) -> Void)
    {
        let urlPath = "/v1/listjobs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listJobs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListJobsInput, ListJobsOutputResponse, ListJobsOutputError>(id: "listJobs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListJobsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListJobsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListJobsInput, ListJobsOutputResponse, ListJobsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListJobsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the tags for an AWS Batch resource. AWS Batch resources that support tags are compute environments, jobs, job definitions, and job
    ///  queues. ARNs for child jobs of array and multi-node parallel (MNP) jobs are not supported.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Registers an AWS Batch job definition.</p>
    public func registerJobDefinition(input: RegisterJobDefinitionInput, completion: @escaping (SdkResult<RegisterJobDefinitionOutputResponse, RegisterJobDefinitionOutputError>) -> Void)
    {
        let urlPath = "/v1/registerjobdefinition"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "registerJobDefinition")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<RegisterJobDefinitionInput, RegisterJobDefinitionOutputResponse, RegisterJobDefinitionOutputError>(id: "registerJobDefinition")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: RegisterJobDefinitionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: RegisterJobDefinitionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<RegisterJobDefinitionInput, RegisterJobDefinitionOutputResponse, RegisterJobDefinitionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: RegisterJobDefinitionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Submits an AWS Batch job from a job definition. Parameters that are specified during <a>SubmitJob</a>
    ///    override parameters defined in the job definition. vCPU and memory requirements that are specified in the
    ///     <code>ResourceRequirements</code> objects in the job definition are the exception. They can't be overridden this way
    ///    using the <code>memory</code> and <code>vcpus</code> parameters. Rather, you must specify updates to job definition
    ///    parameters in a <code>ResourceRequirements</code> object that's included in the <code>containerOverrides</code>
    ///    parameter.</p>
    ///          <important>
    ///             <p>Jobs that run on Fargate resources can't be guaranteed to run for more than 14 days. This is because, after 14
    ///     days, Fargate resources might become unavailable and job might be terminated.</p>
    ///          </important>
    public func submitJob(input: SubmitJobInput, completion: @escaping (SdkResult<SubmitJobOutputResponse, SubmitJobOutputError>) -> Void)
    {
        let urlPath = "/v1/submitjob"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "submitJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<SubmitJobInput, SubmitJobOutputResponse, SubmitJobOutputError>(id: "submitJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: SubmitJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: SubmitJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<SubmitJobInput, SubmitJobOutputResponse, SubmitJobOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: SubmitJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associates the specified tags to a resource with the specified <code>resourceArn</code>. If existing tags on a
    ///    resource aren't specified in the request parameters, they aren't changed. When a resource is deleted, the tags
    ///    associated with that resource are deleted as well. AWS Batch resources that support tags are compute environments, jobs, job definitions, and job
    ///  queues. ARNs for child jobs of array and multi-node parallel (MNP) jobs are not supported.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Terminates a job in a job queue. Jobs that are in the <code>STARTING</code> or <code>RUNNING</code> state are
    ///    terminated, which causes them to transition to <code>FAILED</code>. Jobs that have not progressed to the
    ///     <code>STARTING</code> state are cancelled.</p>
    public func terminateJob(input: TerminateJobInput, completion: @escaping (SdkResult<TerminateJobOutputResponse, TerminateJobOutputError>) -> Void)
    {
        let urlPath = "/v1/terminatejob"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "terminateJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TerminateJobInput, TerminateJobOutputResponse, TerminateJobOutputError>(id: "terminateJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TerminateJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TerminateJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TerminateJobInput, TerminateJobOutputResponse, TerminateJobOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TerminateJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes specified tags from an AWS Batch resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an AWS Batch compute environment.</p>
    public func updateComputeEnvironment(input: UpdateComputeEnvironmentInput, completion: @escaping (SdkResult<UpdateComputeEnvironmentOutputResponse, UpdateComputeEnvironmentOutputError>) -> Void)
    {
        let urlPath = "/v1/updatecomputeenvironment"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateComputeEnvironment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateComputeEnvironmentInput, UpdateComputeEnvironmentOutputResponse, UpdateComputeEnvironmentOutputError>(id: "updateComputeEnvironment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateComputeEnvironmentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateComputeEnvironmentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateComputeEnvironmentInput, UpdateComputeEnvironmentOutputResponse, UpdateComputeEnvironmentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateComputeEnvironmentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a job queue.</p>
    public func updateJobQueue(input: UpdateJobQueueInput, completion: @escaping (SdkResult<UpdateJobQueueOutputResponse, UpdateJobQueueOutputError>) -> Void)
    {
        let urlPath = "/v1/updatejobqueue"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateJobQueue")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "batch.\(config.region).amazonaws.com")
                      .withSigningName(value: "batch")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateJobQueueInput, UpdateJobQueueOutputResponse, UpdateJobQueueOutputError>(id: "updateJobQueue")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateJobQueueInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateJobQueueInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateJobQueueInput, UpdateJobQueueOutputResponse, UpdateJobQueueOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateJobQueueInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
