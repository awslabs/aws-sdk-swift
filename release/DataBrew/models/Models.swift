// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access to the specified resource was denied.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct BatchDeleteRecipeVersionInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteRecipeVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteRecipeVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteRecipeVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteRecipeVersionInput>
    public typealias MOutput = OperationOutput<BatchDeleteRecipeVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteRecipeVersionOutputError>
}

extension BatchDeleteRecipeVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteRecipeVersionInput(name: \(String(describing: name)), recipeVersions: \(String(describing: recipeVersions)))"}
}

extension BatchDeleteRecipeVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recipeVersions = "RecipeVersions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recipeVersions = recipeVersions {
            var recipeVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recipeVersions)
            for recipeversionlist0 in recipeVersions {
                try recipeVersionsContainer.encode(recipeversionlist0)
            }
        }
    }
}

public struct BatchDeleteRecipeVersionInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteRecipeVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteRecipeVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteRecipeVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteRecipeVersionInput>
    public typealias MOutput = OperationOutput<BatchDeleteRecipeVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteRecipeVersionOutputError>
}

public struct BatchDeleteRecipeVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteRecipeVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteRecipeVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteRecipeVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteRecipeVersionInput>
    public typealias MOutput = OperationOutput<BatchDeleteRecipeVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteRecipeVersionOutputError>
}

public struct BatchDeleteRecipeVersionInput: Equatable {
    /// <p>The name of the recipe whose versions are to be deleted.</p>
    public let name: String?
    /// <p>An array of version identifiers, for the recipe versions to be deleted. You can
    ///             specify numeric versions (<code>X.Y</code>) or <code>LATEST_WORKING</code>.
    ///                 <code>LATEST_PUBLISHED</code> is not supported.</p>
    public let recipeVersions: [String]?

    public init (
        name: String? = nil,
        recipeVersions: [String]? = nil
    )
    {
        self.name = name
        self.recipeVersions = recipeVersions
    }
}

struct BatchDeleteRecipeVersionInputBody: Equatable {
    public let recipeVersions: [String]?
}

extension BatchDeleteRecipeVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recipeVersions = "RecipeVersions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .recipeVersions)
        var recipeVersionsDecoded0:[String]? = nil
        if let recipeVersionsContainer = recipeVersionsContainer {
            recipeVersionsDecoded0 = [String]()
            for string0 in recipeVersionsContainer {
                if let string0 = string0 {
                    recipeVersionsDecoded0?.append(string0)
                }
            }
        }
        recipeVersions = recipeVersionsDecoded0
    }
}

extension BatchDeleteRecipeVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteRecipeVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteRecipeVersionOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteRecipeVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteRecipeVersionOutputResponse(errors: \(String(describing: errors)), name: \(String(describing: name)))"}
}

extension BatchDeleteRecipeVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteRecipeVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
            self.name = output.name
        } else {
            self.errors = nil
            self.name = nil
        }
    }
}

public struct BatchDeleteRecipeVersionOutputResponse: Equatable {
    /// <p>Errors, if any, that occurred while attempting to delete the recipe versions.</p>
    public let errors: [RecipeVersionErrorDetail]?
    /// <p>The name of the recipe that was modified.</p>
    public let name: String?

    public init (
        errors: [RecipeVersionErrorDetail]? = nil,
        name: String? = nil
    )
    {
        self.errors = errors
        self.name = name
    }
}

struct BatchDeleteRecipeVersionOutputResponseBody: Equatable {
    public let name: String?
    public let errors: [RecipeVersionErrorDetail]?
}

extension BatchDeleteRecipeVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors = "Errors"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let errorsContainer = try containerValues.decodeIfPresent([RecipeVersionErrorDetail?].self, forKey: .errors)
        var errorsDecoded0:[RecipeVersionErrorDetail]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [RecipeVersionErrorDetail]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public enum CompressionFormat {
    case brotli
    case bzip2
    case deflate
    case gzip
    case lz4
    case lzo
    case snappy
    case zlib
    case zstd
    case sdkUnknown(String)
}

extension CompressionFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CompressionFormat] {
        return [
            .brotli,
            .bzip2,
            .deflate,
            .gzip,
            .lz4,
            .lzo,
            .snappy,
            .zlib,
            .zstd,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .brotli: return "BROTLI"
        case .bzip2: return "BZIP2"
        case .deflate: return "DEFLATE"
        case .gzip: return "GZIP"
        case .lz4: return "LZ4"
        case .lzo: return "LZO"
        case .snappy: return "SNAPPY"
        case .zlib: return "ZLIB"
        case .zstd: return "ZSTD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CompressionFormat(rawValue: rawValue) ?? CompressionFormat.sdkUnknown(rawValue)
    }
}

extension ConditionExpression: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition = "Condition"
        case targetColumn = "TargetColumn"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let targetColumn = targetColumn {
            try encodeContainer.encode(targetColumn, forKey: .targetColumn)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .condition)
        condition = conditionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let targetColumnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetColumn)
        targetColumn = targetColumnDecoded
    }
}

extension ConditionExpression: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConditionExpression(condition: \(String(describing: condition)), targetColumn: \(String(describing: targetColumn)), value: \(String(describing: value)))"}
}

/// <p>Represents an individual condition that evaluates to true or false.</p>
///         <p>Conditions are used with recipe actions. The action is only performed for column values where the condition evaluates to true.</p>
///         <p>If a recipe requires more than one condition, then the recipe must specify multiple <code>ConditionExpression</code> elements. Each condition is applied to the rows in a dataset first, before the recipe action is performed.</p>
public struct ConditionExpression: Equatable {
    /// <p>A specific condition to apply to a recipe action. For more information, see <a href="https://docs.aws.amazon.com/databrew/latest/dg/recipes.html#recipes.structure">Recipe
    ///                 structure</a> in the <i>AWS Glue DataBrew Developer
    ///             Guide</i>.</p>
    public let condition: String?
    /// <p>A column to apply this condition to.</p>
    public let targetColumn: String?
    /// <p>A value that the condition must evaluate to for the condition to succeed.</p>
    public let value: String?

    public init (
        condition: String? = nil,
        targetColumn: String? = nil,
        value: String? = nil
    )
    {
        self.condition = condition
        self.targetColumn = targetColumn
        self.value = value
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Updating or deleting a resource can cause an inconsistent state.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateDatasetInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

extension CreateDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetInput(format: \(String(describing: format)), formatOptions: \(String(describing: formatOptions)), input: \(String(describing: input)), name: \(String(describing: name)), pathOptions: \(String(describing: pathOptions)), tags: \(String(describing: tags)))"}
}

extension CreateDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case format = "Format"
        case formatOptions = "FormatOptions"
        case input = "Input"
        case name = "Name"
        case pathOptions = "PathOptions"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let formatOptions = formatOptions {
            try encodeContainer.encode(formatOptions, forKey: .formatOptions)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pathOptions = pathOptions {
            try encodeContainer.encode(pathOptions, forKey: .pathOptions)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInput: Equatable {
    /// <p>The file format of a dataset that is created from an S3 file or folder.</p>
    public let format: InputFormat?
    /// <p>Represents a set of options that define the structure of either comma-separated value (CSV), Excel, or JSON input.</p>
    public let formatOptions: FormatOptions?
    /// <p>Represents information on how DataBrew can find data, in either the AWS Glue Data Catalog or
    ///             Amazon S3.</p>
    public let input: Input?
    /// <p>The name of the dataset to be created. Valid characters are alphanumeric (A-Z, a-z,
    ///             0-9), hyphen (-), period (.), and space.</p>
    public let name: String?
    /// <p>A set of options that defines how DataBrew interprets an S3 path of the dataset.</p>
    public let pathOptions: PathOptions?
    /// <p>Metadata tags to apply to this dataset.</p>
    public let tags: [String:String]?

    public init (
        format: InputFormat? = nil,
        formatOptions: FormatOptions? = nil,
        input: Input? = nil,
        name: String? = nil,
        pathOptions: PathOptions? = nil,
        tags: [String:String]? = nil
    )
    {
        self.format = format
        self.formatOptions = formatOptions
        self.input = input
        self.name = name
        self.pathOptions = pathOptions
        self.tags = tags
    }
}

struct CreateDatasetInputBody: Equatable {
    public let name: String?
    public let format: InputFormat?
    public let formatOptions: FormatOptions?
    public let input: Input?
    public let pathOptions: PathOptions?
    public let tags: [String:String]?
}

extension CreateDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case format = "Format"
        case formatOptions = "FormatOptions"
        case input = "Input"
        case name = "Name"
        case pathOptions = "PathOptions"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(InputFormat.self, forKey: .format)
        format = formatDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(FormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Input.self, forKey: .input)
        input = inputDecoded
        let pathOptionsDecoded = try containerValues.decodeIfPresent(PathOptions.self, forKey: .pathOptions)
        pathOptions = pathOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetOutputResponse(name: \(String(describing: name)))"}
}

extension CreateDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Equatable {
    /// <p>The name of the dataset that you created.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateDatasetOutputResponseBody: Equatable {
    public let name: String?
}

extension CreateDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateProfileJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateProfileJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProfileJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProfileJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProfileJobInput>
    public typealias MOutput = OperationOutput<CreateProfileJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProfileJobOutputError>
}

extension CreateProfileJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProfileJobInput(datasetName: \(String(describing: datasetName)), encryptionKeyArn: \(String(describing: encryptionKeyArn)), encryptionMode: \(String(describing: encryptionMode)), jobSample: \(String(describing: jobSample)), logSubscription: \(String(describing: logSubscription)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), name: \(String(describing: name)), outputLocation: \(String(describing: outputLocation)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)), timeout: \(String(describing: timeout)))"}
}

extension CreateProfileJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetName = "DatasetName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case jobSample = "JobSample"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let jobSample = jobSample {
            try encodeContainer.encode(jobSample, forKey: .jobSample)
        }
        if let logSubscription = logSubscription {
            try encodeContainer.encode(logSubscription.rawValue, forKey: .logSubscription)
        }
        if maxCapacity != 0 {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if maxRetries != 0 {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }
}

public struct CreateProfileJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProfileJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProfileJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProfileJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProfileJobInput>
    public typealias MOutput = OperationOutput<CreateProfileJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProfileJobOutputError>
}

public struct CreateProfileJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProfileJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProfileJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProfileJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProfileJobInput>
    public typealias MOutput = OperationOutput<CreateProfileJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProfileJobOutputError>
}

public struct CreateProfileJobInput: Equatable {
    /// <p>The name of the dataset that this job is to act upon.</p>
    public let datasetName: String?
    /// <p>The Amazon Resource Name (ARN) of an encryption key that is used to protect the
    ///             job.</p>
    public let encryptionKeyArn: String?
    /// <p>The encryption mode for the job, which can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>SSE-KMS</code> - <code>SSE-KMS</code> - Server-side encryption with AWS
    ///                     KMS-managed keys.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SSE-S3</code> - Server-side encryption with keys managed by Amazon
    ///                     S3.</p>
    ///             </li>
    ///          </ul>
    public let encryptionMode: EncryptionMode?
    /// <p>Sample configuration for profile jobs only. Determines the number of rows on which the
    ///             profile job will be executed. If a JobSample value is not provided, the default value
    ///             will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the
    ///             size parameter.</p>
    public let jobSample: JobSample?
    /// <p>Enables or disables Amazon CloudWatch logging for the job. If logging is enabled,
    ///             CloudWatch writes one log stream for each job run.</p>
    public let logSubscription: LogSubscription?
    /// <p>The maximum number of nodes that DataBrew can use when the job processes data.</p>
    public let maxCapacity: Int
    /// <p>The maximum number of times to retry the job after a job run fails.</p>
    public let maxRetries: Int
    /// <p>The name of the job to be created. Valid characters are alphanumeric (A-Z, a-z, 0-9),
    ///             hyphen (-), period (.), and space.</p>
    public let name: String?
    /// <p>Represents an Amazon S3 location (bucket name and object key) where DataBrew can read
    ///             input data, or write output from a job.</p>
    public let outputLocation: S3Location?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role to
    ///             be assumed when DataBrew runs the job.</p>
    public let roleArn: String?
    /// <p>Metadata tags to apply to this job.</p>
    public let tags: [String:String]?
    /// <p>The job's timeout in minutes. A job that attempts to run longer than this timeout
    ///             period ends with a status of <code>TIMEOUT</code>.</p>
    public let timeout: Int

    public init (
        datasetName: String? = nil,
        encryptionKeyArn: String? = nil,
        encryptionMode: EncryptionMode? = nil,
        jobSample: JobSample? = nil,
        logSubscription: LogSubscription? = nil,
        maxCapacity: Int = 0,
        maxRetries: Int = 0,
        name: String? = nil,
        outputLocation: S3Location? = nil,
        roleArn: String? = nil,
        tags: [String:String]? = nil,
        timeout: Int = 0
    )
    {
        self.datasetName = datasetName
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionMode = encryptionMode
        self.jobSample = jobSample
        self.logSubscription = logSubscription
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.outputLocation = outputLocation
        self.roleArn = roleArn
        self.tags = tags
        self.timeout = timeout
    }
}

struct CreateProfileJobInputBody: Equatable {
    public let datasetName: String?
    public let encryptionKeyArn: String?
    public let encryptionMode: EncryptionMode?
    public let name: String?
    public let logSubscription: LogSubscription?
    public let maxCapacity: Int
    public let maxRetries: Int
    public let outputLocation: S3Location?
    public let roleArn: String?
    public let tags: [String:String]?
    public let timeout: Int
    public let jobSample: JobSample?
}

extension CreateProfileJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetName = "DatasetName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case jobSample = "JobSample"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case timeout = "Timeout"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(EncryptionMode.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let maxCapacityDecoded = try containerValues.decode(Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let maxRetriesDecoded = try containerValues.decode(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let timeoutDecoded = try containerValues.decode(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let jobSampleDecoded = try containerValues.decodeIfPresent(JobSample.self, forKey: .jobSample)
        jobSample = jobSampleDecoded
    }
}

extension CreateProfileJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProfileJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProfileJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProfileJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProfileJobOutputResponse(name: \(String(describing: name)))"}
}

extension CreateProfileJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProfileJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateProfileJobOutputResponse: Equatable {
    /// <p>The name of the job that was created.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateProfileJobOutputResponseBody: Equatable {
    public let name: String?
}

extension CreateProfileJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateProjectInputBodyMiddleware: Middleware {
    public let id: String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectInput(datasetName: \(String(describing: datasetName)), name: \(String(describing: name)), recipeName: \(String(describing: recipeName)), roleArn: \(String(describing: roleArn)), sample: \(String(describing: sample)), tags: \(String(describing: tags)))"}
}

extension CreateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetName = "DatasetName"
        case name = "Name"
        case recipeName = "RecipeName"
        case roleArn = "RoleArn"
        case sample = "Sample"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeName = recipeName {
            try encodeContainer.encode(recipeName, forKey: .recipeName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sample = sample {
            try encodeContainer.encode(sample, forKey: .sample)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInput: Equatable {
    /// <p>The name of an existing dataset to associate this project with.</p>
    public let datasetName: String?
    /// <p>A unique name for the new project. Valid characters are alphanumeric (A-Z, a-z, 0-9),
    ///             hyphen (-), period (.), and space.</p>
    public let name: String?
    /// <p>The name of an existing recipe to associate with the project.</p>
    public let recipeName: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role to
    ///             be assumed for this request.</p>
    public let roleArn: String?
    /// <p>Represents the sample size and sampling type for DataBrew to use for interactive data
    ///             analysis.</p>
    public let sample: Sample?
    /// <p>Metadata tags to apply to this project.</p>
    public let tags: [String:String]?

    public init (
        datasetName: String? = nil,
        name: String? = nil,
        recipeName: String? = nil,
        roleArn: String? = nil,
        sample: Sample? = nil,
        tags: [String:String]? = nil
    )
    {
        self.datasetName = datasetName
        self.name = name
        self.recipeName = recipeName
        self.roleArn = roleArn
        self.sample = sample
        self.tags = tags
    }
}

struct CreateProjectInputBody: Equatable {
    public let datasetName: String?
    public let name: String?
    public let recipeName: String?
    public let sample: Sample?
    public let roleArn: String?
    public let tags: [String:String]?
}

extension CreateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetName = "DatasetName"
        case name = "Name"
        case recipeName = "RecipeName"
        case roleArn = "RoleArn"
        case sample = "Sample"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let recipeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeName)
        recipeName = recipeNameDecoded
        let sampleDecoded = try containerValues.decodeIfPresent(Sample.self, forKey: .sample)
        sample = sampleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectOutputResponse(name: \(String(describing: name)))"}
}

extension CreateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateProjectOutputResponse: Equatable {
    /// <p>The name of the project that you created.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateProjectOutputResponseBody: Equatable {
    public let name: String?
}

extension CreateProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateRecipeInputBodyMiddleware: Middleware {
    public let id: String = "CreateRecipeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRecipeInput>
    public typealias MOutput = OperationOutput<CreateRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRecipeOutputError>
}

extension CreateRecipeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRecipeInput(description: \(String(describing: description)), name: \(String(describing: name)), steps: \(String(describing: steps)), tags: \(String(describing: tags)))"}
}

extension CreateRecipeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case steps = "Steps"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for recipesteplist0 in steps {
                try stepsContainer.encode(recipesteplist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRecipeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRecipeInput>
    public typealias MOutput = OperationOutput<CreateRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRecipeOutputError>
}

public struct CreateRecipeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRecipeInput>
    public typealias MOutput = OperationOutput<CreateRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRecipeOutputError>
}

public struct CreateRecipeInput: Equatable {
    /// <p>A description for the recipe.</p>
    public let description: String?
    /// <p>A unique name for the recipe. Valid characters are alphanumeric (A-Z, a-z, 0-9),
    ///             hyphen (-), period (.), and space.</p>
    public let name: String?
    /// <p>An array containing the steps to be performed by the recipe. Each recipe step consists
    ///             of one recipe action and (optionally) an array of condition expressions.</p>
    public let steps: [RecipeStep]?
    /// <p>Metadata tags to apply to this recipe.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        name: String? = nil,
        steps: [RecipeStep]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.steps = steps
        self.tags = tags
    }
}

struct CreateRecipeInputBody: Equatable {
    public let description: String?
    public let name: String?
    public let steps: [RecipeStep]?
    public let tags: [String:String]?
}

extension CreateRecipeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case steps = "Steps"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stepsContainer = try containerValues.decodeIfPresent([RecipeStep?].self, forKey: .steps)
        var stepsDecoded0:[RecipeStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [RecipeStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateRecipeJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateRecipeJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRecipeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRecipeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRecipeJobInput>
    public typealias MOutput = OperationOutput<CreateRecipeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRecipeJobOutputError>
}

extension CreateRecipeJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRecipeJobInput(datasetName: \(String(describing: datasetName)), encryptionKeyArn: \(String(describing: encryptionKeyArn)), encryptionMode: \(String(describing: encryptionMode)), logSubscription: \(String(describing: logSubscription)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), name: \(String(describing: name)), outputs: \(String(describing: outputs)), projectName: \(String(describing: projectName)), recipeReference: \(String(describing: recipeReference)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)), timeout: \(String(describing: timeout)))"}
}

extension CreateRecipeJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetName = "DatasetName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case outputs = "Outputs"
        case projectName = "ProjectName"
        case recipeReference = "RecipeReference"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let logSubscription = logSubscription {
            try encodeContainer.encode(logSubscription.rawValue, forKey: .logSubscription)
        }
        if maxCapacity != 0 {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if maxRetries != 0 {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for outputlist0 in outputs {
                try outputsContainer.encode(outputlist0)
            }
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let recipeReference = recipeReference {
            try encodeContainer.encode(recipeReference, forKey: .recipeReference)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }
}

public struct CreateRecipeJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRecipeJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRecipeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRecipeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRecipeJobInput>
    public typealias MOutput = OperationOutput<CreateRecipeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRecipeJobOutputError>
}

public struct CreateRecipeJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRecipeJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRecipeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRecipeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRecipeJobInput>
    public typealias MOutput = OperationOutput<CreateRecipeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRecipeJobOutputError>
}

public struct CreateRecipeJobInput: Equatable {
    /// <p>The name of the dataset that this job processes.</p>
    public let datasetName: String?
    /// <p>The Amazon Resource Name (ARN) of an encryption key that is used to protect the
    ///             job.</p>
    public let encryptionKeyArn: String?
    /// <p>The encryption mode for the job, which can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>SSE-KMS</code> - Server-side encryption with keys managed by AWS
    ///                     KMS.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SSE-S3</code> - Server-side encryption with keys managed by Amazon
    ///                     S3.</p>
    ///             </li>
    ///          </ul>
    public let encryptionMode: EncryptionMode?
    /// <p>Enables or disables Amazon CloudWatch logging for the job. If logging is enabled,
    ///             CloudWatch writes one log stream for each job run.</p>
    public let logSubscription: LogSubscription?
    /// <p>The maximum number of nodes that DataBrew can consume when the job processes
    ///             data.</p>
    public let maxCapacity: Int
    /// <p>The maximum number of times to retry the job after a job run fails.</p>
    public let maxRetries: Int
    /// <p>A unique name for the job. Valid characters are alphanumeric (A-Z, a-z, 0-9), hyphen
    ///             (-), period (.), and space.</p>
    public let name: String?
    /// <p>One or more artifacts that represent the output from running the job.</p>
    public let outputs: [Output]?
    /// <p>Either the name of an existing project, or a combination of a recipe and a dataset to
    ///             associate with the recipe.</p>
    public let projectName: String?
    /// <p>Represents the name and version of a DataBrew recipe.</p>
    public let recipeReference: RecipeReference?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role to
    ///             be assumed when DataBrew runs the job.</p>
    public let roleArn: String?
    /// <p>Metadata tags to apply to this job.</p>
    public let tags: [String:String]?
    /// <p>The job's timeout in minutes. A job that attempts to run longer than this timeout
    ///             period ends with a status of <code>TIMEOUT</code>.</p>
    public let timeout: Int

    public init (
        datasetName: String? = nil,
        encryptionKeyArn: String? = nil,
        encryptionMode: EncryptionMode? = nil,
        logSubscription: LogSubscription? = nil,
        maxCapacity: Int = 0,
        maxRetries: Int = 0,
        name: String? = nil,
        outputs: [Output]? = nil,
        projectName: String? = nil,
        recipeReference: RecipeReference? = nil,
        roleArn: String? = nil,
        tags: [String:String]? = nil,
        timeout: Int = 0
    )
    {
        self.datasetName = datasetName
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionMode = encryptionMode
        self.logSubscription = logSubscription
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.outputs = outputs
        self.projectName = projectName
        self.recipeReference = recipeReference
        self.roleArn = roleArn
        self.tags = tags
        self.timeout = timeout
    }
}

struct CreateRecipeJobInputBody: Equatable {
    public let datasetName: String?
    public let encryptionKeyArn: String?
    public let encryptionMode: EncryptionMode?
    public let name: String?
    public let logSubscription: LogSubscription?
    public let maxCapacity: Int
    public let maxRetries: Int
    public let outputs: [Output]?
    public let projectName: String?
    public let recipeReference: RecipeReference?
    public let roleArn: String?
    public let tags: [String:String]?
    public let timeout: Int
}

extension CreateRecipeJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetName = "DatasetName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case outputs = "Outputs"
        case projectName = "ProjectName"
        case recipeReference = "RecipeReference"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case timeout = "Timeout"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(EncryptionMode.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let maxCapacityDecoded = try containerValues.decode(Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let maxRetriesDecoded = try containerValues.decode(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let outputsContainer = try containerValues.decodeIfPresent([Output?].self, forKey: .outputs)
        var outputsDecoded0:[Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let recipeReferenceDecoded = try containerValues.decodeIfPresent(RecipeReference.self, forKey: .recipeReference)
        recipeReference = recipeReferenceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let timeoutDecoded = try containerValues.decode(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension CreateRecipeJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRecipeJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRecipeJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRecipeJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRecipeJobOutputResponse(name: \(String(describing: name)))"}
}

extension CreateRecipeJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRecipeJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateRecipeJobOutputResponse: Equatable {
    /// <p>The name of the job that you created.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateRecipeJobOutputResponseBody: Equatable {
    public let name: String?
}

extension CreateRecipeJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateRecipeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRecipeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRecipeOutputError: Equatable {
    case conflictException(ConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRecipeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRecipeOutputResponse(name: \(String(describing: name)))"}
}

extension CreateRecipeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRecipeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateRecipeOutputResponse: Equatable {
    /// <p>The name of the recipe that you created.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateRecipeOutputResponseBody: Equatable {
    public let name: String?
}

extension CreateRecipeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateScheduleInputBodyMiddleware: Middleware {
    public let id: String = "CreateScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScheduleInput>
    public typealias MOutput = OperationOutput<CreateScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScheduleOutputError>
}

extension CreateScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateScheduleInput(cronExpression: \(String(describing: cronExpression)), jobNames: \(String(describing: jobNames)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cronExpression = "CronExpression"
        case jobNames = "JobNames"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cronExpression = cronExpression {
            try encodeContainer.encode(cronExpression, forKey: .cronExpression)
        }
        if let jobNames = jobNames {
            var jobNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobNames)
            for jobnamelist0 in jobNames {
                try jobNamesContainer.encode(jobnamelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScheduleInput>
    public typealias MOutput = OperationOutput<CreateScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScheduleOutputError>
}

public struct CreateScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateScheduleInput>
    public typealias MOutput = OperationOutput<CreateScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateScheduleOutputError>
}

public struct CreateScheduleInput: Equatable {
    /// <p>The date or dates and time or times when the jobs are to be run. For more information,
    ///             see <a href="https://docs.aws.amazon.com/databrew/latest/dg/jobs.cron.html">Cron
    ///                 expressions</a> in the <i>AWS Glue DataBrew Developer
    ///             Guide</i>.</p>
    public let cronExpression: String?
    /// <p>The name or names of one or more jobs to be run.</p>
    public let jobNames: [String]?
    /// <p>A unique name for the schedule. Valid characters are alphanumeric (A-Z, a-z, 0-9),
    ///             hyphen (-), period (.), and space.</p>
    public let name: String?
    /// <p>Metadata tags to apply to this schedule.</p>
    public let tags: [String:String]?

    public init (
        cronExpression: String? = nil,
        jobNames: [String]? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.cronExpression = cronExpression
        self.jobNames = jobNames
        self.name = name
        self.tags = tags
    }
}

struct CreateScheduleInputBody: Equatable {
    public let jobNames: [String]?
    public let cronExpression: String?
    public let tags: [String:String]?
    public let name: String?
}

extension CreateScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cronExpression = "CronExpression"
        case jobNames = "JobNames"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .jobNames)
        var jobNamesDecoded0:[String]? = nil
        if let jobNamesContainer = jobNamesContainer {
            jobNamesDecoded0 = [String]()
            for string0 in jobNamesContainer {
                if let string0 = string0 {
                    jobNamesDecoded0?.append(string0)
                }
            }
        }
        jobNames = jobNamesDecoded0
        let cronExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cronExpression)
        cronExpression = cronExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateScheduleOutputError: Equatable {
    case conflictException(ConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateScheduleOutputResponse(name: \(String(describing: name)))"}
}

extension CreateScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateScheduleOutputResponse: Equatable {
    /// <p>The name of the schedule that was created.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateScheduleOutputResponseBody: Equatable {
    public let name: String?
}

extension CreateScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CsvOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case delimiter = "Delimiter"
        case headerRow = "HeaderRow"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delimiter = delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let headerRow = headerRow {
            try encodeContainer.encode(headerRow, forKey: .headerRow)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let headerRowDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .headerRow)
        headerRow = headerRowDecoded
    }
}

extension CsvOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CsvOptions(delimiter: \(String(describing: delimiter)), headerRow: \(String(describing: headerRow)))"}
}

/// <p>Represents a set of options that define how DataBrew will read a comma-separated value (CSV) file when creating a dataset from that file.</p>
public struct CsvOptions: Equatable {
    /// <p>A single character that specifies the delimiter being used in the CSV file.</p>
    public let delimiter: String?
    /// <p>A variable that specifies whether the first row in the file is parsed as the
    ///             header. If this value is false, column names are auto-generated.</p>
    public let headerRow: Bool?

    public init (
        delimiter: String? = nil,
        headerRow: Bool? = nil
    )
    {
        self.delimiter = delimiter
        self.headerRow = headerRow
    }
}

extension CsvOutputOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case delimiter = "Delimiter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delimiter = delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
    }
}

extension CsvOutputOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CsvOutputOptions(delimiter: \(String(describing: delimiter)))"}
}

/// <p>Represents a set of options that define how DataBrew will write a comma-separated value (CSV) file.</p>
public struct CsvOutputOptions: Equatable {
    /// <p>A single character that specifies the delimiter used to create CSV job output.</p>
    public let delimiter: String?

    public init (
        delimiter: String? = nil
    )
    {
        self.delimiter = delimiter
    }
}

extension DataCatalogInputDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogId = "CatalogId"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
        case tempDirectory = "TempDirectory"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogId = catalogId {
            try encodeContainer.encode(catalogId, forKey: .catalogId)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tempDirectory = tempDirectory {
            try encodeContainer.encode(tempDirectory, forKey: .tempDirectory)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogId)
        catalogId = catalogIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let tempDirectoryDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .tempDirectory)
        tempDirectory = tempDirectoryDecoded
    }
}

extension DataCatalogInputDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataCatalogInputDefinition(catalogId: \(String(describing: catalogId)), databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)), tempDirectory: \(String(describing: tempDirectory)))"}
}

/// <p>Represents how metadata stored in the AWS Glue Data Catalog is defined in a DataBrew
///             dataset. </p>
public struct DataCatalogInputDefinition: Equatable {
    /// <p>The unique identifier of the AWS account that holds the Data Catalog that stores the
    ///             data.</p>
    public let catalogId: String?
    /// <p>The name of a database in the Data Catalog.</p>
    public let databaseName: String?
    /// <p>The name of a database table in the Data Catalog. This table corresponds to a DataBrew
    ///             dataset.</p>
    public let tableName: String?
    /// <p>An Amazon location that AWS Glue Data Catalog can use as a temporary directory.</p>
    public let tempDirectory: S3Location?

    public init (
        catalogId: String? = nil,
        databaseName: String? = nil,
        tableName: String? = nil,
        tempDirectory: S3Location? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.tempDirectory = tempDirectory
    }
}

extension DatabaseInputDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseTableName = "DatabaseTableName"
        case glueConnectionName = "GlueConnectionName"
        case tempDirectory = "TempDirectory"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseTableName = databaseTableName {
            try encodeContainer.encode(databaseTableName, forKey: .databaseTableName)
        }
        if let glueConnectionName = glueConnectionName {
            try encodeContainer.encode(glueConnectionName, forKey: .glueConnectionName)
        }
        if let tempDirectory = tempDirectory {
            try encodeContainer.encode(tempDirectory, forKey: .tempDirectory)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glueConnectionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .glueConnectionName)
        glueConnectionName = glueConnectionNameDecoded
        let databaseTableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseTableName)
        databaseTableName = databaseTableNameDecoded
        let tempDirectoryDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .tempDirectory)
        tempDirectory = tempDirectoryDecoded
    }
}

extension DatabaseInputDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatabaseInputDefinition(databaseTableName: \(String(describing: databaseTableName)), glueConnectionName: \(String(describing: glueConnectionName)), tempDirectory: \(String(describing: tempDirectory)))"}
}

/// <p>Connection information for dataset input files stored in a database.</p>
public struct DatabaseInputDefinition: Equatable {
    /// <p>The table within the target database.</p>
    public let databaseTableName: String?
    /// <p>The AWS Glue Connection that stores the connection information for the target
    ///             database.</p>
    public let glueConnectionName: String?
    /// <p>Represents an Amazon S3 location (bucket name and object key) where DataBrew can read
    ///             input data, or write output from a job.</p>
    public let tempDirectory: S3Location?

    public init (
        databaseTableName: String? = nil,
        glueConnectionName: String? = nil,
        tempDirectory: S3Location? = nil
    )
    {
        self.databaseTableName = databaseTableName
        self.glueConnectionName = glueConnectionName
        self.tempDirectory = tempDirectory
    }
}

extension Dataset: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case format = "Format"
        case formatOptions = "FormatOptions"
        case input = "Input"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case pathOptions = "PathOptions"
        case resourceArn = "ResourceArn"
        case source = "Source"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let formatOptions = formatOptions {
            try encodeContainer.encode(formatOptions, forKey: .formatOptions)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pathOptions = pathOptions {
            try encodeContainer.encode(pathOptions, forKey: .pathOptions)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let source = source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(InputFormat.self, forKey: .format)
        format = formatDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(FormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Input.self, forKey: .input)
        input = inputDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .source)
        source = sourceDecoded
        let pathOptionsDecoded = try containerValues.decodeIfPresent(PathOptions.self, forKey: .pathOptions)
        pathOptions = pathOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension Dataset: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Dataset(accountId: \(String(describing: accountId)), createDate: \(String(describing: createDate)), createdBy: \(String(describing: createdBy)), format: \(String(describing: format)), formatOptions: \(String(describing: formatOptions)), input: \(String(describing: input)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), pathOptions: \(String(describing: pathOptions)), resourceArn: \(String(describing: resourceArn)), source: \(String(describing: source)), tags: \(String(describing: tags)))"}
}

/// <p>Represents a dataset that can be processed by DataBrew.</p>
public struct Dataset: Equatable {
    /// <p>The ID of the AWS account that owns the dataset.</p>
    public let accountId: String?
    /// <p>The date and time that the dataset was created.</p>
    public let createDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the user who created the dataset.</p>
    public let createdBy: String?
    /// <p>The file format of a dataset that is created from an S3 file or folder.</p>
    public let format: InputFormat?
    /// <p>A set of options that define how DataBrew interprets the data in the dataset.</p>
    public let formatOptions: FormatOptions?
    /// <p>Information on how DataBrew can find the dataset, in either the AWS Glue Data Catalog
    ///             or Amazon S3.</p>
    public let input: Input?
    /// <p>The Amazon Resource Name (ARN) of the user who last modified the dataset.</p>
    public let lastModifiedBy: String?
    /// <p>The last modification date and time of the dataset.</p>
    public let lastModifiedDate: Date?
    /// <p>The unique name of the dataset.</p>
    public let name: String?
    /// <p>A set of options that defines how DataBrew interprets an S3 path of the dataset.</p>
    public let pathOptions: PathOptions?
    /// <p>The unique Amazon Resource Name (ARN) for the dataset.</p>
    public let resourceArn: String?
    /// <p>The location of the data for the dataset, either Amazon S3 or the AWS Glue Data
    ///             Catalog.</p>
    public let source: Source?
    /// <p>Metadata tags that have been applied to the dataset.</p>
    public let tags: [String:String]?

    public init (
        accountId: String? = nil,
        createDate: Date? = nil,
        createdBy: String? = nil,
        format: InputFormat? = nil,
        formatOptions: FormatOptions? = nil,
        input: Input? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedDate: Date? = nil,
        name: String? = nil,
        pathOptions: PathOptions? = nil,
        resourceArn: String? = nil,
        source: Source? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accountId = accountId
        self.createDate = createDate
        self.createdBy = createdBy
        self.format = format
        self.formatOptions = formatOptions
        self.input = input
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.pathOptions = pathOptions
        self.resourceArn = resourceArn
        self.source = source
        self.tags = tags
    }
}

extension DatasetParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createColumn = "CreateColumn"
        case datetimeOptions = "DatetimeOptions"
        case filter = "Filter"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if createColumn != false {
            try encodeContainer.encode(createColumn, forKey: .createColumn)
        }
        if let datetimeOptions = datetimeOptions {
            try encodeContainer.encode(datetimeOptions, forKey: .datetimeOptions)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ParameterType.self, forKey: .type)
        type = typeDecoded
        let datetimeOptionsDecoded = try containerValues.decodeIfPresent(DatetimeOptions.self, forKey: .datetimeOptions)
        datetimeOptions = datetimeOptionsDecoded
        let createColumnDecoded = try containerValues.decode(Bool.self, forKey: .createColumn)
        createColumn = createColumnDecoded
        let filterDecoded = try containerValues.decodeIfPresent(FilterExpression.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension DatasetParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetParameter(createColumn: \(String(describing: createColumn)), datetimeOptions: \(String(describing: datetimeOptions)), filter: \(String(describing: filter)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Represents a dataset paramater that defines type and conditions for a parameter in the S3 path of the dataset.</p>
public struct DatasetParameter: Equatable {
    /// <p>Optional boolean value that defines whether the captured value of this parameter should be loaded as an additional column in the dataset.</p>
    public let createColumn: Bool
    /// <p>Additional parameter options such as a format and a timezone. Required for datetime parameters.</p>
    public let datetimeOptions: DatetimeOptions?
    /// <p>The optional filter expression structure to apply additional matching criteria to the parameter.</p>
    public let filter: FilterExpression?
    /// <p>The name of the parameter that is used in the dataset's S3 path.</p>
    public let name: String?
    /// <p>The type of the dataset parameter, can be one of a 'String', 'Number' or 'Datetime'.</p>
    public let type: ParameterType?

    public init (
        createColumn: Bool = false,
        datetimeOptions: DatetimeOptions? = nil,
        filter: FilterExpression? = nil,
        name: String? = nil,
        type: ParameterType? = nil
    )
    {
        self.createColumn = createColumn
        self.datetimeOptions = datetimeOptions
        self.filter = filter
        self.name = name
        self.type = type
    }
}

extension DatetimeOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case format = "Format"
        case localeCode = "LocaleCode"
        case timezoneOffset = "TimezoneOffset"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let localeCode = localeCode {
            try encodeContainer.encode(localeCode, forKey: .localeCode)
        }
        if let timezoneOffset = timezoneOffset {
            try encodeContainer.encode(timezoneOffset, forKey: .timezoneOffset)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .format)
        format = formatDecoded
        let timezoneOffsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezoneOffset)
        timezoneOffset = timezoneOffsetDecoded
        let localeCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localeCode)
        localeCode = localeCodeDecoded
    }
}

extension DatetimeOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatetimeOptions(format: \(String(describing: format)), localeCode: \(String(describing: localeCode)), timezoneOffset: \(String(describing: timezoneOffset)))"}
}

/// <p>Represents additional options for correct interpretation of datetime parameters used in the S3 path of a dataset.</p>
public struct DatetimeOptions: Equatable {
    /// <p>Required option, that defines the datetime format used for a date parameter in the S3 path. Should use only supported datetime specifiers and separation characters, all
    ///             litera a-z or A-Z character should be escaped with single quotes. E.g. "MM.dd.yyyy-'at'-HH:mm".</p>
    public let format: String?
    /// <p>Optional value for a non-US locale code, needed for correct interpretation of some date formats.</p>
    public let localeCode: String?
    /// <p>Optional value for a timezone offset of the datetime parameter value in the S3 path. Shouldn't be used if Format for this parameter includes timezone fields.
    ///             If no offset specified, UTC is assumed.</p>
    public let timezoneOffset: String?

    public init (
        format: String? = nil,
        localeCode: String? = nil,
        timezoneOffset: String? = nil
    )
    {
        self.format = format
        self.localeCode = localeCode
        self.timezoneOffset = timezoneOffset
    }
}

extension DeleteDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetInput(name: \(String(describing: name)))"}
}

extension DeleteDatasetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInput: Equatable {
    /// <p>The name of the dataset to be deleted.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDatasetInputBody: Equatable {
}

extension DeleteDatasetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetOutputResponse(name: \(String(describing: name)))"}
}

extension DeleteDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct DeleteDatasetOutputResponse: Equatable {
    /// <p>The name of the dataset that you deleted.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDatasetOutputResponseBody: Equatable {
    public let name: String?
}

extension DeleteDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobInput(name: \(String(describing: name)))"}
}

extension DeleteJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteJobInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobInput>
    public typealias MOutput = OperationOutput<DeleteJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobOutputError>
}

public struct DeleteJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobInput>
    public typealias MOutput = OperationOutput<DeleteJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobOutputError>
}

public struct DeleteJobInput: Equatable {
    /// <p>The name of the job to be deleted.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteJobInputBody: Equatable {
}

extension DeleteJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteJobOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobOutputResponse(name: \(String(describing: name)))"}
}

extension DeleteJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct DeleteJobOutputResponse: Equatable {
    /// <p>The name of the job that you deleted.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteJobOutputResponseBody: Equatable {
    public let name: String?
}

extension DeleteJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectInput(name: \(String(describing: name)))"}
}

extension DeleteProjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInput: Equatable {
    /// <p>The name of the project to be deleted.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteProjectInputBody: Equatable {
}

extension DeleteProjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectOutputResponse(name: \(String(describing: name)))"}
}

extension DeleteProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct DeleteProjectOutputResponse: Equatable {
    /// <p>The name of the project that you deleted.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteProjectOutputResponseBody: Equatable {
    public let name: String?
}

extension DeleteProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteRecipeVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRecipeVersionInput(name: \(String(describing: name)), recipeVersion: \(String(describing: recipeVersion)))"}
}

extension DeleteRecipeVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRecipeVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRecipeVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRecipeVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRecipeVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRecipeVersionInput>
    public typealias MOutput = OperationOutput<DeleteRecipeVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRecipeVersionOutputError>
}

public struct DeleteRecipeVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRecipeVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRecipeVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRecipeVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRecipeVersionInput>
    public typealias MOutput = OperationOutput<DeleteRecipeVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRecipeVersionOutputError>
}

public struct DeleteRecipeVersionInput: Equatable {
    /// <p>The name of the recipe.</p>
    public let name: String?
    /// <p>The version of the recipe to be deleted. You can specify a numeric versions
    ///                 (<code>X.Y</code>) or <code>LATEST_WORKING</code>. <code>LATEST_PUBLISHED</code> is
    ///             not supported.</p>
    public let recipeVersion: String?

    public init (
        name: String? = nil,
        recipeVersion: String? = nil
    )
    {
        self.name = name
        self.recipeVersion = recipeVersion
    }
}

struct DeleteRecipeVersionInputBody: Equatable {
}

extension DeleteRecipeVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRecipeVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecipeVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecipeVersionOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecipeVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRecipeVersionOutputResponse(name: \(String(describing: name)), recipeVersion: \(String(describing: recipeVersion)))"}
}

extension DeleteRecipeVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRecipeVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
            self.recipeVersion = output.recipeVersion
        } else {
            self.name = nil
            self.recipeVersion = nil
        }
    }
}

public struct DeleteRecipeVersionOutputResponse: Equatable {
    /// <p>The name of the recipe that was deleted.</p>
    public let name: String?
    /// <p>The version of the recipe that was deleted.</p>
    public let recipeVersion: String?

    public init (
        name: String? = nil,
        recipeVersion: String? = nil
    )
    {
        self.name = name
        self.recipeVersion = recipeVersion
    }
}

struct DeleteRecipeVersionOutputResponseBody: Equatable {
    public let name: String?
    public let recipeVersion: String?
}

extension DeleteRecipeVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case recipeVersion = "RecipeVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let recipeVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeVersion)
        recipeVersion = recipeVersionDecoded
    }
}

extension DeleteScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteScheduleInput(name: \(String(describing: name)))"}
}

extension DeleteScheduleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteScheduleInput>
    public typealias MOutput = OperationOutput<DeleteScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteScheduleOutputError>
}

public struct DeleteScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteScheduleInput>
    public typealias MOutput = OperationOutput<DeleteScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteScheduleOutputError>
}

public struct DeleteScheduleInput: Equatable {
    /// <p>The name of the schedule to be deleted.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteScheduleInputBody: Equatable {
}

extension DeleteScheduleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteScheduleOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteScheduleOutputResponse(name: \(String(describing: name)))"}
}

extension DeleteScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct DeleteScheduleOutputResponse: Equatable {
    /// <p>The name of the schedule that was deleted.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteScheduleOutputResponseBody: Equatable {
    public let name: String?
}

extension DeleteScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetInput(name: \(String(describing: name)))"}
}

extension DescribeDatasetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInput: Equatable {
    /// <p>The name of the dataset to be described.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeDatasetInputBody: Equatable {
}

extension DescribeDatasetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetOutputResponse(createDate: \(String(describing: createDate)), createdBy: \(String(describing: createdBy)), format: \(String(describing: format)), formatOptions: \(String(describing: formatOptions)), input: \(String(describing: input)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), pathOptions: \(String(describing: pathOptions)), resourceArn: \(String(describing: resourceArn)), source: \(String(describing: source)), tags: \(String(describing: tags)))"}
}

extension DescribeDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createDate = output.createDate
            self.createdBy = output.createdBy
            self.format = output.format
            self.formatOptions = output.formatOptions
            self.input = output.input
            self.lastModifiedBy = output.lastModifiedBy
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.pathOptions = output.pathOptions
            self.resourceArn = output.resourceArn
            self.source = output.source
            self.tags = output.tags
        } else {
            self.createDate = nil
            self.createdBy = nil
            self.format = nil
            self.formatOptions = nil
            self.input = nil
            self.lastModifiedBy = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.pathOptions = nil
            self.resourceArn = nil
            self.source = nil
            self.tags = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Equatable {
    /// <p>The date and time that the dataset was created.</p>
    public let createDate: Date?
    /// <p>The identifier (user name) of the user who created the dataset.</p>
    public let createdBy: String?
    /// <p>The file format of a dataset that is created from an S3 file or folder.</p>
    public let format: InputFormat?
    /// <p>Represents a set of options that define the structure of either comma-separated value (CSV), Excel, or JSON input.</p>
    public let formatOptions: FormatOptions?
    /// <p>Represents information on how DataBrew can find data, in either the AWS Glue Data Catalog or
    ///             Amazon S3.</p>
    public let input: Input?
    /// <p>The identifier (user name) of the user who last modified the dataset.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time that the dataset was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The name of the dataset.</p>
    public let name: String?
    /// <p>A set of options that defines how DataBrew interprets an S3 path of the dataset.</p>
    public let pathOptions: PathOptions?
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    public let resourceArn: String?
    /// <p>The location of the data for this dataset, Amazon S3 or the AWS Glue Data
    ///             Catalog.</p>
    public let source: Source?
    /// <p>Metadata tags associated with this dataset.</p>
    public let tags: [String:String]?

    public init (
        createDate: Date? = nil,
        createdBy: String? = nil,
        format: InputFormat? = nil,
        formatOptions: FormatOptions? = nil,
        input: Input? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedDate: Date? = nil,
        name: String? = nil,
        pathOptions: PathOptions? = nil,
        resourceArn: String? = nil,
        source: Source? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createDate = createDate
        self.createdBy = createdBy
        self.format = format
        self.formatOptions = formatOptions
        self.input = input
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.pathOptions = pathOptions
        self.resourceArn = resourceArn
        self.source = source
        self.tags = tags
    }
}

struct DescribeDatasetOutputResponseBody: Equatable {
    public let createdBy: String?
    public let createDate: Date?
    public let name: String?
    public let format: InputFormat?
    public let formatOptions: FormatOptions?
    public let input: Input?
    public let lastModifiedDate: Date?
    public let lastModifiedBy: String?
    public let source: Source?
    public let pathOptions: PathOptions?
    public let tags: [String:String]?
    public let resourceArn: String?
}

extension DescribeDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case format = "Format"
        case formatOptions = "FormatOptions"
        case input = "Input"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case pathOptions = "PathOptions"
        case resourceArn = "ResourceArn"
        case source = "Source"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(InputFormat.self, forKey: .format)
        format = formatDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(FormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Input.self, forKey: .input)
        input = inputDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .source)
        source = sourceDecoded
        let pathOptionsDecoded = try containerValues.decodeIfPresent(PathOptions.self, forKey: .pathOptions)
        pathOptions = pathOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DescribeJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobInput(name: \(String(describing: name)))"}
}

extension DescribeJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobInput>
    public typealias MOutput = OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobOutputError>
}

public struct DescribeJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobInput>
    public typealias MOutput = OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobOutputError>
}

public struct DescribeJobInput: Equatable {
    /// <p>The name of the job to be described.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeJobInputBody: Equatable {
}

extension DescribeJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobOutputResponse(createDate: \(String(describing: createDate)), createdBy: \(String(describing: createdBy)), datasetName: \(String(describing: datasetName)), encryptionKeyArn: \(String(describing: encryptionKeyArn)), encryptionMode: \(String(describing: encryptionMode)), jobSample: \(String(describing: jobSample)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), logSubscription: \(String(describing: logSubscription)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), name: \(String(describing: name)), outputs: \(String(describing: outputs)), projectName: \(String(describing: projectName)), recipeReference: \(String(describing: recipeReference)), resourceArn: \(String(describing: resourceArn)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)), timeout: \(String(describing: timeout)), type: \(String(describing: type)))"}
}

extension DescribeJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createDate = output.createDate
            self.createdBy = output.createdBy
            self.datasetName = output.datasetName
            self.encryptionKeyArn = output.encryptionKeyArn
            self.encryptionMode = output.encryptionMode
            self.jobSample = output.jobSample
            self.lastModifiedBy = output.lastModifiedBy
            self.lastModifiedDate = output.lastModifiedDate
            self.logSubscription = output.logSubscription
            self.maxCapacity = output.maxCapacity
            self.maxRetries = output.maxRetries
            self.name = output.name
            self.outputs = output.outputs
            self.projectName = output.projectName
            self.recipeReference = output.recipeReference
            self.resourceArn = output.resourceArn
            self.roleArn = output.roleArn
            self.tags = output.tags
            self.timeout = output.timeout
            self.type = output.type
        } else {
            self.createDate = nil
            self.createdBy = nil
            self.datasetName = nil
            self.encryptionKeyArn = nil
            self.encryptionMode = nil
            self.jobSample = nil
            self.lastModifiedBy = nil
            self.lastModifiedDate = nil
            self.logSubscription = nil
            self.maxCapacity = 0
            self.maxRetries = 0
            self.name = nil
            self.outputs = nil
            self.projectName = nil
            self.recipeReference = nil
            self.resourceArn = nil
            self.roleArn = nil
            self.tags = nil
            self.timeout = 0
            self.type = nil
        }
    }
}

public struct DescribeJobOutputResponse: Equatable {
    /// <p>The date and time that the job was created.</p>
    public let createDate: Date?
    /// <p>The identifier (user name) of the user associated with the creation of the job.</p>
    public let createdBy: String?
    /// <p>The dataset that the job acts upon.</p>
    public let datasetName: String?
    /// <p>The Amazon Resource Name (ARN) of an encryption key that is used to protect the
    ///             job.</p>
    public let encryptionKeyArn: String?
    /// <p>The encryption mode for the job, which can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>SSE-KMS</code> - Server-side encryption with keys managed by AWS
    ///                     KMS.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SSE-S3</code> - Server-side encryption with keys managed by Amazon
    ///                     S3.</p>
    ///             </li>
    ///          </ul>
    public let encryptionMode: EncryptionMode?
    /// <p>Sample configuration for profile jobs only. Determines the number of rows on which the
    ///             profile job will be executed.</p>
    public let jobSample: JobSample?
    /// <p>The identifier (user name) of the user who last modified the job.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time that the job was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>Indicates whether Amazon CloudWatch logging is enabled for this job.</p>
    public let logSubscription: LogSubscription?
    /// <p>The maximum number of compute nodes that DataBrew can consume when the job processes
    ///             data.</p>
    public let maxCapacity: Int
    /// <p>The maximum number of times to retry the job after a job run fails.</p>
    public let maxRetries: Int
    /// <p>The name of the job.</p>
    public let name: String?
    /// <p>One or more artifacts that represent the output from running the job.</p>
    public let outputs: [Output]?
    /// <p>The DataBrew project associated with this job.</p>
    public let projectName: String?
    /// <p>Represents the name and version of a DataBrew recipe.</p>
    public let recipeReference: RecipeReference?
    /// <p>The Amazon Resource Name (ARN) of the job.</p>
    public let resourceArn: String?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role to be assumed when
    ///             DataBrew runs the job.</p>
    public let roleArn: String?
    /// <p>Metadata tags associated with this job.</p>
    public let tags: [String:String]?
    /// <p>The job's timeout in minutes. A job that attempts to run longer than this timeout
    ///             period ends with a status of <code>TIMEOUT</code>.</p>
    public let timeout: Int
    /// <p>The job type, which must be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>PROFILE</code> - The job analyzes the dataset to determine its size,
    ///                     data types, data distribution, and more.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RECIPE</code> - The job applies one or more transformations to a
    ///                     dataset.</p>
    ///             </li>
    ///          </ul>
    public let type: JobType?

    public init (
        createDate: Date? = nil,
        createdBy: String? = nil,
        datasetName: String? = nil,
        encryptionKeyArn: String? = nil,
        encryptionMode: EncryptionMode? = nil,
        jobSample: JobSample? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedDate: Date? = nil,
        logSubscription: LogSubscription? = nil,
        maxCapacity: Int = 0,
        maxRetries: Int = 0,
        name: String? = nil,
        outputs: [Output]? = nil,
        projectName: String? = nil,
        recipeReference: RecipeReference? = nil,
        resourceArn: String? = nil,
        roleArn: String? = nil,
        tags: [String:String]? = nil,
        timeout: Int = 0,
        type: JobType? = nil
    )
    {
        self.createDate = createDate
        self.createdBy = createdBy
        self.datasetName = datasetName
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionMode = encryptionMode
        self.jobSample = jobSample
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.logSubscription = logSubscription
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.outputs = outputs
        self.projectName = projectName
        self.recipeReference = recipeReference
        self.resourceArn = resourceArn
        self.roleArn = roleArn
        self.tags = tags
        self.timeout = timeout
        self.type = type
    }
}

struct DescribeJobOutputResponseBody: Equatable {
    public let createDate: Date?
    public let createdBy: String?
    public let datasetName: String?
    public let encryptionKeyArn: String?
    public let encryptionMode: EncryptionMode?
    public let name: String?
    public let type: JobType?
    public let lastModifiedBy: String?
    public let lastModifiedDate: Date?
    public let logSubscription: LogSubscription?
    public let maxCapacity: Int
    public let maxRetries: Int
    public let outputs: [Output]?
    public let projectName: String?
    public let recipeReference: RecipeReference?
    public let resourceArn: String?
    public let roleArn: String?
    public let tags: [String:String]?
    public let timeout: Int
    public let jobSample: JobSample?
}

extension DescribeJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case datasetName = "DatasetName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case jobSample = "JobSample"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case outputs = "Outputs"
        case projectName = "ProjectName"
        case recipeReference = "RecipeReference"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case timeout = "Timeout"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(EncryptionMode.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .type)
        type = typeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let maxCapacityDecoded = try containerValues.decode(Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let maxRetriesDecoded = try containerValues.decode(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let outputsContainer = try containerValues.decodeIfPresent([Output?].self, forKey: .outputs)
        var outputsDecoded0:[Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let recipeReferenceDecoded = try containerValues.decodeIfPresent(RecipeReference.self, forKey: .recipeReference)
        recipeReference = recipeReferenceDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let timeoutDecoded = try containerValues.decode(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let jobSampleDecoded = try containerValues.decodeIfPresent(JobSample.self, forKey: .jobSample)
        jobSample = jobSampleDecoded
    }
}

extension DescribeJobRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobRunInput(name: \(String(describing: name)), runId: \(String(describing: runId)))"}
}

extension DescribeJobRunInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeJobRunInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJobRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobRunInput>
    public typealias MOutput = OperationOutput<DescribeJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobRunOutputError>
}

public struct DescribeJobRunInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJobRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobRunInput>
    public typealias MOutput = OperationOutput<DescribeJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobRunOutputError>
}

public struct DescribeJobRunInput: Equatable {
    /// <p>The name of the job being processed during this run.</p>
    public let name: String?
    /// <p>The unique identifier of the job run.</p>
    public let runId: String?

    public init (
        name: String? = nil,
        runId: String? = nil
    )
    {
        self.name = name
        self.runId = runId
    }
}

struct DescribeJobRunInputBody: Equatable {
}

extension DescribeJobRunInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJobRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobRunOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobRunOutputResponse(attempt: \(String(describing: attempt)), completedOn: \(String(describing: completedOn)), datasetName: \(String(describing: datasetName)), errorMessage: \(String(describing: errorMessage)), executionTime: \(String(describing: executionTime)), jobName: \(String(describing: jobName)), jobSample: \(String(describing: jobSample)), logGroupName: \(String(describing: logGroupName)), logSubscription: \(String(describing: logSubscription)), outputs: \(String(describing: outputs)), recipeReference: \(String(describing: recipeReference)), runId: \(String(describing: runId)), startedBy: \(String(describing: startedBy)), startedOn: \(String(describing: startedOn)), state: \(String(describing: state)))"}
}

extension DescribeJobRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeJobRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attempt = output.attempt
            self.completedOn = output.completedOn
            self.datasetName = output.datasetName
            self.errorMessage = output.errorMessage
            self.executionTime = output.executionTime
            self.jobName = output.jobName
            self.jobSample = output.jobSample
            self.logGroupName = output.logGroupName
            self.logSubscription = output.logSubscription
            self.outputs = output.outputs
            self.recipeReference = output.recipeReference
            self.runId = output.runId
            self.startedBy = output.startedBy
            self.startedOn = output.startedOn
            self.state = output.state
        } else {
            self.attempt = 0
            self.completedOn = nil
            self.datasetName = nil
            self.errorMessage = nil
            self.executionTime = 0
            self.jobName = nil
            self.jobSample = nil
            self.logGroupName = nil
            self.logSubscription = nil
            self.outputs = nil
            self.recipeReference = nil
            self.runId = nil
            self.startedBy = nil
            self.startedOn = nil
            self.state = nil
        }
    }
}

public struct DescribeJobRunOutputResponse: Equatable {
    /// <p>The number of times that DataBrew has attempted to run the job.</p>
    public let attempt: Int
    /// <p>The date and time when the job completed processing.</p>
    public let completedOn: Date?
    /// <p>The name of the dataset for the job to process.</p>
    public let datasetName: String?
    /// <p>A message indicating an error (if any) that was encountered when the job ran.</p>
    public let errorMessage: String?
    /// <p>The amount of time, in seconds, during which the job run consumed resources.</p>
    public let executionTime: Int
    /// <p>The name of the job being processed during this run.</p>
    public let jobName: String?
    /// <p>Sample configuration for profile jobs only. Determines the number of rows on which the
    ///             profile job will be executed. If a JobSample value is not provided, the default value
    ///             will be used. The default value is CUSTOM_ROWS for the mode parameter and 20000 for the
    ///             size parameter.</p>
    public let jobSample: JobSample?
    /// <p>The name of an Amazon CloudWatch log group, where the job writes diagnostic messages
    ///             when it runs.</p>
    public let logGroupName: String?
    /// <p>The current status of Amazon CloudWatch logging for the job run.</p>
    public let logSubscription: LogSubscription?
    /// <p>One or more output artifacts from a job run.</p>
    public let outputs: [Output]?
    /// <p>Represents the name and version of a DataBrew recipe.</p>
    public let recipeReference: RecipeReference?
    /// <p>The unique identifier of the job run.</p>
    public let runId: String?
    /// <p>The Amazon Resource Name (ARN) of the user who started the job run.</p>
    public let startedBy: String?
    /// <p>The date and time when the job run began.</p>
    public let startedOn: Date?
    /// <p>The current state of the job run entity itself.</p>
    public let state: JobRunState?

    public init (
        attempt: Int = 0,
        completedOn: Date? = nil,
        datasetName: String? = nil,
        errorMessage: String? = nil,
        executionTime: Int = 0,
        jobName: String? = nil,
        jobSample: JobSample? = nil,
        logGroupName: String? = nil,
        logSubscription: LogSubscription? = nil,
        outputs: [Output]? = nil,
        recipeReference: RecipeReference? = nil,
        runId: String? = nil,
        startedBy: String? = nil,
        startedOn: Date? = nil,
        state: JobRunState? = nil
    )
    {
        self.attempt = attempt
        self.completedOn = completedOn
        self.datasetName = datasetName
        self.errorMessage = errorMessage
        self.executionTime = executionTime
        self.jobName = jobName
        self.jobSample = jobSample
        self.logGroupName = logGroupName
        self.logSubscription = logSubscription
        self.outputs = outputs
        self.recipeReference = recipeReference
        self.runId = runId
        self.startedBy = startedBy
        self.startedOn = startedOn
        self.state = state
    }
}

struct DescribeJobRunOutputResponseBody: Equatable {
    public let attempt: Int
    public let completedOn: Date?
    public let datasetName: String?
    public let errorMessage: String?
    public let executionTime: Int
    public let jobName: String?
    public let runId: String?
    public let state: JobRunState?
    public let logSubscription: LogSubscription?
    public let logGroupName: String?
    public let outputs: [Output]?
    public let recipeReference: RecipeReference?
    public let startedBy: String?
    public let startedOn: Date?
    public let jobSample: JobSample?
}

extension DescribeJobRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attempt = "Attempt"
        case completedOn = "CompletedOn"
        case datasetName = "DatasetName"
        case errorMessage = "ErrorMessage"
        case executionTime = "ExecutionTime"
        case jobName = "JobName"
        case jobSample = "JobSample"
        case logGroupName = "LogGroupName"
        case logSubscription = "LogSubscription"
        case outputs = "Outputs"
        case recipeReference = "RecipeReference"
        case runId = "RunId"
        case startedBy = "StartedBy"
        case startedOn = "StartedOn"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attemptDecoded = try containerValues.decode(Int.self, forKey: .attempt)
        attempt = attemptDecoded
        let completedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedOn)
        completedOn = completedOnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let executionTimeDecoded = try containerValues.decode(Int.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(JobRunState.self, forKey: .state)
        state = stateDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([Output?].self, forKey: .outputs)
        var outputsDecoded0:[Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let recipeReferenceDecoded = try containerValues.decodeIfPresent(RecipeReference.self, forKey: .recipeReference)
        recipeReference = recipeReferenceDecoded
        let startedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let startedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedOn)
        startedOn = startedOnDecoded
        let jobSampleDecoded = try containerValues.decodeIfPresent(JobSample.self, forKey: .jobSample)
        jobSample = jobSampleDecoded
    }
}

extension DescribeProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProjectInput(name: \(String(describing: name)))"}
}

extension DescribeProjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInput: Equatable {
    /// <p>The name of the project to be described.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeProjectInputBody: Equatable {
}

extension DescribeProjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProjectOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProjectOutputResponse(createDate: \(String(describing: createDate)), createdBy: \(String(describing: createdBy)), datasetName: \(String(describing: datasetName)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), openDate: \(String(describing: openDate)), openedBy: \(String(describing: openedBy)), recipeName: \(String(describing: recipeName)), resourceArn: \(String(describing: resourceArn)), roleArn: \(String(describing: roleArn)), sample: \(String(describing: sample)), sessionStatus: \(String(describing: sessionStatus)), tags: \(String(describing: tags)))"}
}

extension DescribeProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createDate = output.createDate
            self.createdBy = output.createdBy
            self.datasetName = output.datasetName
            self.lastModifiedBy = output.lastModifiedBy
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.openDate = output.openDate
            self.openedBy = output.openedBy
            self.recipeName = output.recipeName
            self.resourceArn = output.resourceArn
            self.roleArn = output.roleArn
            self.sample = output.sample
            self.sessionStatus = output.sessionStatus
            self.tags = output.tags
        } else {
            self.createDate = nil
            self.createdBy = nil
            self.datasetName = nil
            self.lastModifiedBy = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.openDate = nil
            self.openedBy = nil
            self.recipeName = nil
            self.resourceArn = nil
            self.roleArn = nil
            self.sample = nil
            self.sessionStatus = nil
            self.tags = nil
        }
    }
}

public struct DescribeProjectOutputResponse: Equatable {
    /// <p>The date and time that the project was created.</p>
    public let createDate: Date?
    /// <p>The identifier (user name) of the user who created the project.</p>
    public let createdBy: String?
    /// <p>The dataset associated with the project.</p>
    public let datasetName: String?
    /// <p>The identifier (user name) of the user who last modified the project.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time that the project was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The name of the project.</p>
    public let name: String?
    /// <p>The date and time when the project was opened. </p>
    public let openDate: Date?
    /// <p>The identifier (user name) of the user that opened the project for use. </p>
    public let openedBy: String?
    /// <p>The recipe associated with this job.</p>
    public let recipeName: String?
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    public let resourceArn: String?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role to be assumed when
    ///             DataBrew runs the job.</p>
    public let roleArn: String?
    /// <p>Represents the sample size and sampling type for DataBrew to use for interactive data
    ///             analysis.</p>
    public let sample: Sample?
    /// <p>Describes the current state of the session:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>PROVISIONING</code> - allocating resources for the session.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>INITIALIZING</code> - getting the session ready for first use.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ASSIGNED</code> - the session is ready for use.</p>
    ///             </li>
    ///          </ul>
    public let sessionStatus: SessionStatus?
    /// <p>Metadata tags associated with this project.</p>
    public let tags: [String:String]?

    public init (
        createDate: Date? = nil,
        createdBy: String? = nil,
        datasetName: String? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedDate: Date? = nil,
        name: String? = nil,
        openDate: Date? = nil,
        openedBy: String? = nil,
        recipeName: String? = nil,
        resourceArn: String? = nil,
        roleArn: String? = nil,
        sample: Sample? = nil,
        sessionStatus: SessionStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createDate = createDate
        self.createdBy = createdBy
        self.datasetName = datasetName
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.openDate = openDate
        self.openedBy = openedBy
        self.recipeName = recipeName
        self.resourceArn = resourceArn
        self.roleArn = roleArn
        self.sample = sample
        self.sessionStatus = sessionStatus
        self.tags = tags
    }
}

struct DescribeProjectOutputResponseBody: Equatable {
    public let createDate: Date?
    public let createdBy: String?
    public let datasetName: String?
    public let lastModifiedDate: Date?
    public let lastModifiedBy: String?
    public let name: String?
    public let recipeName: String?
    public let resourceArn: String?
    public let sample: Sample?
    public let roleArn: String?
    public let tags: [String:String]?
    public let sessionStatus: SessionStatus?
    public let openedBy: String?
    public let openDate: Date?
}

extension DescribeProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case datasetName = "DatasetName"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case openDate = "OpenDate"
        case openedBy = "OpenedBy"
        case recipeName = "RecipeName"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case sample = "Sample"
        case sessionStatus = "SessionStatus"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let recipeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeName)
        recipeName = recipeNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let sampleDecoded = try containerValues.decodeIfPresent(Sample.self, forKey: .sample)
        sample = sampleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let sessionStatusDecoded = try containerValues.decodeIfPresent(SessionStatus.self, forKey: .sessionStatus)
        sessionStatus = sessionStatusDecoded
        let openedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .openedBy)
        openedBy = openedByDecoded
        let openDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .openDate)
        openDate = openDateDecoded
    }
}

extension DescribeRecipeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRecipeInput(name: \(String(describing: name)), recipeVersion: \(String(describing: recipeVersion)))"}
}

extension DescribeRecipeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRecipeInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecipeInput>
    public typealias MOutput = OperationOutput<DescribeRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecipeOutputError>
}

public struct DescribeRecipeInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let recipeVersion = input.operationInput.recipeVersion {
            let recipeVersionQueryItem = URLQueryItem(name: "recipeVersion".urlPercentEncoding(), value: String(recipeVersion).urlPercentEncoding())
            input.builder.withQueryItem(recipeVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRecipeInput>
    public typealias MOutput = OperationOutput<DescribeRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRecipeOutputError>
}

public struct DescribeRecipeInput: Equatable {
    /// <p>The name of the recipe to be described.</p>
    public let name: String?
    /// <p>The recipe version identifier. If this parameter isn't specified, then the latest
    ///             published version is returned.</p>
    public let recipeVersion: String?

    public init (
        name: String? = nil,
        recipeVersion: String? = nil
    )
    {
        self.name = name
        self.recipeVersion = recipeVersion
    }
}

struct DescribeRecipeInputBody: Equatable {
}

extension DescribeRecipeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRecipeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecipeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRecipeOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecipeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRecipeOutputResponse(createDate: \(String(describing: createDate)), createdBy: \(String(describing: createdBy)), description: \(String(describing: description)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), projectName: \(String(describing: projectName)), publishedBy: \(String(describing: publishedBy)), publishedDate: \(String(describing: publishedDate)), recipeVersion: \(String(describing: recipeVersion)), resourceArn: \(String(describing: resourceArn)), steps: \(String(describing: steps)), tags: \(String(describing: tags)))"}
}

extension DescribeRecipeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRecipeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createDate = output.createDate
            self.createdBy = output.createdBy
            self.description = output.description
            self.lastModifiedBy = output.lastModifiedBy
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.projectName = output.projectName
            self.publishedBy = output.publishedBy
            self.publishedDate = output.publishedDate
            self.recipeVersion = output.recipeVersion
            self.resourceArn = output.resourceArn
            self.steps = output.steps
            self.tags = output.tags
        } else {
            self.createDate = nil
            self.createdBy = nil
            self.description = nil
            self.lastModifiedBy = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.projectName = nil
            self.publishedBy = nil
            self.publishedDate = nil
            self.recipeVersion = nil
            self.resourceArn = nil
            self.steps = nil
            self.tags = nil
        }
    }
}

public struct DescribeRecipeOutputResponse: Equatable {
    /// <p>The date and time that the recipe was created.</p>
    public let createDate: Date?
    /// <p>The identifier (user name) of the user who created the recipe.</p>
    public let createdBy: String?
    /// <p>The description of the recipe.</p>
    public let description: String?
    /// <p>The identifier (user name) of the user who last modified the recipe.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time that the recipe was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The name of the recipe.</p>
    public let name: String?
    /// <p>The name of the project associated with this recipe.</p>
    public let projectName: String?
    /// <p>The identifier (user name) of the user who last published the recipe.</p>
    public let publishedBy: String?
    /// <p>The date and time when the recipe was last published.</p>
    public let publishedDate: Date?
    /// <p>The recipe version identifier.</p>
    public let recipeVersion: String?
    /// <p>The ARN of the recipe.</p>
    public let resourceArn: String?
    /// <p>One or more steps to be performed by the recipe. Each step consists of an action, and
    ///             the conditions under which the action should succeed.</p>
    public let steps: [RecipeStep]?
    /// <p>Metadata tags associated with this project.</p>
    public let tags: [String:String]?

    public init (
        createDate: Date? = nil,
        createdBy: String? = nil,
        description: String? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedDate: Date? = nil,
        name: String? = nil,
        projectName: String? = nil,
        publishedBy: String? = nil,
        publishedDate: Date? = nil,
        recipeVersion: String? = nil,
        resourceArn: String? = nil,
        steps: [RecipeStep]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createDate = createDate
        self.createdBy = createdBy
        self.description = description
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.projectName = projectName
        self.publishedBy = publishedBy
        self.publishedDate = publishedDate
        self.recipeVersion = recipeVersion
        self.resourceArn = resourceArn
        self.steps = steps
        self.tags = tags
    }
}

struct DescribeRecipeOutputResponseBody: Equatable {
    public let createdBy: String?
    public let createDate: Date?
    public let lastModifiedBy: String?
    public let lastModifiedDate: Date?
    public let projectName: String?
    public let publishedBy: String?
    public let publishedDate: Date?
    public let description: String?
    public let name: String?
    public let steps: [RecipeStep]?
    public let tags: [String:String]?
    public let resourceArn: String?
    public let recipeVersion: String?
}

extension DescribeRecipeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case description = "Description"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case projectName = "ProjectName"
        case publishedBy = "PublishedBy"
        case publishedDate = "PublishedDate"
        case recipeVersion = "RecipeVersion"
        case resourceArn = "ResourceArn"
        case steps = "Steps"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let publishedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publishedBy)
        publishedBy = publishedByDecoded
        let publishedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .publishedDate)
        publishedDate = publishedDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stepsContainer = try containerValues.decodeIfPresent([RecipeStep?].self, forKey: .steps)
        var stepsDecoded0:[RecipeStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [RecipeStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let recipeVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeVersion)
        recipeVersion = recipeVersionDecoded
    }
}

extension DescribeScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeScheduleInput(name: \(String(describing: name)))"}
}

extension DescribeScheduleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScheduleInput>
    public typealias MOutput = OperationOutput<DescribeScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScheduleOutputError>
}

public struct DescribeScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeScheduleInput>
    public typealias MOutput = OperationOutput<DescribeScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeScheduleOutputError>
}

public struct DescribeScheduleInput: Equatable {
    /// <p>The name of the schedule to be described.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeScheduleInputBody: Equatable {
}

extension DescribeScheduleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeScheduleOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeScheduleOutputResponse(createDate: \(String(describing: createDate)), createdBy: \(String(describing: createdBy)), cronExpression: \(String(describing: cronExpression)), jobNames: \(String(describing: jobNames)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension DescribeScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createDate = output.createDate
            self.createdBy = output.createdBy
            self.cronExpression = output.cronExpression
            self.jobNames = output.jobNames
            self.lastModifiedBy = output.lastModifiedBy
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
            self.resourceArn = output.resourceArn
            self.tags = output.tags
        } else {
            self.createDate = nil
            self.createdBy = nil
            self.cronExpression = nil
            self.jobNames = nil
            self.lastModifiedBy = nil
            self.lastModifiedDate = nil
            self.name = nil
            self.resourceArn = nil
            self.tags = nil
        }
    }
}

public struct DescribeScheduleOutputResponse: Equatable {
    /// <p>The date and time that the schedule was created.</p>
    public let createDate: Date?
    /// <p>The identifier (user name) of the user who created the schedule. </p>
    public let createdBy: String?
    /// <p>The date or dates and time or times when the jobs are to be run for the schedule. For
    ///             more information, see <a href="https://docs.aws.amazon.com/databrew/latest/dg/jobs.cron.html">Cron expressions</a> in the
    ///                 <i>AWS Glue DataBrew Developer Guide</i>.</p>
    public let cronExpression: String?
    /// <p>The name or names of one or more jobs to be run by using the schedule.</p>
    public let jobNames: [String]?
    /// <p>The identifier (user name) of the user who last modified the schedule.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time that the schedule was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The name of the schedule.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the schedule.</p>
    public let resourceArn: String?
    /// <p>Metadata tags associated with this schedule.</p>
    public let tags: [String:String]?

    public init (
        createDate: Date? = nil,
        createdBy: String? = nil,
        cronExpression: String? = nil,
        jobNames: [String]? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedDate: Date? = nil,
        name: String? = nil,
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createDate = createDate
        self.createdBy = createdBy
        self.cronExpression = cronExpression
        self.jobNames = jobNames
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct DescribeScheduleOutputResponseBody: Equatable {
    public let createDate: Date?
    public let createdBy: String?
    public let jobNames: [String]?
    public let lastModifiedBy: String?
    public let lastModifiedDate: Date?
    public let resourceArn: String?
    public let cronExpression: String?
    public let tags: [String:String]?
    public let name: String?
}

extension DescribeScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case cronExpression = "CronExpression"
        case jobNames = "JobNames"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let jobNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .jobNames)
        var jobNamesDecoded0:[String]? = nil
        if let jobNamesContainer = jobNamesContainer {
            jobNamesDecoded0 = [String]()
            for string0 in jobNamesContainer {
                if let string0 = string0 {
                    jobNamesDecoded0?.append(string0)
                }
            }
        }
        jobNames = jobNamesDecoded0
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let cronExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cronExpression)
        cronExpression = cronExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public enum EncryptionMode {
    case ssekms
    case sses3
    case sdkUnknown(String)
}

extension EncryptionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionMode] {
        return [
            .ssekms,
            .sses3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ssekms: return "SSE-KMS"
        case .sses3: return "SSE-S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionMode(rawValue: rawValue) ?? EncryptionMode.sdkUnknown(rawValue)
    }
}

extension ExcelOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case headerRow = "HeaderRow"
        case sheetIndexes = "SheetIndexes"
        case sheetNames = "SheetNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headerRow = headerRow {
            try encodeContainer.encode(headerRow, forKey: .headerRow)
        }
        if let sheetIndexes = sheetIndexes {
            var sheetIndexesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheetIndexes)
            for sheetindexlist0 in sheetIndexes {
                try sheetIndexesContainer.encode(sheetindexlist0)
            }
        }
        if let sheetNames = sheetNames {
            var sheetNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sheetNames)
            for sheetnamelist0 in sheetNames {
                try sheetNamesContainer.encode(sheetnamelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sheetNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sheetNames)
        var sheetNamesDecoded0:[String]? = nil
        if let sheetNamesContainer = sheetNamesContainer {
            sheetNamesDecoded0 = [String]()
            for string0 in sheetNamesContainer {
                if let string0 = string0 {
                    sheetNamesDecoded0?.append(string0)
                }
            }
        }
        sheetNames = sheetNamesDecoded0
        let sheetIndexesContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .sheetIndexes)
        var sheetIndexesDecoded0:[Int]? = nil
        if let sheetIndexesContainer = sheetIndexesContainer {
            sheetIndexesDecoded0 = [Int]()
            for integer0 in sheetIndexesContainer {
                if let integer0 = integer0 {
                    sheetIndexesDecoded0?.append(integer0)
                }
            }
        }
        sheetIndexes = sheetIndexesDecoded0
        let headerRowDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .headerRow)
        headerRow = headerRowDecoded
    }
}

extension ExcelOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExcelOptions(headerRow: \(String(describing: headerRow)), sheetIndexes: \(String(describing: sheetIndexes)), sheetNames: \(String(describing: sheetNames)))"}
}

/// <p>Represents a set of options that define how DataBrew will interpret a Microsoft Excel file when
///             creating a dataset from that file.</p>
public struct ExcelOptions: Equatable {
    /// <p>A variable that specifies whether the first row in the file is parsed as the
    ///             header. If this value is false, column names are auto-generated.</p>
    public let headerRow: Bool?
    /// <p>One or more sheet numbers in the Excel file that will be included in the
    ///             dataset.</p>
    public let sheetIndexes: [Int]?
    /// <p>One or more named sheets in the Excel file that will be included in the dataset.</p>
    public let sheetNames: [String]?

    public init (
        headerRow: Bool? = nil,
        sheetIndexes: [Int]? = nil,
        sheetNames: [String]? = nil
    )
    {
        self.headerRow = headerRow
        self.sheetIndexes = sheetIndexes
        self.sheetNames = sheetNames
    }
}

extension FilesLimit: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxFiles = "MaxFiles"
        case order = "Order"
        case orderedBy = "OrderedBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxFiles != 0 {
            try encodeContainer.encode(maxFiles, forKey: .maxFiles)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let orderedBy = orderedBy {
            try encodeContainer.encode(orderedBy.rawValue, forKey: .orderedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxFilesDecoded = try containerValues.decode(Int.self, forKey: .maxFiles)
        maxFiles = maxFilesDecoded
        let orderedByDecoded = try containerValues.decodeIfPresent(OrderedBy.self, forKey: .orderedBy)
        orderedBy = orderedByDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Order.self, forKey: .order)
        order = orderDecoded
    }
}

extension FilesLimit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FilesLimit(maxFiles: \(String(describing: maxFiles)), order: \(String(describing: order)), orderedBy: \(String(describing: orderedBy)))"}
}

/// <p>Represents a limit imposed on number of S3 files that should be selected for a dataset from a connected
///             S3 path.</p>
public struct FilesLimit: Equatable {
    /// <p>The number of S3 files to select.</p>
    public let maxFiles: Int
    /// <p>A criteria to use for S3 files sorting before their selection. By default uses DESCENDING order,
    ///             i.e. most recent files are selected first. Anotherpossible value is ASCENDING.</p>
    public let order: Order?
    /// <p>A criteria to use for S3 files sorting before their selection. By default uses LAST_MODIFIED_DATE as
    ///             a sorting criteria. Currently it's the only allowed value.</p>
    public let orderedBy: OrderedBy?

    public init (
        maxFiles: Int = 0,
        order: Order? = nil,
        orderedBy: OrderedBy? = nil
    )
    {
        self.maxFiles = maxFiles
        self.order = order
        self.orderedBy = orderedBy
    }
}

extension FilterExpression: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expression = "Expression"
        case valuesMap = "ValuesMap"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let valuesMap = valuesMap {
            var valuesMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .valuesMap)
            for (dictKey0, valuesmap0) in valuesMap {
                try valuesMapContainer.encode(valuesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let valuesMapContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .valuesMap)
        var valuesMapDecoded0: [String:String]? = nil
        if let valuesMapContainer = valuesMapContainer {
            valuesMapDecoded0 = [String:String]()
            for (key0, conditionvalue0) in valuesMapContainer {
                if let conditionvalue0 = conditionvalue0 {
                    valuesMapDecoded0?[key0] = conditionvalue0
                }
            }
        }
        valuesMap = valuesMapDecoded0
    }
}

extension FilterExpression: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FilterExpression(expression: \(String(describing: expression)), valuesMap: \(String(describing: valuesMap)))"}
}

/// <p>Represents a structure for defining parameter conditions.</p>
public struct FilterExpression: Equatable {
    /// <p>The expression which includes condition names followed by substitution variables, possibly grouped
    ///             and combined with other conditions. For example, "(starts_with :prefix1 or starts_with :prefix2) and
    ///             (ends_with :suffix1 or ends_with :suffix2)". Substitution variables should start with ':' symbol.</p>
    public let expression: String?
    /// <p>The map of substitution variable names to their values used in this filter expression.</p>
    public let valuesMap: [String:String]?

    public init (
        expression: String? = nil,
        valuesMap: [String:String]? = nil
    )
    {
        self.expression = expression
        self.valuesMap = valuesMap
    }
}

extension FormatOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case csv = "Csv"
        case excel = "Excel"
        case json = "Json"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csv = csv {
            try encodeContainer.encode(csv, forKey: .csv)
        }
        if let excel = excel {
            try encodeContainer.encode(excel, forKey: .excel)
        }
        if let json = json {
            try encodeContainer.encode(json, forKey: .json)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonDecoded = try containerValues.decodeIfPresent(JsonOptions.self, forKey: .json)
        json = jsonDecoded
        let excelDecoded = try containerValues.decodeIfPresent(ExcelOptions.self, forKey: .excel)
        excel = excelDecoded
        let csvDecoded = try containerValues.decodeIfPresent(CsvOptions.self, forKey: .csv)
        csv = csvDecoded
    }
}

extension FormatOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FormatOptions(csv: \(String(describing: csv)), excel: \(String(describing: excel)), json: \(String(describing: json)))"}
}

/// <p>Represents a set of options that define the structure of either comma-separated value (CSV), Excel, or JSON input.</p>
public struct FormatOptions: Equatable {
    /// <p>Options that define how CSV input is to be interpreted by DataBrew.</p>
    public let csv: CsvOptions?
    /// <p>Options that define how Excel input is to be interpreted by DataBrew.</p>
    public let excel: ExcelOptions?
    /// <p>Options that define how JSON input is to be interpreted by DataBrew.</p>
    public let json: JsonOptions?

    public init (
        csv: CsvOptions? = nil,
        excel: ExcelOptions? = nil,
        json: JsonOptions? = nil
    )
    {
        self.csv = csv
        self.excel = excel
        self.json = json
    }
}

extension Input: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataCatalogInputDefinition = "DataCatalogInputDefinition"
        case databaseInputDefinition = "DatabaseInputDefinition"
        case s3InputDefinition = "S3InputDefinition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataCatalogInputDefinition = dataCatalogInputDefinition {
            try encodeContainer.encode(dataCatalogInputDefinition, forKey: .dataCatalogInputDefinition)
        }
        if let databaseInputDefinition = databaseInputDefinition {
            try encodeContainer.encode(databaseInputDefinition, forKey: .databaseInputDefinition)
        }
        if let s3InputDefinition = s3InputDefinition {
            try encodeContainer.encode(s3InputDefinition, forKey: .s3InputDefinition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3InputDefinitionDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3InputDefinition)
        s3InputDefinition = s3InputDefinitionDecoded
        let dataCatalogInputDefinitionDecoded = try containerValues.decodeIfPresent(DataCatalogInputDefinition.self, forKey: .dataCatalogInputDefinition)
        dataCatalogInputDefinition = dataCatalogInputDefinitionDecoded
        let databaseInputDefinitionDecoded = try containerValues.decodeIfPresent(DatabaseInputDefinition.self, forKey: .databaseInputDefinition)
        databaseInputDefinition = databaseInputDefinitionDecoded
    }
}

extension Input: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Input(dataCatalogInputDefinition: \(String(describing: dataCatalogInputDefinition)), databaseInputDefinition: \(String(describing: databaseInputDefinition)), s3InputDefinition: \(String(describing: s3InputDefinition)))"}
}

/// <p>Represents information on how DataBrew can find data, in either the AWS Glue Data Catalog or
///             Amazon S3.</p>
public struct Input: Equatable {
    /// <p>The AWS Glue Data Catalog parameters for the data.</p>
    public let dataCatalogInputDefinition: DataCatalogInputDefinition?
    /// <p>Connection information for dataset input files stored in a database.</p>
    public let databaseInputDefinition: DatabaseInputDefinition?
    /// <p>The Amazon S3 location where the data is stored.</p>
    public let s3InputDefinition: S3Location?

    public init (
        dataCatalogInputDefinition: DataCatalogInputDefinition? = nil,
        databaseInputDefinition: DatabaseInputDefinition? = nil,
        s3InputDefinition: S3Location? = nil
    )
    {
        self.dataCatalogInputDefinition = dataCatalogInputDefinition
        self.databaseInputDefinition = databaseInputDefinition
        self.s3InputDefinition = s3InputDefinition
    }
}

public enum InputFormat {
    case csv
    case excel
    case json
    case parquet
    case sdkUnknown(String)
}

extension InputFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InputFormat] {
        return [
            .csv,
            .excel,
            .json,
            .parquet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .excel: return "EXCEL"
        case .json: return "JSON"
        case .parquet: return "PARQUET"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InputFormat(rawValue: rawValue) ?? InputFormat.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal service failure occurred.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Job: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case datasetName = "DatasetName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case jobSample = "JobSample"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case name = "Name"
        case outputs = "Outputs"
        case projectName = "ProjectName"
        case recipeReference = "RecipeReference"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case tags = "Tags"
        case timeout = "Timeout"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let jobSample = jobSample {
            try encodeContainer.encode(jobSample, forKey: .jobSample)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let logSubscription = logSubscription {
            try encodeContainer.encode(logSubscription.rawValue, forKey: .logSubscription)
        }
        if maxCapacity != 0 {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if maxRetries != 0 {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for outputlist0 in outputs {
                try outputsContainer.encode(outputlist0)
            }
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let recipeReference = recipeReference {
            try encodeContainer.encode(recipeReference, forKey: .recipeReference)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(EncryptionMode.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .type)
        type = typeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let maxCapacityDecoded = try containerValues.decode(Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let maxRetriesDecoded = try containerValues.decode(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let outputsContainer = try containerValues.decodeIfPresent([Output?].self, forKey: .outputs)
        var outputsDecoded0:[Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let recipeReferenceDecoded = try containerValues.decodeIfPresent(RecipeReference.self, forKey: .recipeReference)
        recipeReference = recipeReferenceDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let timeoutDecoded = try containerValues.decode(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let jobSampleDecoded = try containerValues.decodeIfPresent(JobSample.self, forKey: .jobSample)
        jobSample = jobSampleDecoded
    }
}

extension Job: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Job(accountId: \(String(describing: accountId)), createDate: \(String(describing: createDate)), createdBy: \(String(describing: createdBy)), datasetName: \(String(describing: datasetName)), encryptionKeyArn: \(String(describing: encryptionKeyArn)), encryptionMode: \(String(describing: encryptionMode)), jobSample: \(String(describing: jobSample)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), logSubscription: \(String(describing: logSubscription)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), name: \(String(describing: name)), outputs: \(String(describing: outputs)), projectName: \(String(describing: projectName)), recipeReference: \(String(describing: recipeReference)), resourceArn: \(String(describing: resourceArn)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)), timeout: \(String(describing: timeout)), type: \(String(describing: type)))"}
}

/// <p>Represents all of the attributes of a DataBrew job.</p>
public struct Job: Equatable {
    /// <p>The ID of the AWS account that owns the job.</p>
    public let accountId: String?
    /// <p>The date and time that the job was created.</p>
    public let createDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the user who created the job.</p>
    public let createdBy: String?
    /// <p>A dataset that the job is to process.</p>
    public let datasetName: String?
    /// <p>The Amazon Resource Name (ARN) of an encryption key that is used to protect the job
    ///             output. For more information, see <a href="https://docs.aws.amazon.com/databrew/latest/dg/encryption-security-configuration.html">Encrypting data
    ///                 written by DataBrew jobs</a>
    ///          </p>
    public let encryptionKeyArn: String?
    /// <p>The encryption mode for the job, which can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>SSE-KMS</code> - Server-side encryption with keys managed by AWS KMS.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SSE-S3</code> - Server-side encryption with keys managed by Amazon
    ///                     S3.</p>
    ///             </li>
    ///          </ul>
    public let encryptionMode: EncryptionMode?
    /// <p>A sample configuration for profile jobs only, which determines the number of rows on which the
    ///             profile job is run. If a <code>JobSample</code> value isn't provided, the default value
    ///             is used. The default value is CUSTOM_ROWS for the mode parameter and 20,000 for the
    ///             size parameter.</p>
    public let jobSample: JobSample?
    /// <p>The Amazon Resource Name (ARN) of the user who last modified the job.</p>
    public let lastModifiedBy: String?
    /// <p>The modification date and time of the job.</p>
    public let lastModifiedDate: Date?
    /// <p>The current status of Amazon CloudWatch logging for the job.</p>
    public let logSubscription: LogSubscription?
    /// <p>The maximum number of nodes that can be consumed when the job processes data.</p>
    public let maxCapacity: Int
    /// <p>The maximum number of times to retry the job after a job run fails.</p>
    public let maxRetries: Int
    /// <p>The unique name of the job.</p>
    public let name: String?
    /// <p>One or more artifacts that represent output from running the job.</p>
    public let outputs: [Output]?
    /// <p>The name of the project that the job is associated with.</p>
    public let projectName: String?
    /// <p>A set of steps that the job runs.</p>
    public let recipeReference: RecipeReference?
    /// <p>The unique Amazon Resource Name (ARN) for the job.</p>
    public let resourceArn: String?
    /// <p>The Amazon Resource Name (ARN) of the role to be assumed for this job.</p>
    public let roleArn: String?
    /// <p>Metadata tags that have been applied to the job.</p>
    public let tags: [String:String]?
    /// <p>The job's timeout in minutes. A job that attempts to run longer than this timeout
    ///             period ends with a status of <code>TIMEOUT</code>.</p>
    public let timeout: Int
    /// <p>The job type of the job, which must be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>PROFILE</code> - A job to analyze a dataset, to determine its size, data
    ///                     types, data distribution, and more.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>RECIPE</code> - A job to apply one or more transformations to a
    ///                     dataset.</p>
    ///             </li>
    ///          </ul>
    public let type: JobType?

    public init (
        accountId: String? = nil,
        createDate: Date? = nil,
        createdBy: String? = nil,
        datasetName: String? = nil,
        encryptionKeyArn: String? = nil,
        encryptionMode: EncryptionMode? = nil,
        jobSample: JobSample? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedDate: Date? = nil,
        logSubscription: LogSubscription? = nil,
        maxCapacity: Int = 0,
        maxRetries: Int = 0,
        name: String? = nil,
        outputs: [Output]? = nil,
        projectName: String? = nil,
        recipeReference: RecipeReference? = nil,
        resourceArn: String? = nil,
        roleArn: String? = nil,
        tags: [String:String]? = nil,
        timeout: Int = 0,
        type: JobType? = nil
    )
    {
        self.accountId = accountId
        self.createDate = createDate
        self.createdBy = createdBy
        self.datasetName = datasetName
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionMode = encryptionMode
        self.jobSample = jobSample
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.logSubscription = logSubscription
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.outputs = outputs
        self.projectName = projectName
        self.recipeReference = recipeReference
        self.resourceArn = resourceArn
        self.roleArn = roleArn
        self.tags = tags
        self.timeout = timeout
        self.type = type
    }
}

extension JobRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attempt = "Attempt"
        case completedOn = "CompletedOn"
        case datasetName = "DatasetName"
        case errorMessage = "ErrorMessage"
        case executionTime = "ExecutionTime"
        case jobName = "JobName"
        case jobSample = "JobSample"
        case logGroupName = "LogGroupName"
        case logSubscription = "LogSubscription"
        case outputs = "Outputs"
        case recipeReference = "RecipeReference"
        case runId = "RunId"
        case startedBy = "StartedBy"
        case startedOn = "StartedOn"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if attempt != 0 {
            try encodeContainer.encode(attempt, forKey: .attempt)
        }
        if let completedOn = completedOn {
            try encodeContainer.encode(completedOn.timeIntervalSince1970, forKey: .completedOn)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if executionTime != 0 {
            try encodeContainer.encode(executionTime, forKey: .executionTime)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobSample = jobSample {
            try encodeContainer.encode(jobSample, forKey: .jobSample)
        }
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let logSubscription = logSubscription {
            try encodeContainer.encode(logSubscription.rawValue, forKey: .logSubscription)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for outputlist0 in outputs {
                try outputsContainer.encode(outputlist0)
            }
        }
        if let recipeReference = recipeReference {
            try encodeContainer.encode(recipeReference, forKey: .recipeReference)
        }
        if let runId = runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
        if let startedBy = startedBy {
            try encodeContainer.encode(startedBy, forKey: .startedBy)
        }
        if let startedOn = startedOn {
            try encodeContainer.encode(startedOn.timeIntervalSince1970, forKey: .startedOn)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attemptDecoded = try containerValues.decode(Int.self, forKey: .attempt)
        attempt = attemptDecoded
        let completedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedOn)
        completedOn = completedOnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let executionTimeDecoded = try containerValues.decode(Int.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(JobRunState.self, forKey: .state)
        state = stateDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([Output?].self, forKey: .outputs)
        var outputsDecoded0:[Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let recipeReferenceDecoded = try containerValues.decodeIfPresent(RecipeReference.self, forKey: .recipeReference)
        recipeReference = recipeReferenceDecoded
        let startedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let startedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedOn)
        startedOn = startedOnDecoded
        let jobSampleDecoded = try containerValues.decodeIfPresent(JobSample.self, forKey: .jobSample)
        jobSample = jobSampleDecoded
    }
}

extension JobRun: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobRun(attempt: \(String(describing: attempt)), completedOn: \(String(describing: completedOn)), datasetName: \(String(describing: datasetName)), errorMessage: \(String(describing: errorMessage)), executionTime: \(String(describing: executionTime)), jobName: \(String(describing: jobName)), jobSample: \(String(describing: jobSample)), logGroupName: \(String(describing: logGroupName)), logSubscription: \(String(describing: logSubscription)), outputs: \(String(describing: outputs)), recipeReference: \(String(describing: recipeReference)), runId: \(String(describing: runId)), startedBy: \(String(describing: startedBy)), startedOn: \(String(describing: startedOn)), state: \(String(describing: state)))"}
}

/// <p>Represents one run of a DataBrew job.</p>
public struct JobRun: Equatable {
    /// <p>The number of times that DataBrew has attempted to run the job.</p>
    public let attempt: Int
    /// <p>The date and time when the job completed processing.</p>
    public let completedOn: Date?
    /// <p>The name of the dataset for the job to process.</p>
    public let datasetName: String?
    /// <p>A message indicating an error (if any) that was encountered when the job ran.</p>
    public let errorMessage: String?
    /// <p>The amount of time, in seconds, during which a job run consumed resources.</p>
    public let executionTime: Int
    /// <p>The name of the job being processed during this run.</p>
    public let jobName: String?
    /// <p>A sample configuration for profile jobs only, which determines the number of rows on which the
    ///             profile job is run. If a <code>JobSample</code> value isn't provided, the default
    ///             is used. The default value is CUSTOM_ROWS for the mode parameter and 20,000 for the
    ///             size parameter.</p>
    public let jobSample: JobSample?
    /// <p>The name of an Amazon CloudWatch log group, where the job writes diagnostic messages
    ///             when it runs.</p>
    public let logGroupName: String?
    /// <p>The current status of Amazon CloudWatch logging for the job run.</p>
    public let logSubscription: LogSubscription?
    /// <p>One or more output artifacts from a job run.</p>
    public let outputs: [Output]?
    /// <p>The set of steps processed by the job.</p>
    public let recipeReference: RecipeReference?
    /// <p>The unique identifier of the job run.</p>
    public let runId: String?
    /// <p>The Amazon Resource Name (ARN) of the user who initiated the job run. </p>
    public let startedBy: String?
    /// <p>The date and time when the job run began. </p>
    public let startedOn: Date?
    /// <p>The current state of the job run entity itself.</p>
    public let state: JobRunState?

    public init (
        attempt: Int = 0,
        completedOn: Date? = nil,
        datasetName: String? = nil,
        errorMessage: String? = nil,
        executionTime: Int = 0,
        jobName: String? = nil,
        jobSample: JobSample? = nil,
        logGroupName: String? = nil,
        logSubscription: LogSubscription? = nil,
        outputs: [Output]? = nil,
        recipeReference: RecipeReference? = nil,
        runId: String? = nil,
        startedBy: String? = nil,
        startedOn: Date? = nil,
        state: JobRunState? = nil
    )
    {
        self.attempt = attempt
        self.completedOn = completedOn
        self.datasetName = datasetName
        self.errorMessage = errorMessage
        self.executionTime = executionTime
        self.jobName = jobName
        self.jobSample = jobSample
        self.logGroupName = logGroupName
        self.logSubscription = logSubscription
        self.outputs = outputs
        self.recipeReference = recipeReference
        self.runId = runId
        self.startedBy = startedBy
        self.startedOn = startedOn
        self.state = state
    }
}

public enum JobRunState {
    case failed
    case running
    case starting
    case stopped
    case stopping
    case succeeded
    case timeout
    case sdkUnknown(String)
}

extension JobRunState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobRunState] {
        return [
            .failed,
            .running,
            .starting,
            .stopped,
            .stopping,
            .succeeded,
            .timeout,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .running: return "RUNNING"
        case .starting: return "STARTING"
        case .stopped: return "STOPPED"
        case .stopping: return "STOPPING"
        case .succeeded: return "SUCCEEDED"
        case .timeout: return "TIMEOUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobRunState(rawValue: rawValue) ?? JobRunState.sdkUnknown(rawValue)
    }
}

extension JobSample: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mode = "Mode"
        case size = "Size"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(SampleMode.self, forKey: .mode)
        mode = modeDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension JobSample: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobSample(mode: \(String(describing: mode)), size: \(String(describing: size)))"}
}

/// <p>A sample configuration for profile jobs only, which determines the number of rows on which the
///             profile job is run. If a <code>JobSample</code> value isn't provided, the
///             default is used. The default value is CUSTOM_ROWS for the mode parameter and
///             20,000 for the size parameter.</p>
public struct JobSample: Equatable {
    /// <p>A value that determines whether the profile job is run on the entire dataset or a
    ///             specified number of rows. This value must be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>FULL_DATASET - The profile job is run on the entire dataset.</p>
    ///             </li>
    ///             <li>
    ///                 <p>CUSTOM_ROWS - The profile job is run on the number of rows specified in the
    ///                     <code>Size</code> parameter.</p>
    ///             </li>
    ///          </ul>
    public let mode: SampleMode?
    /// <p>The <code>Size</code> parameter is only required when the mode is CUSTOM_ROWS. The
    ///             profile job is run on the specified number of rows. The maximum value for size is
    ///             Long.MAX_VALUE.</p>
    ///         <p>Long.MAX_VALUE = 9223372036854775807</p>
    public let size: Int?

    public init (
        mode: SampleMode? = nil,
        size: Int? = nil
    )
    {
        self.mode = mode
        self.size = size
    }
}

public enum JobType {
    case profile
    case recipe
    case sdkUnknown(String)
}

extension JobType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobType] {
        return [
            .profile,
            .recipe,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .profile: return "PROFILE"
        case .recipe: return "RECIPE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
    }
}

extension JsonOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case multiLine = "MultiLine"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if multiLine != false {
            try encodeContainer.encode(multiLine, forKey: .multiLine)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multiLineDecoded = try containerValues.decode(Bool.self, forKey: .multiLine)
        multiLine = multiLineDecoded
    }
}

extension JsonOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JsonOptions(multiLine: \(String(describing: multiLine)))"}
}

/// <p>Represents the JSON-specific options that define how input is to be interpreted by AWS
///             Glue DataBrew.</p>
public struct JsonOptions: Equatable {
    /// <p>A value that specifies whether JSON input contains embedded new line
    ///             characters.</p>
    public let multiLine: Bool

    public init (
        multiLine: Bool = false
    )
    {
        self.multiLine = multiLine
    }
}

extension ListDatasetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDatasetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInput: Equatable {
    /// <p>The maximum number of results to return in this request. </p>
    public let maxResults: Int?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Equatable {
}

extension ListDatasetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDatasetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetsOutputError: Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetsOutputResponse(datasets: \(String(describing: datasets)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutputResponse: Equatable {
    /// <p>A list of datasets that are defined.</p>
    public let datasets: [Dataset]?
    /// <p>A token that you can use in a subsequent call to retrieve the next set of
    ///             results.</p>
    public let nextToken: String?

    public init (
        datasets: [Dataset]? = nil,
        nextToken: String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Equatable {
    public let datasets: [Dataset]?
    public let nextToken: String?
}

extension ListDatasetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasets = "Datasets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([Dataset?].self, forKey: .datasets)
        var datasetsDecoded0:[Dataset]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [Dataset]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobRunsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobRunsInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobRunsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobRunsInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobRunsInput>
    public typealias MOutput = OperationOutput<ListJobRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobRunsOutputError>
}

public struct ListJobRunsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobRunsInput>
    public typealias MOutput = OperationOutput<ListJobRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobRunsOutputError>
}

public struct ListJobRunsInput: Equatable {
    /// <p>The maximum number of results to return in this request. </p>
    public let maxResults: Int?
    /// <p>The name of the job.</p>
    public let name: String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListJobRunsInputBody: Equatable {
}

extension ListJobRunsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobRunsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobRunsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobRunsOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobRunsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobRunsOutputResponse(jobRuns: \(String(describing: jobRuns)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobRunsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobRunsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobRuns = output.jobRuns
            self.nextToken = output.nextToken
        } else {
            self.jobRuns = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobRunsOutputResponse: Equatable {
    /// <p>A list of job runs that have occurred for the specified job.</p>
    public let jobRuns: [JobRun]?
    /// <p>A token that you can use in a subsequent call to retrieve the next set of
    ///             results.</p>
    public let nextToken: String?

    public init (
        jobRuns: [JobRun]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobRuns = jobRuns
        self.nextToken = nextToken
    }
}

struct ListJobRunsOutputResponseBody: Equatable {
    public let jobRuns: [JobRun]?
    public let nextToken: String?
}

extension ListJobRunsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobRuns = "JobRuns"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunsContainer = try containerValues.decodeIfPresent([JobRun?].self, forKey: .jobRuns)
        var jobRunsDecoded0:[JobRun]? = nil
        if let jobRunsContainer = jobRunsContainer {
            jobRunsDecoded0 = [JobRun]()
            for structure0 in jobRunsContainer {
                if let structure0 = structure0 {
                    jobRunsDecoded0?.append(structure0)
                }
            }
        }
        jobRuns = jobRunsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsInput(datasetName: \(String(describing: datasetName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), projectName: \(String(describing: projectName)))"}
}

extension ListJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let projectName = input.operationInput.projectName {
            let projectNameQueryItem = URLQueryItem(name: "projectName".urlPercentEncoding(), value: String(projectName).urlPercentEncoding())
            input.builder.withQueryItem(projectNameQueryItem)
        }
        if let datasetName = input.operationInput.datasetName {
            let datasetNameQueryItem = URLQueryItem(name: "datasetName".urlPercentEncoding(), value: String(datasetName).urlPercentEncoding())
            input.builder.withQueryItem(datasetNameQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInput: Equatable {
    /// <p>The name of a dataset. Using this parameter indicates to return only those jobs that
    ///             act on the specified dataset.</p>
    public let datasetName: String?
    /// <p>The maximum number of results to return in this request. </p>
    public let maxResults: Int?
    /// <p>A token generated by DataBrew that specifies where to continue pagination if a
    ///             previous request was truncated. To get the next set of pages, pass in the NextToken
    ///             value from the response object of the previous page call. </p>
    public let nextToken: String?
    /// <p>The name of a project. Using this parameter indicates to return only those jobs that
    ///             are associated with the specified project.</p>
    public let projectName: String?

    public init (
        datasetName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        projectName: String? = nil
    )
    {
        self.datasetName = datasetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
    }
}

struct ListJobsInputBody: Equatable {
}

extension ListJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsOutputResponse(jobs: \(String(describing: jobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutputResponse: Equatable {
    /// <p>A list of jobs that are defined.</p>
    public let jobs: [Job]?
    /// <p>A token that you can use in a subsequent call to retrieve the next set of
    ///             results.</p>
    public let nextToken: String?

    public init (
        jobs: [Job]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Equatable {
    public let jobs: [Job]?
    public let nextToken: String?
}

extension ListJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([Job?].self, forKey: .jobs)
        var jobsDecoded0:[Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProjectsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProjectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInput: Equatable {
    /// <p>The maximum number of results to return in this request. </p>
    public let maxResults: Int?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Equatable {
}

extension ListProjectsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsOutputResponse(nextToken: \(String(describing: nextToken)), projects: \(String(describing: projects)))"}
}

extension ListProjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutputResponse: Equatable {
    /// <p>A token that you can use in a subsequent call to retrieve the next set of
    ///             results.</p>
    public let nextToken: String?
    /// <p>A list of projects that are defined .</p>
    public let projects: [Project]?

    public init (
        nextToken: String? = nil,
        projects: [Project]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Equatable {
    public let projects: [Project]?
    public let nextToken: String?
}

extension ListProjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case projects = "Projects"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([Project?].self, forKey: .projects)
        var projectsDecoded0:[Project]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [Project]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecipeVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecipeVersionsInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRecipeVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRecipeVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRecipeVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecipeVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecipeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecipeVersionsInput>
    public typealias MOutput = OperationOutput<ListRecipeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecipeVersionsOutputError>
}

public struct ListRecipeVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRecipeVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecipeVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecipeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let name = input.operationInput.name {
            let nameQueryItem = URLQueryItem(name: "name".urlPercentEncoding(), value: String(name).urlPercentEncoding())
            input.builder.withQueryItem(nameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecipeVersionsInput>
    public typealias MOutput = OperationOutput<ListRecipeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecipeVersionsOutputError>
}

public struct ListRecipeVersionsInput: Equatable {
    /// <p>The maximum number of results to return in this request. </p>
    public let maxResults: Int?
    /// <p>The name of the recipe for which to return version information.</p>
    public let name: String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListRecipeVersionsInputBody: Equatable {
}

extension ListRecipeVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRecipeVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecipeVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecipeVersionsOutputError: Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecipeVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecipeVersionsOutputResponse(nextToken: \(String(describing: nextToken)), recipes: \(String(describing: recipes)))"}
}

extension ListRecipeVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRecipeVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.recipes = output.recipes
        } else {
            self.nextToken = nil
            self.recipes = nil
        }
    }
}

public struct ListRecipeVersionsOutputResponse: Equatable {
    /// <p>A token that you can use in a subsequent call to retrieve the next set of
    ///             results.</p>
    public let nextToken: String?
    /// <p>A list of versions for the specified recipe.</p>
    public let recipes: [Recipe]?

    public init (
        nextToken: String? = nil,
        recipes: [Recipe]? = nil
    )
    {
        self.nextToken = nextToken
        self.recipes = recipes
    }
}

struct ListRecipeVersionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let recipes: [Recipe]?
}

extension ListRecipeVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case recipes = "Recipes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recipesContainer = try containerValues.decodeIfPresent([Recipe?].self, forKey: .recipes)
        var recipesDecoded0:[Recipe]? = nil
        if let recipesContainer = recipesContainer {
            recipesDecoded0 = [Recipe]()
            for structure0 in recipesContainer {
                if let structure0 = structure0 {
                    recipesDecoded0?.append(structure0)
                }
            }
        }
        recipes = recipesDecoded0
    }
}

extension ListRecipesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecipesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), recipeVersion: \(String(describing: recipeVersion)))"}
}

extension ListRecipesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRecipesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRecipesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecipesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecipesInput>
    public typealias MOutput = OperationOutput<ListRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecipesOutputError>
}

public struct ListRecipesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRecipesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecipesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let recipeVersion = input.operationInput.recipeVersion {
            let recipeVersionQueryItem = URLQueryItem(name: "recipeVersion".urlPercentEncoding(), value: String(recipeVersion).urlPercentEncoding())
            input.builder.withQueryItem(recipeVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecipesInput>
    public typealias MOutput = OperationOutput<ListRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecipesOutputError>
}

public struct ListRecipesInput: Equatable {
    /// <p>The maximum number of results to return in this request. </p>
    public let maxResults: Int?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>Return only those recipes with a version identifier of <code>LATEST_WORKING</code> or
    ///                 <code>LATEST_PUBLISHED</code>. If <code>RecipeVersion</code> is omitted,
    ///                 <code>ListRecipes</code> returns all of the <code>LATEST_PUBLISHED</code> recipe
    ///             versions.</p>
    ///         <p>Valid values: <code>LATEST_WORKING</code> | <code>LATEST_PUBLISHED</code>
    ///          </p>
    public let recipeVersion: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        recipeVersion: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recipeVersion = recipeVersion
    }
}

struct ListRecipesInputBody: Equatable {
}

extension ListRecipesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRecipesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecipesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecipesOutputError: Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecipesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecipesOutputResponse(nextToken: \(String(describing: nextToken)), recipes: \(String(describing: recipes)))"}
}

extension ListRecipesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRecipesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.recipes = output.recipes
        } else {
            self.nextToken = nil
            self.recipes = nil
        }
    }
}

public struct ListRecipesOutputResponse: Equatable {
    /// <p>A token that you can use in a subsequent call to retrieve the next set of
    ///             results.</p>
    public let nextToken: String?
    /// <p>A list of recipes that are defined.</p>
    public let recipes: [Recipe]?

    public init (
        nextToken: String? = nil,
        recipes: [Recipe]? = nil
    )
    {
        self.nextToken = nextToken
        self.recipes = recipes
    }
}

struct ListRecipesOutputResponseBody: Equatable {
    public let recipes: [Recipe]?
    public let nextToken: String?
}

extension ListRecipesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case recipes = "Recipes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipesContainer = try containerValues.decodeIfPresent([Recipe?].self, forKey: .recipes)
        var recipesDecoded0:[Recipe]? = nil
        if let recipesContainer = recipesContainer {
            recipesDecoded0 = [Recipe]()
            for structure0 in recipesContainer {
                if let structure0 = structure0 {
                    recipesDecoded0?.append(structure0)
                }
            }
        }
        recipes = recipesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSchedulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchedulesInput(jobName: \(String(describing: jobName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSchedulesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSchedulesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSchedulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchedulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchedulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchedulesInput>
    public typealias MOutput = OperationOutput<ListSchedulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchedulesOutputError>
}

public struct ListSchedulesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSchedulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSchedulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSchedulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let jobName = input.operationInput.jobName {
            let jobNameQueryItem = URLQueryItem(name: "jobName".urlPercentEncoding(), value: String(jobName).urlPercentEncoding())
            input.builder.withQueryItem(jobNameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSchedulesInput>
    public typealias MOutput = OperationOutput<ListSchedulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSchedulesOutputError>
}

public struct ListSchedulesInput: Equatable {
    /// <p>The name of the job that these schedules apply to.</p>
    public let jobName: String?
    /// <p>The maximum number of results to return in this request. </p>
    public let maxResults: Int?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        jobName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.jobName = jobName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSchedulesInputBody: Equatable {
}

extension ListSchedulesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSchedulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchedulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSchedulesOutputError: Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchedulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSchedulesOutputResponse(nextToken: \(String(describing: nextToken)), schedules: \(String(describing: schedules)))"}
}

extension ListSchedulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSchedulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schedules = output.schedules
        } else {
            self.nextToken = nil
            self.schedules = nil
        }
    }
}

public struct ListSchedulesOutputResponse: Equatable {
    /// <p>A token that you can use in a subsequent call to retrieve the next set of
    ///             results.</p>
    public let nextToken: String?
    /// <p>A list of schedules that are defined.</p>
    public let schedules: [Schedule]?

    public init (
        nextToken: String? = nil,
        schedules: [Schedule]? = nil
    )
    {
        self.nextToken = nextToken
        self.schedules = schedules
    }
}

struct ListSchedulesOutputResponseBody: Equatable {
    public let schedules: [Schedule]?
    public let nextToken: String?
}

extension ListSchedulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schedules = "Schedules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schedulesContainer = try containerValues.decodeIfPresent([Schedule?].self, forKey: .schedules)
        var schedulesDecoded0:[Schedule]? = nil
        if let schedulesContainer = schedulesContainer {
            schedulesDecoded0 = [Schedule]()
            for structure0 in schedulesContainer {
                if let structure0 = structure0 {
                    schedulesDecoded0?.append(structure0)
                }
            }
        }
        schedules = schedulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) string that uniquely identifies the DataBrew resource.
    ///         </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of tags associated with the DataBrew resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum LogSubscription {
    case disable
    case enable
    case sdkUnknown(String)
}

extension LogSubscription : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogSubscription] {
        return [
            .disable,
            .enable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disable: return "DISABLE"
        case .enable: return "ENABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogSubscription(rawValue: rawValue) ?? LogSubscription.sdkUnknown(rawValue)
    }
}

public enum Order {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension Order : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Order] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASCENDING"
        case .descending: return "DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Order(rawValue: rawValue) ?? Order.sdkUnknown(rawValue)
    }
}

public enum OrderedBy {
    case lastModifiedDate
    case sdkUnknown(String)
}

extension OrderedBy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrderedBy] {
        return [
            .lastModifiedDate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lastModifiedDate: return "LAST_MODIFIED_DATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrderedBy(rawValue: rawValue) ?? OrderedBy.sdkUnknown(rawValue)
    }
}

extension Output: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compressionFormat = "CompressionFormat"
        case format = "Format"
        case formatOptions = "FormatOptions"
        case location = "Location"
        case overwrite = "Overwrite"
        case partitionColumns = "PartitionColumns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compressionFormat = compressionFormat {
            try encodeContainer.encode(compressionFormat.rawValue, forKey: .compressionFormat)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let formatOptions = formatOptions {
            try encodeContainer.encode(formatOptions, forKey: .formatOptions)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if overwrite != false {
            try encodeContainer.encode(overwrite, forKey: .overwrite)
        }
        if let partitionColumns = partitionColumns {
            var partitionColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionColumns)
            for columnnamelist0 in partitionColumns {
                try partitionColumnsContainer.encode(columnnamelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compressionFormatDecoded = try containerValues.decodeIfPresent(CompressionFormat.self, forKey: .compressionFormat)
        compressionFormat = compressionFormatDecoded
        let formatDecoded = try containerValues.decodeIfPresent(OutputFormat.self, forKey: .format)
        format = formatDecoded
        let partitionColumnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .partitionColumns)
        var partitionColumnsDecoded0:[String]? = nil
        if let partitionColumnsContainer = partitionColumnsContainer {
            partitionColumnsDecoded0 = [String]()
            for string0 in partitionColumnsContainer {
                if let string0 = string0 {
                    partitionColumnsDecoded0?.append(string0)
                }
            }
        }
        partitionColumns = partitionColumnsDecoded0
        let locationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .location)
        location = locationDecoded
        let overwriteDecoded = try containerValues.decode(Bool.self, forKey: .overwrite)
        overwrite = overwriteDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(OutputFormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
    }
}

extension Output: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Output(compressionFormat: \(String(describing: compressionFormat)), format: \(String(describing: format)), formatOptions: \(String(describing: formatOptions)), location: \(String(describing: location)), overwrite: \(String(describing: overwrite)), partitionColumns: \(String(describing: partitionColumns)))"}
}

/// <p>Represents options that specify how and where DataBrew writes the output generated by
///             recipe jobs or profile jobs.</p>
public struct Output: Equatable {
    /// <p>The compression algorithm used to compress the output text of the job.</p>
    public let compressionFormat: CompressionFormat?
    /// <p>The data format of the output of the job.</p>
    public let format: OutputFormat?
    /// <p>Represents options that define how DataBrew formats job output files.</p>
    public let formatOptions: OutputFormatOptions?
    /// <p>The location in Amazon S3 where the job writes its output.</p>
    public let location: S3Location?
    /// <p>A value that, if true, means that any data in the location specified for output is
    ///             overwritten with new output.</p>
    public let overwrite: Bool
    /// <p>The names of one or more partition columns for the output of the job.</p>
    public let partitionColumns: [String]?

    public init (
        compressionFormat: CompressionFormat? = nil,
        format: OutputFormat? = nil,
        formatOptions: OutputFormatOptions? = nil,
        location: S3Location? = nil,
        overwrite: Bool = false,
        partitionColumns: [String]? = nil
    )
    {
        self.compressionFormat = compressionFormat
        self.format = format
        self.formatOptions = formatOptions
        self.location = location
        self.overwrite = overwrite
        self.partitionColumns = partitionColumns
    }
}

public enum OutputFormat {
    case avro
    case csv
    case glueparquet
    case json
    case orc
    case parquet
    case xml
    case sdkUnknown(String)
}

extension OutputFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OutputFormat] {
        return [
            .avro,
            .csv,
            .glueparquet,
            .json,
            .orc,
            .parquet,
            .xml,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .avro: return "AVRO"
        case .csv: return "CSV"
        case .glueparquet: return "GLUEPARQUET"
        case .json: return "JSON"
        case .orc: return "ORC"
        case .parquet: return "PARQUET"
        case .xml: return "XML"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OutputFormat(rawValue: rawValue) ?? OutputFormat.sdkUnknown(rawValue)
    }
}

extension OutputFormatOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case csv = "Csv"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csv = csv {
            try encodeContainer.encode(csv, forKey: .csv)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvDecoded = try containerValues.decodeIfPresent(CsvOutputOptions.self, forKey: .csv)
        csv = csvDecoded
    }
}

extension OutputFormatOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputFormatOptions(csv: \(String(describing: csv)))"}
}

/// <p>Represents a set of options that define the structure of comma-separated (CSV) job output.</p>
public struct OutputFormatOptions: Equatable {
    /// <p>Represents a set of options that define the structure of comma-separated value (CSV)
    ///             job output.</p>
    public let csv: CsvOutputOptions?

    public init (
        csv: CsvOutputOptions? = nil
    )
    {
        self.csv = csv
    }
}

public enum ParameterType {
    case datetime
    case number
    case string
    case sdkUnknown(String)
}

extension ParameterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParameterType] {
        return [
            .datetime,
            .number,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .datetime: return "Datetime"
        case .number: return "Number"
        case .string: return "String"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParameterType(rawValue: rawValue) ?? ParameterType.sdkUnknown(rawValue)
    }
}

extension PathOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filesLimit = "FilesLimit"
        case lastModifiedDateCondition = "LastModifiedDateCondition"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filesLimit = filesLimit {
            try encodeContainer.encode(filesLimit, forKey: .filesLimit)
        }
        if let lastModifiedDateCondition = lastModifiedDateCondition {
            try encodeContainer.encode(lastModifiedDateCondition, forKey: .lastModifiedDateCondition)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, pathparametersmap0) in parameters {
                try parametersContainer.encode(pathparametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDateConditionDecoded = try containerValues.decodeIfPresent(FilterExpression.self, forKey: .lastModifiedDateCondition)
        lastModifiedDateCondition = lastModifiedDateConditionDecoded
        let filesLimitDecoded = try containerValues.decodeIfPresent(FilesLimit.self, forKey: .filesLimit)
        filesLimit = filesLimitDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: DatasetParameter?].self, forKey: .parameters)
        var parametersDecoded0: [String:DatasetParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:DatasetParameter]()
            for (key0, datasetparameter0) in parametersContainer {
                if let datasetparameter0 = datasetparameter0 {
                    parametersDecoded0?[key0] = datasetparameter0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension PathOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PathOptions(filesLimit: \(String(describing: filesLimit)), lastModifiedDateCondition: \(String(describing: lastModifiedDateCondition)), parameters: \(String(describing: parameters)))"}
}

/// <p>Represents a set of options that define how DataBrew selects files for a given S3 path in a dataset.</p>
public struct PathOptions: Equatable {
    /// <p>If provided, this structure imposes a limit on a number of files that should be selected.</p>
    public let filesLimit: FilesLimit?
    /// <p>If provided, this structure defines a date range for matching S3 objects based on their LastModifiedDate attribute in S3.</p>
    public let lastModifiedDateCondition: FilterExpression?
    /// <p>A structure that maps names of parameters used in the S3 path of a dataset to their definitions.</p>
    public let parameters: [String:DatasetParameter]?

    public init (
        filesLimit: FilesLimit? = nil,
        lastModifiedDateCondition: FilterExpression? = nil,
        parameters: [String:DatasetParameter]? = nil
    )
    {
        self.filesLimit = filesLimit
        self.lastModifiedDateCondition = lastModifiedDateCondition
        self.parameters = parameters
    }
}

extension Project: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case datasetName = "DatasetName"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case openDate = "OpenDate"
        case openedBy = "OpenedBy"
        case recipeName = "RecipeName"
        case resourceArn = "ResourceArn"
        case roleArn = "RoleArn"
        case sample = "Sample"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openDate = openDate {
            try encodeContainer.encode(openDate.timeIntervalSince1970, forKey: .openDate)
        }
        if let openedBy = openedBy {
            try encodeContainer.encode(openedBy, forKey: .openedBy)
        }
        if let recipeName = recipeName {
            try encodeContainer.encode(recipeName, forKey: .recipeName)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sample = sample {
            try encodeContainer.encode(sample, forKey: .sample)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let recipeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeName)
        recipeName = recipeNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let sampleDecoded = try containerValues.decodeIfPresent(Sample.self, forKey: .sample)
        sample = sampleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let openedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .openedBy)
        openedBy = openedByDecoded
        let openDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .openDate)
        openDate = openDateDecoded
    }
}

extension Project: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Project(accountId: \(String(describing: accountId)), createDate: \(String(describing: createDate)), createdBy: \(String(describing: createdBy)), datasetName: \(String(describing: datasetName)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), openDate: \(String(describing: openDate)), openedBy: \(String(describing: openedBy)), recipeName: \(String(describing: recipeName)), resourceArn: \(String(describing: resourceArn)), roleArn: \(String(describing: roleArn)), sample: \(String(describing: sample)), tags: \(String(describing: tags)))"}
}

/// <p>Represents all of the attributes of a DataBrew project.</p>
public struct Project: Equatable {
    /// <p>The ID of the AWS account that owns the project.</p>
    public let accountId: String?
    /// <p>The date and time that the project was created.</p>
    public let createDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the user who crated the project.</p>
    public let createdBy: String?
    /// <p>The dataset that the project is to act upon.</p>
    public let datasetName: String?
    /// <p>The Amazon Resource Name (ARN) of the user who last modified the project.</p>
    public let lastModifiedBy: String?
    /// <p>The last modification date and time for the project.</p>
    public let lastModifiedDate: Date?
    /// <p>The unique name of a project.</p>
    public let name: String?
    /// <p>The date and time when the project was opened.</p>
    public let openDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the user that opened the project for use.</p>
    public let openedBy: String?
    /// <p>The name of a recipe that will be developed during a project session.</p>
    public let recipeName: String?
    /// <p>The Amazon Resource Name (ARN) for the project.</p>
    public let resourceArn: String?
    /// <p>The Amazon Resource Name (ARN) of the role that will be assumed for this
    ///             project.</p>
    public let roleArn: String?
    /// <p>The sample size and sampling type to apply to the data. If this parameter isn't
    ///             specified, then the sample consists of the first 500 rows from the dataset.</p>
    public let sample: Sample?
    /// <p>Metadata tags that have been applied to the project.</p>
    public let tags: [String:String]?

    public init (
        accountId: String? = nil,
        createDate: Date? = nil,
        createdBy: String? = nil,
        datasetName: String? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedDate: Date? = nil,
        name: String? = nil,
        openDate: Date? = nil,
        openedBy: String? = nil,
        recipeName: String? = nil,
        resourceArn: String? = nil,
        roleArn: String? = nil,
        sample: Sample? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accountId = accountId
        self.createDate = createDate
        self.createdBy = createdBy
        self.datasetName = datasetName
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.openDate = openDate
        self.openedBy = openedBy
        self.recipeName = recipeName
        self.resourceArn = resourceArn
        self.roleArn = roleArn
        self.sample = sample
        self.tags = tags
    }
}

public struct PublishRecipeInputBodyMiddleware: Middleware {
    public let id: String = "PublishRecipeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishRecipeInput>
    public typealias MOutput = OperationOutput<PublishRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishRecipeOutputError>
}

extension PublishRecipeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishRecipeInput(description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension PublishRecipeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct PublishRecipeInputHeadersMiddleware: Middleware {
    public let id: String = "PublishRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishRecipeInput>
    public typealias MOutput = OperationOutput<PublishRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishRecipeOutputError>
}

public struct PublishRecipeInputQueryItemMiddleware: Middleware {
    public let id: String = "PublishRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishRecipeInput>
    public typealias MOutput = OperationOutput<PublishRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishRecipeOutputError>
}

public struct PublishRecipeInput: Equatable {
    /// <p>A description of the recipe to be published, for this version of the recipe.</p>
    public let description: String?
    /// <p>The name of the recipe to be published.</p>
    public let name: String?

    public init (
        description: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

struct PublishRecipeInputBody: Equatable {
    public let description: String?
}

extension PublishRecipeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension PublishRecipeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishRecipeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishRecipeOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishRecipeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishRecipeOutputResponse(name: \(String(describing: name)))"}
}

extension PublishRecipeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PublishRecipeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct PublishRecipeOutputResponse: Equatable {
    /// <p>The name of the recipe that you published.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct PublishRecipeOutputResponseBody: Equatable {
    public let name: String?
}

extension PublishRecipeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Recipe: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case description = "Description"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case projectName = "ProjectName"
        case publishedBy = "PublishedBy"
        case publishedDate = "PublishedDate"
        case recipeVersion = "RecipeVersion"
        case resourceArn = "ResourceArn"
        case steps = "Steps"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let publishedBy = publishedBy {
            try encodeContainer.encode(publishedBy, forKey: .publishedBy)
        }
        if let publishedDate = publishedDate {
            try encodeContainer.encode(publishedDate.timeIntervalSince1970, forKey: .publishedDate)
        }
        if let recipeVersion = recipeVersion {
            try encodeContainer.encode(recipeVersion, forKey: .recipeVersion)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for recipesteplist0 in steps {
                try stepsContainer.encode(recipesteplist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let publishedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publishedBy)
        publishedBy = publishedByDecoded
        let publishedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .publishedDate)
        publishedDate = publishedDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let stepsContainer = try containerValues.decodeIfPresent([RecipeStep?].self, forKey: .steps)
        var stepsDecoded0:[RecipeStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [RecipeStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let recipeVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeVersion)
        recipeVersion = recipeVersionDecoded
    }
}

extension Recipe: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Recipe(createDate: \(String(describing: createDate)), createdBy: \(String(describing: createdBy)), description: \(String(describing: description)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), projectName: \(String(describing: projectName)), publishedBy: \(String(describing: publishedBy)), publishedDate: \(String(describing: publishedDate)), recipeVersion: \(String(describing: recipeVersion)), resourceArn: \(String(describing: resourceArn)), steps: \(String(describing: steps)), tags: \(String(describing: tags)))"}
}

/// <p>Represents one or more actions to be performed on a DataBrew dataset.</p>
public struct Recipe: Equatable {
    /// <p>The date and time that the recipe was created.</p>
    public let createDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the user who created the recipe.</p>
    public let createdBy: String?
    /// <p>The description of the recipe.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the user who last modified the recipe.</p>
    public let lastModifiedBy: String?
    /// <p>The last modification date and time of the recipe.</p>
    public let lastModifiedDate: Date?
    /// <p>The unique name for the recipe.</p>
    public let name: String?
    /// <p>The name of the project that the recipe is associated with.</p>
    public let projectName: String?
    /// <p>The Amazon Resource Name (ARN) of the user who published the recipe.</p>
    public let publishedBy: String?
    /// <p>The date and time when the recipe was published.</p>
    public let publishedDate: Date?
    /// <p>The identifier for the version for the recipe. Must be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Numeric version (<code>X.Y</code>) - <code>X</code> and <code>Y</code> stand
    ///                     for major and minor version numbers. The maximum length of each is 6 digits, and
    ///                     neither can be negative values. Both <code>X</code> and <code>Y</code> are
    ///                     required, and "0.0" isn't a valid version.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>LATEST_WORKING</code> - the most recent valid version being developed in
    ///                     a DataBrew project.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>LATEST_PUBLISHED</code> - the most recent published version.</p>
    ///             </li>
    ///          </ul>
    public let recipeVersion: String?
    /// <p>The Amazon Resource Name (ARN) for the recipe.</p>
    public let resourceArn: String?
    /// <p>A list of steps that are defined by the recipe.</p>
    public let steps: [RecipeStep]?
    /// <p>Metadata tags that have been applied to the recipe.</p>
    public let tags: [String:String]?

    public init (
        createDate: Date? = nil,
        createdBy: String? = nil,
        description: String? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedDate: Date? = nil,
        name: String? = nil,
        projectName: String? = nil,
        publishedBy: String? = nil,
        publishedDate: Date? = nil,
        recipeVersion: String? = nil,
        resourceArn: String? = nil,
        steps: [RecipeStep]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createDate = createDate
        self.createdBy = createdBy
        self.description = description
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.projectName = projectName
        self.publishedBy = publishedBy
        self.publishedDate = publishedDate
        self.recipeVersion = recipeVersion
        self.resourceArn = resourceArn
        self.steps = steps
        self.tags = tags
    }
}

extension RecipeAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case operation = "Operation"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametermap0) in parameters {
                try parametersContainer.encode(parametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operation)
        operation = operationDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametervalue0) in parametersContainer {
                if let parametervalue0 = parametervalue0 {
                    parametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension RecipeAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecipeAction(operation: \(String(describing: operation)), parameters: \(String(describing: parameters)))"}
}

/// <p>Represents a transformation and associated parameters that are used to apply a change
///             to a DataBrew dataset. For more information, see <a href="https://docs.aws.amazon.com/databrew/latest/dg/recipe-structure.html">Recipe structure</a> and <a href="https://docs.aws.amazon.com/databrew/latest/dg/recipe-actions-reference.html">Recipe
///                 actions reference</a>.</p>
public struct RecipeAction: Equatable {
    /// <p>The name of a valid DataBrew transformation to be performed on the data.</p>
    public let operation: String?
    /// <p>Contextual parameters for the transformation.</p>
    public let parameters: [String:String]?

    public init (
        operation: String? = nil,
        parameters: [String:String]? = nil
    )
    {
        self.operation = operation
        self.parameters = parameters
    }
}

extension RecipeReference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case recipeVersion = "RecipeVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeVersion = recipeVersion {
            try encodeContainer.encode(recipeVersion, forKey: .recipeVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let recipeVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeVersion)
        recipeVersion = recipeVersionDecoded
    }
}

extension RecipeReference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecipeReference(name: \(String(describing: name)), recipeVersion: \(String(describing: recipeVersion)))"}
}

/// <p>Represents the name and version of a DataBrew recipe.</p>
public struct RecipeReference: Equatable {
    /// <p>The name of the recipe.</p>
    public let name: String?
    /// <p>The identifier for the version for the recipe. </p>
    public let recipeVersion: String?

    public init (
        name: String? = nil,
        recipeVersion: String? = nil
    )
    {
        self.name = name
        self.recipeVersion = recipeVersion
    }
}

extension RecipeStep: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case conditionExpressions = "ConditionExpressions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let conditionExpressions = conditionExpressions {
            var conditionExpressionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditionExpressions)
            for conditionexpressionlist0 in conditionExpressions {
                try conditionExpressionsContainer.encode(conditionexpressionlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(RecipeAction.self, forKey: .action)
        action = actionDecoded
        let conditionExpressionsContainer = try containerValues.decodeIfPresent([ConditionExpression?].self, forKey: .conditionExpressions)
        var conditionExpressionsDecoded0:[ConditionExpression]? = nil
        if let conditionExpressionsContainer = conditionExpressionsContainer {
            conditionExpressionsDecoded0 = [ConditionExpression]()
            for structure0 in conditionExpressionsContainer {
                if let structure0 = structure0 {
                    conditionExpressionsDecoded0?.append(structure0)
                }
            }
        }
        conditionExpressions = conditionExpressionsDecoded0
    }
}

extension RecipeStep: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecipeStep(action: \(String(describing: action)), conditionExpressions: \(String(describing: conditionExpressions)))"}
}

/// <p>Represents a single step from a DataBrew recipe to be performed.</p>
public struct RecipeStep: Equatable {
    /// <p>The particular action to be performed in the recipe step.</p>
    public let action: RecipeAction?
    /// <p>One or more conditions that must be met for the recipe step to succeed.</p>
    ///         <note>
    ///             <p>All of the conditions in the array must be met. In other words, all of the
    ///                 conditions must be combined using a logical AND operation.</p>
    ///         </note>
    public let conditionExpressions: [ConditionExpression]?

    public init (
        action: RecipeAction? = nil,
        conditionExpressions: [ConditionExpression]? = nil
    )
    {
        self.action = action
        self.conditionExpressions = conditionExpressions
    }
}

extension RecipeVersionErrorDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case recipeVersion = "RecipeVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let recipeVersion = recipeVersion {
            try encodeContainer.encode(recipeVersion, forKey: .recipeVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let recipeVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipeVersion)
        recipeVersion = recipeVersionDecoded
    }
}

extension RecipeVersionErrorDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecipeVersionErrorDetail(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), recipeVersion: \(String(describing: recipeVersion)))"}
}

/// <p>Represents any errors encountered when attempting to delete multiple recipe
///             versions.</p>
public struct RecipeVersionErrorDetail: Equatable {
    /// <p>The HTTP status code for the error.</p>
    public let errorCode: String?
    /// <p>The text of the error message.</p>
    public let errorMessage: String?
    /// <p>The identifier for the recipe version associated with this error.</p>
    public let recipeVersion: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        recipeVersion: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.recipeVersion = recipeVersion
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more resources can't be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension S3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Location(bucket: \(String(describing: bucket)), key: \(String(describing: key)))"}
}

/// <p>Represents an Amazon S3 location (bucket name and object key) where DataBrew can read
///             input data, or write output from a job.</p>
public struct S3Location: Equatable {
    /// <p>The S3 bucket name.</p>
    public let bucket: String?
    /// <p>The unique name of the object in the bucket.</p>
    public let key: String?

    public init (
        bucket: String? = nil,
        key: String? = nil
    )
    {
        self.bucket = bucket
        self.key = key
    }
}

extension Sample: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case size = "Size"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .size)
        size = sizeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SampleType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Sample: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Sample(size: \(String(describing: size)), type: \(String(describing: type)))"}
}

/// <p>Represents the sample size and sampling type for DataBrew to use for interactive data
///             analysis.</p>
public struct Sample: Equatable {
    /// <p>The number of rows in the sample.</p>
    public let size: Int?
    /// <p>The way in which DataBrew obtains rows from a dataset.</p>
    public let type: SampleType?

    public init (
        size: Int? = nil,
        type: SampleType? = nil
    )
    {
        self.size = size
        self.type = type
    }
}

public enum SampleMode {
    case customRows
    case fullDataset
    case sdkUnknown(String)
}

extension SampleMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SampleMode] {
        return [
            .customRows,
            .fullDataset,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .customRows: return "CUSTOM_ROWS"
        case .fullDataset: return "FULL_DATASET"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SampleMode(rawValue: rawValue) ?? SampleMode.sdkUnknown(rawValue)
    }
}

public enum SampleType {
    case firstN
    case lastN
    case random
    case sdkUnknown(String)
}

extension SampleType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SampleType] {
        return [
            .firstN,
            .lastN,
            .random,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .firstN: return "FIRST_N"
        case .lastN: return "LAST_N"
        case .random: return "RANDOM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SampleType(rawValue: rawValue) ?? SampleType.sdkUnknown(rawValue)
    }
}

extension Schedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case createDate = "CreateDate"
        case createdBy = "CreatedBy"
        case cronExpression = "CronExpression"
        case jobNames = "JobNames"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createDate = createDate {
            try encodeContainer.encode(createDate.timeIntervalSince1970, forKey: .createDate)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let cronExpression = cronExpression {
            try encodeContainer.encode(cronExpression, forKey: .cronExpression)
        }
        if let jobNames = jobNames {
            var jobNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobNames)
            for jobnamelist0 in jobNames {
                try jobNamesContainer.encode(jobnamelist0)
            }
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createDate)
        createDate = createDateDecoded
        let jobNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .jobNames)
        var jobNamesDecoded0:[String]? = nil
        if let jobNamesContainer = jobNamesContainer {
            jobNamesDecoded0 = [String]()
            for string0 in jobNamesContainer {
                if let string0 = string0 {
                    jobNamesDecoded0?.append(string0)
                }
            }
        }
        jobNames = jobNamesDecoded0
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let cronExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cronExpression)
        cronExpression = cronExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Schedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Schedule(accountId: \(String(describing: accountId)), createDate: \(String(describing: createDate)), createdBy: \(String(describing: createdBy)), cronExpression: \(String(describing: cronExpression)), jobNames: \(String(describing: jobNames)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

/// <p>Represents one or more dates and times when a job is to run.</p>
public struct Schedule: Equatable {
    /// <p>The ID of the AWS account that owns the schedule.</p>
    public let accountId: String?
    /// <p>The date and time that the schedule was created.</p>
    public let createDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the user who created the schedule.</p>
    public let createdBy: String?
    /// <p>The dates and times when the job is to run. For more information, see <a href="https://docs.aws.amazon.com/databrew/latest/dg/jobs.cron.html">Cron
    ///                 expressions</a> in the <i>AWS Glue DataBrew Developer
    ///             Guide</i>.</p>
    public let cronExpression: String?
    /// <p>A list of jobs to be run, according to the schedule.</p>
    public let jobNames: [String]?
    /// <p>The Amazon Resource Name (ARN) of the user who last modified the schedule.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time when the schedule was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The name of the schedule.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the schedule.</p>
    public let resourceArn: String?
    /// <p>Metadata tags that have been applied to the schedule.</p>
    public let tags: [String:String]?

    public init (
        accountId: String? = nil,
        createDate: Date? = nil,
        createdBy: String? = nil,
        cronExpression: String? = nil,
        jobNames: [String]? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedDate: Date? = nil,
        name: String? = nil,
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accountId = accountId
        self.createDate = createDate
        self.createdBy = createdBy
        self.cronExpression = cronExpression
        self.jobNames = jobNames
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct SendProjectSessionActionInputBodyMiddleware: Middleware {
    public let id: String = "SendProjectSessionActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendProjectSessionActionInput>,
                  next: H) -> Swift.Result<OperationOutput<SendProjectSessionActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendProjectSessionActionInput>
    public typealias MOutput = OperationOutput<SendProjectSessionActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendProjectSessionActionOutputError>
}

extension SendProjectSessionActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendProjectSessionActionInput(clientSessionId: \(String(describing: clientSessionId)), name: \(String(describing: name)), preview: \(String(describing: preview)), recipeStep: \(String(describing: recipeStep)), stepIndex: \(String(describing: stepIndex)), viewFrame: \(String(describing: viewFrame)))"}
}

extension SendProjectSessionActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientSessionId = "ClientSessionId"
        case preview = "Preview"
        case recipeStep = "RecipeStep"
        case stepIndex = "StepIndex"
        case viewFrame = "ViewFrame"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientSessionId = clientSessionId {
            try encodeContainer.encode(clientSessionId, forKey: .clientSessionId)
        }
        if preview != false {
            try encodeContainer.encode(preview, forKey: .preview)
        }
        if let recipeStep = recipeStep {
            try encodeContainer.encode(recipeStep, forKey: .recipeStep)
        }
        if let stepIndex = stepIndex {
            try encodeContainer.encode(stepIndex, forKey: .stepIndex)
        }
        if let viewFrame = viewFrame {
            try encodeContainer.encode(viewFrame, forKey: .viewFrame)
        }
    }
}

public struct SendProjectSessionActionInputHeadersMiddleware: Middleware {
    public let id: String = "SendProjectSessionActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendProjectSessionActionInput>,
                  next: H) -> Swift.Result<OperationOutput<SendProjectSessionActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendProjectSessionActionInput>
    public typealias MOutput = OperationOutput<SendProjectSessionActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendProjectSessionActionOutputError>
}

public struct SendProjectSessionActionInputQueryItemMiddleware: Middleware {
    public let id: String = "SendProjectSessionActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendProjectSessionActionInput>,
                  next: H) -> Swift.Result<OperationOutput<SendProjectSessionActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendProjectSessionActionInput>
    public typealias MOutput = OperationOutput<SendProjectSessionActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendProjectSessionActionOutputError>
}

public struct SendProjectSessionActionInput: Equatable {
    /// <p>A unique identifier for an interactive session that's currently open and ready for
    ///             work. The action will be performed on this session.</p>
    public let clientSessionId: String?
    /// <p>The name of the project to apply the action to.</p>
    public let name: String?
    /// <p>If true, the result of the recipe step will be returned, but not applied.</p>
    public let preview: Bool
    /// <p>Represents a single step from a DataBrew recipe to be performed.</p>
    public let recipeStep: RecipeStep?
    /// <p>The index from which to preview a step. This index is used to preview the result of
    ///             steps that have already been applied, so that the resulting view frame is from earlier
    ///             in the view frame stack.</p>
    public let stepIndex: Int?
    /// <p>Represents the data being transformed during an action.</p>
    public let viewFrame: ViewFrame?

    public init (
        clientSessionId: String? = nil,
        name: String? = nil,
        preview: Bool = false,
        recipeStep: RecipeStep? = nil,
        stepIndex: Int? = nil,
        viewFrame: ViewFrame? = nil
    )
    {
        self.clientSessionId = clientSessionId
        self.name = name
        self.preview = preview
        self.recipeStep = recipeStep
        self.stepIndex = stepIndex
        self.viewFrame = viewFrame
    }
}

struct SendProjectSessionActionInputBody: Equatable {
    public let preview: Bool
    public let recipeStep: RecipeStep?
    public let stepIndex: Int?
    public let clientSessionId: String?
    public let viewFrame: ViewFrame?
}

extension SendProjectSessionActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientSessionId = "ClientSessionId"
        case preview = "Preview"
        case recipeStep = "RecipeStep"
        case stepIndex = "StepIndex"
        case viewFrame = "ViewFrame"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previewDecoded = try containerValues.decode(Bool.self, forKey: .preview)
        preview = previewDecoded
        let recipeStepDecoded = try containerValues.decodeIfPresent(RecipeStep.self, forKey: .recipeStep)
        recipeStep = recipeStepDecoded
        let stepIndexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stepIndex)
        stepIndex = stepIndexDecoded
        let clientSessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSessionId)
        clientSessionId = clientSessionIdDecoded
        let viewFrameDecoded = try containerValues.decodeIfPresent(ViewFrame.self, forKey: .viewFrame)
        viewFrame = viewFrameDecoded
    }
}

extension SendProjectSessionActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendProjectSessionActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendProjectSessionActionOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendProjectSessionActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendProjectSessionActionOutputResponse(actionId: \(String(describing: actionId)), name: \(String(describing: name)), result: \(String(describing: result)))"}
}

extension SendProjectSessionActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendProjectSessionActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionId = output.actionId
            self.name = output.name
            self.result = output.result
        } else {
            self.actionId = nil
            self.name = nil
            self.result = nil
        }
    }
}

public struct SendProjectSessionActionOutputResponse: Equatable {
    /// <p>A unique identifier for the action that was performed.</p>
    public let actionId: Int?
    /// <p>The name of the project that was affected by the action.</p>
    public let name: String?
    /// <p>A message indicating the result of performing the action.</p>
    public let result: String?

    public init (
        actionId: Int? = nil,
        name: String? = nil,
        result: String? = nil
    )
    {
        self.actionId = actionId
        self.name = name
        self.result = result
    }
}

struct SendProjectSessionActionOutputResponseBody: Equatable {
    public let result: String?
    public let name: String?
    public let actionId: Int?
}

extension SendProjectSessionActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionId = "ActionId"
        case name = "Name"
        case result = "Result"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .result)
        result = resultDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A service quota is exceeded.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SessionStatus {
    case assigned
    case failed
    case initializing
    case provisioning
    case ready
    case recycling
    case rotating
    case terminated
    case terminating
    case updating
    case sdkUnknown(String)
}

extension SessionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SessionStatus] {
        return [
            .assigned,
            .failed,
            .initializing,
            .provisioning,
            .ready,
            .recycling,
            .rotating,
            .terminated,
            .terminating,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assigned: return "ASSIGNED"
        case .failed: return "FAILED"
        case .initializing: return "INITIALIZING"
        case .provisioning: return "PROVISIONING"
        case .ready: return "READY"
        case .recycling: return "RECYCLING"
        case .rotating: return "ROTATING"
        case .terminated: return "TERMINATED"
        case .terminating: return "TERMINATING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SessionStatus(rawValue: rawValue) ?? SessionStatus.sdkUnknown(rawValue)
    }
}

public enum Source {
    case database
    case datacatalog
    case s3
    case sdkUnknown(String)
}

extension Source : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Source] {
        return [
            .database,
            .datacatalog,
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .database: return "DATABASE"
        case .datacatalog: return "DATA-CATALOG"
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Source(rawValue: rawValue) ?? Source.sdkUnknown(rawValue)
    }
}

extension StartJobRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartJobRunInput(name: \(String(describing: name)))"}
}

extension StartJobRunInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StartJobRunInputHeadersMiddleware: Middleware {
    public let id: String = "StartJobRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobRunInput>
    public typealias MOutput = OperationOutput<StartJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobRunOutputError>
}

public struct StartJobRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StartJobRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobRunInput>
    public typealias MOutput = OperationOutput<StartJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobRunOutputError>
}

public struct StartJobRunInput: Equatable {
    /// <p>The name of the job to be run.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StartJobRunInputBody: Equatable {
}

extension StartJobRunInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StartJobRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartJobRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartJobRunOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartJobRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartJobRunOutputResponse(runId: \(String(describing: runId)))"}
}

extension StartJobRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartJobRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.runId = output.runId
        } else {
            self.runId = nil
        }
    }
}

public struct StartJobRunOutputResponse: Equatable {
    /// <p>A system-generated identifier for this particular job run.</p>
    public let runId: String?

    public init (
        runId: String? = nil
    )
    {
        self.runId = runId
    }
}

struct StartJobRunOutputResponseBody: Equatable {
    public let runId: String?
}

extension StartJobRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case runId = "RunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
    }
}

public struct StartProjectSessionInputBodyMiddleware: Middleware {
    public let id: String = "StartProjectSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartProjectSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartProjectSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartProjectSessionInput>
    public typealias MOutput = OperationOutput<StartProjectSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartProjectSessionOutputError>
}

extension StartProjectSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartProjectSessionInput(assumeControl: \(String(describing: assumeControl)), name: \(String(describing: name)))"}
}

extension StartProjectSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assumeControl = "AssumeControl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assumeControl != false {
            try encodeContainer.encode(assumeControl, forKey: .assumeControl)
        }
    }
}

public struct StartProjectSessionInputHeadersMiddleware: Middleware {
    public let id: String = "StartProjectSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartProjectSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartProjectSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartProjectSessionInput>
    public typealias MOutput = OperationOutput<StartProjectSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartProjectSessionOutputError>
}

public struct StartProjectSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartProjectSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartProjectSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartProjectSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartProjectSessionInput>
    public typealias MOutput = OperationOutput<StartProjectSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartProjectSessionOutputError>
}

public struct StartProjectSessionInput: Equatable {
    /// <p>A value that, if true, enables you to take control of a session, even if a different
    ///             client is currently accessing the project.</p>
    public let assumeControl: Bool
    /// <p>The name of the project to act upon.</p>
    public let name: String?

    public init (
        assumeControl: Bool = false,
        name: String? = nil
    )
    {
        self.assumeControl = assumeControl
        self.name = name
    }
}

struct StartProjectSessionInputBody: Equatable {
    public let assumeControl: Bool
}

extension StartProjectSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assumeControl = "AssumeControl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assumeControlDecoded = try containerValues.decode(Bool.self, forKey: .assumeControl)
        assumeControl = assumeControlDecoded
    }
}

extension StartProjectSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartProjectSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartProjectSessionOutputError: Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartProjectSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartProjectSessionOutputResponse(clientSessionId: \(String(describing: clientSessionId)), name: \(String(describing: name)))"}
}

extension StartProjectSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartProjectSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientSessionId = output.clientSessionId
            self.name = output.name
        } else {
            self.clientSessionId = nil
            self.name = nil
        }
    }
}

public struct StartProjectSessionOutputResponse: Equatable {
    /// <p>A system-generated identifier for the session.</p>
    public let clientSessionId: String?
    /// <p>The name of the project to be acted upon.</p>
    public let name: String?

    public init (
        clientSessionId: String? = nil,
        name: String? = nil
    )
    {
        self.clientSessionId = clientSessionId
        self.name = name
    }
}

struct StartProjectSessionOutputResponseBody: Equatable {
    public let name: String?
    public let clientSessionId: String?
}

extension StartProjectSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientSessionId = "ClientSessionId"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let clientSessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSessionId)
        clientSessionId = clientSessionIdDecoded
    }
}

extension StopJobRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopJobRunInput(name: \(String(describing: name)), runId: \(String(describing: runId)))"}
}

extension StopJobRunInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopJobRunInputHeadersMiddleware: Middleware {
    public let id: String = "StopJobRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopJobRunInput>
    public typealias MOutput = OperationOutput<StopJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopJobRunOutputError>
}

public struct StopJobRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StopJobRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopJobRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopJobRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopJobRunInput>
    public typealias MOutput = OperationOutput<StopJobRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopJobRunOutputError>
}

public struct StopJobRunInput: Equatable {
    /// <p>The name of the job to be stopped.</p>
    public let name: String?
    /// <p>The ID of the job run to be stopped.</p>
    public let runId: String?

    public init (
        name: String? = nil,
        runId: String? = nil
    )
    {
        self.name = name
        self.runId = runId
    }
}

struct StopJobRunInputBody: Equatable {
}

extension StopJobRunInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopJobRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopJobRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopJobRunOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopJobRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopJobRunOutputResponse(runId: \(String(describing: runId)))"}
}

extension StopJobRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopJobRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.runId = output.runId
        } else {
            self.runId = nil
        }
    }
}

public struct StopJobRunOutputResponse: Equatable {
    /// <p>The ID of the job run that you stopped.</p>
    public let runId: String?

    public init (
        runId: String? = nil
    )
    {
        self.runId = runId
    }
}

struct StopJobRunOutputResponseBody: Equatable {
    public let runId: String?
}

extension StopJobRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case runId = "RunId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runId)
        runId = runIdDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The DataBrew resource to which tags should be added. The value for this parameter is
    ///             an Amazon Resource Name (ARN). For DataBrew, you can tag a dataset, a job, a project, or
    ///             a recipe.</p>
    public let resourceArn: String?
    /// <p>One or more tags to be assigned to the resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>A DataBrew resource from which you want to remove a tag or tags. The value for this
    ///             parameter is an Amazon Resource Name (ARN). </p>
    public let resourceArn: String?
    /// <p>The tag keys (names) of one or more tags to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDatasetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatasetInput>
    public typealias MOutput = OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatasetOutputError>
}

extension UpdateDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatasetInput(format: \(String(describing: format)), formatOptions: \(String(describing: formatOptions)), input: \(String(describing: input)), name: \(String(describing: name)), pathOptions: \(String(describing: pathOptions)))"}
}

extension UpdateDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case format = "Format"
        case formatOptions = "FormatOptions"
        case input = "Input"
        case pathOptions = "PathOptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let formatOptions = formatOptions {
            try encodeContainer.encode(formatOptions, forKey: .formatOptions)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let pathOptions = pathOptions {
            try encodeContainer.encode(pathOptions, forKey: .pathOptions)
        }
    }
}

public struct UpdateDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatasetInput>
    public typealias MOutput = OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatasetOutputError>
}

public struct UpdateDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatasetInput>
    public typealias MOutput = OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatasetOutputError>
}

public struct UpdateDatasetInput: Equatable {
    /// <p>The file format of a dataset that is created from an S3 file or folder.</p>
    public let format: InputFormat?
    /// <p>Represents a set of options that define the structure of either comma-separated value (CSV), Excel, or JSON input.</p>
    public let formatOptions: FormatOptions?
    /// <p>Represents information on how DataBrew can find data, in either the AWS Glue Data Catalog or
    ///             Amazon S3.</p>
    public let input: Input?
    /// <p>The name of the dataset to be updated.</p>
    public let name: String?
    /// <p>A set of options that defines how DataBrew interprets an S3 path of the dataset.</p>
    public let pathOptions: PathOptions?

    public init (
        format: InputFormat? = nil,
        formatOptions: FormatOptions? = nil,
        input: Input? = nil,
        name: String? = nil,
        pathOptions: PathOptions? = nil
    )
    {
        self.format = format
        self.formatOptions = formatOptions
        self.input = input
        self.name = name
        self.pathOptions = pathOptions
    }
}

struct UpdateDatasetInputBody: Equatable {
    public let format: InputFormat?
    public let formatOptions: FormatOptions?
    public let input: Input?
    public let pathOptions: PathOptions?
}

extension UpdateDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case format = "Format"
        case formatOptions = "FormatOptions"
        case input = "Input"
        case pathOptions = "PathOptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(InputFormat.self, forKey: .format)
        format = formatDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(FormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
        let inputDecoded = try containerValues.decodeIfPresent(Input.self, forKey: .input)
        input = inputDecoded
        let pathOptionsDecoded = try containerValues.decodeIfPresent(PathOptions.self, forKey: .pathOptions)
        pathOptions = pathOptionsDecoded
    }
}

extension UpdateDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatasetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatasetOutputResponse(name: \(String(describing: name)))"}
}

extension UpdateDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateDatasetOutputResponse: Equatable {
    /// <p>The name of the dataset that you updated.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateDatasetOutputResponseBody: Equatable {
    public let name: String?
}

extension UpdateDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct UpdateProfileJobInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProfileJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProfileJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProfileJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProfileJobInput>
    public typealias MOutput = OperationOutput<UpdateProfileJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProfileJobOutputError>
}

extension UpdateProfileJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProfileJobInput(encryptionKeyArn: \(String(describing: encryptionKeyArn)), encryptionMode: \(String(describing: encryptionMode)), jobSample: \(String(describing: jobSample)), logSubscription: \(String(describing: logSubscription)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), name: \(String(describing: name)), outputLocation: \(String(describing: outputLocation)), roleArn: \(String(describing: roleArn)), timeout: \(String(describing: timeout)))"}
}

extension UpdateProfileJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case jobSample = "JobSample"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case outputLocation = "OutputLocation"
        case roleArn = "RoleArn"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let jobSample = jobSample {
            try encodeContainer.encode(jobSample, forKey: .jobSample)
        }
        if let logSubscription = logSubscription {
            try encodeContainer.encode(logSubscription.rawValue, forKey: .logSubscription)
        }
        if maxCapacity != 0 {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if maxRetries != 0 {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }
}

public struct UpdateProfileJobInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProfileJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProfileJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProfileJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProfileJobInput>
    public typealias MOutput = OperationOutput<UpdateProfileJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProfileJobOutputError>
}

public struct UpdateProfileJobInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProfileJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProfileJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProfileJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProfileJobInput>
    public typealias MOutput = OperationOutput<UpdateProfileJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProfileJobOutputError>
}

public struct UpdateProfileJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an encryption key that is used to protect the
    ///             job.</p>
    public let encryptionKeyArn: String?
    /// <p>The encryption mode for the job, which can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>SSE-KMS</code> - Server-side encryption with keys managed by AWS
    ///                     KMS.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SSE-S3</code> - Server-side encryption with keys managed by Amazon
    ///                     S3.</p>
    ///             </li>
    ///          </ul>
    public let encryptionMode: EncryptionMode?
    /// <p>Sample configuration for Profile Jobs only. Determines the number of rows on which the
    ///             Profile job will be executed. If a JobSample value is not provided for profile jobs, the
    ///             default value will be used. The default value is CUSTOM_ROWS for the mode parameter and
    ///             20000 for the size parameter.</p>
    public let jobSample: JobSample?
    /// <p>Enables or disables Amazon CloudWatch logging for the job. If logging is enabled,
    ///             CloudWatch writes one log stream for each job run.</p>
    public let logSubscription: LogSubscription?
    /// <p>The maximum number of compute nodes that DataBrew can use when the job processes
    ///             data.</p>
    public let maxCapacity: Int
    /// <p>The maximum number of times to retry the job after a job run fails.</p>
    public let maxRetries: Int
    /// <p>The name of the job to be updated.</p>
    public let name: String?
    /// <p>Represents an Amazon S3 location (bucket name and object key) where DataBrew can read
    ///             input data, or write output from a job.</p>
    public let outputLocation: S3Location?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role to
    ///             be assumed when DataBrew runs the job.</p>
    public let roleArn: String?
    /// <p>The job's timeout in minutes. A job that attempts to run longer than this timeout
    ///             period ends with a status of <code>TIMEOUT</code>.</p>
    public let timeout: Int

    public init (
        encryptionKeyArn: String? = nil,
        encryptionMode: EncryptionMode? = nil,
        jobSample: JobSample? = nil,
        logSubscription: LogSubscription? = nil,
        maxCapacity: Int = 0,
        maxRetries: Int = 0,
        name: String? = nil,
        outputLocation: S3Location? = nil,
        roleArn: String? = nil,
        timeout: Int = 0
    )
    {
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionMode = encryptionMode
        self.jobSample = jobSample
        self.logSubscription = logSubscription
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.outputLocation = outputLocation
        self.roleArn = roleArn
        self.timeout = timeout
    }
}

struct UpdateProfileJobInputBody: Equatable {
    public let encryptionKeyArn: String?
    public let encryptionMode: EncryptionMode?
    public let logSubscription: LogSubscription?
    public let maxCapacity: Int
    public let maxRetries: Int
    public let outputLocation: S3Location?
    public let roleArn: String?
    public let timeout: Int
    public let jobSample: JobSample?
}

extension UpdateProfileJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case jobSample = "JobSample"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case outputLocation = "OutputLocation"
        case roleArn = "RoleArn"
        case timeout = "Timeout"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(EncryptionMode.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let maxCapacityDecoded = try containerValues.decode(Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let maxRetriesDecoded = try containerValues.decode(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let timeoutDecoded = try containerValues.decode(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let jobSampleDecoded = try containerValues.decodeIfPresent(JobSample.self, forKey: .jobSample)
        jobSample = jobSampleDecoded
    }
}

extension UpdateProfileJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProfileJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProfileJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProfileJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProfileJobOutputResponse(name: \(String(describing: name)))"}
}

extension UpdateProfileJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateProfileJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateProfileJobOutputResponse: Equatable {
    /// <p>The name of the job that was updated.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateProfileJobOutputResponseBody: Equatable {
    public let name: String?
}

extension UpdateProfileJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct UpdateProjectInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

extension UpdateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectInput(name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), sample: \(String(describing: sample)))"}
}

extension UpdateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
        case sample = "Sample"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sample = sample {
            try encodeContainer.encode(sample, forKey: .sample)
        }
    }
}

public struct UpdateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInput: Equatable {
    /// <p>The name of the project to be updated.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to be assumed for this request.</p>
    public let roleArn: String?
    /// <p>Represents the sample size and sampling type for DataBrew to use for interactive data
    ///             analysis.</p>
    public let sample: Sample?

    public init (
        name: String? = nil,
        roleArn: String? = nil,
        sample: Sample? = nil
    )
    {
        self.name = name
        self.roleArn = roleArn
        self.sample = sample
    }
}

struct UpdateProjectInputBody: Equatable {
    public let sample: Sample?
    public let roleArn: String?
}

extension UpdateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
        case sample = "Sample"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sampleDecoded = try containerValues.decodeIfPresent(Sample.self, forKey: .sample)
        sample = sampleDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectOutputResponse(lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)))"}
}

extension UpdateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lastModifiedDate = output.lastModifiedDate
            self.name = output.name
        } else {
            self.lastModifiedDate = nil
            self.name = nil
        }
    }
}

public struct UpdateProjectOutputResponse: Equatable {
    /// <p>The date and time that the project was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The name of the project that you updated.</p>
    public let name: String?

    public init (
        lastModifiedDate: Date? = nil,
        name: String? = nil
    )
    {
        self.lastModifiedDate = lastModifiedDate
        self.name = name
    }
}

struct UpdateProjectOutputResponseBody: Equatable {
    public let lastModifiedDate: Date?
    public let name: String?
}

extension UpdateProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct UpdateRecipeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRecipeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecipeInput>
    public typealias MOutput = OperationOutput<UpdateRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecipeOutputError>
}

extension UpdateRecipeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRecipeInput(description: \(String(describing: description)), name: \(String(describing: name)), steps: \(String(describing: steps)))"}
}

extension UpdateRecipeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case steps = "Steps"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for recipesteplist0 in steps {
                try stepsContainer.encode(recipesteplist0)
            }
        }
    }
}

public struct UpdateRecipeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecipeInput>
    public typealias MOutput = OperationOutput<UpdateRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecipeOutputError>
}

public struct UpdateRecipeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecipeInput>
    public typealias MOutput = OperationOutput<UpdateRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecipeOutputError>
}

public struct UpdateRecipeInput: Equatable {
    /// <p>A description of the recipe.</p>
    public let description: String?
    /// <p>The name of the recipe to be updated.</p>
    public let name: String?
    /// <p>One or more steps to be performed by the recipe. Each step consists of an action, and
    ///             the conditions under which the action should succeed.</p>
    public let steps: [RecipeStep]?

    public init (
        description: String? = nil,
        name: String? = nil,
        steps: [RecipeStep]? = nil
    )
    {
        self.description = description
        self.name = name
        self.steps = steps
    }
}

struct UpdateRecipeInputBody: Equatable {
    public let description: String?
    public let steps: [RecipeStep]?
}

extension UpdateRecipeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case steps = "Steps"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stepsContainer = try containerValues.decodeIfPresent([RecipeStep?].self, forKey: .steps)
        var stepsDecoded0:[RecipeStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [RecipeStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

public struct UpdateRecipeJobInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRecipeJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecipeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecipeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecipeJobInput>
    public typealias MOutput = OperationOutput<UpdateRecipeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecipeJobOutputError>
}

extension UpdateRecipeJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRecipeJobInput(encryptionKeyArn: \(String(describing: encryptionKeyArn)), encryptionMode: \(String(describing: encryptionMode)), logSubscription: \(String(describing: logSubscription)), maxCapacity: \(String(describing: maxCapacity)), maxRetries: \(String(describing: maxRetries)), name: \(String(describing: name)), outputs: \(String(describing: outputs)), roleArn: \(String(describing: roleArn)), timeout: \(String(describing: timeout)))"}
}

extension UpdateRecipeJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case outputs = "Outputs"
        case roleArn = "RoleArn"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let encryptionMode = encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let logSubscription = logSubscription {
            try encodeContainer.encode(logSubscription.rawValue, forKey: .logSubscription)
        }
        if maxCapacity != 0 {
            try encodeContainer.encode(maxCapacity, forKey: .maxCapacity)
        }
        if maxRetries != 0 {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for outputlist0 in outputs {
                try outputsContainer.encode(outputlist0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }
}

public struct UpdateRecipeJobInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRecipeJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecipeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecipeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecipeJobInput>
    public typealias MOutput = OperationOutput<UpdateRecipeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecipeJobOutputError>
}

public struct UpdateRecipeJobInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRecipeJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecipeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecipeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecipeJobInput>
    public typealias MOutput = OperationOutput<UpdateRecipeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecipeJobOutputError>
}

public struct UpdateRecipeJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an encryption key that is used to protect the
    ///             job.</p>
    public let encryptionKeyArn: String?
    /// <p>The encryption mode for the job, which can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>SSE-KMS</code> - Server-side encryption with keys managed by AWS
    ///                     KMS.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SSE-S3</code> - Server-side encryption with keys managed by Amazon
    ///                     S3.</p>
    ///             </li>
    ///          </ul>
    public let encryptionMode: EncryptionMode?
    /// <p>Enables or disables Amazon CloudWatch logging for the job. If logging is enabled,
    ///             CloudWatch writes one log stream for each job run.</p>
    public let logSubscription: LogSubscription?
    /// <p>The maximum number of nodes that DataBrew can consume when the job processes
    ///             data.</p>
    public let maxCapacity: Int
    /// <p>The maximum number of times to retry the job after a job run fails.</p>
    public let maxRetries: Int
    /// <p>The name of the job to update.</p>
    public let name: String?
    /// <p>One or more artifacts that represent the output from running the job. </p>
    public let outputs: [Output]?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role to
    ///             be assumed when DataBrew runs the job.</p>
    public let roleArn: String?
    /// <p>The job's timeout in minutes. A job that attempts to run longer than this timeout
    ///             period ends with a status of <code>TIMEOUT</code>.</p>
    public let timeout: Int

    public init (
        encryptionKeyArn: String? = nil,
        encryptionMode: EncryptionMode? = nil,
        logSubscription: LogSubscription? = nil,
        maxCapacity: Int = 0,
        maxRetries: Int = 0,
        name: String? = nil,
        outputs: [Output]? = nil,
        roleArn: String? = nil,
        timeout: Int = 0
    )
    {
        self.encryptionKeyArn = encryptionKeyArn
        self.encryptionMode = encryptionMode
        self.logSubscription = logSubscription
        self.maxCapacity = maxCapacity
        self.maxRetries = maxRetries
        self.name = name
        self.outputs = outputs
        self.roleArn = roleArn
        self.timeout = timeout
    }
}

struct UpdateRecipeJobInputBody: Equatable {
    public let encryptionKeyArn: String?
    public let encryptionMode: EncryptionMode?
    public let logSubscription: LogSubscription?
    public let maxCapacity: Int
    public let maxRetries: Int
    public let outputs: [Output]?
    public let roleArn: String?
    public let timeout: Int
}

extension UpdateRecipeJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionKeyArn = "EncryptionKeyArn"
        case encryptionMode = "EncryptionMode"
        case logSubscription = "LogSubscription"
        case maxCapacity = "MaxCapacity"
        case maxRetries = "MaxRetries"
        case outputs = "Outputs"
        case roleArn = "RoleArn"
        case timeout = "Timeout"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(EncryptionMode.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let logSubscriptionDecoded = try containerValues.decodeIfPresent(LogSubscription.self, forKey: .logSubscription)
        logSubscription = logSubscriptionDecoded
        let maxCapacityDecoded = try containerValues.decode(Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let maxRetriesDecoded = try containerValues.decode(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let outputsContainer = try containerValues.decodeIfPresent([Output?].self, forKey: .outputs)
        var outputsDecoded0:[Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let timeoutDecoded = try containerValues.decode(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension UpdateRecipeJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRecipeJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRecipeJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRecipeJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRecipeJobOutputResponse(name: \(String(describing: name)))"}
}

extension UpdateRecipeJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRecipeJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateRecipeJobOutputResponse: Equatable {
    /// <p>The name of the job that you updated.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateRecipeJobOutputResponseBody: Equatable {
    public let name: String?
}

extension UpdateRecipeJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateRecipeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRecipeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRecipeOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRecipeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRecipeOutputResponse(name: \(String(describing: name)))"}
}

extension UpdateRecipeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRecipeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateRecipeOutputResponse: Equatable {
    /// <p>The name of the recipe that was updated.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateRecipeOutputResponseBody: Equatable {
    public let name: String?
}

extension UpdateRecipeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct UpdateScheduleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateScheduleInput>
    public typealias MOutput = OperationOutput<UpdateScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateScheduleOutputError>
}

extension UpdateScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateScheduleInput(cronExpression: \(String(describing: cronExpression)), jobNames: \(String(describing: jobNames)), name: \(String(describing: name)))"}
}

extension UpdateScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cronExpression = "CronExpression"
        case jobNames = "JobNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cronExpression = cronExpression {
            try encodeContainer.encode(cronExpression, forKey: .cronExpression)
        }
        if let jobNames = jobNames {
            var jobNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobNames)
            for jobnamelist0 in jobNames {
                try jobNamesContainer.encode(jobnamelist0)
            }
        }
    }
}

public struct UpdateScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateScheduleInput>
    public typealias MOutput = OperationOutput<UpdateScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateScheduleOutputError>
}

public struct UpdateScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateScheduleInput>
    public typealias MOutput = OperationOutput<UpdateScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateScheduleOutputError>
}

public struct UpdateScheduleInput: Equatable {
    /// <p>The date or dates and time or times when the jobs are to be run. For more information,
    ///             see <a href="https://docs.aws.amazon.com/databrew/latest/dg/jobs.cron.html">Cron
    ///                 expressions</a> in the <i>AWS Glue DataBrew Developer
    ///             Guide</i>.</p>
    public let cronExpression: String?
    /// <p>The name or names of one or more jobs to be run for this schedule.</p>
    public let jobNames: [String]?
    /// <p>The name of the schedule to update.</p>
    public let name: String?

    public init (
        cronExpression: String? = nil,
        jobNames: [String]? = nil,
        name: String? = nil
    )
    {
        self.cronExpression = cronExpression
        self.jobNames = jobNames
        self.name = name
    }
}

struct UpdateScheduleInputBody: Equatable {
    public let jobNames: [String]?
    public let cronExpression: String?
}

extension UpdateScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cronExpression = "CronExpression"
        case jobNames = "JobNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .jobNames)
        var jobNamesDecoded0:[String]? = nil
        if let jobNamesContainer = jobNamesContainer {
            jobNamesDecoded0 = [String]()
            for string0 in jobNamesContainer {
                if let string0 = string0 {
                    jobNamesDecoded0?.append(string0)
                }
            }
        }
        jobNames = jobNamesDecoded0
        let cronExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cronExpression)
        cronExpression = cronExpressionDecoded
    }
}

extension UpdateScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateScheduleOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateScheduleOutputResponse(name: \(String(describing: name)))"}
}

extension UpdateScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateScheduleOutputResponse: Equatable {
    /// <p>The name of the schedule that was updated.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateScheduleOutputResponseBody: Equatable {
    public let name: String?
}

extension UpdateScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input parameters for this request failed validation.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ViewFrame: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnRange = "ColumnRange"
        case hiddenColumns = "HiddenColumns"
        case startColumnIndex = "StartColumnIndex"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnRange = columnRange {
            try encodeContainer.encode(columnRange, forKey: .columnRange)
        }
        if let hiddenColumns = hiddenColumns {
            var hiddenColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hiddenColumns)
            for hiddencolumnlist0 in hiddenColumns {
                try hiddenColumnsContainer.encode(hiddencolumnlist0)
            }
        }
        if let startColumnIndex = startColumnIndex {
            try encodeContainer.encode(startColumnIndex, forKey: .startColumnIndex)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startColumnIndexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startColumnIndex)
        startColumnIndex = startColumnIndexDecoded
        let columnRangeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .columnRange)
        columnRange = columnRangeDecoded
        let hiddenColumnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .hiddenColumns)
        var hiddenColumnsDecoded0:[String]? = nil
        if let hiddenColumnsContainer = hiddenColumnsContainer {
            hiddenColumnsDecoded0 = [String]()
            for string0 in hiddenColumnsContainer {
                if let string0 = string0 {
                    hiddenColumnsDecoded0?.append(string0)
                }
            }
        }
        hiddenColumns = hiddenColumnsDecoded0
    }
}

extension ViewFrame: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ViewFrame(columnRange: \(String(describing: columnRange)), hiddenColumns: \(String(describing: hiddenColumns)), startColumnIndex: \(String(describing: startColumnIndex)))"}
}

/// <p>Represents the data being transformed during an action.</p>
public struct ViewFrame: Equatable {
    /// <p>The number of columns to include in the view frame, beginning with the
    ///                 <code>StartColumnIndex</code> value and ignoring any columns in the
    ///                 <code>HiddenColumns</code> list.</p>
    public let columnRange: Int?
    /// <p>A list of columns to hide in the view frame.</p>
    public let hiddenColumns: [String]?
    /// <p>The starting index for the range of columns to return in the view frame.</p>
    public let startColumnIndex: Int?

    public init (
        columnRange: Int? = nil,
        hiddenColumns: [String]? = nil,
        startColumnIndex: Int? = nil
    )
    {
        self.columnRange = columnRange
        self.hiddenColumns = hiddenColumns
        self.startColumnIndex = startColumnIndex
    }
}
