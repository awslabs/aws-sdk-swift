// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CloseTunnelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloseTunnelInput(delete: \(String(describing: delete)), tunnelId: \(String(describing: tunnelId)))"}
}

extension CloseTunnelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CloseTunnelInputHeadersMiddleware: Middleware {
    public let id: String = "CloseTunnelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CloseTunnelInput>,
                  next: H) -> Swift.Result<OperationOutput<CloseTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CloseTunnelInput>
    public typealias MOutput = OperationOutput<CloseTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CloseTunnelOutputError>
}

public struct CloseTunnelInputQueryItemMiddleware: Middleware {
    public let id: String = "CloseTunnelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CloseTunnelInput>,
                  next: H) -> Swift.Result<OperationOutput<CloseTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CloseTunnelInput>
    public typealias MOutput = OperationOutput<CloseTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CloseTunnelOutputError>
}

public struct CloseTunnelInput: Equatable {
    /// <p>When set to true, AWS IoT Secure Tunneling deletes the tunnel data
    /// 			immediately.</p>
    public let delete: Bool
    /// <p>The ID of the tunnel to close.</p>
    public let tunnelId: String?

    public init (
        delete: Bool = false,
        tunnelId: String? = nil
    )
    {
        self.delete = delete
        self.tunnelId = tunnelId
    }
}

struct CloseTunnelInputBody: Equatable {
}

extension CloseTunnelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CloseTunnelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CloseTunnelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CloseTunnelOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CloseTunnelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloseTunnelOutputResponse()"}
}

extension CloseTunnelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CloseTunnelOutputResponse: Equatable {

    public init() {}
}

struct CloseTunnelOutputResponseBody: Equatable {
}

extension CloseTunnelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ConnectionState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastUpdatedAt
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension ConnectionState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionState(lastUpdatedAt: \(String(describing: lastUpdatedAt)), status: \(String(describing: status)))"}
}

/// <p>The state of a connection.</p>
public struct ConnectionState: Equatable {
    /// <p>The last time the connection status was updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The connection status of the tunnel. Valid values are <code>CONNECTED</code> and
    /// 				<code>DISCONNECTED</code>.</p>
    public let status: ConnectionStatus?

    public init (
        lastUpdatedAt: Date? = nil,
        status: ConnectionStatus? = nil
    )
    {
        self.lastUpdatedAt = lastUpdatedAt
        self.status = status
    }
}

public enum ConnectionStatus {
    case connected
    case disconnected
    case sdkUnknown(String)
}

extension ConnectionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionStatus] {
        return [
            .connected,
            .disconnected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connected: return "CONNECTED"
        case .disconnected: return "DISCONNECTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
    }
}

extension DescribeTunnelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTunnelInput(tunnelId: \(String(describing: tunnelId)))"}
}

extension DescribeTunnelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeTunnelInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTunnelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTunnelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTunnelInput>
    public typealias MOutput = OperationOutput<DescribeTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTunnelOutputError>
}

public struct DescribeTunnelInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTunnelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTunnelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTunnelInput>
    public typealias MOutput = OperationOutput<DescribeTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTunnelOutputError>
}

public struct DescribeTunnelInput: Equatable {
    /// <p>The tunnel to describe.</p>
    public let tunnelId: String?

    public init (
        tunnelId: String? = nil
    )
    {
        self.tunnelId = tunnelId
    }
}

struct DescribeTunnelInputBody: Equatable {
}

extension DescribeTunnelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeTunnelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTunnelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTunnelOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTunnelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTunnelOutputResponse(tunnel: \(String(describing: tunnel)))"}
}

extension DescribeTunnelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTunnelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tunnel = output.tunnel
        } else {
            self.tunnel = nil
        }
    }
}

public struct DescribeTunnelOutputResponse: Equatable {
    /// <p>The tunnel being described.</p>
    public let tunnel: Tunnel?

    public init (
        tunnel: Tunnel? = nil
    )
    {
        self.tunnel = tunnel
    }
}

struct DescribeTunnelOutputResponseBody: Equatable {
    public let tunnel: Tunnel?
}

extension DescribeTunnelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tunnel
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelDecoded = try containerValues.decodeIfPresent(Tunnel.self, forKey: .tunnel)
        tunnel = tunnelDecoded
    }
}

extension DestinationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case services
        case thingName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for servicelist0 in services {
                try servicesContainer.encode(servicelist0)
            }
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let servicesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .services)
        var servicesDecoded0:[String]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [String]()
            for string0 in servicesContainer {
                if let string0 = string0 {
                    servicesDecoded0?.append(string0)
                }
            }
        }
        services = servicesDecoded0
    }
}

extension DestinationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationConfig(services: \(String(describing: services)), thingName: \(String(describing: thingName)))"}
}

/// <p>The destination configuration.</p>
public struct DestinationConfig: Equatable {
    /// <p>A list of service names that identity the target application. The AWS IoT client running on the destination device reads
    /// 			this value and uses it to look up a port or an IP address and a port. The AWS IoT client
    /// 			instantiates the local proxy which uses this information to connect to the destination
    /// 			application.</p>
    public let services: [String]?
    /// <p>The name of the IoT thing to which you want to connect.</p>
    public let thingName: String?

    public init (
        services: [String]? = nil,
        thingName: String? = nil
    )
    {
        self.services = services
        self.thingName = thingName
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when a tunnel limit is exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The resource ARN.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags for the specified resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTunnelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTunnelsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), thingName: \(String(describing: thingName)))"}
}

extension ListTunnelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTunnelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTunnelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTunnelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTunnelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTunnelsInput>
    public typealias MOutput = OperationOutput<ListTunnelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTunnelsOutputError>
}

public struct ListTunnelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTunnelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTunnelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTunnelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTunnelsInput>
    public typealias MOutput = OperationOutput<ListTunnelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTunnelsOutputError>
}

public struct ListTunnelsInput: Equatable {
    /// <p>The maximum number of results to return at once.</p>
    public let maxResults: Int
    /// <p>A token to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The name of the IoT thing associated with the destination device.</p>
    public let thingName: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        thingName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thingName = thingName
    }
}

struct ListTunnelsInputBody: Equatable {
}

extension ListTunnelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTunnelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTunnelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTunnelsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTunnelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTunnelsOutputResponse(nextToken: \(String(describing: nextToken)), tunnelSummaries: \(String(describing: tunnelSummaries)))"}
}

extension ListTunnelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTunnelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tunnelSummaries = output.tunnelSummaries
        } else {
            self.nextToken = nil
            self.tunnelSummaries = nil
        }
    }
}

public struct ListTunnelsOutputResponse: Equatable {
    /// <p>A token to used to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>A short description of the tunnels in an AWS account.</p>
    public let tunnelSummaries: [TunnelSummary]?

    public init (
        nextToken: String? = nil,
        tunnelSummaries: [TunnelSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tunnelSummaries = tunnelSummaries
    }
}

struct ListTunnelsOutputResponseBody: Equatable {
    public let tunnelSummaries: [TunnelSummary]?
    public let nextToken: String?
}

extension ListTunnelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tunnelSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelSummariesContainer = try containerValues.decodeIfPresent([TunnelSummary?].self, forKey: .tunnelSummaries)
        var tunnelSummariesDecoded0:[TunnelSummary]? = nil
        if let tunnelSummariesContainer = tunnelSummariesContainer {
            tunnelSummariesDecoded0 = [TunnelSummary]()
            for structure0 in tunnelSummariesContainer {
                if let structure0 = structure0 {
                    tunnelSummariesDecoded0?.append(structure0)
                }
            }
        }
        tunnelSummaries = tunnelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct OpenTunnelInputBodyMiddleware: Middleware {
    public let id: String = "OpenTunnelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<OpenTunnelInput>,
                  next: H) -> Swift.Result<OperationOutput<OpenTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<OpenTunnelInput>
    public typealias MOutput = OperationOutput<OpenTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<OpenTunnelOutputError>
}

extension OpenTunnelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpenTunnelInput(description: \(String(describing: description)), destinationConfig: \(String(describing: destinationConfig)), tags: \(String(describing: tags)), timeoutConfig: \(String(describing: timeoutConfig)))"}
}

extension OpenTunnelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case destinationConfig
        case tags
        case timeoutConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let timeoutConfig = timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }
}

public struct OpenTunnelInputHeadersMiddleware: Middleware {
    public let id: String = "OpenTunnelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<OpenTunnelInput>,
                  next: H) -> Swift.Result<OperationOutput<OpenTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<OpenTunnelInput>
    public typealias MOutput = OperationOutput<OpenTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<OpenTunnelOutputError>
}

public struct OpenTunnelInputQueryItemMiddleware: Middleware {
    public let id: String = "OpenTunnelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<OpenTunnelInput>,
                  next: H) -> Swift.Result<OperationOutput<OpenTunnelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<OpenTunnelInput>
    public typealias MOutput = OperationOutput<OpenTunnelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<OpenTunnelOutputError>
}

public struct OpenTunnelInput: Equatable {
    /// <p>A short text description of the tunnel. </p>
    public let description: String?
    /// <p>The destination configuration for the OpenTunnel request.</p>
    public let destinationConfig: DestinationConfig?
    /// <p>A collection of tag metadata.</p>
    public let tags: [Tag]?
    /// <p>Timeout configuration for a tunnel.</p>
    public let timeoutConfig: TimeoutConfig?

    public init (
        description: String? = nil,
        destinationConfig: DestinationConfig? = nil,
        tags: [Tag]? = nil,
        timeoutConfig: TimeoutConfig? = nil
    )
    {
        self.description = description
        self.destinationConfig = destinationConfig
        self.tags = tags
        self.timeoutConfig = timeoutConfig
    }
}

struct OpenTunnelInputBody: Equatable {
    public let description: String?
    public let tags: [Tag]?
    public let destinationConfig: DestinationConfig?
    public let timeoutConfig: TimeoutConfig?
}

extension OpenTunnelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case destinationConfig
        case tags
        case timeoutConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
    }
}

extension OpenTunnelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension OpenTunnelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum OpenTunnelOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension OpenTunnelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpenTunnelOutputResponse(destinationAccessToken: \(String(describing: destinationAccessToken)), sourceAccessToken: \(String(describing: sourceAccessToken)), tunnelArn: \(String(describing: tunnelArn)), tunnelId: \(String(describing: tunnelId)))"}
}

extension OpenTunnelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpenTunnelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.destinationAccessToken = output.destinationAccessToken
            self.sourceAccessToken = output.sourceAccessToken
            self.tunnelArn = output.tunnelArn
            self.tunnelId = output.tunnelId
        } else {
            self.destinationAccessToken = nil
            self.sourceAccessToken = nil
            self.tunnelArn = nil
            self.tunnelId = nil
        }
    }
}

public struct OpenTunnelOutputResponse: Equatable {
    /// <p>The access token the destination local proxy uses to connect to AWS IoT Secure
    /// 			Tunneling.</p>
    public let destinationAccessToken: String?
    /// <p>The access token the source local proxy uses to connect to AWS IoT Secure
    /// 			Tunneling.</p>
    public let sourceAccessToken: String?
    /// <p>The Amazon Resource Name for the tunnel. The tunnel ARN format is
    /// 				<code>arn:aws:tunnel:<region>:<account-id>:tunnel/<tunnel-id></code>
    ///          </p>
    public let tunnelArn: String?
    /// <p>A unique alpha-numeric tunnel ID.</p>
    public let tunnelId: String?

    public init (
        destinationAccessToken: String? = nil,
        sourceAccessToken: String? = nil,
        tunnelArn: String? = nil,
        tunnelId: String? = nil
    )
    {
        self.destinationAccessToken = destinationAccessToken
        self.sourceAccessToken = sourceAccessToken
        self.tunnelArn = tunnelArn
        self.tunnelId = tunnelId
    }
}

struct OpenTunnelOutputResponseBody: Equatable {
    public let tunnelId: String?
    public let tunnelArn: String?
    public let sourceAccessToken: String?
    public let destinationAccessToken: String?
}

extension OpenTunnelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationAccessToken
        case sourceAccessToken
        case tunnelArn
        case tunnelId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tunnelId)
        tunnelId = tunnelIdDecoded
        let tunnelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tunnelArn)
        tunnelArn = tunnelArnDecoded
        let sourceAccessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceAccessToken)
        sourceAccessToken = sourceAccessTokenDecoded
        let destinationAccessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationAccessToken)
        destinationAccessToken = destinationAccessTokenDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when an operation is attempted on a resource that does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>An arbitary key/value pair used to add searchable metadata to secure tunnel
/// 			resources.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: String?
    /// <p>The tags for the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TimeoutConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxLifetimeTimeoutMinutes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxLifetimeTimeoutMinutes != 0 {
            try encodeContainer.encode(maxLifetimeTimeoutMinutes, forKey: .maxLifetimeTimeoutMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxLifetimeTimeoutMinutesDecoded = try containerValues.decode(Int.self, forKey: .maxLifetimeTimeoutMinutes)
        maxLifetimeTimeoutMinutes = maxLifetimeTimeoutMinutesDecoded
    }
}

extension TimeoutConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeoutConfig(maxLifetimeTimeoutMinutes: \(String(describing: maxLifetimeTimeoutMinutes)))"}
}

/// <p>Tunnel timeout configuration.</p>
public struct TimeoutConfig: Equatable {
    /// <p>The maximum amount of time (in minutes) a tunnel can remain open. If not specified,
    /// 			maxLifetimeTimeoutMinutes defaults to 720 minutes. Valid values are from 1 minute to 12
    /// 			hours (720 minutes) </p>
    public let maxLifetimeTimeoutMinutes: Int

    public init (
        maxLifetimeTimeoutMinutes: Int = 0
    )
    {
        self.maxLifetimeTimeoutMinutes = maxLifetimeTimeoutMinutes
    }
}

extension Tunnel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case description
        case destinationConfig
        case destinationConnectionState
        case lastUpdatedAt
        case sourceConnectionState
        case status
        case tags
        case timeoutConfig
        case tunnelArn
        case tunnelId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let destinationConnectionState = destinationConnectionState {
            try encodeContainer.encode(destinationConnectionState, forKey: .destinationConnectionState)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let sourceConnectionState = sourceConnectionState {
            try encodeContainer.encode(sourceConnectionState, forKey: .sourceConnectionState)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let timeoutConfig = timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
        if let tunnelArn = tunnelArn {
            try encodeContainer.encode(tunnelArn, forKey: .tunnelArn)
        }
        if let tunnelId = tunnelId {
            try encodeContainer.encode(tunnelId, forKey: .tunnelId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tunnelId)
        tunnelId = tunnelIdDecoded
        let tunnelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tunnelArn)
        tunnelArn = tunnelArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TunnelStatus.self, forKey: .status)
        status = statusDecoded
        let sourceConnectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .sourceConnectionState)
        sourceConnectionState = sourceConnectionStateDecoded
        let destinationConnectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .destinationConnectionState)
        destinationConnectionState = destinationConnectionStateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension Tunnel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tunnel(createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), destinationConfig: \(String(describing: destinationConfig)), destinationConnectionState: \(String(describing: destinationConnectionState)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), sourceConnectionState: \(String(describing: sourceConnectionState)), status: \(String(describing: status)), tags: \(String(describing: tags)), timeoutConfig: \(String(describing: timeoutConfig)), tunnelArn: \(String(describing: tunnelArn)), tunnelId: \(String(describing: tunnelId)))"}
}

/// <p>A connection between a source computer and a destination device.</p>
public struct Tunnel: Equatable {
    /// <p>The time when the tunnel was created.</p>
    public let createdAt: Date?
    /// <p>A description of the tunnel.</p>
    public let description: String?
    /// <p>The destination configuration that specifies the thing name of the destination
    /// 			device and a service name that the local proxy uses to connect to the destination
    /// 			application.</p>
    public let destinationConfig: DestinationConfig?
    /// <p>The connection state of the destination application.</p>
    public let destinationConnectionState: ConnectionState?
    /// <p>The last time the tunnel was updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The connection state of the source application.</p>
    public let sourceConnectionState: ConnectionState?
    /// <p>The status of a tunnel. Valid values are: Open and Closed.</p>
    public let status: TunnelStatus?
    /// <p>A list of tag metadata associated with the secure tunnel.</p>
    public let tags: [Tag]?
    /// <p>Timeout configuration for the tunnel.</p>
    public let timeoutConfig: TimeoutConfig?
    /// <p>The Amazon Resource Name (ARN) of a tunnel. The tunnel ARN format is
    /// 				<code>arn:aws:tunnel:<region>:<account-id>:tunnel/<tunnel-id></code>
    ///          </p>
    public let tunnelArn: String?
    /// <p>A unique alpha-numeric ID that identifies a tunnel.</p>
    public let tunnelId: String?

    public init (
        createdAt: Date? = nil,
        description: String? = nil,
        destinationConfig: DestinationConfig? = nil,
        destinationConnectionState: ConnectionState? = nil,
        lastUpdatedAt: Date? = nil,
        sourceConnectionState: ConnectionState? = nil,
        status: TunnelStatus? = nil,
        tags: [Tag]? = nil,
        timeoutConfig: TimeoutConfig? = nil,
        tunnelArn: String? = nil,
        tunnelId: String? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.destinationConfig = destinationConfig
        self.destinationConnectionState = destinationConnectionState
        self.lastUpdatedAt = lastUpdatedAt
        self.sourceConnectionState = sourceConnectionState
        self.status = status
        self.tags = tags
        self.timeoutConfig = timeoutConfig
        self.tunnelArn = tunnelArn
        self.tunnelId = tunnelId
    }
}

public enum TunnelStatus {
    case closed
    case `open`
    case sdkUnknown(String)
}

extension TunnelStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TunnelStatus] {
        return [
            .closed,
            .open,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .closed: return "CLOSED"
        case .open: return "OPEN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TunnelStatus(rawValue: rawValue) ?? TunnelStatus.sdkUnknown(rawValue)
    }
}

extension TunnelSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case description
        case lastUpdatedAt
        case status
        case tunnelArn
        case tunnelId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tunnelArn = tunnelArn {
            try encodeContainer.encode(tunnelArn, forKey: .tunnelArn)
        }
        if let tunnelId = tunnelId {
            try encodeContainer.encode(tunnelId, forKey: .tunnelId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tunnelId)
        tunnelId = tunnelIdDecoded
        let tunnelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tunnelArn)
        tunnelArn = tunnelArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TunnelStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension TunnelSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TunnelSummary(createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), status: \(String(describing: status)), tunnelArn: \(String(describing: tunnelArn)), tunnelId: \(String(describing: tunnelId)))"}
}

/// <p>Information about the tunnel.</p>
public struct TunnelSummary: Equatable {
    /// <p>The time the tunnel was created.</p>
    public let createdAt: Date?
    /// <p>A description of the tunnel.</p>
    public let description: String?
    /// <p>The time the tunnel was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The status of a tunnel. Valid values are: Open and Closed.</p>
    public let status: TunnelStatus?
    /// <p>The Amazon Resource Name of the tunnel. The tunnel ARN format is
    /// 				<code>arn:aws:tunnel:<region>:<account-id>:tunnel/<tunnel-id></code>
    ///          </p>
    public let tunnelArn: String?
    /// <p>The unique alpha-numeric identifier for the tunnel.</p>
    public let tunnelId: String?

    public init (
        createdAt: Date? = nil,
        description: String? = nil,
        lastUpdatedAt: Date? = nil,
        status: TunnelStatus? = nil,
        tunnelArn: String? = nil,
        tunnelId: String? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.lastUpdatedAt = lastUpdatedAt
        self.status = status
        self.tunnelArn = tunnelArn
        self.tunnelId = tunnelId
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The resource ARN.</p>
    public let resourceArn: String?
    /// <p>The keys of the tags to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
