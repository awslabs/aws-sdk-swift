// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Accelerator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case createdTime = "CreatedTime"
        case dnsName = "DnsName"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case ipSets = "IpSets"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dnsName = dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipSets = ipSets {
            var ipSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipSets)
            for ipsets0 in ipSets {
                try ipSetsContainer.encode(ipsets0)
            }
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let ipSetsContainer = try containerValues.decodeIfPresent([IpSet?].self, forKey: .ipSets)
        var ipSetsDecoded0:[IpSet]? = nil
        if let ipSetsContainer = ipSetsContainer {
            ipSetsDecoded0 = [IpSet]()
            for structure0 in ipSetsContainer {
                if let structure0 = structure0 {
                    ipSetsDecoded0?.append(structure0)
                }
            }
        }
        ipSets = ipSetsDecoded0
        let dnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AcceleratorStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension Accelerator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Accelerator(acceleratorArn: \(String(describing: acceleratorArn)), createdTime: \(String(describing: createdTime)), dnsName: \(String(describing: dnsName)), enabled: \(String(describing: enabled)), ipAddressType: \(String(describing: ipAddressType)), ipSets: \(String(describing: ipSets)), lastModifiedTime: \(String(describing: lastModifiedTime)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>An accelerator is a complex type that includes one or more listeners that process inbound connections and then direct
/// 			traffic to one or more endpoint groups, each of which includes endpoints, such as load balancers.</p>
public struct Accelerator: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator.</p>
    public let acceleratorArn: String?
    /// <p>The date and time that the accelerator was created.</p>
    public let createdTime: Date?
    /// <p>The Domain Name System (DNS) name that Global Accelerator creates that points to your accelerator's static IP addresses. </p>
    /// 		       <p>The naming convention for the DNS name is the following: A lowercase letter a,
    /// 			followed by a 16-bit random hex string, followed by .awsglobalaccelerator.com. For example:
    /// 			a1234567890abcdef.awsglobalaccelerator.com.</p>
    /// 		       <p>For more information about the default DNS name, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-accelerators.html#about-accelerators.dns-addressing">
    /// 			Support for DNS Addressing in Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let dnsName: String?
    /// <p>Indicates whether the accelerator is enabled. The value is true or false. The default value is true. </p>
    /// 		       <p>If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.</p>
    public let enabled: Bool?
    /// <p>The value for the address type must be IPv4.
    /// 			</p>
    public let ipAddressType: IpAddressType?
    /// <p>The static IP addresses that Global Accelerator associates with the accelerator.</p>
    public let ipSets: [IpSet]?
    /// <p>The date and time that the accelerator was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the accelerator. The name must contain only alphanumeric characters or
    /// 			hyphens (-), and must not begin or end with a hyphen.</p>
    public let name: String?
    /// <p>Describes the deployment status of the accelerator.</p>
    public let status: AcceleratorStatus?

    public init (
        acceleratorArn: String? = nil,
        createdTime: Date? = nil,
        dnsName: String? = nil,
        enabled: Bool? = nil,
        ipAddressType: IpAddressType? = nil,
        ipSets: [IpSet]? = nil,
        lastModifiedTime: Date? = nil,
        name: String? = nil,
        status: AcceleratorStatus? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.createdTime = createdTime
        self.dnsName = dnsName
        self.enabled = enabled
        self.ipAddressType = ipAddressType
        self.ipSets = ipSets
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.status = status
    }
}

extension AcceleratorAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowLogsEnabled = flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension AcceleratorAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceleratorAttributes(flowLogsEnabled: \(String(describing: flowLogsEnabled)), flowLogsS3Bucket: \(String(describing: flowLogsS3Bucket)), flowLogsS3Prefix: \(String(describing: flowLogsS3Prefix)))"}
}

/// <p>Attributes of an accelerator.</p>
public struct AcceleratorAttributes: Equatable {
    /// <p>Indicates whether flow logs are enabled. The default value is false. If the value is true,
    /// 				<code>FlowLogsS3Bucket</code> and <code>FlowLogsS3Prefix</code> must be specified.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html">Flow Logs</a> in
    /// 			the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let flowLogsEnabled: Bool?
    /// <p>The name of the Amazon S3 bucket for the flow logs. Attribute is required if <code>FlowLogsEnabled</code> is
    /// 				<code>true</code>. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the
    /// 			bucket.</p>
    public let flowLogsS3Bucket: String?
    /// <p>The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if
    /// 				<code>FlowLogsEnabled</code> is <code>true</code>.</p>
    /// 		       <p>If you donâ€™t specify a prefix, the flow logs are stored in the
    /// 			root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following:</p>
    /// 		       <p>s3-bucket_name//AWSLogs/aws_account_id</p>
    public let flowLogsS3Prefix: String?

    public init (
        flowLogsEnabled: Bool? = nil,
        flowLogsS3Bucket: String? = nil,
        flowLogsS3Prefix: String? = nil
    )
    {
        self.flowLogsEnabled = flowLogsEnabled
        self.flowLogsS3Bucket = flowLogsS3Bucket
        self.flowLogsS3Prefix = flowLogsS3Prefix
    }
}

extension AcceleratorNotDisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceleratorNotDisabledException(message: \(String(describing: message)))"}
}

extension AcceleratorNotDisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AcceleratorNotDisabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The accelerator that you specified could not be disabled.</p>
public struct AcceleratorNotDisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AcceleratorNotDisabledExceptionBody: Equatable {
    public let message: String?
}

extension AcceleratorNotDisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AcceleratorNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceleratorNotFoundException(message: \(String(describing: message)))"}
}

extension AcceleratorNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AcceleratorNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The accelerator that you specified doesn't exist.</p>
public struct AcceleratorNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AcceleratorNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension AcceleratorNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum AcceleratorStatus {
    case deployed
    case inProgress
    case sdkUnknown(String)
}

extension AcceleratorStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AcceleratorStatus] {
        return [
            .deployed,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deployed: return "DEPLOYED"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AcceleratorStatus(rawValue: rawValue) ?? AcceleratorStatus.sdkUnknown(rawValue)
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You don't have access permission.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AddCustomRoutingEndpointsInputBodyMiddleware: Middleware {
    public let id: String = "AddCustomRoutingEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddCustomRoutingEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddCustomRoutingEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddCustomRoutingEndpointsInput>
    public typealias MOutput = OperationOutput<AddCustomRoutingEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddCustomRoutingEndpointsOutputError>
}

extension AddCustomRoutingEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddCustomRoutingEndpointsInput(endpointConfigurations: \(String(describing: endpointConfigurations)), endpointGroupArn: \(String(describing: endpointGroupArn)))"}
}

extension AddCustomRoutingEndpointsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for customroutingendpointconfigurations0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(customroutingendpointconfigurations0)
            }
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

public struct AddCustomRoutingEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "AddCustomRoutingEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddCustomRoutingEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddCustomRoutingEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddCustomRoutingEndpointsInput>
    public typealias MOutput = OperationOutput<AddCustomRoutingEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddCustomRoutingEndpointsOutputError>
}

public struct AddCustomRoutingEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "AddCustomRoutingEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddCustomRoutingEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddCustomRoutingEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddCustomRoutingEndpointsInput>
    public typealias MOutput = OperationOutput<AddCustomRoutingEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddCustomRoutingEndpointsOutputError>
}

public struct AddCustomRoutingEndpointsInput: Equatable {
    /// <p>The list of endpoint objects to add to a custom routing accelerator.</p>
    public let endpointConfigurations: [CustomRoutingEndpointConfiguration]?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group for the custom routing endpoint.</p>
    public let endpointGroupArn: String?

    public init (
        endpointConfigurations: [CustomRoutingEndpointConfiguration]? = nil,
        endpointGroupArn: String? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
    }
}

struct AddCustomRoutingEndpointsInputBody: Equatable {
    public let endpointConfigurations: [CustomRoutingEndpointConfiguration]?
    public let endpointGroupArn: String?
}

extension AddCustomRoutingEndpointsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([CustomRoutingEndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[CustomRoutingEndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [CustomRoutingEndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension AddCustomRoutingEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddCustomRoutingEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointAlreadyExistsException" : self = .endpointAlreadyExistsException(try EndpointAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddCustomRoutingEndpointsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case endpointAlreadyExistsException(EndpointAlreadyExistsException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddCustomRoutingEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddCustomRoutingEndpointsOutputResponse(endpointDescriptions: \(String(describing: endpointDescriptions)), endpointGroupArn: \(String(describing: endpointGroupArn)))"}
}

extension AddCustomRoutingEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddCustomRoutingEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointDescriptions = output.endpointDescriptions
            self.endpointGroupArn = output.endpointGroupArn
        } else {
            self.endpointDescriptions = nil
            self.endpointGroupArn = nil
        }
    }
}

public struct AddCustomRoutingEndpointsOutputResponse: Equatable {
    /// <p>The endpoint objects added to the custom routing accelerator.</p>
    public let endpointDescriptions: [CustomRoutingEndpointDescription]?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group for the custom routing endpoint.</p>
    public let endpointGroupArn: String?

    public init (
        endpointDescriptions: [CustomRoutingEndpointDescription]? = nil,
        endpointGroupArn: String? = nil
    )
    {
        self.endpointDescriptions = endpointDescriptions
        self.endpointGroupArn = endpointGroupArn
    }
}

struct AddCustomRoutingEndpointsOutputResponseBody: Equatable {
    public let endpointDescriptions: [CustomRoutingEndpointDescription]?
    public let endpointGroupArn: String?
}

extension AddCustomRoutingEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([CustomRoutingEndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[CustomRoutingEndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [CustomRoutingEndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

public struct AdvertiseByoipCidrInputBodyMiddleware: Middleware {
    public let id: String = "AdvertiseByoipCidrInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdvertiseByoipCidrInput>,
                  next: H) -> Swift.Result<OperationOutput<AdvertiseByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdvertiseByoipCidrInput>
    public typealias MOutput = OperationOutput<AdvertiseByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdvertiseByoipCidrOutputError>
}

extension AdvertiseByoipCidrInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdvertiseByoipCidrInput(cidr: \(String(describing: cidr)))"}
}

extension AdvertiseByoipCidrInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }
}

public struct AdvertiseByoipCidrInputHeadersMiddleware: Middleware {
    public let id: String = "AdvertiseByoipCidrInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdvertiseByoipCidrInput>,
                  next: H) -> Swift.Result<OperationOutput<AdvertiseByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdvertiseByoipCidrInput>
    public typealias MOutput = OperationOutput<AdvertiseByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdvertiseByoipCidrOutputError>
}

public struct AdvertiseByoipCidrInputQueryItemMiddleware: Middleware {
    public let id: String = "AdvertiseByoipCidrInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdvertiseByoipCidrInput>,
                  next: H) -> Swift.Result<OperationOutput<AdvertiseByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdvertiseByoipCidrInput>
    public typealias MOutput = OperationOutput<AdvertiseByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdvertiseByoipCidrOutputError>
}

public struct AdvertiseByoipCidrInput: Equatable {
    /// <p>The address range, in CIDR notation. This must be the exact range that you provisioned.
    /// 			You can't advertise only a portion of the provisioned range.</p>
    public let cidr: String?

    public init (
        cidr: String? = nil
    )
    {
        self.cidr = cidr
    }
}

struct AdvertiseByoipCidrInputBody: Equatable {
    public let cidr: String?
}

extension AdvertiseByoipCidrInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension AdvertiseByoipCidrOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdvertiseByoipCidrOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ByoipCidrNotFoundException" : self = .byoipCidrNotFoundException(try ByoipCidrNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectCidrStateException" : self = .incorrectCidrStateException(try IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdvertiseByoipCidrOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case byoipCidrNotFoundException(ByoipCidrNotFoundException)
    case incorrectCidrStateException(IncorrectCidrStateException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdvertiseByoipCidrOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdvertiseByoipCidrOutputResponse(byoipCidr: \(String(describing: byoipCidr)))"}
}

extension AdvertiseByoipCidrOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AdvertiseByoipCidrOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct AdvertiseByoipCidrOutputResponse: Equatable {
    /// <p>Information about the address range.</p>
    public let byoipCidr: ByoipCidr?

    public init (
        byoipCidr: ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct AdvertiseByoipCidrOutputResponseBody: Equatable {
    public let byoipCidr: ByoipCidr?
}

extension AdvertiseByoipCidrOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

public struct AllowCustomRoutingTrafficInputBodyMiddleware: Middleware {
    public let id: String = "AllowCustomRoutingTrafficInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllowCustomRoutingTrafficInput>,
                  next: H) -> Swift.Result<OperationOutput<AllowCustomRoutingTrafficOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllowCustomRoutingTrafficInput>
    public typealias MOutput = OperationOutput<AllowCustomRoutingTrafficOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllowCustomRoutingTrafficOutputError>
}

extension AllowCustomRoutingTrafficInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllowCustomRoutingTrafficInput(allowAllTrafficToEndpoint: \(String(describing: allowAllTrafficToEndpoint)), destinationAddresses: \(String(describing: destinationAddresses)), destinationPorts: \(String(describing: destinationPorts)), endpointGroupArn: \(String(describing: endpointGroupArn)), endpointId: \(String(describing: endpointId)))"}
}

extension AllowCustomRoutingTrafficInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowAllTrafficToEndpoint = "AllowAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowAllTrafficToEndpoint = allowAllTrafficToEndpoint {
            try encodeContainer.encode(allowAllTrafficToEndpoint, forKey: .allowAllTrafficToEndpoint)
        }
        if let destinationAddresses = destinationAddresses {
            var destinationAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationAddresses)
            for destinationaddresses0 in destinationAddresses {
                try destinationAddressesContainer.encode(destinationaddresses0)
            }
        }
        if let destinationPorts = destinationPorts {
            var destinationPortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPorts)
            for destinationports0 in destinationPorts {
                try destinationPortsContainer.encode(destinationports0)
            }
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }
}

public struct AllowCustomRoutingTrafficInputHeadersMiddleware: Middleware {
    public let id: String = "AllowCustomRoutingTrafficInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllowCustomRoutingTrafficInput>,
                  next: H) -> Swift.Result<OperationOutput<AllowCustomRoutingTrafficOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllowCustomRoutingTrafficInput>
    public typealias MOutput = OperationOutput<AllowCustomRoutingTrafficOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllowCustomRoutingTrafficOutputError>
}

public struct AllowCustomRoutingTrafficInputQueryItemMiddleware: Middleware {
    public let id: String = "AllowCustomRoutingTrafficInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AllowCustomRoutingTrafficInput>,
                  next: H) -> Swift.Result<OperationOutput<AllowCustomRoutingTrafficOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AllowCustomRoutingTrafficInput>
    public typealias MOutput = OperationOutput<AllowCustomRoutingTrafficOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AllowCustomRoutingTrafficOutputError>
}

public struct AllowCustomRoutingTrafficInput: Equatable {
    /// <p>Indicates whether all destination IP addresses and ports for a specified VPC subnet endpoint can receive traffic
    /// 			from a custom routing accelerator. The value is TRUE or FALSE. </p>
    /// 		       <p>When set to TRUE, <i>all</i> destinations in the custom routing VPC subnet can receive traffic. Note
    /// 			that you cannot specify destination IP addresses and ports when the value is set to TRUE.</p>
    /// 		       <p>When set to FALSE (or not specified), you <i>must</i> specify a list of destination IP addresses that are allowed
    /// 			to receive traffic. A list of ports is optional. If you don't specify a list of ports, the ports that can accept traffic is
    /// 			the same as the ports configured for the endpoint group.</p>
    /// 		       <p>The default value is FALSE.</p>
    public let allowAllTrafficToEndpoint: Bool?
    /// <p>A list of specific Amazon EC2 instance IP addresses (destination addresses) in a subnet that you want to allow to receive
    /// 			traffic. The IP addresses must be a subset of the IP addresses that you specified for the endpoint group.</p>
    /// 		       <p>
    ///             <code>DestinationAddresses</code> is required if <code>AllowAllTrafficToEndpoint</code> is <code>FALSE</code> or is
    /// 		not specified.</p>
    public let destinationAddresses: [String]?
    /// <p>A list of specific Amazon EC2 instance ports (destination ports) that you want to allow to receive traffic.</p>
    public let destinationPorts: [Int]?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
    public let endpointGroupArn: String?
    /// <p>An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.</p>
    public let endpointId: String?

    public init (
        allowAllTrafficToEndpoint: Bool? = nil,
        destinationAddresses: [String]? = nil,
        destinationPorts: [Int]? = nil,
        endpointGroupArn: String? = nil,
        endpointId: String? = nil
    )
    {
        self.allowAllTrafficToEndpoint = allowAllTrafficToEndpoint
        self.destinationAddresses = destinationAddresses
        self.destinationPorts = destinationPorts
        self.endpointGroupArn = endpointGroupArn
        self.endpointId = endpointId
    }
}

struct AllowCustomRoutingTrafficInputBody: Equatable {
    public let endpointGroupArn: String?
    public let endpointId: String?
    public let destinationAddresses: [String]?
    public let destinationPorts: [Int]?
    public let allowAllTrafficToEndpoint: Bool?
}

extension AllowCustomRoutingTrafficInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowAllTrafficToEndpoint = "AllowAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .destinationAddresses)
        var destinationAddressesDecoded0:[String]? = nil
        if let destinationAddressesContainer = destinationAddressesContainer {
            destinationAddressesDecoded0 = [String]()
            for string0 in destinationAddressesContainer {
                if let string0 = string0 {
                    destinationAddressesDecoded0?.append(string0)
                }
            }
        }
        destinationAddresses = destinationAddressesDecoded0
        let destinationPortsContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .destinationPorts)
        var destinationPortsDecoded0:[Int]? = nil
        if let destinationPortsContainer = destinationPortsContainer {
            destinationPortsDecoded0 = [Int]()
            for integer0 in destinationPortsContainer {
                if let integer0 = integer0 {
                    destinationPortsDecoded0?.append(integer0)
                }
            }
        }
        destinationPorts = destinationPortsDecoded0
        let allowAllTrafficToEndpointDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowAllTrafficToEndpoint)
        allowAllTrafficToEndpoint = allowAllTrafficToEndpointDecoded
    }
}

extension AllowCustomRoutingTrafficOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AllowCustomRoutingTrafficOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AllowCustomRoutingTrafficOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AllowCustomRoutingTrafficOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllowCustomRoutingTrafficOutputResponse()"}
}

extension AllowCustomRoutingTrafficOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AllowCustomRoutingTrafficOutputResponse: Equatable {

    public init() {}
}

struct AllowCustomRoutingTrafficOutputResponseBody: Equatable {
}

extension AllowCustomRoutingTrafficOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AssociatedEndpointGroupFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociatedEndpointGroupFoundException(message: \(String(describing: message)))"}
}

extension AssociatedEndpointGroupFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociatedEndpointGroupFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The listener that you specified has an endpoint group associated with it. You must remove all dependent resources
/// 			from a listener before you can delete it.</p>
public struct AssociatedEndpointGroupFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AssociatedEndpointGroupFoundExceptionBody: Equatable {
    public let message: String?
}

extension AssociatedEndpointGroupFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociatedListenerFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociatedListenerFoundException(message: \(String(describing: message)))"}
}

extension AssociatedListenerFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociatedListenerFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The accelerator that you specified has a listener associated with it. You must remove all dependent resources from an
/// 			accelerator before you can delete it.</p>
public struct AssociatedListenerFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AssociatedListenerFoundExceptionBody: Equatable {
    public let message: String?
}

extension AssociatedListenerFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ByoipCidr: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case events = "Events"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for byoipcidrevents0 in events {
                try eventsContainer.encode(byoipcidrevents0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidr)
        cidr = cidrDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ByoipCidrState.self, forKey: .state)
        state = stateDecoded
        let eventsContainer = try containerValues.decodeIfPresent([ByoipCidrEvent?].self, forKey: .events)
        var eventsDecoded0:[ByoipCidrEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [ByoipCidrEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension ByoipCidr: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ByoipCidr(cidr: \(String(describing: cidr)), events: \(String(describing: events)), state: \(String(describing: state)))"}
}

/// <p>Information about an IP address range that is provisioned for use with your AWS resources through
/// 			bring your own IP address (BYOIP).</p>
/// 		       <p>The following describes each BYOIP <code>State</code> that your IP address range can be in.</p>
/// 		       <ul>
///             <li>
///                <p>
///                   <b>PENDING_PROVISIONING</b> â€”
/// 				Youâ€™ve submitted a request to provision an IP address range but it is not yet provisioned with
/// 				AWS Global Accelerator.</p>
///             </li>
///             <li>
///                <p>
///                   <b>READY</b> â€” The address range is provisioned
/// 				with AWS Global Accelerator and can be advertised.</p>
///             </li>
///             <li>
///                <p>
///                   <b>PENDING_ADVERTISING</b> â€” Youâ€™ve submitted a
/// 				request for AWS Global Accelerator to advertise an address range but it is not yet being advertised.</p>
///             </li>
///             <li>
///                <p>
///                   <b>ADVERTISING</b> â€” The address range is
/// 				being advertised by AWS Global Accelerator.</p>
///             </li>
///             <li>
///                <p>
///                   <b>PENDING_WITHDRAWING</b> â€” Youâ€™ve submitted
/// 				a request to withdraw an address range from being advertised but it is still being advertised
/// 				by AWS Global Accelerator.</p>
///             </li>
///             <li>
///                <p>
///                   <b>PENDING_DEPROVISIONING</b> â€” Youâ€™ve submitted a
/// 				request to deprovision an address range from AWS Global Accelerator but it is still provisioned.</p>
///             </li>
///             <li>
///                <p>
///                   <b>DEPROVISIONED</b> â€” The address range is deprovisioned
/// 				from AWS Global Accelerator.</p>
///             </li>
///             <li>
///                <p>
///                   <b>FAILED_PROVISION </b> â€” The request to
/// 				provision the address range from AWS Global Accelerator was not successful. Please make sure that
/// 				you provide all of the correct information, and try again. If the request fails
/// 				a second time, contact AWS support.</p>
///             </li>
///             <li>
///                <p>
///                   <b>FAILED_ADVERTISING</b> â€” The request for AWS Global Accelerator
/// 				to advertise the address range was not successful. Please make sure that
/// 				you provide all of the correct information, and try again. If the request fails
/// 				a second time, contact AWS support.</p>
///             </li>
///             <li>
///                <p>
///                   <b>FAILED_WITHDRAW</b> â€” The request to withdraw
/// 				the address range from advertising by AWS Global Accelerator was not successful. Please make sure that
/// 				you provide all of the correct information, and try again. If the request fails
/// 				a second time, contact AWS support.</p>
///             </li>
///             <li>
///                <p>
///                   <b>FAILED_DEPROVISION </b> â€” The request to
/// 				deprovision the address range from AWS Global Accelerator was not successful. Please make sure that
/// 				you provide all of the correct information, and try again. If the request fails
/// 				a second time, contact AWS support.</p>
///             </li>
///          </ul>
public struct ByoipCidr: Equatable {
    /// <p>The address range, in CIDR notation.</p>
    public let cidr: String?
    /// <p>A history of status changes for an IP address range that you bring to AWS Global Accelerator
    /// 			through bring your own IP address (BYOIP).</p>
    public let events: [ByoipCidrEvent]?
    /// <p>The state of the address pool.</p>
    public let state: ByoipCidrState?

    public init (
        cidr: String? = nil,
        events: [ByoipCidrEvent]? = nil,
        state: ByoipCidrState? = nil
    )
    {
        self.cidr = cidr
        self.events = events
        self.state = state
    }
}

extension ByoipCidrEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension ByoipCidrEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ByoipCidrEvent(message: \(String(describing: message)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>A complex type that contains a <code>Message</code> and a <code>Timestamp</code> value for changes
/// 			that you make in the status an IP address range that you bring to AWS Global Accelerator through bring your own IP
/// 			address (BYOIP).</p>
public struct ByoipCidrEvent: Equatable {
    /// <p>A string that contains an <code>Event</code> message describing changes that you make in the status
    /// 			of an IP address range that you bring to AWS Global Accelerator through bring your own IP address (BYOIP).</p>
    public let message: String?
    /// <p>A timestamp when you make a status change for an IP address range that you bring to AWS Global Accelerator through
    /// 			bring your own IP address (BYOIP).</p>
    public let timestamp: Date?

    public init (
        message: String? = nil,
        timestamp: Date? = nil
    )
    {
        self.message = message
        self.timestamp = timestamp
    }
}

extension ByoipCidrNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ByoipCidrNotFoundException(message: \(String(describing: message)))"}
}

extension ByoipCidrNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ByoipCidrNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The CIDR that you specified was not found or is incorrect.</p>
public struct ByoipCidrNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ByoipCidrNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ByoipCidrNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ByoipCidrState {
    case advertising
    case deprovisioned
    case failedAdvertising
    case failedDeprovision
    case failedProvision
    case failedWithdraw
    case pendingAdvertising
    case pendingDeprovisioning
    case pendingProvisioning
    case pendingWithdrawing
    case ready
    case sdkUnknown(String)
}

extension ByoipCidrState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ByoipCidrState] {
        return [
            .advertising,
            .deprovisioned,
            .failedAdvertising,
            .failedDeprovision,
            .failedProvision,
            .failedWithdraw,
            .pendingAdvertising,
            .pendingDeprovisioning,
            .pendingProvisioning,
            .pendingWithdrawing,
            .ready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .advertising: return "ADVERTISING"
        case .deprovisioned: return "DEPROVISIONED"
        case .failedAdvertising: return "FAILED_ADVERTISING"
        case .failedDeprovision: return "FAILED_DEPROVISION"
        case .failedProvision: return "FAILED_PROVISION"
        case .failedWithdraw: return "FAILED_WITHDRAW"
        case .pendingAdvertising: return "PENDING_ADVERTISING"
        case .pendingDeprovisioning: return "PENDING_DEPROVISIONING"
        case .pendingProvisioning: return "PENDING_PROVISIONING"
        case .pendingWithdrawing: return "PENDING_WITHDRAWING"
        case .ready: return "READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ByoipCidrState(rawValue: rawValue) ?? ByoipCidrState.sdkUnknown(rawValue)
    }
}

extension CidrAuthorizationContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case signature = "Signature"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let signature = signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signature)
        signature = signatureDecoded
    }
}

extension CidrAuthorizationContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CidrAuthorizationContext(message: \(String(describing: message)), signature: \(String(describing: signature)))"}
}

/// <p>Provides authorization for Amazon to bring a specific IP address range to a specific AWS
/// 			account using bring your own IP addresses (BYOIP). </p>
/// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring Your Own
/// 			IP Addresses (BYOIP)</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
public struct CidrAuthorizationContext: Equatable {
    /// <p>The plain-text authorization message for the prefix and account.</p>
    public let message: String?
    /// <p>The signed authorization message for the prefix and account.</p>
    public let signature: String?

    public init (
        message: String? = nil,
        signature: String? = nil
    )
    {
        self.message = message
        self.signature = signature
    }
}

public enum ClientAffinity {
    case `none`
    case sourceIp
    case sdkUnknown(String)
}

extension ClientAffinity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ClientAffinity] {
        return [
            .none,
            .sourceIp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "NONE"
        case .sourceIp: return "SOURCE_IP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ClientAffinity(rawValue: rawValue) ?? ClientAffinity.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't use both of those options.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateAcceleratorInputBodyMiddleware: Middleware {
    public let id: String = "CreateAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAcceleratorInput>
    public typealias MOutput = OperationOutput<CreateAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAcceleratorOutputError>
}

extension CreateAcceleratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAcceleratorInput(enabled: \(String(describing: enabled)), idempotencyToken: \(String(describing: idempotencyToken)), ipAddressType: \(String(describing: ipAddressType)), ipAddresses: \(String(describing: ipAddresses)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateAcceleratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddresses0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddresses0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateAcceleratorInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAcceleratorInput>
    public typealias MOutput = OperationOutput<CreateAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAcceleratorOutputError>
}

public struct CreateAcceleratorInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAcceleratorInput>
    public typealias MOutput = OperationOutput<CreateAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAcceleratorOutputError>
}

public struct CreateAcceleratorInput: Equatable {
    /// <p>Indicates whether an accelerator is enabled. The value is true or false. The default value is true. </p>
    /// 		       <p>If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.</p>
    public let enabled: Bool?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotencyâ€”that is, the
    /// 			uniquenessâ€”of an accelerator.</p>
    public var idempotencyToken: String?
    /// <p>The value for the address type must be IPv4.</p>
    public let ipAddressType: IpAddressType?
    /// <p>Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose IP addresses
    /// 			from your own pool to use for the accelerator's static IP addresses when you create an accelerator. You can
    /// 			specify one or two addresses, separated by a space. Do not include the /32 suffix.</p>
    /// 		       <p>Only one IP address from each of your IP address ranges can be used for each accelerator. If you specify only
    /// 			one IP address from your IP address range, Global Accelerator assigns a second static IP address for the
    /// 			accelerator from the AWS IP address pool.</p>
    /// 		       <p>Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new
    /// 			accelerator with the new addresses.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring Your Own
    /// 			IP Addresses (BYOIP)</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let ipAddresses: [String]?
    /// <p>The name of an accelerator. The name can have a maximum of 32 characters, must contain only alphanumeric characters or
    /// 			hyphens (-), and must not begin or end with a hyphen.</p>
    public let name: String?
    /// <p>Create tags for an accelerator.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html">Tagging
    /// 			in AWS Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let tags: [Tag]?

    public init (
        enabled: Bool? = nil,
        idempotencyToken: String? = nil,
        ipAddressType: IpAddressType? = nil,
        ipAddresses: [String]? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.enabled = enabled
        self.idempotencyToken = idempotencyToken
        self.ipAddressType = ipAddressType
        self.ipAddresses = ipAddresses
        self.name = name
        self.tags = tags
    }
}

struct CreateAcceleratorInputBody: Equatable {
    public let name: String?
    public let ipAddressType: IpAddressType?
    public let ipAddresses: [String]?
    public let enabled: Bool?
    public let idempotencyToken: String?
    public let tags: [Tag]?
}

extension CreateAcceleratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAcceleratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAcceleratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAcceleratorOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAcceleratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAcceleratorOutputResponse(accelerator: \(String(describing: accelerator)))"}
}

extension CreateAcceleratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct CreateAcceleratorOutputResponse: Equatable {
    /// <p>The accelerator that is created by specifying a listener and the supported IP address types.</p>
    public let accelerator: Accelerator?

    public init (
        accelerator: Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct CreateAcceleratorOutputResponseBody: Equatable {
    public let accelerator: Accelerator?
}

extension CreateAcceleratorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(Accelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

public struct CreateCustomRoutingAcceleratorInputBodyMiddleware: Middleware {
    public let id: String = "CreateCustomRoutingAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomRoutingAcceleratorInput>
    public typealias MOutput = OperationOutput<CreateCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomRoutingAcceleratorOutputError>
}

extension CreateCustomRoutingAcceleratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomRoutingAcceleratorInput(enabled: \(String(describing: enabled)), idempotencyToken: \(String(describing: idempotencyToken)), ipAddressType: \(String(describing: ipAddressType)), ipAddresses: \(String(describing: ipAddresses)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateCustomRoutingAcceleratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddresses0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddresses0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateCustomRoutingAcceleratorInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCustomRoutingAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomRoutingAcceleratorInput>
    public typealias MOutput = OperationOutput<CreateCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomRoutingAcceleratorOutputError>
}

public struct CreateCustomRoutingAcceleratorInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCustomRoutingAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomRoutingAcceleratorInput>
    public typealias MOutput = OperationOutput<CreateCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomRoutingAcceleratorOutputError>
}

public struct CreateCustomRoutingAcceleratorInput: Equatable {
    /// <p>Indicates whether an accelerator is enabled. The value is true or false. The default value is true. </p>
    /// 	        <p>If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.</p>
    public let enabled: Bool?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotencyâ€”that
    /// 			is, the uniquenessâ€”of the request.</p>
    public var idempotencyToken: String?
    /// <p>The value for the address type must be IPv4.</p>
    public let ipAddressType: IpAddressType?
    /// <p>Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose IP addresses
    /// 				from your own pool to use for the accelerator's static IP addresses when you create an accelerator. You can
    /// 				specify one or two addresses, separated by a space. Do not include the /32 suffix.</p>
    /// 			      <p>Only one IP address from each of your IP address ranges can be used for each accelerator. If you specify only
    /// 				one IP address from your IP address range, Global Accelerator assigns a second static IP address for the
    /// 				accelerator from the AWS IP address pool.</p>
    /// 			      <p>Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new
    /// 				accelerator with the new addresses.</p>
    /// 			      <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/using-byoip.html">Bring
    /// 				your own IP addresses (BYOIP)</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let ipAddresses: [String]?
    /// <p>The name of a custom routing accelerator. The name can have a maximum of 64 characters, must contain
    /// 		only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.</p>
    public let name: String?
    /// <p>Create tags for an accelerator.</p>
    /// 	        <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/tagging-in-global-accelerator.html">Tagging
    /// 		in AWS Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let tags: [Tag]?

    public init (
        enabled: Bool? = nil,
        idempotencyToken: String? = nil,
        ipAddressType: IpAddressType? = nil,
        ipAddresses: [String]? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.enabled = enabled
        self.idempotencyToken = idempotencyToken
        self.ipAddressType = ipAddressType
        self.ipAddresses = ipAddresses
        self.name = name
        self.tags = tags
    }
}

struct CreateCustomRoutingAcceleratorInputBody: Equatable {
    public let name: String?
    public let ipAddressType: IpAddressType?
    public let ipAddresses: [String]?
    public let enabled: Bool?
    public let idempotencyToken: String?
    public let tags: [Tag]?
}

extension CreateCustomRoutingAcceleratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case idempotencyToken = "IdempotencyToken"
        case ipAddressType = "IpAddressType"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCustomRoutingAcceleratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomRoutingAcceleratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomRoutingAcceleratorOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomRoutingAcceleratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomRoutingAcceleratorOutputResponse(accelerator: \(String(describing: accelerator)))"}
}

extension CreateCustomRoutingAcceleratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCustomRoutingAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct CreateCustomRoutingAcceleratorOutputResponse: Equatable {
    /// <p>The accelerator that is created.</p>
    public let accelerator: CustomRoutingAccelerator?

    public init (
        accelerator: CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct CreateCustomRoutingAcceleratorOutputResponseBody: Equatable {
    public let accelerator: CustomRoutingAccelerator?
}

extension CreateCustomRoutingAcceleratorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(CustomRoutingAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

public struct CreateCustomRoutingEndpointGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateCustomRoutingEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomRoutingEndpointGroupInput>
    public typealias MOutput = OperationOutput<CreateCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomRoutingEndpointGroupOutputError>
}

extension CreateCustomRoutingEndpointGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomRoutingEndpointGroupInput(destinationConfigurations: \(String(describing: destinationConfigurations)), endpointGroupRegion: \(String(describing: endpointGroupRegion)), idempotencyToken: \(String(describing: idempotencyToken)), listenerArn: \(String(describing: listenerArn)))"}
}

extension CreateCustomRoutingEndpointGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationConfigurations = "DestinationConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfigurations = destinationConfigurations {
            var destinationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationConfigurations)
            for customroutingdestinationconfigurations0 in destinationConfigurations {
                try destinationConfigurationsContainer.encode(customroutingdestinationconfigurations0)
            }
        }
        if let endpointGroupRegion = endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

public struct CreateCustomRoutingEndpointGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCustomRoutingEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomRoutingEndpointGroupInput>
    public typealias MOutput = OperationOutput<CreateCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomRoutingEndpointGroupOutputError>
}

public struct CreateCustomRoutingEndpointGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCustomRoutingEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomRoutingEndpointGroupInput>
    public typealias MOutput = OperationOutput<CreateCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomRoutingEndpointGroupOutputError>
}

public struct CreateCustomRoutingEndpointGroupInput: Equatable {
    /// <p>Sets the port range and protocol for all endpoints (virtual private cloud subnets) in a custom routing endpoint group to accept
    /// 		client traffic on.</p>
    public let destinationConfigurations: [CustomRoutingDestinationConfiguration]?
    /// <p>The AWS Region where the endpoint group is located. A listener can have only one endpoint group in a
    /// 		specific Region.</p>
    public let endpointGroupRegion: String?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotencyâ€”that is, the
    /// 		uniquenessâ€”of the request.</p>
    public var idempotencyToken: String?
    /// <p>The Amazon Resource Name (ARN) of the listener for a custom routing endpoint.</p>
    public let listenerArn: String?

    public init (
        destinationConfigurations: [CustomRoutingDestinationConfiguration]? = nil,
        endpointGroupRegion: String? = nil,
        idempotencyToken: String? = nil,
        listenerArn: String? = nil
    )
    {
        self.destinationConfigurations = destinationConfigurations
        self.endpointGroupRegion = endpointGroupRegion
        self.idempotencyToken = idempotencyToken
        self.listenerArn = listenerArn
    }
}

struct CreateCustomRoutingEndpointGroupInputBody: Equatable {
    public let listenerArn: String?
    public let endpointGroupRegion: String?
    public let destinationConfigurations: [CustomRoutingDestinationConfiguration]?
    public let idempotencyToken: String?
}

extension CreateCustomRoutingEndpointGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationConfigurations = "DestinationConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let destinationConfigurationsContainer = try containerValues.decodeIfPresent([CustomRoutingDestinationConfiguration?].self, forKey: .destinationConfigurations)
        var destinationConfigurationsDecoded0:[CustomRoutingDestinationConfiguration]? = nil
        if let destinationConfigurationsContainer = destinationConfigurationsContainer {
            destinationConfigurationsDecoded0 = [CustomRoutingDestinationConfiguration]()
            for structure0 in destinationConfigurationsContainer {
                if let structure0 = structure0 {
                    destinationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        destinationConfigurations = destinationConfigurationsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateCustomRoutingEndpointGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomRoutingEndpointGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupAlreadyExistsException" : self = .endpointGroupAlreadyExistsException(try EndpointGroupAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomRoutingEndpointGroupOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case endpointGroupAlreadyExistsException(EndpointGroupAlreadyExistsException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomRoutingEndpointGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomRoutingEndpointGroupOutputResponse(endpointGroup: \(String(describing: endpointGroup)))"}
}

extension CreateCustomRoutingEndpointGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCustomRoutingEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct CreateCustomRoutingEndpointGroupOutputResponse: Equatable {
    /// <p>The information about the endpoint group created for a custom routing accelerator.</p>
    public let endpointGroup: CustomRoutingEndpointGroup?

    public init (
        endpointGroup: CustomRoutingEndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct CreateCustomRoutingEndpointGroupOutputResponseBody: Equatable {
    public let endpointGroup: CustomRoutingEndpointGroup?
}

extension CreateCustomRoutingEndpointGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(CustomRoutingEndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

public struct CreateCustomRoutingListenerInputBodyMiddleware: Middleware {
    public let id: String = "CreateCustomRoutingListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomRoutingListenerInput>
    public typealias MOutput = OperationOutput<CreateCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomRoutingListenerOutputError>
}

extension CreateCustomRoutingListenerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomRoutingListenerInput(acceleratorArn: \(String(describing: acceleratorArn)), idempotencyToken: \(String(describing: idempotencyToken)), portRanges: \(String(describing: portRanges)))"}
}

extension CreateCustomRoutingListenerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portranges0 in portRanges {
                try portRangesContainer.encode(portranges0)
            }
        }
    }
}

public struct CreateCustomRoutingListenerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCustomRoutingListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomRoutingListenerInput>
    public typealias MOutput = OperationOutput<CreateCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomRoutingListenerOutputError>
}

public struct CreateCustomRoutingListenerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCustomRoutingListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomRoutingListenerInput>
    public typealias MOutput = OperationOutput<CreateCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomRoutingListenerOutputError>
}

public struct CreateCustomRoutingListenerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator for a custom routing listener.</p>
    public let acceleratorArn: String?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotencyâ€”that is, the
    /// 		uniquenessâ€”of the request.</p>
    public var idempotencyToken: String?
    /// <p>The port range to support for connections from clients to your accelerator.</p>
    /// 	        <p>Separately, you set port ranges for endpoints. For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html">About
    /// 		endpoints for custom routing accelerators</a>.</p>
    public let portRanges: [PortRange]?

    public init (
        acceleratorArn: String? = nil,
        idempotencyToken: String? = nil,
        portRanges: [PortRange]? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.idempotencyToken = idempotencyToken
        self.portRanges = portRanges
    }
}

struct CreateCustomRoutingListenerInputBody: Equatable {
    public let acceleratorArn: String?
    public let portRanges: [PortRange]?
    public let idempotencyToken: String?
}

extension CreateCustomRoutingListenerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateCustomRoutingListenerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomRoutingListenerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomRoutingListenerOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomRoutingListenerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomRoutingListenerOutputResponse(listener: \(String(describing: listener)))"}
}

extension CreateCustomRoutingListenerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCustomRoutingListenerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct CreateCustomRoutingListenerOutputResponse: Equatable {
    /// <p>The listener that you've created for a custom routing accelerator.</p>
    public let listener: CustomRoutingListener?

    public init (
        listener: CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

struct CreateCustomRoutingListenerOutputResponseBody: Equatable {
    public let listener: CustomRoutingListener?
}

extension CreateCustomRoutingListenerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(CustomRoutingListener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

public struct CreateEndpointGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEndpointGroupInput>
    public typealias MOutput = OperationOutput<CreateEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEndpointGroupOutputError>
}

extension CreateEndpointGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEndpointGroupInput(endpointConfigurations: \(String(describing: endpointConfigurations)), endpointGroupRegion: \(String(describing: endpointGroupRegion)), healthCheckIntervalSeconds: \(String(describing: healthCheckIntervalSeconds)), healthCheckPath: \(String(describing: healthCheckPath)), healthCheckPort: \(String(describing: healthCheckPort)), healthCheckProtocol: \(String(describing: healthCheckProtocol)), idempotencyToken: \(String(describing: idempotencyToken)), listenerArn: \(String(describing: listenerArn)), portOverrides: \(String(describing: portOverrides)), thresholdCount: \(String(describing: thresholdCount)), trafficDialPercentage: \(String(describing: trafficDialPercentage)))"}
}

extension CreateEndpointGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for endpointconfigurations0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(endpointconfigurations0)
            }
        }
        if let endpointGroupRegion = endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let healthCheckIntervalSeconds = healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckPath = healthCheckPath {
            try encodeContainer.encode(healthCheckPath, forKey: .healthCheckPath)
        }
        if let healthCheckPort = healthCheckPort {
            try encodeContainer.encode(healthCheckPort, forKey: .healthCheckPort)
        }
        if let healthCheckProtocol = healthCheckProtocol {
            try encodeContainer.encode(healthCheckProtocol.rawValue, forKey: .healthCheckProtocol)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portOverrides = portOverrides {
            var portOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portOverrides)
            for portoverrides0 in portOverrides {
                try portOverridesContainer.encode(portoverrides0)
            }
        }
        if let thresholdCount = thresholdCount {
            try encodeContainer.encode(thresholdCount, forKey: .thresholdCount)
        }
        if let trafficDialPercentage = trafficDialPercentage {
            try encodeContainer.encode(trafficDialPercentage, forKey: .trafficDialPercentage)
        }
    }
}

public struct CreateEndpointGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEndpointGroupInput>
    public typealias MOutput = OperationOutput<CreateEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEndpointGroupOutputError>
}

public struct CreateEndpointGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEndpointGroupInput>
    public typealias MOutput = OperationOutput<CreateEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEndpointGroupOutputError>
}

public struct CreateEndpointGroupInput: Equatable {
    /// <p>The list of endpoint objects.</p>
    public let endpointConfigurations: [EndpointConfiguration]?
    /// <p>The AWS Region where the endpoint group is located. A listener can have only one endpoint group in a
    /// 			specific Region.</p>
    public let endpointGroupRegion: String?
    /// <p>The timeâ€”10 seconds or 30 secondsâ€”between each health check for an endpoint. The default value is 30.</p>
    public let healthCheckIntervalSeconds: Int?
    /// <p>If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The
    /// 			default value is slash (/).</p>
    public let healthCheckPath: String?
    /// <p>The port that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port
    /// 			is the listener port that this endpoint group is associated with. If listener port is a list of ports, Global Accelerator uses the
    /// 			first port in the list.</p>
    public let healthCheckPort: Int?
    /// <p>The protocol that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default
    /// 			value is TCP.</p>
    public let healthCheckProtocol: HealthCheckProtocol?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotencyâ€”that is, the
    /// 			uniquenessâ€”of the request.</p>
    public var idempotencyToken: String?
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: String?
    /// <p>Override specific listener ports used to route traffic to endpoints that are part of this endpoint group.
    /// 			For example, you can create a port override in which the listener
    /// 			receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080
    /// 			and 1443, respectively, on the endpoints.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html">
    /// 			Port overrides</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let portOverrides: [PortOverride]?
    /// <p>The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an
    /// 			unhealthy endpoint to healthy. The default value is 3.</p>
    public let thresholdCount: Int?
    /// <p>The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for
    /// 			this listener. </p>
    /// 		       <p>Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is
    /// 			applied to the traffic that would otherwise have been routed to the Region based on optimal routing.</p>
    /// 		       <p>The default value is 100.</p>
    public let trafficDialPercentage: Float?

    public init (
        endpointConfigurations: [EndpointConfiguration]? = nil,
        endpointGroupRegion: String? = nil,
        healthCheckIntervalSeconds: Int? = nil,
        healthCheckPath: String? = nil,
        healthCheckPort: Int? = nil,
        healthCheckProtocol: HealthCheckProtocol? = nil,
        idempotencyToken: String? = nil,
        listenerArn: String? = nil,
        portOverrides: [PortOverride]? = nil,
        thresholdCount: Int? = nil,
        trafficDialPercentage: Float? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupRegion = endpointGroupRegion
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.idempotencyToken = idempotencyToken
        self.listenerArn = listenerArn
        self.portOverrides = portOverrides
        self.thresholdCount = thresholdCount
        self.trafficDialPercentage = trafficDialPercentage
    }
}

struct CreateEndpointGroupInputBody: Equatable {
    public let listenerArn: String?
    public let endpointGroupRegion: String?
    public let endpointConfigurations: [EndpointConfiguration]?
    public let trafficDialPercentage: Float?
    public let healthCheckPort: Int?
    public let healthCheckProtocol: HealthCheckProtocol?
    public let healthCheckPath: String?
    public let healthCheckIntervalSeconds: Int?
    public let thresholdCount: Int?
    public let idempotencyToken: String?
    public let portOverrides: [PortOverride]?
}

extension CreateEndpointGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupRegion = "EndpointGroupRegion"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case idempotencyToken = "IdempotencyToken"
        case listenerArn = "ListenerArn"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([EndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[EndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [EndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(HealthCheckProtocol.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let thresholdCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .thresholdCount)
        thresholdCount = thresholdCountDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let portOverridesContainer = try containerValues.decodeIfPresent([PortOverride?].self, forKey: .portOverrides)
        var portOverridesDecoded0:[PortOverride]? = nil
        if let portOverridesContainer = portOverridesContainer {
            portOverridesDecoded0 = [PortOverride]()
            for structure0 in portOverridesContainer {
                if let structure0 = structure0 {
                    portOverridesDecoded0?.append(structure0)
                }
            }
        }
        portOverrides = portOverridesDecoded0
    }
}

extension CreateEndpointGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEndpointGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupAlreadyExistsException" : self = .endpointGroupAlreadyExistsException(try EndpointGroupAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEndpointGroupOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case endpointGroupAlreadyExistsException(EndpointGroupAlreadyExistsException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEndpointGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEndpointGroupOutputResponse(endpointGroup: \(String(describing: endpointGroup)))"}
}

extension CreateEndpointGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct CreateEndpointGroupOutputResponse: Equatable {
    /// <p>The information about the endpoint group that was created.</p>
    public let endpointGroup: EndpointGroup?

    public init (
        endpointGroup: EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct CreateEndpointGroupOutputResponseBody: Equatable {
    public let endpointGroup: EndpointGroup?
}

extension CreateEndpointGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(EndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

public struct CreateListenerInputBodyMiddleware: Middleware {
    public let id: String = "CreateListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateListenerInput>
    public typealias MOutput = OperationOutput<CreateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateListenerOutputError>
}

extension CreateListenerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateListenerInput(acceleratorArn: \(String(describing: acceleratorArn)), clientAffinity: \(String(describing: clientAffinity)), idempotencyToken: \(String(describing: idempotencyToken)), portRanges: \(String(describing: portRanges)), protocol: \(String(describing: `protocol`)))"}
}

extension CreateListenerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case clientAffinity = "ClientAffinity"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let clientAffinity = clientAffinity {
            try encodeContainer.encode(clientAffinity.rawValue, forKey: .clientAffinity)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portranges0 in portRanges {
                try portRangesContainer.encode(portranges0)
            }
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }
}

public struct CreateListenerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateListenerInput>
    public typealias MOutput = OperationOutput<CreateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateListenerOutputError>
}

public struct CreateListenerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateListenerInput>
    public typealias MOutput = OperationOutput<CreateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateListenerOutputError>
}

public struct CreateListenerInput: Equatable {
    /// <p>The protocol for connections from clients to your accelerator.</p>
    public let `protocol`: `Protocol`?
    /// <p>The Amazon Resource Name (ARN) of your accelerator.</p>
    public let acceleratorArn: String?
    /// <p>Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications,
    /// 			regardless of the port and protocol of the client request. Client affinity gives you control over whether to always
    /// 			route each client to the same specific endpoint.</p>
    /// 		       <p>AWS Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client
    /// 			affinity is <code>NONE</code>, Global Accelerator uses the "five-tuple" (5-tuple) propertiesâ€”source IP address, source port,
    /// 			destination IP address, destination port, and protocolâ€”to select the hash value, and then chooses the best
    /// 			endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not
    /// 			be always routed to the same endpoint because the hash value changes. </p>
    /// 		       <p>If you want a given client to always be routed to the same endpoint, set client affinity to <code>SOURCE_IP</code>
    /// 			instead. When you use the <code>SOURCE_IP</code> setting, Global Accelerator uses the "two-tuple" (2-tuple) propertiesâ€”
    /// 			source (client) IP address and destination IP addressâ€”to select the hash value.</p>
    /// 		       <p>The default value is <code>NONE</code>.</p>
    public let clientAffinity: ClientAffinity?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotencyâ€”that is, the
    /// 			uniquenessâ€”of the request.</p>
    public var idempotencyToken: String?
    /// <p>The list of port ranges to support for connections from clients to your accelerator.</p>
    public let portRanges: [PortRange]?

    public init (
        `protocol`: `Protocol`? = nil,
        acceleratorArn: String? = nil,
        clientAffinity: ClientAffinity? = nil,
        idempotencyToken: String? = nil,
        portRanges: [PortRange]? = nil
    )
    {
        self.`protocol` = `protocol`
        self.acceleratorArn = acceleratorArn
        self.clientAffinity = clientAffinity
        self.idempotencyToken = idempotencyToken
        self.portRanges = portRanges
    }
}

struct CreateListenerInputBody: Equatable {
    public let acceleratorArn: String?
    public let portRanges: [PortRange]?
    public let `protocol`: `Protocol`?
    public let clientAffinity: ClientAffinity?
    public let idempotencyToken: String?
}

extension CreateListenerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case clientAffinity = "ClientAffinity"
        case idempotencyToken = "IdempotencyToken"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(`Protocol`.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let clientAffinityDecoded = try containerValues.decodeIfPresent(ClientAffinity.self, forKey: .clientAffinity)
        clientAffinity = clientAffinityDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateListenerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateListenerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateListenerOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateListenerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateListenerOutputResponse(listener: \(String(describing: listener)))"}
}

extension CreateListenerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateListenerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct CreateListenerOutputResponse: Equatable {
    /// <p>The listener that you've created.</p>
    public let listener: Listener?

    public init (
        listener: Listener? = nil
    )
    {
        self.listener = listener
    }
}

struct CreateListenerOutputResponseBody: Equatable {
    public let listener: Listener?
}

extension CreateListenerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(Listener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

extension CustomRoutingAccelerator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case createdTime = "CreatedTime"
        case dnsName = "DnsName"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case ipSets = "IpSets"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let dnsName = dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let ipSets = ipSets {
            var ipSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipSets)
            for ipsets0 in ipSets {
                try ipSetsContainer.encode(ipsets0)
            }
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let ipSetsContainer = try containerValues.decodeIfPresent([IpSet?].self, forKey: .ipSets)
        var ipSetsDecoded0:[IpSet]? = nil
        if let ipSetsContainer = ipSetsContainer {
            ipSetsDecoded0 = [IpSet]()
            for structure0 in ipSetsContainer {
                if let structure0 = structure0 {
                    ipSetsDecoded0?.append(structure0)
                }
            }
        }
        ipSets = ipSetsDecoded0
        let dnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CustomRoutingAcceleratorStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension CustomRoutingAccelerator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomRoutingAccelerator(acceleratorArn: \(String(describing: acceleratorArn)), createdTime: \(String(describing: createdTime)), dnsName: \(String(describing: dnsName)), enabled: \(String(describing: enabled)), ipAddressType: \(String(describing: ipAddressType)), ipSets: \(String(describing: ipSets)), lastModifiedTime: \(String(describing: lastModifiedTime)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Attributes of a custom routing accelerator.</p>
public struct CustomRoutingAccelerator: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom routing accelerator.</p>
    public let acceleratorArn: String?
    /// <p>The date and time that the accelerator was created.</p>
    public let createdTime: Date?
    /// <p>The Domain Name System (DNS) name that Global Accelerator creates that points to your accelerator's static IP addresses. </p>
    /// 		       <p>The naming convention for the DNS name is the following: A lowercase letter a,
    /// 			followed by a 16-bit random hex string, followed by .awsglobalaccelerator.com. For example:
    /// 			a1234567890abcdef.awsglobalaccelerator.com.</p>
    /// 		       <p>For more information about the default DNS name, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-accelerators.html#about-accelerators.dns-addressing">
    /// 			Support for DNS Addressing in Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let dnsName: String?
    /// <p>Indicates whether the accelerator is enabled. The value is true or false. The default value is true. </p>
    /// 		       <p>If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.</p>
    public let enabled: Bool?
    /// <p>The value for the address type must be IPv4.</p>
    public let ipAddressType: IpAddressType?
    /// <p>The static IP addresses that Global Accelerator associates with the accelerator.</p>
    public let ipSets: [IpSet]?
    /// <p>The date and time that the accelerator was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the accelerator. The name must contain only alphanumeric characters or
    /// 			hyphens (-), and must not begin or end with a hyphen.</p>
    public let name: String?
    /// <p>Describes the deployment status of the accelerator.</p>
    public let status: CustomRoutingAcceleratorStatus?

    public init (
        acceleratorArn: String? = nil,
        createdTime: Date? = nil,
        dnsName: String? = nil,
        enabled: Bool? = nil,
        ipAddressType: IpAddressType? = nil,
        ipSets: [IpSet]? = nil,
        lastModifiedTime: Date? = nil,
        name: String? = nil,
        status: CustomRoutingAcceleratorStatus? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.createdTime = createdTime
        self.dnsName = dnsName
        self.enabled = enabled
        self.ipAddressType = ipAddressType
        self.ipSets = ipSets
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.status = status
    }
}

extension CustomRoutingAcceleratorAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowLogsEnabled = flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension CustomRoutingAcceleratorAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomRoutingAcceleratorAttributes(flowLogsEnabled: \(String(describing: flowLogsEnabled)), flowLogsS3Bucket: \(String(describing: flowLogsS3Bucket)), flowLogsS3Prefix: \(String(describing: flowLogsS3Prefix)))"}
}

/// <p>Attributes of a custom routing accelerator.</p>
public struct CustomRoutingAcceleratorAttributes: Equatable {
    /// <p>Indicates whether flow logs are enabled. The default value is false. If the value is true,
    /// 			<code>FlowLogsS3Bucket</code> and <code>FlowLogsS3Prefix</code> must be specified.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html">Flow Logs</a> in
    /// 			the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let flowLogsEnabled: Bool?
    /// <p>The name of the Amazon S3 bucket for the flow logs. Attribute is required if <code>FlowLogsEnabled</code> is
    /// 			<code>true</code>. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the
    /// 			bucket.</p>
    public let flowLogsS3Bucket: String?
    /// <p>The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if
    /// 			<code>FlowLogsEnabled</code> is <code>true</code>.</p>
    /// 		       <p>If you donâ€™t specify a prefix, the flow logs are stored in the
    /// 			root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following:</p>
    /// 		       <p>DOC-EXAMPLE-BUCKET//AWSLogs/aws_account_id</p>
    public let flowLogsS3Prefix: String?

    public init (
        flowLogsEnabled: Bool? = nil,
        flowLogsS3Bucket: String? = nil,
        flowLogsS3Prefix: String? = nil
    )
    {
        self.flowLogsEnabled = flowLogsEnabled
        self.flowLogsS3Bucket = flowLogsS3Bucket
        self.flowLogsS3Prefix = flowLogsS3Prefix
    }
}

public enum CustomRoutingAcceleratorStatus {
    case deployed
    case inProgress
    case sdkUnknown(String)
}

extension CustomRoutingAcceleratorStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomRoutingAcceleratorStatus] {
        return [
            .deployed,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deployed: return "DEPLOYED"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomRoutingAcceleratorStatus(rawValue: rawValue) ?? CustomRoutingAcceleratorStatus.sdkUnknown(rawValue)
    }
}

extension CustomRoutingDestinationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromPort = "FromPort"
        case protocols = "Protocols"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for customroutingprotocols0 in protocols {
                try protocolsContainer.encode(customroutingprotocols0.rawValue)
            }
        }
        if let toPort = toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .toPort)
        toPort = toPortDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([CustomRoutingProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[CustomRoutingProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [CustomRoutingProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
    }
}

extension CustomRoutingDestinationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomRoutingDestinationConfiguration(fromPort: \(String(describing: fromPort)), protocols: \(String(describing: protocols)), toPort: \(String(describing: toPort)))"}
}

/// <p>For a custom routing accelerator, sets the port range and protocol for all endpoints (virtual
/// 			private cloud subnets) in an endpoint group to accept client traffic on.</p>
public struct CustomRoutingDestinationConfiguration: Equatable {
    /// <p>The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.</p>
    public let fromPort: Int?
    /// <p>The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either TCP or UDP.</p>
    public let protocols: [CustomRoutingProtocol]?
    /// <p>The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.</p>
    public let toPort: Int?

    public init (
        fromPort: Int? = nil,
        protocols: [CustomRoutingProtocol]? = nil,
        toPort: Int? = nil
    )
    {
        self.fromPort = fromPort
        self.protocols = protocols
        self.toPort = toPort
    }
}

extension CustomRoutingDestinationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromPort = "FromPort"
        case protocols = "Protocols"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let toPort = toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .toPort)
        toPort = toPortDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([`Protocol`?].self, forKey: .protocols)
        var protocolsDecoded0:[`Protocol`]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [`Protocol`]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
    }
}

extension CustomRoutingDestinationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomRoutingDestinationDescription(fromPort: \(String(describing: fromPort)), protocols: \(String(describing: protocols)), toPort: \(String(describing: toPort)))"}
}

/// <p>For a custom routing accelerator, describes the port range and protocol for all endpoints
/// 			(virtual private cloud subnets) in an endpoint group to accept client traffic on.</p>
public struct CustomRoutingDestinationDescription: Equatable {
    /// <p>The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.</p>
    public let fromPort: Int?
    /// <p>The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either TCP or UDP.</p>
    public let protocols: [`Protocol`]?
    /// <p>The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.</p>
    public let toPort: Int?

    public init (
        fromPort: Int? = nil,
        protocols: [`Protocol`]? = nil,
        toPort: Int? = nil
    )
    {
        self.fromPort = fromPort
        self.protocols = protocols
        self.toPort = toPort
    }
}

public enum CustomRoutingDestinationTrafficState {
    case allow
    case deny
    case sdkUnknown(String)
}

extension CustomRoutingDestinationTrafficState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomRoutingDestinationTrafficState] {
        return [
            .allow,
            .deny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "ALLOW"
        case .deny: return "DENY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomRoutingDestinationTrafficState(rawValue: rawValue) ?? CustomRoutingDestinationTrafficState.sdkUnknown(rawValue)
    }
}

extension CustomRoutingEndpointConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

extension CustomRoutingEndpointConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomRoutingEndpointConfiguration(endpointId: \(String(describing: endpointId)))"}
}

/// <p>The list of endpoint objects. For custom routing, this is a list of virtual private cloud (VPC) subnet IDs.</p>
public struct CustomRoutingEndpointConfiguration: Equatable {
    /// <p>An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC)
    /// 			subnet ID. </p>
    public let endpointId: String?

    public init (
        endpointId: String? = nil
    )
    {
        self.endpointId = endpointId
    }
}

extension CustomRoutingEndpointDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

extension CustomRoutingEndpointDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomRoutingEndpointDescription(endpointId: \(String(describing: endpointId)))"}
}

/// <p>A complex type for an endpoint for a custom routing accelerator. Each endpoint group can include one or more endpoints,
/// 			which are virtual private cloud (VPC) subnets.</p>
public struct CustomRoutingEndpointDescription: Equatable {
    /// <p>An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC)
    /// 			subnet ID. </p>
    public let endpointId: String?

    public init (
        endpointId: String? = nil
    )
    {
        self.endpointId = endpointId
    }
}

extension CustomRoutingEndpointGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationDescriptions = "DestinationDescriptions"
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointGroupRegion = "EndpointGroupRegion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationDescriptions = destinationDescriptions {
            var destinationDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationDescriptions)
            for customroutingdestinationdescriptions0 in destinationDescriptions {
                try destinationDescriptionsContainer.encode(customroutingdestinationdescriptions0)
            }
        }
        if let endpointDescriptions = endpointDescriptions {
            var endpointDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDescriptions)
            for customroutingendpointdescriptions0 in endpointDescriptions {
                try endpointDescriptionsContainer.encode(customroutingendpointdescriptions0)
            }
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointGroupRegion = endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let destinationDescriptionsContainer = try containerValues.decodeIfPresent([CustomRoutingDestinationDescription?].self, forKey: .destinationDescriptions)
        var destinationDescriptionsDecoded0:[CustomRoutingDestinationDescription]? = nil
        if let destinationDescriptionsContainer = destinationDescriptionsContainer {
            destinationDescriptionsDecoded0 = [CustomRoutingDestinationDescription]()
            for structure0 in destinationDescriptionsContainer {
                if let structure0 = structure0 {
                    destinationDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        destinationDescriptions = destinationDescriptionsDecoded0
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([CustomRoutingEndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[CustomRoutingEndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [CustomRoutingEndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
    }
}

extension CustomRoutingEndpointGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomRoutingEndpointGroup(destinationDescriptions: \(String(describing: destinationDescriptions)), endpointDescriptions: \(String(describing: endpointDescriptions)), endpointGroupArn: \(String(describing: endpointGroupArn)), endpointGroupRegion: \(String(describing: endpointGroupRegion)))"}
}

/// <p>A complex type for the endpoint group for a custom routing accelerator. An AWS Region can have only one endpoint group for a specific listener.
/// 		</p>
public struct CustomRoutingEndpointGroup: Equatable {
    /// <p>For a custom routing accelerator, describes the port range and protocol for all endpoints
    /// 			(virtual private cloud subnets) in an endpoint group to accept client traffic on.</p>
    public let destinationDescriptions: [CustomRoutingDestinationDescription]?
    /// <p>For a custom routing accelerator, describes the endpoints (virtual private cloud subnets) in an
    /// 			endpoint group to accept client traffic on.</p>
    public let endpointDescriptions: [CustomRoutingEndpointDescription]?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
    public let endpointGroupArn: String?
    /// <p>The AWS Region where the endpoint group is located.</p>
    public let endpointGroupRegion: String?

    public init (
        destinationDescriptions: [CustomRoutingDestinationDescription]? = nil,
        endpointDescriptions: [CustomRoutingEndpointDescription]? = nil,
        endpointGroupArn: String? = nil,
        endpointGroupRegion: String? = nil
    )
    {
        self.destinationDescriptions = destinationDescriptions
        self.endpointDescriptions = endpointDescriptions
        self.endpointGroupArn = endpointGroupArn
        self.endpointGroupRegion = endpointGroupRegion
    }
}

extension CustomRoutingListener: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portranges0 in portRanges {
                try portRangesContainer.encode(portranges0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
    }
}

extension CustomRoutingListener: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomRoutingListener(listenerArn: \(String(describing: listenerArn)), portRanges: \(String(describing: portRanges)))"}
}

/// <p>A complex type for a listener for a custom routing accelerator.</p>
public struct CustomRoutingListener: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: String?
    /// <p>The port range to support for connections from clients to your accelerator.</p>
    /// 		       <p>Separately, you set port ranges for endpoints. For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html">About
    /// 				endpoints for custom routing accelerators</a>.</p>
    public let portRanges: [PortRange]?

    public init (
        listenerArn: String? = nil,
        portRanges: [PortRange]? = nil
    )
    {
        self.listenerArn = listenerArn
        self.portRanges = portRanges
    }
}

public enum CustomRoutingProtocol {
    case tcp
    case udp
    case sdkUnknown(String)
}

extension CustomRoutingProtocol : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomRoutingProtocol] {
        return [
            .tcp,
            .udp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .tcp: return "TCP"
        case .udp: return "UDP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomRoutingProtocol(rawValue: rawValue) ?? CustomRoutingProtocol.sdkUnknown(rawValue)
    }
}

public struct DeleteAcceleratorInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAcceleratorInput>
    public typealias MOutput = OperationOutput<DeleteAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAcceleratorOutputError>
}

extension DeleteAcceleratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAcceleratorInput(acceleratorArn: \(String(describing: acceleratorArn)))"}
}

extension DeleteAcceleratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

public struct DeleteAcceleratorInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAcceleratorInput>
    public typealias MOutput = OperationOutput<DeleteAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAcceleratorOutputError>
}

public struct DeleteAcceleratorInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAcceleratorInput>
    public typealias MOutput = OperationOutput<DeleteAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAcceleratorOutputError>
}

public struct DeleteAcceleratorInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an accelerator.</p>
    public let acceleratorArn: String?

    public init (
        acceleratorArn: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DeleteAcceleratorInputBody: Equatable {
    public let acceleratorArn: String?
}

extension DeleteAcceleratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DeleteAcceleratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAcceleratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotDisabledException" : self = .acceleratorNotDisabledException(try AcceleratorNotDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociatedListenerFoundException" : self = .associatedListenerFoundException(try AssociatedListenerFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAcceleratorOutputError: Equatable {
    case acceleratorNotDisabledException(AcceleratorNotDisabledException)
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case associatedListenerFoundException(AssociatedListenerFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAcceleratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAcceleratorOutputResponse()"}
}

extension DeleteAcceleratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAcceleratorOutputResponse: Equatable {

    public init() {}
}

struct DeleteAcceleratorOutputResponseBody: Equatable {
}

extension DeleteAcceleratorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteCustomRoutingAcceleratorInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCustomRoutingAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomRoutingAcceleratorInput>
    public typealias MOutput = OperationOutput<DeleteCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomRoutingAcceleratorOutputError>
}

extension DeleteCustomRoutingAcceleratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomRoutingAcceleratorInput(acceleratorArn: \(String(describing: acceleratorArn)))"}
}

extension DeleteCustomRoutingAcceleratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

public struct DeleteCustomRoutingAcceleratorInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCustomRoutingAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomRoutingAcceleratorInput>
    public typealias MOutput = OperationOutput<DeleteCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomRoutingAcceleratorOutputError>
}

public struct DeleteCustomRoutingAcceleratorInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCustomRoutingAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomRoutingAcceleratorInput>
    public typealias MOutput = OperationOutput<DeleteCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomRoutingAcceleratorOutputError>
}

public struct DeleteCustomRoutingAcceleratorInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom routing accelerator to delete.</p>
    public let acceleratorArn: String?

    public init (
        acceleratorArn: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DeleteCustomRoutingAcceleratorInputBody: Equatable {
    public let acceleratorArn: String?
}

extension DeleteCustomRoutingAcceleratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DeleteCustomRoutingAcceleratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomRoutingAcceleratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotDisabledException" : self = .acceleratorNotDisabledException(try AcceleratorNotDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociatedListenerFoundException" : self = .associatedListenerFoundException(try AssociatedListenerFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomRoutingAcceleratorOutputError: Equatable {
    case acceleratorNotDisabledException(AcceleratorNotDisabledException)
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case associatedListenerFoundException(AssociatedListenerFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomRoutingAcceleratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomRoutingAcceleratorOutputResponse()"}
}

extension DeleteCustomRoutingAcceleratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomRoutingAcceleratorOutputResponse: Equatable {

    public init() {}
}

struct DeleteCustomRoutingAcceleratorOutputResponseBody: Equatable {
}

extension DeleteCustomRoutingAcceleratorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteCustomRoutingEndpointGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCustomRoutingEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomRoutingEndpointGroupInput>
    public typealias MOutput = OperationOutput<DeleteCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomRoutingEndpointGroupOutputError>
}

extension DeleteCustomRoutingEndpointGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomRoutingEndpointGroupInput(endpointGroupArn: \(String(describing: endpointGroupArn)))"}
}

extension DeleteCustomRoutingEndpointGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

public struct DeleteCustomRoutingEndpointGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCustomRoutingEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomRoutingEndpointGroupInput>
    public typealias MOutput = OperationOutput<DeleteCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomRoutingEndpointGroupOutputError>
}

public struct DeleteCustomRoutingEndpointGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCustomRoutingEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomRoutingEndpointGroupInput>
    public typealias MOutput = OperationOutput<DeleteCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomRoutingEndpointGroupOutputError>
}

public struct DeleteCustomRoutingEndpointGroupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the endpoint group to delete.</p>
    public let endpointGroupArn: String?

    public init (
        endpointGroupArn: String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DeleteCustomRoutingEndpointGroupInputBody: Equatable {
    public let endpointGroupArn: String?
}

extension DeleteCustomRoutingEndpointGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DeleteCustomRoutingEndpointGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomRoutingEndpointGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomRoutingEndpointGroupOutputError: Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomRoutingEndpointGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomRoutingEndpointGroupOutputResponse()"}
}

extension DeleteCustomRoutingEndpointGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomRoutingEndpointGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteCustomRoutingEndpointGroupOutputResponseBody: Equatable {
}

extension DeleteCustomRoutingEndpointGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteCustomRoutingListenerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCustomRoutingListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomRoutingListenerInput>
    public typealias MOutput = OperationOutput<DeleteCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomRoutingListenerOutputError>
}

extension DeleteCustomRoutingListenerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomRoutingListenerInput(listenerArn: \(String(describing: listenerArn)))"}
}

extension DeleteCustomRoutingListenerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

public struct DeleteCustomRoutingListenerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCustomRoutingListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomRoutingListenerInput>
    public typealias MOutput = OperationOutput<DeleteCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomRoutingListenerOutputError>
}

public struct DeleteCustomRoutingListenerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCustomRoutingListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomRoutingListenerInput>
    public typealias MOutput = OperationOutput<DeleteCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomRoutingListenerOutputError>
}

public struct DeleteCustomRoutingListenerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener to delete.</p>
    public let listenerArn: String?

    public init (
        listenerArn: String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DeleteCustomRoutingListenerInputBody: Equatable {
    public let listenerArn: String?
}

extension DeleteCustomRoutingListenerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DeleteCustomRoutingListenerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomRoutingListenerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociatedEndpointGroupFoundException" : self = .associatedEndpointGroupFoundException(try AssociatedEndpointGroupFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomRoutingListenerOutputError: Equatable {
    case associatedEndpointGroupFoundException(AssociatedEndpointGroupFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomRoutingListenerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomRoutingListenerOutputResponse()"}
}

extension DeleteCustomRoutingListenerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomRoutingListenerOutputResponse: Equatable {

    public init() {}
}

struct DeleteCustomRoutingListenerOutputResponseBody: Equatable {
}

extension DeleteCustomRoutingListenerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteEndpointGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointGroupInput>
    public typealias MOutput = OperationOutput<DeleteEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointGroupOutputError>
}

extension DeleteEndpointGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEndpointGroupInput(endpointGroupArn: \(String(describing: endpointGroupArn)))"}
}

extension DeleteEndpointGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

public struct DeleteEndpointGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointGroupInput>
    public typealias MOutput = OperationOutput<DeleteEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointGroupOutputError>
}

public struct DeleteEndpointGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointGroupInput>
    public typealias MOutput = OperationOutput<DeleteEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointGroupOutputError>
}

public struct DeleteEndpointGroupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the endpoint group to delete.</p>
    public let endpointGroupArn: String?

    public init (
        endpointGroupArn: String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DeleteEndpointGroupInputBody: Equatable {
    public let endpointGroupArn: String?
}

extension DeleteEndpointGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DeleteEndpointGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEndpointGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEndpointGroupOutputError: Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEndpointGroupOutputResponse()"}
}

extension DeleteEndpointGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEndpointGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteEndpointGroupOutputResponseBody: Equatable {
}

extension DeleteEndpointGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteListenerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteListenerInput>
    public typealias MOutput = OperationOutput<DeleteListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteListenerOutputError>
}

extension DeleteListenerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteListenerInput(listenerArn: \(String(describing: listenerArn)))"}
}

extension DeleteListenerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

public struct DeleteListenerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteListenerInput>
    public typealias MOutput = OperationOutput<DeleteListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteListenerOutputError>
}

public struct DeleteListenerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteListenerInput>
    public typealias MOutput = OperationOutput<DeleteListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteListenerOutputError>
}

public struct DeleteListenerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: String?

    public init (
        listenerArn: String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DeleteListenerInputBody: Equatable {
    public let listenerArn: String?
}

extension DeleteListenerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DeleteListenerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteListenerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociatedEndpointGroupFoundException" : self = .associatedEndpointGroupFoundException(try AssociatedEndpointGroupFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteListenerOutputError: Equatable {
    case associatedEndpointGroupFoundException(AssociatedEndpointGroupFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteListenerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteListenerOutputResponse()"}
}

extension DeleteListenerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteListenerOutputResponse: Equatable {

    public init() {}
}

struct DeleteListenerOutputResponseBody: Equatable {
}

extension DeleteListenerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DenyCustomRoutingTrafficInputBodyMiddleware: Middleware {
    public let id: String = "DenyCustomRoutingTrafficInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DenyCustomRoutingTrafficInput>,
                  next: H) -> Swift.Result<OperationOutput<DenyCustomRoutingTrafficOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DenyCustomRoutingTrafficInput>
    public typealias MOutput = OperationOutput<DenyCustomRoutingTrafficOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DenyCustomRoutingTrafficOutputError>
}

extension DenyCustomRoutingTrafficInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DenyCustomRoutingTrafficInput(denyAllTrafficToEndpoint: \(String(describing: denyAllTrafficToEndpoint)), destinationAddresses: \(String(describing: destinationAddresses)), destinationPorts: \(String(describing: destinationPorts)), endpointGroupArn: \(String(describing: endpointGroupArn)), endpointId: \(String(describing: endpointId)))"}
}

extension DenyCustomRoutingTrafficInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case denyAllTrafficToEndpoint = "DenyAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let denyAllTrafficToEndpoint = denyAllTrafficToEndpoint {
            try encodeContainer.encode(denyAllTrafficToEndpoint, forKey: .denyAllTrafficToEndpoint)
        }
        if let destinationAddresses = destinationAddresses {
            var destinationAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationAddresses)
            for destinationaddresses0 in destinationAddresses {
                try destinationAddressesContainer.encode(destinationaddresses0)
            }
        }
        if let destinationPorts = destinationPorts {
            var destinationPortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPorts)
            for destinationports0 in destinationPorts {
                try destinationPortsContainer.encode(destinationports0)
            }
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
    }
}

public struct DenyCustomRoutingTrafficInputHeadersMiddleware: Middleware {
    public let id: String = "DenyCustomRoutingTrafficInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DenyCustomRoutingTrafficInput>,
                  next: H) -> Swift.Result<OperationOutput<DenyCustomRoutingTrafficOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DenyCustomRoutingTrafficInput>
    public typealias MOutput = OperationOutput<DenyCustomRoutingTrafficOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DenyCustomRoutingTrafficOutputError>
}

public struct DenyCustomRoutingTrafficInputQueryItemMiddleware: Middleware {
    public let id: String = "DenyCustomRoutingTrafficInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DenyCustomRoutingTrafficInput>,
                  next: H) -> Swift.Result<OperationOutput<DenyCustomRoutingTrafficOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DenyCustomRoutingTrafficInput>
    public typealias MOutput = OperationOutput<DenyCustomRoutingTrafficOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DenyCustomRoutingTrafficOutputError>
}

public struct DenyCustomRoutingTrafficInput: Equatable {
    /// <p>Indicates whether all destination IP addresses and ports for a specified VPC subnet endpoint <i>cannot</i>
    /// 			receive traffic from a custom routing accelerator. The value is TRUE or FALSE. </p>
    /// 		       <p>When set to TRUE, <i>no</i> destinations in the custom routing VPC subnet can receive traffic. Note
    /// 			that you cannot specify destination IP addresses and ports when the value is set to TRUE.</p>
    /// 		       <p>When set to FALSE (or not specified), you <i>must</i> specify a list of destination IP addresses that cannot receive
    /// 			traffic. A list of ports is optional. If you don't specify a list of ports, the ports that can accept traffic is
    /// 			the same as the ports configured for the endpoint group.</p>
    /// 		       <p>The default value is FALSE.</p>
    public let denyAllTrafficToEndpoint: Bool?
    /// <p>A list of specific Amazon EC2 instance IP addresses (destination addresses) in a subnet that you want to prevent from receiving
    /// 			traffic. The IP addresses must be a subset of the IP addresses allowed for the VPC subnet associated with the
    /// 			endpoint group.</p>
    public let destinationAddresses: [String]?
    /// <p>A list of specific Amazon EC2 instance ports (destination ports) in a subnet endpoint that you want to prevent from
    /// 			receiving traffic.</p>
    public let destinationPorts: [Int]?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
    public let endpointGroupArn: String?
    /// <p>An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.</p>
    public let endpointId: String?

    public init (
        denyAllTrafficToEndpoint: Bool? = nil,
        destinationAddresses: [String]? = nil,
        destinationPorts: [Int]? = nil,
        endpointGroupArn: String? = nil,
        endpointId: String? = nil
    )
    {
        self.denyAllTrafficToEndpoint = denyAllTrafficToEndpoint
        self.destinationAddresses = destinationAddresses
        self.destinationPorts = destinationPorts
        self.endpointGroupArn = endpointGroupArn
        self.endpointId = endpointId
    }
}

struct DenyCustomRoutingTrafficInputBody: Equatable {
    public let endpointGroupArn: String?
    public let endpointId: String?
    public let destinationAddresses: [String]?
    public let destinationPorts: [Int]?
    public let denyAllTrafficToEndpoint: Bool?
}

extension DenyCustomRoutingTrafficInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case denyAllTrafficToEndpoint = "DenyAllTrafficToEndpoint"
        case destinationAddresses = "DestinationAddresses"
        case destinationPorts = "DestinationPorts"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .destinationAddresses)
        var destinationAddressesDecoded0:[String]? = nil
        if let destinationAddressesContainer = destinationAddressesContainer {
            destinationAddressesDecoded0 = [String]()
            for string0 in destinationAddressesContainer {
                if let string0 = string0 {
                    destinationAddressesDecoded0?.append(string0)
                }
            }
        }
        destinationAddresses = destinationAddressesDecoded0
        let destinationPortsContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .destinationPorts)
        var destinationPortsDecoded0:[Int]? = nil
        if let destinationPortsContainer = destinationPortsContainer {
            destinationPortsDecoded0 = [Int]()
            for integer0 in destinationPortsContainer {
                if let integer0 = integer0 {
                    destinationPortsDecoded0?.append(integer0)
                }
            }
        }
        destinationPorts = destinationPortsDecoded0
        let denyAllTrafficToEndpointDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .denyAllTrafficToEndpoint)
        denyAllTrafficToEndpoint = denyAllTrafficToEndpointDecoded
    }
}

extension DenyCustomRoutingTrafficOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DenyCustomRoutingTrafficOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DenyCustomRoutingTrafficOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DenyCustomRoutingTrafficOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DenyCustomRoutingTrafficOutputResponse()"}
}

extension DenyCustomRoutingTrafficOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DenyCustomRoutingTrafficOutputResponse: Equatable {

    public init() {}
}

struct DenyCustomRoutingTrafficOutputResponseBody: Equatable {
}

extension DenyCustomRoutingTrafficOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeprovisionByoipCidrInputBodyMiddleware: Middleware {
    public let id: String = "DeprovisionByoipCidrInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeprovisionByoipCidrInput>,
                  next: H) -> Swift.Result<OperationOutput<DeprovisionByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeprovisionByoipCidrInput>
    public typealias MOutput = OperationOutput<DeprovisionByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeprovisionByoipCidrOutputError>
}

extension DeprovisionByoipCidrInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeprovisionByoipCidrInput(cidr: \(String(describing: cidr)))"}
}

extension DeprovisionByoipCidrInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }
}

public struct DeprovisionByoipCidrInputHeadersMiddleware: Middleware {
    public let id: String = "DeprovisionByoipCidrInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeprovisionByoipCidrInput>,
                  next: H) -> Swift.Result<OperationOutput<DeprovisionByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeprovisionByoipCidrInput>
    public typealias MOutput = OperationOutput<DeprovisionByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeprovisionByoipCidrOutputError>
}

public struct DeprovisionByoipCidrInputQueryItemMiddleware: Middleware {
    public let id: String = "DeprovisionByoipCidrInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeprovisionByoipCidrInput>,
                  next: H) -> Swift.Result<OperationOutput<DeprovisionByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeprovisionByoipCidrInput>
    public typealias MOutput = OperationOutput<DeprovisionByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeprovisionByoipCidrOutputError>
}

public struct DeprovisionByoipCidrInput: Equatable {
    /// <p>The address range, in CIDR notation. The prefix must be the same prefix that you specified
    /// 			when you provisioned the address range.</p>
    public let cidr: String?

    public init (
        cidr: String? = nil
    )
    {
        self.cidr = cidr
    }
}

struct DeprovisionByoipCidrInputBody: Equatable {
    public let cidr: String?
}

extension DeprovisionByoipCidrInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension DeprovisionByoipCidrOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeprovisionByoipCidrOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ByoipCidrNotFoundException" : self = .byoipCidrNotFoundException(try ByoipCidrNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectCidrStateException" : self = .incorrectCidrStateException(try IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeprovisionByoipCidrOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case byoipCidrNotFoundException(ByoipCidrNotFoundException)
    case incorrectCidrStateException(IncorrectCidrStateException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeprovisionByoipCidrOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeprovisionByoipCidrOutputResponse(byoipCidr: \(String(describing: byoipCidr)))"}
}

extension DeprovisionByoipCidrOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeprovisionByoipCidrOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct DeprovisionByoipCidrOutputResponse: Equatable {
    /// <p>Information about the address range.</p>
    public let byoipCidr: ByoipCidr?

    public init (
        byoipCidr: ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct DeprovisionByoipCidrOutputResponseBody: Equatable {
    public let byoipCidr: ByoipCidr?
}

extension DeprovisionByoipCidrOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

public struct DescribeAcceleratorAttributesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorAttributesOutputError>
}

extension DescribeAcceleratorAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAcceleratorAttributesInput(acceleratorArn: \(String(describing: acceleratorArn)))"}
}

extension DescribeAcceleratorAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

public struct DescribeAcceleratorAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorAttributesOutputError>
}

public struct DescribeAcceleratorAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorAttributesOutputError>
}

public struct DescribeAcceleratorAttributesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator with the attributes that you want to describe.</p>
    public let acceleratorArn: String?

    public init (
        acceleratorArn: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeAcceleratorAttributesInputBody: Equatable {
    public let acceleratorArn: String?
}

extension DescribeAcceleratorAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeAcceleratorAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAcceleratorAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAcceleratorAttributesOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAcceleratorAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAcceleratorAttributesOutputResponse(acceleratorAttributes: \(String(describing: acceleratorAttributes)))"}
}

extension DescribeAcceleratorAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAcceleratorAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct DescribeAcceleratorAttributesOutputResponse: Equatable {
    /// <p>The attributes of the accelerator.</p>
    public let acceleratorAttributes: AcceleratorAttributes?

    public init (
        acceleratorAttributes: AcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct DescribeAcceleratorAttributesOutputResponseBody: Equatable {
    public let acceleratorAttributes: AcceleratorAttributes?
}

extension DescribeAcceleratorAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(AcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

public struct DescribeAcceleratorInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorOutputError>
}

extension DescribeAcceleratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAcceleratorInput(acceleratorArn: \(String(describing: acceleratorArn)))"}
}

extension DescribeAcceleratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

public struct DescribeAcceleratorInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorOutputError>
}

public struct DescribeAcceleratorInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAcceleratorInput>
    public typealias MOutput = OperationOutput<DescribeAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAcceleratorOutputError>
}

public struct DescribeAcceleratorInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to describe.</p>
    public let acceleratorArn: String?

    public init (
        acceleratorArn: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeAcceleratorInputBody: Equatable {
    public let acceleratorArn: String?
}

extension DescribeAcceleratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeAcceleratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAcceleratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAcceleratorOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAcceleratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAcceleratorOutputResponse(accelerator: \(String(describing: accelerator)))"}
}

extension DescribeAcceleratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct DescribeAcceleratorOutputResponse: Equatable {
    /// <p>The description of the accelerator.</p>
    public let accelerator: Accelerator?

    public init (
        accelerator: Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct DescribeAcceleratorOutputResponseBody: Equatable {
    public let accelerator: Accelerator?
}

extension DescribeAcceleratorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(Accelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

public struct DescribeCustomRoutingAcceleratorAttributesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCustomRoutingAcceleratorAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomRoutingAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomRoutingAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomRoutingAcceleratorAttributesInput>
    public typealias MOutput = OperationOutput<DescribeCustomRoutingAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomRoutingAcceleratorAttributesOutputError>
}

extension DescribeCustomRoutingAcceleratorAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomRoutingAcceleratorAttributesInput(acceleratorArn: \(String(describing: acceleratorArn)))"}
}

extension DescribeCustomRoutingAcceleratorAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

public struct DescribeCustomRoutingAcceleratorAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCustomRoutingAcceleratorAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomRoutingAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomRoutingAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomRoutingAcceleratorAttributesInput>
    public typealias MOutput = OperationOutput<DescribeCustomRoutingAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomRoutingAcceleratorAttributesOutputError>
}

public struct DescribeCustomRoutingAcceleratorAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCustomRoutingAcceleratorAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomRoutingAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomRoutingAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomRoutingAcceleratorAttributesInput>
    public typealias MOutput = OperationOutput<DescribeCustomRoutingAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomRoutingAcceleratorAttributesOutputError>
}

public struct DescribeCustomRoutingAcceleratorAttributesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom routing accelerator to describe the attributes for.</p>
    public let acceleratorArn: String?

    public init (
        acceleratorArn: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeCustomRoutingAcceleratorAttributesInputBody: Equatable {
    public let acceleratorArn: String?
}

extension DescribeCustomRoutingAcceleratorAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeCustomRoutingAcceleratorAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomRoutingAcceleratorAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomRoutingAcceleratorAttributesOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomRoutingAcceleratorAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomRoutingAcceleratorAttributesOutputResponse(acceleratorAttributes: \(String(describing: acceleratorAttributes)))"}
}

extension DescribeCustomRoutingAcceleratorAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCustomRoutingAcceleratorAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct DescribeCustomRoutingAcceleratorAttributesOutputResponse: Equatable {
    /// <p>The attributes of the custom routing accelerator.</p>
    public let acceleratorAttributes: CustomRoutingAcceleratorAttributes?

    public init (
        acceleratorAttributes: CustomRoutingAcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct DescribeCustomRoutingAcceleratorAttributesOutputResponseBody: Equatable {
    public let acceleratorAttributes: CustomRoutingAcceleratorAttributes?
}

extension DescribeCustomRoutingAcceleratorAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(CustomRoutingAcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

public struct DescribeCustomRoutingAcceleratorInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCustomRoutingAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomRoutingAcceleratorInput>
    public typealias MOutput = OperationOutput<DescribeCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomRoutingAcceleratorOutputError>
}

extension DescribeCustomRoutingAcceleratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomRoutingAcceleratorInput(acceleratorArn: \(String(describing: acceleratorArn)))"}
}

extension DescribeCustomRoutingAcceleratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
    }
}

public struct DescribeCustomRoutingAcceleratorInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCustomRoutingAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomRoutingAcceleratorInput>
    public typealias MOutput = OperationOutput<DescribeCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomRoutingAcceleratorOutputError>
}

public struct DescribeCustomRoutingAcceleratorInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCustomRoutingAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomRoutingAcceleratorInput>
    public typealias MOutput = OperationOutput<DescribeCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomRoutingAcceleratorOutputError>
}

public struct DescribeCustomRoutingAcceleratorInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to describe.</p>
    public let acceleratorArn: String?

    public init (
        acceleratorArn: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
    }
}

struct DescribeCustomRoutingAcceleratorInputBody: Equatable {
    public let acceleratorArn: String?
}

extension DescribeCustomRoutingAcceleratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
    }
}

extension DescribeCustomRoutingAcceleratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomRoutingAcceleratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomRoutingAcceleratorOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomRoutingAcceleratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomRoutingAcceleratorOutputResponse(accelerator: \(String(describing: accelerator)))"}
}

extension DescribeCustomRoutingAcceleratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCustomRoutingAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct DescribeCustomRoutingAcceleratorOutputResponse: Equatable {
    /// <p>The description of the custom routing accelerator.</p>
    public let accelerator: CustomRoutingAccelerator?

    public init (
        accelerator: CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct DescribeCustomRoutingAcceleratorOutputResponseBody: Equatable {
    public let accelerator: CustomRoutingAccelerator?
}

extension DescribeCustomRoutingAcceleratorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(CustomRoutingAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

public struct DescribeCustomRoutingEndpointGroupInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCustomRoutingEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomRoutingEndpointGroupInput>
    public typealias MOutput = OperationOutput<DescribeCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomRoutingEndpointGroupOutputError>
}

extension DescribeCustomRoutingEndpointGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomRoutingEndpointGroupInput(endpointGroupArn: \(String(describing: endpointGroupArn)))"}
}

extension DescribeCustomRoutingEndpointGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

public struct DescribeCustomRoutingEndpointGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCustomRoutingEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomRoutingEndpointGroupInput>
    public typealias MOutput = OperationOutput<DescribeCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomRoutingEndpointGroupOutputError>
}

public struct DescribeCustomRoutingEndpointGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCustomRoutingEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomRoutingEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomRoutingEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomRoutingEndpointGroupInput>
    public typealias MOutput = OperationOutput<DescribeCustomRoutingEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomRoutingEndpointGroupOutputError>
}

public struct DescribeCustomRoutingEndpointGroupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the endpoint group to describe.</p>
    public let endpointGroupArn: String?

    public init (
        endpointGroupArn: String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DescribeCustomRoutingEndpointGroupInputBody: Equatable {
    public let endpointGroupArn: String?
}

extension DescribeCustomRoutingEndpointGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DescribeCustomRoutingEndpointGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomRoutingEndpointGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomRoutingEndpointGroupOutputError: Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomRoutingEndpointGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomRoutingEndpointGroupOutputResponse(endpointGroup: \(String(describing: endpointGroup)))"}
}

extension DescribeCustomRoutingEndpointGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCustomRoutingEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct DescribeCustomRoutingEndpointGroupOutputResponse: Equatable {
    /// <p>The description of an endpoint group for a custom routing accelerator.</p>
    public let endpointGroup: CustomRoutingEndpointGroup?

    public init (
        endpointGroup: CustomRoutingEndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct DescribeCustomRoutingEndpointGroupOutputResponseBody: Equatable {
    public let endpointGroup: CustomRoutingEndpointGroup?
}

extension DescribeCustomRoutingEndpointGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(CustomRoutingEndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

public struct DescribeCustomRoutingListenerInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCustomRoutingListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomRoutingListenerInput>
    public typealias MOutput = OperationOutput<DescribeCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomRoutingListenerOutputError>
}

extension DescribeCustomRoutingListenerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomRoutingListenerInput(listenerArn: \(String(describing: listenerArn)))"}
}

extension DescribeCustomRoutingListenerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

public struct DescribeCustomRoutingListenerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCustomRoutingListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomRoutingListenerInput>
    public typealias MOutput = OperationOutput<DescribeCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomRoutingListenerOutputError>
}

public struct DescribeCustomRoutingListenerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCustomRoutingListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCustomRoutingListenerInput>
    public typealias MOutput = OperationOutput<DescribeCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCustomRoutingListenerOutputError>
}

public struct DescribeCustomRoutingListenerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener to describe.</p>
    public let listenerArn: String?

    public init (
        listenerArn: String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DescribeCustomRoutingListenerInputBody: Equatable {
    public let listenerArn: String?
}

extension DescribeCustomRoutingListenerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DescribeCustomRoutingListenerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomRoutingListenerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomRoutingListenerOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomRoutingListenerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCustomRoutingListenerOutputResponse(listener: \(String(describing: listener)))"}
}

extension DescribeCustomRoutingListenerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCustomRoutingListenerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct DescribeCustomRoutingListenerOutputResponse: Equatable {
    /// <p>The description of a listener for a custom routing accelerator.</p>
    public let listener: CustomRoutingListener?

    public init (
        listener: CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

struct DescribeCustomRoutingListenerOutputResponseBody: Equatable {
    public let listener: CustomRoutingListener?
}

extension DescribeCustomRoutingListenerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(CustomRoutingListener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

public struct DescribeEndpointGroupInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointGroupInput>
    public typealias MOutput = OperationOutput<DescribeEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointGroupOutputError>
}

extension DescribeEndpointGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointGroupInput(endpointGroupArn: \(String(describing: endpointGroupArn)))"}
}

extension DescribeEndpointGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
    }
}

public struct DescribeEndpointGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointGroupInput>
    public typealias MOutput = OperationOutput<DescribeEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointGroupOutputError>
}

public struct DescribeEndpointGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointGroupInput>
    public typealias MOutput = OperationOutput<DescribeEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointGroupOutputError>
}

public struct DescribeEndpointGroupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the endpoint group to describe.</p>
    public let endpointGroupArn: String?

    public init (
        endpointGroupArn: String? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
    }
}

struct DescribeEndpointGroupInputBody: Equatable {
    public let endpointGroupArn: String?
}

extension DescribeEndpointGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension DescribeEndpointGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointGroupOutputError: Equatable {
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointGroupOutputResponse(endpointGroup: \(String(describing: endpointGroup)))"}
}

extension DescribeEndpointGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct DescribeEndpointGroupOutputResponse: Equatable {
    /// <p>The description of an endpoint group.</p>
    public let endpointGroup: EndpointGroup?

    public init (
        endpointGroup: EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct DescribeEndpointGroupOutputResponseBody: Equatable {
    public let endpointGroup: EndpointGroup?
}

extension DescribeEndpointGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(EndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

public struct DescribeListenerInputBodyMiddleware: Middleware {
    public let id: String = "DescribeListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeListenerInput>
    public typealias MOutput = OperationOutput<DescribeListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeListenerOutputError>
}

extension DescribeListenerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeListenerInput(listenerArn: \(String(describing: listenerArn)))"}
}

extension DescribeListenerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
    }
}

public struct DescribeListenerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeListenerInput>
    public typealias MOutput = OperationOutput<DescribeListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeListenerOutputError>
}

public struct DescribeListenerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeListenerInput>
    public typealias MOutput = OperationOutput<DescribeListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeListenerOutputError>
}

public struct DescribeListenerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener to describe.</p>
    public let listenerArn: String?

    public init (
        listenerArn: String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

struct DescribeListenerInputBody: Equatable {
    public let listenerArn: String?
}

extension DescribeListenerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
    }
}

extension DescribeListenerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeListenerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeListenerOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeListenerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeListenerOutputResponse(listener: \(String(describing: listener)))"}
}

extension DescribeListenerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeListenerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct DescribeListenerOutputResponse: Equatable {
    /// <p>The description of a listener.</p>
    public let listener: Listener?

    public init (
        listener: Listener? = nil
    )
    {
        self.listener = listener
    }
}

struct DescribeListenerOutputResponseBody: Equatable {
    public let listener: Listener?
}

extension DescribeListenerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(Listener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

extension DestinationPortMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case acceleratorSocketAddresses = "AcceleratorSocketAddresses"
        case destinationSocketAddress = "DestinationSocketAddress"
        case destinationTrafficState = "DestinationTrafficState"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointGroupRegion = "EndpointGroupRegion"
        case endpointId = "EndpointId"
        case ipAddressType = "IpAddressType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let acceleratorSocketAddresses = acceleratorSocketAddresses {
            var acceleratorSocketAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorSocketAddresses)
            for socketaddresses0 in acceleratorSocketAddresses {
                try acceleratorSocketAddressesContainer.encode(socketaddresses0)
            }
        }
        if let destinationSocketAddress = destinationSocketAddress {
            try encodeContainer.encode(destinationSocketAddress, forKey: .destinationSocketAddress)
        }
        if let destinationTrafficState = destinationTrafficState {
            try encodeContainer.encode(destinationTrafficState.rawValue, forKey: .destinationTrafficState)
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointGroupRegion = endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let acceleratorSocketAddressesContainer = try containerValues.decodeIfPresent([SocketAddress?].self, forKey: .acceleratorSocketAddresses)
        var acceleratorSocketAddressesDecoded0:[SocketAddress]? = nil
        if let acceleratorSocketAddressesContainer = acceleratorSocketAddressesContainer {
            acceleratorSocketAddressesDecoded0 = [SocketAddress]()
            for structure0 in acceleratorSocketAddressesContainer {
                if let structure0 = structure0 {
                    acceleratorSocketAddressesDecoded0?.append(structure0)
                }
            }
        }
        acceleratorSocketAddresses = acceleratorSocketAddressesDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let destinationSocketAddressDecoded = try containerValues.decodeIfPresent(SocketAddress.self, forKey: .destinationSocketAddress)
        destinationSocketAddress = destinationSocketAddressDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let destinationTrafficStateDecoded = try containerValues.decodeIfPresent(CustomRoutingDestinationTrafficState.self, forKey: .destinationTrafficState)
        destinationTrafficState = destinationTrafficStateDecoded
    }
}

extension DestinationPortMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationPortMapping(acceleratorArn: \(String(describing: acceleratorArn)), acceleratorSocketAddresses: \(String(describing: acceleratorSocketAddresses)), destinationSocketAddress: \(String(describing: destinationSocketAddress)), destinationTrafficState: \(String(describing: destinationTrafficState)), endpointGroupArn: \(String(describing: endpointGroupArn)), endpointGroupRegion: \(String(describing: endpointGroupRegion)), endpointId: \(String(describing: endpointId)), ipAddressType: \(String(describing: ipAddressType)))"}
}

/// <p>The port mappings for a specified endpoint IP address (destination).</p>
public struct DestinationPortMapping: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom routing accelerator
    /// 			that you have port mappings for.</p>
    public let acceleratorArn: String?
    /// <p>The IP address/port combinations (sockets) that map to a given destination socket
    /// 			address.</p>
    public let acceleratorSocketAddresses: [SocketAddress]?
    /// <p>The endpoint IP address/port combination for traffic received on the accelerator socket address.</p>
    public let destinationSocketAddress: SocketAddress?
    /// <p>Indicates whether or not a port mapping destination can receive traffic. The value is either ALLOW, if
    /// 			traffic is allowed to the destination, or DENY, if traffic is not allowed to the destination.</p>
    public let destinationTrafficState: CustomRoutingDestinationTrafficState?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
    public let endpointGroupArn: String?
    /// <p>The AWS Region for the endpoint group.</p>
    public let endpointGroupRegion: String?
    /// <p>The ID for the virtual private cloud (VPC) subnet.</p>
    public let endpointId: String?
    /// <p>The IP address type, which must be IPv4.</p>
    public let ipAddressType: IpAddressType?

    public init (
        acceleratorArn: String? = nil,
        acceleratorSocketAddresses: [SocketAddress]? = nil,
        destinationSocketAddress: SocketAddress? = nil,
        destinationTrafficState: CustomRoutingDestinationTrafficState? = nil,
        endpointGroupArn: String? = nil,
        endpointGroupRegion: String? = nil,
        endpointId: String? = nil,
        ipAddressType: IpAddressType? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.acceleratorSocketAddresses = acceleratorSocketAddresses
        self.destinationSocketAddress = destinationSocketAddress
        self.destinationTrafficState = destinationTrafficState
        self.endpointGroupArn = endpointGroupArn
        self.endpointGroupRegion = endpointGroupRegion
        self.endpointId = endpointId
        self.ipAddressType = ipAddressType
    }
}

extension EndpointAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointAlreadyExistsException(message: \(String(describing: message)))"}
}

extension EndpointAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EndpointAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The endpoint that you specified doesn't exist.</p>
public struct EndpointAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension EndpointAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
        case endpointId = "EndpointId"
        case weight = "Weight"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIPPreservationEnabled = clientIPPreservationEnabled {
            try encodeContainer.encode(clientIPPreservationEnabled, forKey: .clientIPPreservationEnabled)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let weight = weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .weight)
        weight = weightDecoded
        let clientIPPreservationEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .clientIPPreservationEnabled)
        clientIPPreservationEnabled = clientIPPreservationEnabledDecoded
    }
}

extension EndpointConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointConfiguration(clientIPPreservationEnabled: \(String(describing: clientIPPreservationEnabled)), endpointId: \(String(describing: endpointId)), weight: \(String(describing: weight)))"}
}

/// <p>A complex type for endpoints. A resource must be valid and active when you add it as an endpoint.</p>
public struct EndpointConfiguration: Equatable {
    /// <p>Indicates whether client IP address preservation is enabled for an Application Load Balancer endpoint.
    /// 			The value is true or false. The default value is true for new accelerators. </p>
    /// 		       <p>If the value is set to true, the client's IP address is preserved in the <code>X-Forwarded-For</code> request header as
    /// 			traffic travels to applications on the Application Load Balancer endpoint fronted by the accelerator.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/preserve-client-ip-address.html">
    /// 			Preserve Client IP Addresses in AWS Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let clientIPPreservationEnabled: Bool?
    /// <p>An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon
    /// 			Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address
    /// 			allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. A resource must be valid and active
    /// 			when you add it as an endpoint.</p>
    /// 		       <p>An Application Load Balancer can be either internal or internet-facing.</p>
    public let endpointId: String?
    /// <p>The weight associated with the endpoint. When you add weights to endpoints, you configure AWS Global Accelerator to route traffic
    /// 			based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The
    /// 			result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second
    /// 			and third endpoints, and 6/20 is routed to the last endpoint. For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoints-endpoint-weights.html">Endpoint Weights</a> in the
    /// 				<i>AWS Global Accelerator Developer Guide</i>.</p>
    public let weight: Int?

    public init (
        clientIPPreservationEnabled: Bool? = nil,
        endpointId: String? = nil,
        weight: Int? = nil
    )
    {
        self.clientIPPreservationEnabled = clientIPPreservationEnabled
        self.endpointId = endpointId
        self.weight = weight
    }
}

extension EndpointDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
        case endpointId = "EndpointId"
        case healthReason = "HealthReason"
        case healthState = "HealthState"
        case weight = "Weight"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIPPreservationEnabled = clientIPPreservationEnabled {
            try encodeContainer.encode(clientIPPreservationEnabled, forKey: .clientIPPreservationEnabled)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let healthReason = healthReason {
            try encodeContainer.encode(healthReason, forKey: .healthReason)
        }
        if let healthState = healthState {
            try encodeContainer.encode(healthState.rawValue, forKey: .healthState)
        }
        if let weight = weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .weight)
        weight = weightDecoded
        let healthStateDecoded = try containerValues.decodeIfPresent(HealthState.self, forKey: .healthState)
        healthState = healthStateDecoded
        let healthReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthReason)
        healthReason = healthReasonDecoded
        let clientIPPreservationEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .clientIPPreservationEnabled)
        clientIPPreservationEnabled = clientIPPreservationEnabledDecoded
    }
}

extension EndpointDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointDescription(clientIPPreservationEnabled: \(String(describing: clientIPPreservationEnabled)), endpointId: \(String(describing: endpointId)), healthReason: \(String(describing: healthReason)), healthState: \(String(describing: healthState)), weight: \(String(describing: weight)))"}
}

/// <p>A complex type for an endpoint. Each endpoint group can include one or more endpoints, such as load
/// 			balancers.</p>
public struct EndpointDescription: Equatable {
    /// <p>Indicates whether client IP address preservation is enabled for an Application Load Balancer endpoint.
    /// 			The value is true or false. The default value is true for new accelerators. </p>
    /// 		       <p>If the value is set to true, the client's IP address is preserved in the <code>X-Forwarded-For</code> request header as
    /// 			traffic travels to applications on the Application Load Balancer endpoint fronted by the accelerator.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/introduction-how-it-works-client-ip.html">
    /// 			Viewing Client IP Addresses in AWS Global Accelerator</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let clientIPPreservationEnabled: Bool?
    /// <p>An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon
    /// 			Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address
    /// 			allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. </p>
    /// 		       <p>An Application Load Balancer can be either internal or internet-facing.</p>
    public let endpointId: String?
    /// <p>Returns a null result.</p>
    public let healthReason: String?
    /// <p>The health status of the endpoint.</p>
    public let healthState: HealthState?
    /// <p>The weight associated with the endpoint. When you add weights to endpoints, you configure AWS Global Accelerator to route traffic
    /// 			based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The
    /// 			result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second
    /// 			and third endpoints, and 6/20 is routed to the last endpoint. For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoints-endpoint-weights.html">Endpoint Weights</a> in the
    /// 				<i>AWS Global Accelerator Developer Guide</i>. </p>
    public let weight: Int?

    public init (
        clientIPPreservationEnabled: Bool? = nil,
        endpointId: String? = nil,
        healthReason: String? = nil,
        healthState: HealthState? = nil,
        weight: Int? = nil
    )
    {
        self.clientIPPreservationEnabled = clientIPPreservationEnabled
        self.endpointId = endpointId
        self.healthReason = healthReason
        self.healthState = healthState
        self.weight = weight
    }
}

extension EndpointGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointDescriptions = "EndpointDescriptions"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointGroupRegion = "EndpointGroupRegion"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointDescriptions = endpointDescriptions {
            var endpointDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDescriptions)
            for endpointdescriptions0 in endpointDescriptions {
                try endpointDescriptionsContainer.encode(endpointdescriptions0)
            }
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointGroupRegion = endpointGroupRegion {
            try encodeContainer.encode(endpointGroupRegion, forKey: .endpointGroupRegion)
        }
        if let healthCheckIntervalSeconds = healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckPath = healthCheckPath {
            try encodeContainer.encode(healthCheckPath, forKey: .healthCheckPath)
        }
        if let healthCheckPort = healthCheckPort {
            try encodeContainer.encode(healthCheckPort, forKey: .healthCheckPort)
        }
        if let healthCheckProtocol = healthCheckProtocol {
            try encodeContainer.encode(healthCheckProtocol.rawValue, forKey: .healthCheckProtocol)
        }
        if let portOverrides = portOverrides {
            var portOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portOverrides)
            for portoverrides0 in portOverrides {
                try portOverridesContainer.encode(portoverrides0)
            }
        }
        if let thresholdCount = thresholdCount {
            try encodeContainer.encode(thresholdCount, forKey: .thresholdCount)
        }
        if let trafficDialPercentage = trafficDialPercentage {
            try encodeContainer.encode(trafficDialPercentage, forKey: .trafficDialPercentage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointGroupRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupRegion)
        endpointGroupRegion = endpointGroupRegionDecoded
        let endpointDescriptionsContainer = try containerValues.decodeIfPresent([EndpointDescription?].self, forKey: .endpointDescriptions)
        var endpointDescriptionsDecoded0:[EndpointDescription]? = nil
        if let endpointDescriptionsContainer = endpointDescriptionsContainer {
            endpointDescriptionsDecoded0 = [EndpointDescription]()
            for structure0 in endpointDescriptionsContainer {
                if let structure0 = structure0 {
                    endpointDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        endpointDescriptions = endpointDescriptionsDecoded0
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(HealthCheckProtocol.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let thresholdCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .thresholdCount)
        thresholdCount = thresholdCountDecoded
        let portOverridesContainer = try containerValues.decodeIfPresent([PortOverride?].self, forKey: .portOverrides)
        var portOverridesDecoded0:[PortOverride]? = nil
        if let portOverridesContainer = portOverridesContainer {
            portOverridesDecoded0 = [PortOverride]()
            for structure0 in portOverridesContainer {
                if let structure0 = structure0 {
                    portOverridesDecoded0?.append(structure0)
                }
            }
        }
        portOverrides = portOverridesDecoded0
    }
}

extension EndpointGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointGroup(endpointDescriptions: \(String(describing: endpointDescriptions)), endpointGroupArn: \(String(describing: endpointGroupArn)), endpointGroupRegion: \(String(describing: endpointGroupRegion)), healthCheckIntervalSeconds: \(String(describing: healthCheckIntervalSeconds)), healthCheckPath: \(String(describing: healthCheckPath)), healthCheckPort: \(String(describing: healthCheckPort)), healthCheckProtocol: \(String(describing: healthCheckProtocol)), portOverrides: \(String(describing: portOverrides)), thresholdCount: \(String(describing: thresholdCount)), trafficDialPercentage: \(String(describing: trafficDialPercentage)))"}
}

/// <p>A complex type for the endpoint group. An AWS Region can have only one endpoint group for a specific listener.
/// 		</p>
public struct EndpointGroup: Equatable {
    /// <p>The list of endpoint objects.</p>
    public let endpointDescriptions: [EndpointDescription]?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
    public let endpointGroupArn: String?
    /// <p>The AWS Region where the endpoint group is located.</p>
    public let endpointGroupRegion: String?
    /// <p>The timeâ€”10 seconds or 30 secondsâ€”between health checks for each endpoint. The default value is 30.</p>
    public let healthCheckIntervalSeconds: Int?
    /// <p>If the protocol is HTTP/S, then this value provides the ping path that Global Accelerator uses for the destination on the
    /// 			endpoints for health checks. The default is slash (/).</p>
    public let healthCheckPath: String?
    /// <p>The port that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group. </p>
    /// 		
    /// 		       <p>The default port is the port for the listener that this endpoint group is associated with. If the listener port is a
    /// 			list, Global Accelerator uses the first specified port in the list of ports.</p>
    public let healthCheckPort: Int?
    /// <p>The protocol that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group. The default
    /// 			value is TCP.</p>
    public let healthCheckProtocol: HealthCheckProtocol?
    /// <p>Allows you to override the destination ports used to route traffic to an endpoint.
    /// 			Using a port override lets you to map a list of external destination ports (that your
    /// 			users send traffic to) to a list of internal destination ports that you want an application
    /// 			endpoint to receive traffic on. </p>
    public let portOverrides: [PortOverride]?
    /// <p>The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an
    /// 			unhealthy endpoint to healthy. The default value is 3.</p>
    public let thresholdCount: Int?
    /// <p>The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for
    /// 			this listener. </p>
    /// 		       <p>Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is
    /// 			applied to the traffic that would otherwise have been routed to the Region based on optimal routing.</p>
    /// 		       <p>The default value is 100.</p>
    public let trafficDialPercentage: Float?

    public init (
        endpointDescriptions: [EndpointDescription]? = nil,
        endpointGroupArn: String? = nil,
        endpointGroupRegion: String? = nil,
        healthCheckIntervalSeconds: Int? = nil,
        healthCheckPath: String? = nil,
        healthCheckPort: Int? = nil,
        healthCheckProtocol: HealthCheckProtocol? = nil,
        portOverrides: [PortOverride]? = nil,
        thresholdCount: Int? = nil,
        trafficDialPercentage: Float? = nil
    )
    {
        self.endpointDescriptions = endpointDescriptions
        self.endpointGroupArn = endpointGroupArn
        self.endpointGroupRegion = endpointGroupRegion
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.portOverrides = portOverrides
        self.thresholdCount = thresholdCount
        self.trafficDialPercentage = trafficDialPercentage
    }
}

extension EndpointGroupAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointGroupAlreadyExistsException(message: \(String(describing: message)))"}
}

extension EndpointGroupAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EndpointGroupAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The endpoint group that you specified already exists.</p>
public struct EndpointGroupAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointGroupAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension EndpointGroupAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointGroupNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointGroupNotFoundException(message: \(String(describing: message)))"}
}

extension EndpointGroupNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EndpointGroupNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The endpoint group that you specified doesn't exist.</p>
public struct EndpointGroupNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointGroupNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension EndpointGroupNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EndpointNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointNotFoundException(message: \(String(describing: message)))"}
}

extension EndpointNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EndpointNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The endpoint that you specified doesn't exist.</p>
public struct EndpointNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EndpointNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension EndpointNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum HealthCheckProtocol {
    case http
    case https
    case tcp
    case sdkUnknown(String)
}

extension HealthCheckProtocol : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HealthCheckProtocol] {
        return [
            .http,
            .https,
            .tcp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .http: return "HTTP"
        case .https: return "HTTPS"
        case .tcp: return "TCP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HealthCheckProtocol(rawValue: rawValue) ?? HealthCheckProtocol.sdkUnknown(rawValue)
    }
}

public enum HealthState {
    case healthy
    case initial
    case unhealthy
    case sdkUnknown(String)
}

extension HealthState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HealthState] {
        return [
            .healthy,
            .initial,
            .unhealthy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .healthy: return "HEALTHY"
        case .initial: return "INITIAL"
        case .unhealthy: return "UNHEALTHY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HealthState(rawValue: rawValue) ?? HealthState.sdkUnknown(rawValue)
    }
}

extension IncorrectCidrStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncorrectCidrStateException(message: \(String(describing: message)))"}
}

extension IncorrectCidrStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncorrectCidrStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The CIDR that you specified is not valid for this action. For example, the state of the CIDR might be
/// 		incorrect for this action.</p>
public struct IncorrectCidrStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IncorrectCidrStateExceptionBody: Equatable {
    public let message: String?
}

extension IncorrectCidrStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServiceErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceErrorException(message: \(String(describing: message)))"}
}

extension InternalServiceErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was an internal error for AWS Global Accelerator.</p>
public struct InternalServiceErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgumentException(message: \(String(describing: message)))"}
}

extension InvalidArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An argument that you specified is invalid.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There isn't another item to return.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPortRangeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPortRangeException(message: \(String(describing: message)))"}
}

extension InvalidPortRangeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPortRangeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The port numbers that you specified are not valid numbers or are not unique for this accelerator.</p>
public struct InvalidPortRangeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPortRangeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPortRangeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum IpAddressType {
    case ipv4
    case sdkUnknown(String)
}

extension IpAddressType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IpAddressType] {
        return [
            .ipv4,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ipv4: return "IPV4"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IpAddressType(rawValue: rawValue) ?? IpAddressType.sdkUnknown(rawValue)
    }
}

extension IpSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipAddresses = "IpAddresses"
        case ipFamily = "IpFamily"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddresses0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddresses0)
            }
        }
        if let ipFamily = ipFamily {
            try encodeContainer.encode(ipFamily, forKey: .ipFamily)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipFamily)
        ipFamily = ipFamilyDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[String]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [String]()
            for string0 in ipAddressesContainer {
                if let string0 = string0 {
                    ipAddressesDecoded0?.append(string0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
    }
}

extension IpSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpSet(ipAddresses: \(String(describing: ipAddresses)), ipFamily: \(String(describing: ipFamily)))"}
}

/// <p>A complex type for the set of IP addresses for an accelerator.</p>
public struct IpSet: Equatable {
    /// <p>The array of IP addresses in the IP address set. An IP address set can have a maximum of two IP addresses.</p>
    public let ipAddresses: [String]?
    /// <p>The types of IP addresses included in this IP set.</p>
    public let ipFamily: String?

    public init (
        ipAddresses: [String]? = nil,
        ipFamily: String? = nil
    )
    {
        self.ipAddresses = ipAddresses
        self.ipFamily = ipFamily
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Processing your request would cause you to exceed an AWS Global Accelerator limit.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAcceleratorsInputBodyMiddleware: Middleware {
    public let id: String = "ListAcceleratorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAcceleratorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAcceleratorsInput>
    public typealias MOutput = OperationOutput<ListAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAcceleratorsOutputError>
}

extension ListAcceleratorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAcceleratorsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAcceleratorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAcceleratorsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAcceleratorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAcceleratorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAcceleratorsInput>
    public typealias MOutput = OperationOutput<ListAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAcceleratorsOutputError>
}

public struct ListAcceleratorsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAcceleratorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAcceleratorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAcceleratorsInput>
    public typealias MOutput = OperationOutput<ListAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAcceleratorsOutputError>
}

public struct ListAcceleratorsInput: Equatable {
    /// <p>The number of Global Accelerator objects that you want to return with this call. The default value is 10.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAcceleratorsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListAcceleratorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAcceleratorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAcceleratorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAcceleratorsOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAcceleratorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAcceleratorsOutputResponse(accelerators: \(String(describing: accelerators)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAcceleratorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAcceleratorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accelerators = output.accelerators
            self.nextToken = output.nextToken
        } else {
            self.accelerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListAcceleratorsOutputResponse: Equatable {
    /// <p>The list of accelerators for a customer account.</p>
    public let accelerators: [Accelerator]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        accelerators: [Accelerator]? = nil,
        nextToken: String? = nil
    )
    {
        self.accelerators = accelerators
        self.nextToken = nextToken
    }
}

struct ListAcceleratorsOutputResponseBody: Equatable {
    public let accelerators: [Accelerator]?
    public let nextToken: String?
}

extension ListAcceleratorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accelerators = "Accelerators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorsContainer = try containerValues.decodeIfPresent([Accelerator?].self, forKey: .accelerators)
        var acceleratorsDecoded0:[Accelerator]? = nil
        if let acceleratorsContainer = acceleratorsContainer {
            acceleratorsDecoded0 = [Accelerator]()
            for structure0 in acceleratorsContainer {
                if let structure0 = structure0 {
                    acceleratorsDecoded0?.append(structure0)
                }
            }
        }
        accelerators = acceleratorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListByoipCidrsInputBodyMiddleware: Middleware {
    public let id: String = "ListByoipCidrsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListByoipCidrsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListByoipCidrsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListByoipCidrsInput>
    public typealias MOutput = OperationOutput<ListByoipCidrsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListByoipCidrsOutputError>
}

extension ListByoipCidrsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListByoipCidrsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListByoipCidrsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListByoipCidrsInputHeadersMiddleware: Middleware {
    public let id: String = "ListByoipCidrsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListByoipCidrsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListByoipCidrsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListByoipCidrsInput>
    public typealias MOutput = OperationOutput<ListByoipCidrsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListByoipCidrsOutputError>
}

public struct ListByoipCidrsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListByoipCidrsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListByoipCidrsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListByoipCidrsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListByoipCidrsInput>
    public typealias MOutput = OperationOutput<ListByoipCidrsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListByoipCidrsOutputError>
}

public struct ListByoipCidrsInput: Equatable {
    /// <p>The maximum number of results to return with a single call. To retrieve the remaining results, make
    /// 			another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListByoipCidrsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListByoipCidrsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListByoipCidrsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListByoipCidrsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListByoipCidrsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListByoipCidrsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListByoipCidrsOutputResponse(byoipCidrs: \(String(describing: byoipCidrs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListByoipCidrsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListByoipCidrsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.byoipCidrs = output.byoipCidrs
            self.nextToken = output.nextToken
        } else {
            self.byoipCidrs = nil
            self.nextToken = nil
        }
    }
}

public struct ListByoipCidrsOutputResponse: Equatable {
    /// <p>Information about your address ranges.</p>
    public let byoipCidrs: [ByoipCidr]?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        byoipCidrs: [ByoipCidr]? = nil,
        nextToken: String? = nil
    )
    {
        self.byoipCidrs = byoipCidrs
        self.nextToken = nextToken
    }
}

struct ListByoipCidrsOutputResponseBody: Equatable {
    public let byoipCidrs: [ByoipCidr]?
    public let nextToken: String?
}

extension ListByoipCidrsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byoipCidrs = "ByoipCidrs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrsContainer = try containerValues.decodeIfPresent([ByoipCidr?].self, forKey: .byoipCidrs)
        var byoipCidrsDecoded0:[ByoipCidr]? = nil
        if let byoipCidrsContainer = byoipCidrsContainer {
            byoipCidrsDecoded0 = [ByoipCidr]()
            for structure0 in byoipCidrsContainer {
                if let structure0 = structure0 {
                    byoipCidrsDecoded0?.append(structure0)
                }
            }
        }
        byoipCidrs = byoipCidrsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCustomRoutingAcceleratorsInputBodyMiddleware: Middleware {
    public let id: String = "ListCustomRoutingAcceleratorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingAcceleratorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingAcceleratorsInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingAcceleratorsOutputError>
}

extension ListCustomRoutingAcceleratorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomRoutingAcceleratorsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomRoutingAcceleratorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCustomRoutingAcceleratorsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCustomRoutingAcceleratorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingAcceleratorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingAcceleratorsInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingAcceleratorsOutputError>
}

public struct ListCustomRoutingAcceleratorsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCustomRoutingAcceleratorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingAcceleratorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingAcceleratorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingAcceleratorsInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingAcceleratorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingAcceleratorsOutputError>
}

public struct ListCustomRoutingAcceleratorsInput: Equatable {
    /// <p>The number of custom routing Global Accelerator objects that you want to return with this call. The default value is 10.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingAcceleratorsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListCustomRoutingAcceleratorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingAcceleratorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingAcceleratorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomRoutingAcceleratorsOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingAcceleratorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomRoutingAcceleratorsOutputResponse(accelerators: \(String(describing: accelerators)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomRoutingAcceleratorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCustomRoutingAcceleratorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accelerators = output.accelerators
            self.nextToken = output.nextToken
        } else {
            self.accelerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingAcceleratorsOutputResponse: Equatable {
    /// <p>The list of custom routing accelerators for a customer account.</p>
    public let accelerators: [CustomRoutingAccelerator]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        accelerators: [CustomRoutingAccelerator]? = nil,
        nextToken: String? = nil
    )
    {
        self.accelerators = accelerators
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingAcceleratorsOutputResponseBody: Equatable {
    public let accelerators: [CustomRoutingAccelerator]?
    public let nextToken: String?
}

extension ListCustomRoutingAcceleratorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accelerators = "Accelerators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorsContainer = try containerValues.decodeIfPresent([CustomRoutingAccelerator?].self, forKey: .accelerators)
        var acceleratorsDecoded0:[CustomRoutingAccelerator]? = nil
        if let acceleratorsContainer = acceleratorsContainer {
            acceleratorsDecoded0 = [CustomRoutingAccelerator]()
            for structure0 in acceleratorsContainer {
                if let structure0 = structure0 {
                    acceleratorsDecoded0?.append(structure0)
                }
            }
        }
        accelerators = acceleratorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCustomRoutingEndpointGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListCustomRoutingEndpointGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingEndpointGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingEndpointGroupsInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingEndpointGroupsOutputError>
}

extension ListCustomRoutingEndpointGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomRoutingEndpointGroupsInput(listenerArn: \(String(describing: listenerArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomRoutingEndpointGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCustomRoutingEndpointGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCustomRoutingEndpointGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingEndpointGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingEndpointGroupsInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingEndpointGroupsOutputError>
}

public struct ListCustomRoutingEndpointGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCustomRoutingEndpointGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingEndpointGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingEndpointGroupsInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingEndpointGroupsOutputError>
}

public struct ListCustomRoutingEndpointGroupsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener to list endpoint groups for.</p>
    public let listenerArn: String?
    /// <p>The number of endpoint group objects that you want to return with this call. The default value is 10.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        listenerArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.listenerArn = listenerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingEndpointGroupsInputBody: Equatable {
    public let listenerArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListCustomRoutingEndpointGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingEndpointGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingEndpointGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomRoutingEndpointGroupsOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingEndpointGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomRoutingEndpointGroupsOutputResponse(endpointGroups: \(String(describing: endpointGroups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomRoutingEndpointGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCustomRoutingEndpointGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointGroups = output.endpointGroups
            self.nextToken = output.nextToken
        } else {
            self.endpointGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingEndpointGroupsOutputResponse: Equatable {
    /// <p>The list of the endpoint groups associated with a listener for a custom routing accelerator.</p>
    public let endpointGroups: [CustomRoutingEndpointGroup]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        endpointGroups: [CustomRoutingEndpointGroup]? = nil,
        nextToken: String? = nil
    )
    {
        self.endpointGroups = endpointGroups
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingEndpointGroupsOutputResponseBody: Equatable {
    public let endpointGroups: [CustomRoutingEndpointGroup]?
    public let nextToken: String?
}

extension ListCustomRoutingEndpointGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointGroups = "EndpointGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupsContainer = try containerValues.decodeIfPresent([CustomRoutingEndpointGroup?].self, forKey: .endpointGroups)
        var endpointGroupsDecoded0:[CustomRoutingEndpointGroup]? = nil
        if let endpointGroupsContainer = endpointGroupsContainer {
            endpointGroupsDecoded0 = [CustomRoutingEndpointGroup]()
            for structure0 in endpointGroupsContainer {
                if let structure0 = structure0 {
                    endpointGroupsDecoded0?.append(structure0)
                }
            }
        }
        endpointGroups = endpointGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCustomRoutingListenersInputBodyMiddleware: Middleware {
    public let id: String = "ListCustomRoutingListenersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingListenersInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingListenersOutputError>
}

extension ListCustomRoutingListenersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomRoutingListenersInput(acceleratorArn: \(String(describing: acceleratorArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomRoutingListenersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCustomRoutingListenersInputHeadersMiddleware: Middleware {
    public let id: String = "ListCustomRoutingListenersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingListenersInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingListenersOutputError>
}

public struct ListCustomRoutingListenersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCustomRoutingListenersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingListenersInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingListenersOutputError>
}

public struct ListCustomRoutingListenersInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to list listeners for.</p>
    public let acceleratorArn: String?
    /// <p>The number of listener objects that you want to return with this call. The default value is 10.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        acceleratorArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingListenersInputBody: Equatable {
    public let acceleratorArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListCustomRoutingListenersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingListenersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingListenersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomRoutingListenersOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingListenersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomRoutingListenersOutputResponse(listeners: \(String(describing: listeners)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomRoutingListenersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCustomRoutingListenersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.listeners = output.listeners
            self.nextToken = output.nextToken
        } else {
            self.listeners = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingListenersOutputResponse: Equatable {
    /// <p>The list of listeners for a custom routing accelerator.</p>
    public let listeners: [CustomRoutingListener]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        listeners: [CustomRoutingListener]? = nil,
        nextToken: String? = nil
    )
    {
        self.listeners = listeners
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingListenersOutputResponseBody: Equatable {
    public let listeners: [CustomRoutingListener]?
    public let nextToken: String?
}

extension ListCustomRoutingListenersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listeners = "Listeners"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenersContainer = try containerValues.decodeIfPresent([CustomRoutingListener?].self, forKey: .listeners)
        var listenersDecoded0:[CustomRoutingListener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [CustomRoutingListener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCustomRoutingPortMappingsByDestinationInputBodyMiddleware: Middleware {
    public let id: String = "ListCustomRoutingPortMappingsByDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingPortMappingsByDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingPortMappingsByDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingPortMappingsByDestinationInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingPortMappingsByDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingPortMappingsByDestinationOutputError>
}

extension ListCustomRoutingPortMappingsByDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomRoutingPortMappingsByDestinationInput(destinationAddress: \(String(describing: destinationAddress)), endpointId: \(String(describing: endpointId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomRoutingPortMappingsByDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationAddress = "DestinationAddress"
        case endpointId = "EndpointId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationAddress = destinationAddress {
            try encodeContainer.encode(destinationAddress, forKey: .destinationAddress)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCustomRoutingPortMappingsByDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "ListCustomRoutingPortMappingsByDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingPortMappingsByDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingPortMappingsByDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingPortMappingsByDestinationInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingPortMappingsByDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingPortMappingsByDestinationOutputError>
}

public struct ListCustomRoutingPortMappingsByDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCustomRoutingPortMappingsByDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingPortMappingsByDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingPortMappingsByDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingPortMappingsByDestinationInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingPortMappingsByDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingPortMappingsByDestinationOutputError>
}

public struct ListCustomRoutingPortMappingsByDestinationInput: Equatable {
    /// <p>The endpoint IP address in a virtual private cloud (VPC) subnet for which you want to receive back port
    /// 		mappings.</p>
    public let destinationAddress: String?
    /// <p>The ID for the virtual private cloud (VPC) subnet.</p>
    public let endpointId: String?
    /// <p>The number of destination port mappings that you want to return with this call. The default value is 10.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        destinationAddress: String? = nil,
        endpointId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.destinationAddress = destinationAddress
        self.endpointId = endpointId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingPortMappingsByDestinationInputBody: Equatable {
    public let endpointId: String?
    public let destinationAddress: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListCustomRoutingPortMappingsByDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationAddress = "DestinationAddress"
        case endpointId = "EndpointId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationAddress)
        destinationAddress = destinationAddressDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingPortMappingsByDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingPortMappingsByDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EndpointNotFoundException" : self = .endpointNotFoundException(try EndpointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomRoutingPortMappingsByDestinationOutputError: Equatable {
    case endpointNotFoundException(EndpointNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingPortMappingsByDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomRoutingPortMappingsByDestinationOutputResponse(destinationPortMappings: \(String(describing: destinationPortMappings)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomRoutingPortMappingsByDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCustomRoutingPortMappingsByDestinationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.destinationPortMappings = output.destinationPortMappings
            self.nextToken = output.nextToken
        } else {
            self.destinationPortMappings = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomRoutingPortMappingsByDestinationOutputResponse: Equatable {
    /// <p>The port mappings for the endpoint IP address that you specified in the request.</p>
    public let destinationPortMappings: [DestinationPortMapping]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        destinationPortMappings: [DestinationPortMapping]? = nil,
        nextToken: String? = nil
    )
    {
        self.destinationPortMappings = destinationPortMappings
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingPortMappingsByDestinationOutputResponseBody: Equatable {
    public let destinationPortMappings: [DestinationPortMapping]?
    public let nextToken: String?
}

extension ListCustomRoutingPortMappingsByDestinationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationPortMappings = "DestinationPortMappings"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPortMappingsContainer = try containerValues.decodeIfPresent([DestinationPortMapping?].self, forKey: .destinationPortMappings)
        var destinationPortMappingsDecoded0:[DestinationPortMapping]? = nil
        if let destinationPortMappingsContainer = destinationPortMappingsContainer {
            destinationPortMappingsDecoded0 = [DestinationPortMapping]()
            for structure0 in destinationPortMappingsContainer {
                if let structure0 = structure0 {
                    destinationPortMappingsDecoded0?.append(structure0)
                }
            }
        }
        destinationPortMappings = destinationPortMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCustomRoutingPortMappingsInputBodyMiddleware: Middleware {
    public let id: String = "ListCustomRoutingPortMappingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingPortMappingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingPortMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingPortMappingsInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingPortMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingPortMappingsOutputError>
}

extension ListCustomRoutingPortMappingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomRoutingPortMappingsInput(acceleratorArn: \(String(describing: acceleratorArn)), endpointGroupArn: \(String(describing: endpointGroupArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomRoutingPortMappingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case endpointGroupArn = "EndpointGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCustomRoutingPortMappingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCustomRoutingPortMappingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingPortMappingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingPortMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingPortMappingsInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingPortMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingPortMappingsOutputError>
}

public struct ListCustomRoutingPortMappingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCustomRoutingPortMappingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomRoutingPortMappingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomRoutingPortMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomRoutingPortMappingsInput>
    public typealias MOutput = OperationOutput<ListCustomRoutingPortMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomRoutingPortMappingsOutputError>
}

public struct ListCustomRoutingPortMappingsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to list the custom routing port mappings for.</p>
    public let acceleratorArn: String?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group to list the custom routing port mappings for.</p>
    public let endpointGroupArn: String?
    /// <p>The number of destination port mappings that you want to return with this call. The default value is 10.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        acceleratorArn: String? = nil,
        endpointGroupArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.endpointGroupArn = endpointGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomRoutingPortMappingsInputBody: Equatable {
    public let acceleratorArn: String?
    public let endpointGroupArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListCustomRoutingPortMappingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case endpointGroupArn = "EndpointGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomRoutingPortMappingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomRoutingPortMappingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomRoutingPortMappingsOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomRoutingPortMappingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomRoutingPortMappingsOutputResponse(nextToken: \(String(describing: nextToken)), portMappings: \(String(describing: portMappings)))"}
}

extension ListCustomRoutingPortMappingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCustomRoutingPortMappingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.portMappings = output.portMappings
        } else {
            self.nextToken = nil
            self.portMappings = nil
        }
    }
}

public struct ListCustomRoutingPortMappingsOutputResponse: Equatable {
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?
    /// <p>The port mappings for a custom routing accelerator.</p>
    public let portMappings: [PortMapping]?

    public init (
        nextToken: String? = nil,
        portMappings: [PortMapping]? = nil
    )
    {
        self.nextToken = nextToken
        self.portMappings = portMappings
    }
}

struct ListCustomRoutingPortMappingsOutputResponseBody: Equatable {
    public let portMappings: [PortMapping]?
    public let nextToken: String?
}

extension ListCustomRoutingPortMappingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case portMappings = "PortMappings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portMappingsContainer = try containerValues.decodeIfPresent([PortMapping?].self, forKey: .portMappings)
        var portMappingsDecoded0:[PortMapping]? = nil
        if let portMappingsContainer = portMappingsContainer {
            portMappingsDecoded0 = [PortMapping]()
            for structure0 in portMappingsContainer {
                if let structure0 = structure0 {
                    portMappingsDecoded0?.append(structure0)
                }
            }
        }
        portMappings = portMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEndpointGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListEndpointGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEndpointGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEndpointGroupsInput>
    public typealias MOutput = OperationOutput<ListEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEndpointGroupsOutputError>
}

extension ListEndpointGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEndpointGroupsInput(listenerArn: \(String(describing: listenerArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEndpointGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEndpointGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEndpointGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEndpointGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEndpointGroupsInput>
    public typealias MOutput = OperationOutput<ListEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEndpointGroupsOutputError>
}

public struct ListEndpointGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEndpointGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEndpointGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEndpointGroupsInput>
    public typealias MOutput = OperationOutput<ListEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEndpointGroupsOutputError>
}

public struct ListEndpointGroupsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: String?
    /// <p>The number of endpoint group objects that you want to return with this call. The default value is 10.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        listenerArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.listenerArn = listenerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEndpointGroupsInputBody: Equatable {
    public let listenerArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListEndpointGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEndpointGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEndpointGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEndpointGroupsOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEndpointGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEndpointGroupsOutputResponse(endpointGroups: \(String(describing: endpointGroups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEndpointGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEndpointGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointGroups = output.endpointGroups
            self.nextToken = output.nextToken
        } else {
            self.endpointGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListEndpointGroupsOutputResponse: Equatable {
    /// <p>The list of the endpoint groups associated with a listener.</p>
    public let endpointGroups: [EndpointGroup]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        endpointGroups: [EndpointGroup]? = nil,
        nextToken: String? = nil
    )
    {
        self.endpointGroups = endpointGroups
        self.nextToken = nextToken
    }
}

struct ListEndpointGroupsOutputResponseBody: Equatable {
    public let endpointGroups: [EndpointGroup]?
    public let nextToken: String?
}

extension ListEndpointGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointGroups = "EndpointGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupsContainer = try containerValues.decodeIfPresent([EndpointGroup?].self, forKey: .endpointGroups)
        var endpointGroupsDecoded0:[EndpointGroup]? = nil
        if let endpointGroupsContainer = endpointGroupsContainer {
            endpointGroupsDecoded0 = [EndpointGroup]()
            for structure0 in endpointGroupsContainer {
                if let structure0 = structure0 {
                    endpointGroupsDecoded0?.append(structure0)
                }
            }
        }
        endpointGroups = endpointGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListListenersInputBodyMiddleware: Middleware {
    public let id: String = "ListListenersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListListenersInput>
    public typealias MOutput = OperationOutput<ListListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListListenersOutputError>
}

extension ListListenersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListListenersInput(acceleratorArn: \(String(describing: acceleratorArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListListenersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListListenersInputHeadersMiddleware: Middleware {
    public let id: String = "ListListenersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListListenersInput>
    public typealias MOutput = OperationOutput<ListListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListListenersOutputError>
}

public struct ListListenersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListListenersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListListenersInput>
    public typealias MOutput = OperationOutput<ListListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListListenersOutputError>
}

public struct ListListenersInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator for which you want to list listener objects.</p>
    public let acceleratorArn: String?
    /// <p>The number of listener objects that you want to return with this call. The default value is 10.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        acceleratorArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListListenersInputBody: Equatable {
    public let acceleratorArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListListenersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListListenersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListListenersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListListenersOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListListenersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListListenersOutputResponse(listeners: \(String(describing: listeners)), nextToken: \(String(describing: nextToken)))"}
}

extension ListListenersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListListenersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.listeners = output.listeners
            self.nextToken = output.nextToken
        } else {
            self.listeners = nil
            self.nextToken = nil
        }
    }
}

public struct ListListenersOutputResponse: Equatable {
    /// <p>The list of listeners for an accelerator.</p>
    public let listeners: [Listener]?
    /// <p>The token for the next set of results. You receive this token from a previous call.</p>
    public let nextToken: String?

    public init (
        listeners: [Listener]? = nil,
        nextToken: String? = nil
    )
    {
        self.listeners = listeners
        self.nextToken = nextToken
    }
}

struct ListListenersOutputResponseBody: Equatable {
    public let listeners: [Listener]?
    public let nextToken: String?
}

extension ListListenersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listeners = "Listeners"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenersContainer = try containerValues.decodeIfPresent([Listener?].self, forKey: .listeners)
        var listenersDecoded0:[Listener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [Listener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to list tags for. An ARN uniquely identifies an accelerator.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>Root level tag for the Tags parameters.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Listener: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientAffinity = "ClientAffinity"
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAffinity = clientAffinity {
            try encodeContainer.encode(clientAffinity.rawValue, forKey: .clientAffinity)
        }
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portranges0 in portRanges {
                try portRangesContainer.encode(portranges0)
            }
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(`Protocol`.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let clientAffinityDecoded = try containerValues.decodeIfPresent(ClientAffinity.self, forKey: .clientAffinity)
        clientAffinity = clientAffinityDecoded
    }
}

extension Listener: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Listener(clientAffinity: \(String(describing: clientAffinity)), listenerArn: \(String(describing: listenerArn)), portRanges: \(String(describing: portRanges)), protocol: \(String(describing: `protocol`)))"}
}

/// <p>A complex type for a listener.</p>
public struct Listener: Equatable {
    /// <p>The protocol for the connections from clients to the accelerator.</p>
    public let `protocol`: `Protocol`?
    /// <p>Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications,
    /// 			regardless of the port and protocol of the client request. Client affinity gives you control over whether to always
    /// 			route each client to the same specific endpoint.</p>
    /// 		       <p>AWS Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client
    /// 			affinity is <code>NONE</code>, Global Accelerator uses the "five-tuple" (5-tuple) propertiesâ€”source IP address, source port,
    /// 			destination IP address, destination port, and protocolâ€”to select the hash value, and then chooses the best
    /// 			endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not
    /// 			be always routed to the same endpoint because the hash value changes. </p>
    /// 		       <p>If you want a given client to always be routed to the same endpoint, set client affinity to <code>SOURCE_IP</code>
    /// 			instead. When you use the <code>SOURCE_IP</code> setting, Global Accelerator uses the "two-tuple" (2-tuple) propertiesâ€”
    /// 			source (client) IP address and destination IP addressâ€”to select the hash value.</p>
    /// 		       <p>The default value is <code>NONE</code>.</p>
    public let clientAffinity: ClientAffinity?
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: String?
    /// <p>The list of port ranges for the connections from clients to the accelerator.</p>
    public let portRanges: [PortRange]?

    public init (
        `protocol`: `Protocol`? = nil,
        clientAffinity: ClientAffinity? = nil,
        listenerArn: String? = nil,
        portRanges: [PortRange]? = nil
    )
    {
        self.`protocol` = `protocol`
        self.clientAffinity = clientAffinity
        self.listenerArn = listenerArn
        self.portRanges = portRanges
    }
}

extension ListenerNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListenerNotFoundException(message: \(String(describing: message)))"}
}

extension ListenerNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListenerNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The listener that you specified doesn't exist.</p>
public struct ListenerNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ListenerNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ListenerNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PortMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorPort = "AcceleratorPort"
        case destinationSocketAddress = "DestinationSocketAddress"
        case destinationTrafficState = "DestinationTrafficState"
        case endpointGroupArn = "EndpointGroupArn"
        case endpointId = "EndpointId"
        case protocols = "Protocols"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorPort = acceleratorPort {
            try encodeContainer.encode(acceleratorPort, forKey: .acceleratorPort)
        }
        if let destinationSocketAddress = destinationSocketAddress {
            try encodeContainer.encode(destinationSocketAddress, forKey: .destinationSocketAddress)
        }
        if let destinationTrafficState = destinationTrafficState {
            try encodeContainer.encode(destinationTrafficState.rawValue, forKey: .destinationTrafficState)
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for customroutingprotocols0 in protocols {
                try protocolsContainer.encode(customroutingprotocols0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .acceleratorPort)
        acceleratorPort = acceleratorPortDecoded
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let destinationSocketAddressDecoded = try containerValues.decodeIfPresent(SocketAddress.self, forKey: .destinationSocketAddress)
        destinationSocketAddress = destinationSocketAddressDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([CustomRoutingProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[CustomRoutingProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [CustomRoutingProtocol]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let destinationTrafficStateDecoded = try containerValues.decodeIfPresent(CustomRoutingDestinationTrafficState.self, forKey: .destinationTrafficState)
        destinationTrafficState = destinationTrafficStateDecoded
    }
}

extension PortMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortMapping(acceleratorPort: \(String(describing: acceleratorPort)), destinationSocketAddress: \(String(describing: destinationSocketAddress)), destinationTrafficState: \(String(describing: destinationTrafficState)), endpointGroupArn: \(String(describing: endpointGroupArn)), endpointId: \(String(describing: endpointId)), protocols: \(String(describing: protocols)))"}
}

/// <p>Returns the ports and associated IP addresses and ports of Amazon EC2 instances in your virtual
/// 			private cloud (VPC) subnets. Custom routing is a port mapping protocol in AWS Global Accelerator that
/// 			statically associates port ranges with VPC subnets, which allows Global Accelerator to route to
/// 			specific instances and ports within one or more subnets. </p>
public struct PortMapping: Equatable {
    /// <p>The accelerator port.</p>
    public let acceleratorPort: Int?
    /// <p>The EC2 instance IP address and port number in the virtual private cloud (VPC) subnet.</p>
    public let destinationSocketAddress: SocketAddress?
    /// <p>Indicates whether or not a port mapping destination can receive traffic. The value is either ALLOW, if
    /// 			traffic is allowed to the destination, or DENY, if traffic is not allowed to the destination.</p>
    public let destinationTrafficState: CustomRoutingDestinationTrafficState?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
    public let endpointGroupArn: String?
    /// <p>The IP address of the VPC subnet (the subnet ID).</p>
    public let endpointId: String?
    /// <p>The protocols supported by the endpoint group.</p>
    public let protocols: [CustomRoutingProtocol]?

    public init (
        acceleratorPort: Int? = nil,
        destinationSocketAddress: SocketAddress? = nil,
        destinationTrafficState: CustomRoutingDestinationTrafficState? = nil,
        endpointGroupArn: String? = nil,
        endpointId: String? = nil,
        protocols: [CustomRoutingProtocol]? = nil
    )
    {
        self.acceleratorPort = acceleratorPort
        self.destinationSocketAddress = destinationSocketAddress
        self.destinationTrafficState = destinationTrafficState
        self.endpointGroupArn = endpointGroupArn
        self.endpointId = endpointId
        self.protocols = protocols
    }
}

extension PortOverride: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointPort = "EndpointPort"
        case listenerPort = "ListenerPort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointPort = endpointPort {
            try encodeContainer.encode(endpointPort, forKey: .endpointPort)
        }
        if let listenerPort = listenerPort {
            try encodeContainer.encode(listenerPort, forKey: .listenerPort)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .listenerPort)
        listenerPort = listenerPortDecoded
        let endpointPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endpointPort)
        endpointPort = endpointPortDecoded
    }
}

extension PortOverride: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortOverride(endpointPort: \(String(describing: endpointPort)), listenerPort: \(String(describing: listenerPort)))"}
}

/// <p>Override specific listener ports used to route traffic to endpoints that are part of an endpoint group.
/// 			For example, you can create a port override in which the listener
/// 			receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080
/// 			and 1443, respectively, on the endpoints.</p>
/// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html">
/// 			Port overrides</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
public struct PortOverride: Equatable {
    /// <p>The endpoint port that you want a listener port to be mapped to. This is the port on the endpoint,
    /// 			such as the Application Load Balancer or Amazon EC2 instance.</p>
    public let endpointPort: Int?
    /// <p>The listener port that you want to map to a specific endpoint port. This is the port that user traffic
    /// 		arrives to the Global Accelerator on.</p>
    public let listenerPort: Int?

    public init (
        endpointPort: Int? = nil,
        listenerPort: Int? = nil
    )
    {
        self.endpointPort = endpointPort
        self.listenerPort = listenerPort
    }
}

extension PortRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromPort = "FromPort"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromPort = fromPort {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let toPort = toPort {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .toPort)
        toPort = toPortDecoded
    }
}

extension PortRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortRange(fromPort: \(String(describing: fromPort)), toPort: \(String(describing: toPort)))"}
}

/// <p>A complex type for a range of ports for a listener.</p>
public struct PortRange: Equatable {
    /// <p>The first port in the range of ports, inclusive.</p>
    public let fromPort: Int?
    /// <p>The last port in the range of ports, inclusive.</p>
    public let toPort: Int?

    public init (
        fromPort: Int? = nil,
        toPort: Int? = nil
    )
    {
        self.fromPort = fromPort
        self.toPort = toPort
    }
}

public enum `Protocol` {
    case tcp
    case udp
    case sdkUnknown(String)
}

extension `Protocol` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Protocol`] {
        return [
            .tcp,
            .udp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .tcp: return "TCP"
        case .udp: return "UDP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Protocol`(rawValue: rawValue) ?? `Protocol`.sdkUnknown(rawValue)
    }
}

public struct ProvisionByoipCidrInputBodyMiddleware: Middleware {
    public let id: String = "ProvisionByoipCidrInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ProvisionByoipCidrInput>,
                  next: H) -> Swift.Result<OperationOutput<ProvisionByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ProvisionByoipCidrInput>
    public typealias MOutput = OperationOutput<ProvisionByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ProvisionByoipCidrOutputError>
}

extension ProvisionByoipCidrInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionByoipCidrInput(cidr: \(String(describing: cidr)), cidrAuthorizationContext: \(String(describing: cidrAuthorizationContext)))"}
}

extension ProvisionByoipCidrInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case cidrAuthorizationContext = "CidrAuthorizationContext"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
        if let cidrAuthorizationContext = cidrAuthorizationContext {
            try encodeContainer.encode(cidrAuthorizationContext, forKey: .cidrAuthorizationContext)
        }
    }
}

public struct ProvisionByoipCidrInputHeadersMiddleware: Middleware {
    public let id: String = "ProvisionByoipCidrInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ProvisionByoipCidrInput>,
                  next: H) -> Swift.Result<OperationOutput<ProvisionByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ProvisionByoipCidrInput>
    public typealias MOutput = OperationOutput<ProvisionByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ProvisionByoipCidrOutputError>
}

public struct ProvisionByoipCidrInputQueryItemMiddleware: Middleware {
    public let id: String = "ProvisionByoipCidrInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ProvisionByoipCidrInput>,
                  next: H) -> Swift.Result<OperationOutput<ProvisionByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ProvisionByoipCidrInput>
    public typealias MOutput = OperationOutput<ProvisionByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ProvisionByoipCidrOutputError>
}

public struct ProvisionByoipCidrInput: Equatable {
    /// <p>The public IPv4 address range, in CIDR notation. The most specific IP prefix that you can
    /// 			specify is /24. The address range cannot overlap with another address range that you've brought
    /// 			to this or another Region.</p>
    public let cidr: String?
    /// <p>A signed document that proves that you are authorized to bring the specified IP address range to
    /// 			Amazon using BYOIP.
    /// 		</p>
    public let cidrAuthorizationContext: CidrAuthorizationContext?

    public init (
        cidr: String? = nil,
        cidrAuthorizationContext: CidrAuthorizationContext? = nil
    )
    {
        self.cidr = cidr
        self.cidrAuthorizationContext = cidrAuthorizationContext
    }
}

struct ProvisionByoipCidrInputBody: Equatable {
    public let cidr: String?
    public let cidrAuthorizationContext: CidrAuthorizationContext?
}

extension ProvisionByoipCidrInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case cidrAuthorizationContext = "CidrAuthorizationContext"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidr)
        cidr = cidrDecoded
        let cidrAuthorizationContextDecoded = try containerValues.decodeIfPresent(CidrAuthorizationContext.self, forKey: .cidrAuthorizationContext)
        cidrAuthorizationContext = cidrAuthorizationContextDecoded
    }
}

extension ProvisionByoipCidrOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ProvisionByoipCidrOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectCidrStateException" : self = .incorrectCidrStateException(try IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ProvisionByoipCidrOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incorrectCidrStateException(IncorrectCidrStateException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ProvisionByoipCidrOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionByoipCidrOutputResponse(byoipCidr: \(String(describing: byoipCidr)))"}
}

extension ProvisionByoipCidrOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ProvisionByoipCidrOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct ProvisionByoipCidrOutputResponse: Equatable {
    /// <p>Information about the address range.</p>
    public let byoipCidr: ByoipCidr?

    public init (
        byoipCidr: ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct ProvisionByoipCidrOutputResponseBody: Equatable {
    public let byoipCidr: ByoipCidr?
}

extension ProvisionByoipCidrOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}

public struct RemoveCustomRoutingEndpointsInputBodyMiddleware: Middleware {
    public let id: String = "RemoveCustomRoutingEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveCustomRoutingEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveCustomRoutingEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveCustomRoutingEndpointsInput>
    public typealias MOutput = OperationOutput<RemoveCustomRoutingEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveCustomRoutingEndpointsOutputError>
}

extension RemoveCustomRoutingEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveCustomRoutingEndpointsInput(endpointGroupArn: \(String(describing: endpointGroupArn)), endpointIds: \(String(describing: endpointIds)))"}
}

extension RemoveCustomRoutingEndpointsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
        case endpointIds = "EndpointIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let endpointIds = endpointIds {
            var endpointIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointIds)
            for endpointids0 in endpointIds {
                try endpointIdsContainer.encode(endpointids0)
            }
        }
    }
}

public struct RemoveCustomRoutingEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveCustomRoutingEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveCustomRoutingEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveCustomRoutingEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveCustomRoutingEndpointsInput>
    public typealias MOutput = OperationOutput<RemoveCustomRoutingEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveCustomRoutingEndpointsOutputError>
}

public struct RemoveCustomRoutingEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveCustomRoutingEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveCustomRoutingEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveCustomRoutingEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveCustomRoutingEndpointsInput>
    public typealias MOutput = OperationOutput<RemoveCustomRoutingEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveCustomRoutingEndpointsOutputError>
}

public struct RemoveCustomRoutingEndpointsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the endpoint group to remove endpoints from.</p>
    public let endpointGroupArn: String?
    /// <p>The IDs for the endpoints. For custom routing accelerators, endpoint IDs are the virtual private cloud (VPC)
    /// 		subnet IDs. </p>
    public let endpointIds: [String]?

    public init (
        endpointGroupArn: String? = nil,
        endpointIds: [String]? = nil
    )
    {
        self.endpointGroupArn = endpointGroupArn
        self.endpointIds = endpointIds
    }
}

struct RemoveCustomRoutingEndpointsInputBody: Equatable {
    public let endpointIds: [String]?
    public let endpointGroupArn: String?
}

extension RemoveCustomRoutingEndpointsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointGroupArn = "EndpointGroupArn"
        case endpointIds = "EndpointIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .endpointIds)
        var endpointIdsDecoded0:[String]? = nil
        if let endpointIdsContainer = endpointIdsContainer {
            endpointIdsDecoded0 = [String]()
            for string0 in endpointIdsContainer {
                if let string0 = string0 {
                    endpointIdsDecoded0?.append(string0)
                }
            }
        }
        endpointIds = endpointIdsDecoded0
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
    }
}

extension RemoveCustomRoutingEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveCustomRoutingEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointNotFoundException" : self = .endpointNotFoundException(try EndpointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveCustomRoutingEndpointsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case endpointNotFoundException(EndpointNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveCustomRoutingEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveCustomRoutingEndpointsOutputResponse()"}
}

extension RemoveCustomRoutingEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveCustomRoutingEndpointsOutputResponse: Equatable {

    public init() {}
}

struct RemoveCustomRoutingEndpointsOutputResponseBody: Equatable {
}

extension RemoveCustomRoutingEndpointsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SocketAddress: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipAddress = "IpAddress"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
    }
}

extension SocketAddress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SocketAddress(ipAddress: \(String(describing: ipAddress)), port: \(String(describing: port)))"}
}

/// <p>An IP address/port combination.</p>
public struct SocketAddress: Equatable {
    /// <p>The IP address for the socket address.</p>
    public let ipAddress: String?
    /// <p>The port for the socket address.</p>
    public let port: Int?

    public init (
        ipAddress: String? = nil,
        port: Int? = nil
    )
    {
        self.ipAddress = ipAddress
        self.port = port
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A complex type that contains a <code>Tag</code> key and <code>Tag</code> value.</p>
public struct Tag: Equatable {
    /// <p>A string that contains a <code>Tag</code> key.</p>
    public let key: String?
    /// <p>A string that contains a <code>Tag</code> value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Global Accelerator resource to add tags to. An ARN uniquely identifies a resource.</p>
    public let resourceArn: String?
    /// <p>The tags to add to a resource. A tag consists of a key and a value that you define.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Global Accelerator resource to remove tags from. An ARN uniquely identifies a resource.</p>
    public let resourceArn: String?
    /// <p>The tag key pairs that you want to remove from the specified resources.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAcceleratorAttributesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAcceleratorAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAcceleratorAttributesInput>
    public typealias MOutput = OperationOutput<UpdateAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAcceleratorAttributesOutputError>
}

extension UpdateAcceleratorAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAcceleratorAttributesInput(acceleratorArn: \(String(describing: acceleratorArn)), flowLogsEnabled: \(String(describing: flowLogsEnabled)), flowLogsS3Bucket: \(String(describing: flowLogsS3Bucket)), flowLogsS3Prefix: \(String(describing: flowLogsS3Prefix)))"}
}

extension UpdateAcceleratorAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let flowLogsEnabled = flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }
}

public struct UpdateAcceleratorAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAcceleratorAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAcceleratorAttributesInput>
    public typealias MOutput = OperationOutput<UpdateAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAcceleratorAttributesOutputError>
}

public struct UpdateAcceleratorAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAcceleratorAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAcceleratorAttributesInput>
    public typealias MOutput = OperationOutput<UpdateAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAcceleratorAttributesOutputError>
}

public struct UpdateAcceleratorAttributesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator that you want to update.</p>
    public let acceleratorArn: String?
    /// <p>Update whether flow logs are enabled. The default value is false. If the value is true,
    /// 				<code>FlowLogsS3Bucket</code> and <code>FlowLogsS3Prefix</code> must be specified.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html">Flow Logs</a> in
    /// 			the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let flowLogsEnabled: Bool?
    /// <p>The name of the Amazon S3 bucket for the flow logs. Attribute is required if <code>FlowLogsEnabled</code> is
    /// 				<code>true</code>. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the
    /// 			bucket.</p>
    public let flowLogsS3Bucket: String?
    /// <p>Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if
    /// 				<code>FlowLogsEnabled</code> is <code>true</code>. </p>
    /// 		       <p>If you donâ€™t specify a prefix, the flow logs are stored in the
    /// 			root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following:</p>
    /// 			      <p>s3-bucket_name//AWSLogs/aws_account_id</p>
    public let flowLogsS3Prefix: String?

    public init (
        acceleratorArn: String? = nil,
        flowLogsEnabled: Bool? = nil,
        flowLogsS3Bucket: String? = nil,
        flowLogsS3Prefix: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.flowLogsEnabled = flowLogsEnabled
        self.flowLogsS3Bucket = flowLogsS3Bucket
        self.flowLogsS3Prefix = flowLogsS3Prefix
    }
}

struct UpdateAcceleratorAttributesInputBody: Equatable {
    public let acceleratorArn: String?
    public let flowLogsEnabled: Bool?
    public let flowLogsS3Bucket: String?
    public let flowLogsS3Prefix: String?
}

extension UpdateAcceleratorAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension UpdateAcceleratorAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAcceleratorAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAcceleratorAttributesOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAcceleratorAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAcceleratorAttributesOutputResponse(acceleratorAttributes: \(String(describing: acceleratorAttributes)))"}
}

extension UpdateAcceleratorAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAcceleratorAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct UpdateAcceleratorAttributesOutputResponse: Equatable {
    /// <p>Updated attributes for the accelerator.</p>
    public let acceleratorAttributes: AcceleratorAttributes?

    public init (
        acceleratorAttributes: AcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct UpdateAcceleratorAttributesOutputResponseBody: Equatable {
    public let acceleratorAttributes: AcceleratorAttributes?
}

extension UpdateAcceleratorAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(AcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

public struct UpdateAcceleratorInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAcceleratorInput>
    public typealias MOutput = OperationOutput<UpdateAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAcceleratorOutputError>
}

extension UpdateAcceleratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAcceleratorInput(acceleratorArn: \(String(describing: acceleratorArn)), enabled: \(String(describing: enabled)), ipAddressType: \(String(describing: ipAddressType)), name: \(String(describing: name)))"}
}

extension UpdateAcceleratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAcceleratorInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAcceleratorInput>
    public typealias MOutput = OperationOutput<UpdateAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAcceleratorOutputError>
}

public struct UpdateAcceleratorInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAcceleratorInput>
    public typealias MOutput = OperationOutput<UpdateAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAcceleratorOutputError>
}

public struct UpdateAcceleratorInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to update.</p>
    public let acceleratorArn: String?
    /// <p>Indicates whether an accelerator is enabled. The value is true or false. The default value is true. </p>
    /// 		       <p>If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.</p>
    public let enabled: Bool?
    /// <p>The IP address type, which must be IPv4.</p>
    public let ipAddressType: IpAddressType?
    /// <p>The name of the accelerator. The name can have a maximum of 32 characters, must contain only alphanumeric characters or
    /// 			hyphens (-), and must not begin or end with a hyphen.</p>
    public let name: String?

    public init (
        acceleratorArn: String? = nil,
        enabled: Bool? = nil,
        ipAddressType: IpAddressType? = nil,
        name: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.enabled = enabled
        self.ipAddressType = ipAddressType
        self.name = name
    }
}

struct UpdateAcceleratorInputBody: Equatable {
    public let acceleratorArn: String?
    public let name: String?
    public let ipAddressType: IpAddressType?
    public let enabled: Bool?
}

extension UpdateAcceleratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateAcceleratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAcceleratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAcceleratorOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAcceleratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAcceleratorOutputResponse(accelerator: \(String(describing: accelerator)))"}
}

extension UpdateAcceleratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct UpdateAcceleratorOutputResponse: Equatable {
    /// <p>Information about the updated accelerator.</p>
    public let accelerator: Accelerator?

    public init (
        accelerator: Accelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct UpdateAcceleratorOutputResponseBody: Equatable {
    public let accelerator: Accelerator?
}

extension UpdateAcceleratorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(Accelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

public struct UpdateCustomRoutingAcceleratorAttributesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCustomRoutingAcceleratorAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomRoutingAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomRoutingAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomRoutingAcceleratorAttributesInput>
    public typealias MOutput = OperationOutput<UpdateCustomRoutingAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomRoutingAcceleratorAttributesOutputError>
}

extension UpdateCustomRoutingAcceleratorAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomRoutingAcceleratorAttributesInput(acceleratorArn: \(String(describing: acceleratorArn)), flowLogsEnabled: \(String(describing: flowLogsEnabled)), flowLogsS3Bucket: \(String(describing: flowLogsS3Bucket)), flowLogsS3Prefix: \(String(describing: flowLogsS3Prefix)))"}
}

extension UpdateCustomRoutingAcceleratorAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let flowLogsEnabled = flowLogsEnabled {
            try encodeContainer.encode(flowLogsEnabled, forKey: .flowLogsEnabled)
        }
        if let flowLogsS3Bucket = flowLogsS3Bucket {
            try encodeContainer.encode(flowLogsS3Bucket, forKey: .flowLogsS3Bucket)
        }
        if let flowLogsS3Prefix = flowLogsS3Prefix {
            try encodeContainer.encode(flowLogsS3Prefix, forKey: .flowLogsS3Prefix)
        }
    }
}

public struct UpdateCustomRoutingAcceleratorAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCustomRoutingAcceleratorAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomRoutingAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomRoutingAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomRoutingAcceleratorAttributesInput>
    public typealias MOutput = OperationOutput<UpdateCustomRoutingAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomRoutingAcceleratorAttributesOutputError>
}

public struct UpdateCustomRoutingAcceleratorAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCustomRoutingAcceleratorAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomRoutingAcceleratorAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomRoutingAcceleratorAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomRoutingAcceleratorAttributesInput>
    public typealias MOutput = OperationOutput<UpdateCustomRoutingAcceleratorAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomRoutingAcceleratorAttributesOutputError>
}

public struct UpdateCustomRoutingAcceleratorAttributesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom routing accelerator to update attributes for.</p>
    public let acceleratorArn: String?
    /// <p>Update whether flow logs are enabled. The default value is false. If the value is true,
    /// 		<code>FlowLogsS3Bucket</code> and <code>FlowLogsS3Prefix</code> must be specified.</p>
    /// 	        <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/monitoring-global-accelerator.flow-logs.html">Flow Logs</a> in
    /// 		the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let flowLogsEnabled: Bool?
    /// <p>The name of the Amazon S3 bucket for the flow logs. Attribute is required if <code>FlowLogsEnabled</code> is
    /// 		<code>true</code>. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the
    /// 		bucket.</p>
    public let flowLogsS3Bucket: String?
    /// <p>Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if
    /// 		<code>FlowLogsEnabled</code> is <code>true</code>. </p>
    /// 	        <p>If you donâ€™t specify a prefix, the flow logs are stored in the
    /// 		root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following:</p>
    /// 	        <p>DOC-EXAMPLE-BUCKET//AWSLogs/aws_account_id</p>
    public let flowLogsS3Prefix: String?

    public init (
        acceleratorArn: String? = nil,
        flowLogsEnabled: Bool? = nil,
        flowLogsS3Bucket: String? = nil,
        flowLogsS3Prefix: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.flowLogsEnabled = flowLogsEnabled
        self.flowLogsS3Bucket = flowLogsS3Bucket
        self.flowLogsS3Prefix = flowLogsS3Prefix
    }
}

struct UpdateCustomRoutingAcceleratorAttributesInputBody: Equatable {
    public let acceleratorArn: String?
    public let flowLogsEnabled: Bool?
    public let flowLogsS3Bucket: String?
    public let flowLogsS3Prefix: String?
}

extension UpdateCustomRoutingAcceleratorAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case flowLogsEnabled = "FlowLogsEnabled"
        case flowLogsS3Bucket = "FlowLogsS3Bucket"
        case flowLogsS3Prefix = "FlowLogsS3Prefix"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let flowLogsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .flowLogsEnabled)
        flowLogsEnabled = flowLogsEnabledDecoded
        let flowLogsS3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowLogsS3Bucket)
        flowLogsS3Bucket = flowLogsS3BucketDecoded
        let flowLogsS3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .flowLogsS3Prefix)
        flowLogsS3Prefix = flowLogsS3PrefixDecoded
    }
}

extension UpdateCustomRoutingAcceleratorAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomRoutingAcceleratorAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCustomRoutingAcceleratorAttributesOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomRoutingAcceleratorAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomRoutingAcceleratorAttributesOutputResponse(acceleratorAttributes: \(String(describing: acceleratorAttributes)))"}
}

extension UpdateCustomRoutingAcceleratorAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateCustomRoutingAcceleratorAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.acceleratorAttributes = output.acceleratorAttributes
        } else {
            self.acceleratorAttributes = nil
        }
    }
}

public struct UpdateCustomRoutingAcceleratorAttributesOutputResponse: Equatable {
    /// <p>Updated custom routing accelerator.</p>
    public let acceleratorAttributes: CustomRoutingAcceleratorAttributes?

    public init (
        acceleratorAttributes: CustomRoutingAcceleratorAttributes? = nil
    )
    {
        self.acceleratorAttributes = acceleratorAttributes
    }
}

struct UpdateCustomRoutingAcceleratorAttributesOutputResponseBody: Equatable {
    public let acceleratorAttributes: CustomRoutingAcceleratorAttributes?
}

extension UpdateCustomRoutingAcceleratorAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorAttributes = "AcceleratorAttributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorAttributesDecoded = try containerValues.decodeIfPresent(CustomRoutingAcceleratorAttributes.self, forKey: .acceleratorAttributes)
        acceleratorAttributes = acceleratorAttributesDecoded
    }
}

public struct UpdateCustomRoutingAcceleratorInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCustomRoutingAcceleratorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomRoutingAcceleratorInput>
    public typealias MOutput = OperationOutput<UpdateCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomRoutingAcceleratorOutputError>
}

extension UpdateCustomRoutingAcceleratorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomRoutingAcceleratorInput(acceleratorArn: \(String(describing: acceleratorArn)), enabled: \(String(describing: enabled)), ipAddressType: \(String(describing: ipAddressType)), name: \(String(describing: name)))"}
}

extension UpdateCustomRoutingAcceleratorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorArn = acceleratorArn {
            try encodeContainer.encode(acceleratorArn, forKey: .acceleratorArn)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ipAddressType = ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateCustomRoutingAcceleratorInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCustomRoutingAcceleratorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomRoutingAcceleratorInput>
    public typealias MOutput = OperationOutput<UpdateCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomRoutingAcceleratorOutputError>
}

public struct UpdateCustomRoutingAcceleratorInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCustomRoutingAcceleratorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomRoutingAcceleratorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomRoutingAcceleratorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomRoutingAcceleratorInput>
    public typealias MOutput = OperationOutput<UpdateCustomRoutingAcceleratorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomRoutingAcceleratorOutputError>
}

public struct UpdateCustomRoutingAcceleratorInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the accelerator to update.</p>
    public let acceleratorArn: String?
    /// <p>Indicates whether an accelerator is enabled. The value is true or false. The default value is true. </p>
    /// 	        <p>If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.</p>
    public let enabled: Bool?
    /// <p>The value for the address type must be IPv4.</p>
    public let ipAddressType: IpAddressType?
    /// <p>The name of the accelerator. The name can have a maximum of 32 characters, must contain only alphanumeric characters or
    /// 		hyphens (-), and must not begin or end with a hyphen.</p>
    public let name: String?

    public init (
        acceleratorArn: String? = nil,
        enabled: Bool? = nil,
        ipAddressType: IpAddressType? = nil,
        name: String? = nil
    )
    {
        self.acceleratorArn = acceleratorArn
        self.enabled = enabled
        self.ipAddressType = ipAddressType
        self.name = name
    }
}

struct UpdateCustomRoutingAcceleratorInputBody: Equatable {
    public let acceleratorArn: String?
    public let name: String?
    public let ipAddressType: IpAddressType?
    public let enabled: Bool?
}

extension UpdateCustomRoutingAcceleratorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acceleratorArn = "AcceleratorArn"
        case enabled = "Enabled"
        case ipAddressType = "IpAddressType"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acceleratorArn)
        acceleratorArn = acceleratorArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateCustomRoutingAcceleratorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomRoutingAcceleratorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AcceleratorNotFoundException" : self = .acceleratorNotFoundException(try AcceleratorNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCustomRoutingAcceleratorOutputError: Equatable {
    case acceleratorNotFoundException(AcceleratorNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomRoutingAcceleratorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomRoutingAcceleratorOutputResponse(accelerator: \(String(describing: accelerator)))"}
}

extension UpdateCustomRoutingAcceleratorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateCustomRoutingAcceleratorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accelerator = output.accelerator
        } else {
            self.accelerator = nil
        }
    }
}

public struct UpdateCustomRoutingAcceleratorOutputResponse: Equatable {
    /// <p>Information about the updated custom routing accelerator.</p>
    public let accelerator: CustomRoutingAccelerator?

    public init (
        accelerator: CustomRoutingAccelerator? = nil
    )
    {
        self.accelerator = accelerator
    }
}

struct UpdateCustomRoutingAcceleratorOutputResponseBody: Equatable {
    public let accelerator: CustomRoutingAccelerator?
}

extension UpdateCustomRoutingAcceleratorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accelerator = "Accelerator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorDecoded = try containerValues.decodeIfPresent(CustomRoutingAccelerator.self, forKey: .accelerator)
        accelerator = acceleratorDecoded
    }
}

public struct UpdateCustomRoutingListenerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCustomRoutingListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomRoutingListenerInput>
    public typealias MOutput = OperationOutput<UpdateCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomRoutingListenerOutputError>
}

extension UpdateCustomRoutingListenerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomRoutingListenerInput(listenerArn: \(String(describing: listenerArn)), portRanges: \(String(describing: portRanges)))"}
}

extension UpdateCustomRoutingListenerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portranges0 in portRanges {
                try portRangesContainer.encode(portranges0)
            }
        }
    }
}

public struct UpdateCustomRoutingListenerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCustomRoutingListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomRoutingListenerInput>
    public typealias MOutput = OperationOutput<UpdateCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomRoutingListenerOutputError>
}

public struct UpdateCustomRoutingListenerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCustomRoutingListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomRoutingListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomRoutingListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomRoutingListenerInput>
    public typealias MOutput = OperationOutput<UpdateCustomRoutingListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomRoutingListenerOutputError>
}

public struct UpdateCustomRoutingListenerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener to update.</p>
    public let listenerArn: String?
    /// <p>The updated port range to support for connections from clients to your accelerator. If you remove ports that are
    /// 	currently being used by a subnet endpoint, the call fails.</p>
    /// 	        <p>Separately, you set port ranges for endpoints. For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-custom-routing-endpoints.html">About
    /// 		endpoints for custom routing accelerators</a>.</p>
    public let portRanges: [PortRange]?

    public init (
        listenerArn: String? = nil,
        portRanges: [PortRange]? = nil
    )
    {
        self.listenerArn = listenerArn
        self.portRanges = portRanges
    }
}

struct UpdateCustomRoutingListenerInputBody: Equatable {
    public let listenerArn: String?
    public let portRanges: [PortRange]?
}

extension UpdateCustomRoutingListenerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
    }
}

extension UpdateCustomRoutingListenerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomRoutingListenerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCustomRoutingListenerOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomRoutingListenerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomRoutingListenerOutputResponse(listener: \(String(describing: listener)))"}
}

extension UpdateCustomRoutingListenerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateCustomRoutingListenerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct UpdateCustomRoutingListenerOutputResponse: Equatable {
    /// <p>Information for the updated listener for a custom routing accelerator.</p>
    public let listener: CustomRoutingListener?

    public init (
        listener: CustomRoutingListener? = nil
    )
    {
        self.listener = listener
    }
}

struct UpdateCustomRoutingListenerOutputResponseBody: Equatable {
    public let listener: CustomRoutingListener?
}

extension UpdateCustomRoutingListenerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(CustomRoutingListener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

public struct UpdateEndpointGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEndpointGroupInput>
    public typealias MOutput = OperationOutput<UpdateEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEndpointGroupOutputError>
}

extension UpdateEndpointGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEndpointGroupInput(endpointConfigurations: \(String(describing: endpointConfigurations)), endpointGroupArn: \(String(describing: endpointGroupArn)), healthCheckIntervalSeconds: \(String(describing: healthCheckIntervalSeconds)), healthCheckPath: \(String(describing: healthCheckPath)), healthCheckPort: \(String(describing: healthCheckPort)), healthCheckProtocol: \(String(describing: healthCheckProtocol)), portOverrides: \(String(describing: portOverrides)), thresholdCount: \(String(describing: thresholdCount)), trafficDialPercentage: \(String(describing: trafficDialPercentage)))"}
}

extension UpdateEndpointGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointConfigurations = endpointConfigurations {
            var endpointConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointConfigurations)
            for endpointconfigurations0 in endpointConfigurations {
                try endpointConfigurationsContainer.encode(endpointconfigurations0)
            }
        }
        if let endpointGroupArn = endpointGroupArn {
            try encodeContainer.encode(endpointGroupArn, forKey: .endpointGroupArn)
        }
        if let healthCheckIntervalSeconds = healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckPath = healthCheckPath {
            try encodeContainer.encode(healthCheckPath, forKey: .healthCheckPath)
        }
        if let healthCheckPort = healthCheckPort {
            try encodeContainer.encode(healthCheckPort, forKey: .healthCheckPort)
        }
        if let healthCheckProtocol = healthCheckProtocol {
            try encodeContainer.encode(healthCheckProtocol.rawValue, forKey: .healthCheckProtocol)
        }
        if let portOverrides = portOverrides {
            var portOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portOverrides)
            for portoverrides0 in portOverrides {
                try portOverridesContainer.encode(portoverrides0)
            }
        }
        if let thresholdCount = thresholdCount {
            try encodeContainer.encode(thresholdCount, forKey: .thresholdCount)
        }
        if let trafficDialPercentage = trafficDialPercentage {
            try encodeContainer.encode(trafficDialPercentage, forKey: .trafficDialPercentage)
        }
    }
}

public struct UpdateEndpointGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEndpointGroupInput>
    public typealias MOutput = OperationOutput<UpdateEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEndpointGroupOutputError>
}

public struct UpdateEndpointGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEndpointGroupInput>
    public typealias MOutput = OperationOutput<UpdateEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEndpointGroupOutputError>
}

public struct UpdateEndpointGroupInput: Equatable {
    /// <p>The list of endpoint objects. A resource must be valid and active when you add it as an endpoint.</p>
    public let endpointConfigurations: [EndpointConfiguration]?
    /// <p>The Amazon Resource Name (ARN) of the endpoint group.</p>
    public let endpointGroupArn: String?
    /// <p>The timeâ€”10 seconds or 30 secondsâ€”between each health check for an endpoint. The default value is 30.</p>
    public let healthCheckIntervalSeconds: Int?
    /// <p>If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The
    /// 			default value is slash (/).</p>
    public let healthCheckPath: String?
    /// <p>The port that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port
    /// 			is the listener port that this endpoint group is associated with. If the listener port is a list of ports, Global Accelerator uses
    /// 			the first port in the list.</p>
    public let healthCheckPort: Int?
    /// <p>The protocol that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default
    /// 			value is TCP.</p>
    public let healthCheckProtocol: HealthCheckProtocol?
    /// <p>Override specific listener ports used to route traffic to endpoints that are part of this endpoint group.
    /// 			For example, you can create a port override in which the listener
    /// 			receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080
    /// 			and 1443, respectively, on the endpoints.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/global-accelerator/latest/dg/about-endpoint-groups-port-override.html">
    /// 			Port overrides</a> in the <i>AWS Global Accelerator Developer Guide</i>.</p>
    public let portOverrides: [PortOverride]?
    /// <p>The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an
    /// 			unhealthy endpoint to healthy. The default value is 3.</p>
    public let thresholdCount: Int?
    /// <p>The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for
    /// 			this listener. </p>
    /// 		       <p>Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is
    /// 			applied to the traffic that would otherwise have been routed to the Region based on optimal routing.</p>
    /// 		       <p>The default value is 100.</p>
    public let trafficDialPercentage: Float?

    public init (
        endpointConfigurations: [EndpointConfiguration]? = nil,
        endpointGroupArn: String? = nil,
        healthCheckIntervalSeconds: Int? = nil,
        healthCheckPath: String? = nil,
        healthCheckPort: Int? = nil,
        healthCheckProtocol: HealthCheckProtocol? = nil,
        portOverrides: [PortOverride]? = nil,
        thresholdCount: Int? = nil,
        trafficDialPercentage: Float? = nil
    )
    {
        self.endpointConfigurations = endpointConfigurations
        self.endpointGroupArn = endpointGroupArn
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.portOverrides = portOverrides
        self.thresholdCount = thresholdCount
        self.trafficDialPercentage = trafficDialPercentage
    }
}

struct UpdateEndpointGroupInputBody: Equatable {
    public let endpointGroupArn: String?
    public let endpointConfigurations: [EndpointConfiguration]?
    public let trafficDialPercentage: Float?
    public let healthCheckPort: Int?
    public let healthCheckProtocol: HealthCheckProtocol?
    public let healthCheckPath: String?
    public let healthCheckIntervalSeconds: Int?
    public let thresholdCount: Int?
    public let portOverrides: [PortOverride]?
}

extension UpdateEndpointGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointConfigurations = "EndpointConfigurations"
        case endpointGroupArn = "EndpointGroupArn"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case portOverrides = "PortOverrides"
        case thresholdCount = "ThresholdCount"
        case trafficDialPercentage = "TrafficDialPercentage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointGroupArn)
        endpointGroupArn = endpointGroupArnDecoded
        let endpointConfigurationsContainer = try containerValues.decodeIfPresent([EndpointConfiguration?].self, forKey: .endpointConfigurations)
        var endpointConfigurationsDecoded0:[EndpointConfiguration]? = nil
        if let endpointConfigurationsContainer = endpointConfigurationsContainer {
            endpointConfigurationsDecoded0 = [EndpointConfiguration]()
            for structure0 in endpointConfigurationsContainer {
                if let structure0 = structure0 {
                    endpointConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        endpointConfigurations = endpointConfigurationsDecoded0
        let trafficDialPercentageDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .trafficDialPercentage)
        trafficDialPercentage = trafficDialPercentageDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(HealthCheckProtocol.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let thresholdCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .thresholdCount)
        thresholdCount = thresholdCountDecoded
        let portOverridesContainer = try containerValues.decodeIfPresent([PortOverride?].self, forKey: .portOverrides)
        var portOverridesDecoded0:[PortOverride]? = nil
        if let portOverridesContainer = portOverridesContainer {
            portOverridesDecoded0 = [PortOverride]()
            for structure0 in portOverridesContainer {
                if let structure0 = structure0 {
                    portOverridesDecoded0?.append(structure0)
                }
            }
        }
        portOverrides = portOverridesDecoded0
    }
}

extension UpdateEndpointGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEndpointGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EndpointGroupNotFoundException" : self = .endpointGroupNotFoundException(try EndpointGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEndpointGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case endpointGroupNotFoundException(EndpointGroupNotFoundException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEndpointGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEndpointGroupOutputResponse(endpointGroup: \(String(describing: endpointGroup)))"}
}

extension UpdateEndpointGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpointGroup = output.endpointGroup
        } else {
            self.endpointGroup = nil
        }
    }
}

public struct UpdateEndpointGroupOutputResponse: Equatable {
    /// <p>The information about the endpoint group that was updated.</p>
    public let endpointGroup: EndpointGroup?

    public init (
        endpointGroup: EndpointGroup? = nil
    )
    {
        self.endpointGroup = endpointGroup
    }
}

struct UpdateEndpointGroupOutputResponseBody: Equatable {
    public let endpointGroup: EndpointGroup?
}

extension UpdateEndpointGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointGroup = "EndpointGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointGroupDecoded = try containerValues.decodeIfPresent(EndpointGroup.self, forKey: .endpointGroup)
        endpointGroup = endpointGroupDecoded
    }
}

public struct UpdateListenerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateListenerInput>
    public typealias MOutput = OperationOutput<UpdateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateListenerOutputError>
}

extension UpdateListenerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateListenerInput(clientAffinity: \(String(describing: clientAffinity)), listenerArn: \(String(describing: listenerArn)), portRanges: \(String(describing: portRanges)), protocol: \(String(describing: `protocol`)))"}
}

extension UpdateListenerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientAffinity = "ClientAffinity"
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientAffinity = clientAffinity {
            try encodeContainer.encode(clientAffinity.rawValue, forKey: .clientAffinity)
        }
        if let listenerArn = listenerArn {
            try encodeContainer.encode(listenerArn, forKey: .listenerArn)
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portranges0 in portRanges {
                try portRangesContainer.encode(portranges0)
            }
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }
}

public struct UpdateListenerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateListenerInput>
    public typealias MOutput = OperationOutput<UpdateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateListenerOutputError>
}

public struct UpdateListenerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateListenerInput>
    public typealias MOutput = OperationOutput<UpdateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateListenerOutputError>
}

public struct UpdateListenerInput: Equatable {
    /// <p>The updated protocol for the connections from clients to the accelerator.</p>
    public let `protocol`: `Protocol`?
    /// <p>Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications,
    /// 			regardless of the port and protocol of the client request. Client affinity gives you control over whether to always
    /// 			route each client to the same specific endpoint.</p>
    /// 		       <p>AWS Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client
    /// 			affinity is <code>NONE</code>, Global Accelerator uses the "five-tuple" (5-tuple) propertiesâ€”source IP address, source port,
    /// 			destination IP address, destination port, and protocolâ€”to select the hash value, and then chooses the best
    /// 			endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not
    /// 			be always routed to the same endpoint because the hash value changes. </p>
    /// 		       <p>If you want a given client to always be routed to the same endpoint, set client affinity to <code>SOURCE_IP</code>
    /// 			instead. When you use the <code>SOURCE_IP</code> setting, Global Accelerator uses the "two-tuple" (2-tuple) propertiesâ€”
    /// 			source (client) IP address and destination IP addressâ€”to select the hash value.</p>
    /// 		       <p>The default value is <code>NONE</code>.</p>
    public let clientAffinity: ClientAffinity?
    /// <p>The Amazon Resource Name (ARN) of the listener to update.</p>
    public let listenerArn: String?
    /// <p>The updated list of port ranges for the connections from clients to the accelerator.</p>
    public let portRanges: [PortRange]?

    public init (
        `protocol`: `Protocol`? = nil,
        clientAffinity: ClientAffinity? = nil,
        listenerArn: String? = nil,
        portRanges: [PortRange]? = nil
    )
    {
        self.`protocol` = `protocol`
        self.clientAffinity = clientAffinity
        self.listenerArn = listenerArn
        self.portRanges = portRanges
    }
}

struct UpdateListenerInputBody: Equatable {
    public let listenerArn: String?
    public let portRanges: [PortRange]?
    public let `protocol`: `Protocol`?
    public let clientAffinity: ClientAffinity?
}

extension UpdateListenerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientAffinity = "ClientAffinity"
        case listenerArn = "ListenerArn"
        case portRanges = "PortRanges"
        case `protocol` = "Protocol"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let portRangesContainer = try containerValues.decodeIfPresent([PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
        let protocolDecoded = try containerValues.decodeIfPresent(`Protocol`.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let clientAffinityDecoded = try containerValues.decodeIfPresent(ClientAffinity.self, forKey: .clientAffinity)
        clientAffinity = clientAffinityDecoded
    }
}

extension UpdateListenerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateListenerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPortRangeException" : self = .invalidPortRangeException(try InvalidPortRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateListenerOutputError: Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPortRangeException(InvalidPortRangeException)
    case limitExceededException(LimitExceededException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateListenerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateListenerOutputResponse(listener: \(String(describing: listener)))"}
}

extension UpdateListenerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateListenerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.listener = output.listener
        } else {
            self.listener = nil
        }
    }
}

public struct UpdateListenerOutputResponse: Equatable {
    /// <p>Information for the updated listener.</p>
    public let listener: Listener?

    public init (
        listener: Listener? = nil
    )
    {
        self.listener = listener
    }
}

struct UpdateListenerOutputResponseBody: Equatable {
    public let listener: Listener?
}

extension UpdateListenerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listener = "Listener"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(Listener.self, forKey: .listener)
        listener = listenerDecoded
    }
}

public struct WithdrawByoipCidrInputBodyMiddleware: Middleware {
    public let id: String = "WithdrawByoipCidrInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<WithdrawByoipCidrInput>,
                  next: H) -> Swift.Result<OperationOutput<WithdrawByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<WithdrawByoipCidrInput>
    public typealias MOutput = OperationOutput<WithdrawByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<WithdrawByoipCidrOutputError>
}

extension WithdrawByoipCidrInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WithdrawByoipCidrInput(cidr: \(String(describing: cidr)))"}
}

extension WithdrawByoipCidrInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }
}

public struct WithdrawByoipCidrInputHeadersMiddleware: Middleware {
    public let id: String = "WithdrawByoipCidrInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<WithdrawByoipCidrInput>,
                  next: H) -> Swift.Result<OperationOutput<WithdrawByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<WithdrawByoipCidrInput>
    public typealias MOutput = OperationOutput<WithdrawByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<WithdrawByoipCidrOutputError>
}

public struct WithdrawByoipCidrInputQueryItemMiddleware: Middleware {
    public let id: String = "WithdrawByoipCidrInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<WithdrawByoipCidrInput>,
                  next: H) -> Swift.Result<OperationOutput<WithdrawByoipCidrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<WithdrawByoipCidrInput>
    public typealias MOutput = OperationOutput<WithdrawByoipCidrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<WithdrawByoipCidrOutputError>
}

public struct WithdrawByoipCidrInput: Equatable {
    /// <p>The address range, in CIDR notation.</p>
    public let cidr: String?

    public init (
        cidr: String? = nil
    )
    {
        self.cidr = cidr
    }
}

struct WithdrawByoipCidrInputBody: Equatable {
    public let cidr: String?
}

extension WithdrawByoipCidrInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension WithdrawByoipCidrOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension WithdrawByoipCidrOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ByoipCidrNotFoundException" : self = .byoipCidrNotFoundException(try ByoipCidrNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncorrectCidrStateException" : self = .incorrectCidrStateException(try IncorrectCidrStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum WithdrawByoipCidrOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case byoipCidrNotFoundException(ByoipCidrNotFoundException)
    case incorrectCidrStateException(IncorrectCidrStateException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension WithdrawByoipCidrOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WithdrawByoipCidrOutputResponse(byoipCidr: \(String(describing: byoipCidr)))"}
}

extension WithdrawByoipCidrOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WithdrawByoipCidrOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.byoipCidr = output.byoipCidr
        } else {
            self.byoipCidr = nil
        }
    }
}

public struct WithdrawByoipCidrOutputResponse: Equatable {
    /// <p>Information about the address pool.</p>
    public let byoipCidr: ByoipCidr?

    public init (
        byoipCidr: ByoipCidr? = nil
    )
    {
        self.byoipCidr = byoipCidr
    }
}

struct WithdrawByoipCidrOutputResponseBody: Equatable {
    public let byoipCidr: ByoipCidr?
}

extension WithdrawByoipCidrOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byoipCidr = "ByoipCidr"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byoipCidrDecoded = try containerValues.decodeIfPresent(ByoipCidr.self, forKey: .byoipCidr)
        byoipCidr = byoipCidrDecoded
    }
}
