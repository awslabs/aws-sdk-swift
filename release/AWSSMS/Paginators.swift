// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[GetConnectorsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetConnectorsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetConnectorsOutputResponse`
extension SmsClient {
    public func getConnectorsPaginated(input: GetConnectorsInput) -> ClientRuntime.PaginatorSequence<GetConnectorsInput, GetConnectorsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetConnectorsInput, GetConnectorsOutputResponse>(input: input, inputKey: \GetConnectorsInput.nextToken, outputKey: \GetConnectorsOutputResponse.nextToken, paginationFunction: self.getConnectors(input:))
    }
}

extension GetConnectorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetConnectorsInput {
        return GetConnectorsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getConnectorsPaginated`
/// to access the nested member `[SmsClientTypes.Connector]`
/// - Returns: `[SmsClientTypes.Connector]`
extension PaginatorSequence where Input == GetConnectorsInput, Output == GetConnectorsOutputResponse {
    func connectorList() async throws -> [SmsClientTypes.Connector] {
        return try await self.asyncCompactMap { item in item.connectorList }
    }
}

/// Paginate over `[GetReplicationJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetReplicationJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetReplicationJobsOutputResponse`
extension SmsClient {
    public func getReplicationJobsPaginated(input: GetReplicationJobsInput) -> ClientRuntime.PaginatorSequence<GetReplicationJobsInput, GetReplicationJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetReplicationJobsInput, GetReplicationJobsOutputResponse>(input: input, inputKey: \GetReplicationJobsInput.nextToken, outputKey: \GetReplicationJobsOutputResponse.nextToken, paginationFunction: self.getReplicationJobs(input:))
    }
}

extension GetReplicationJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetReplicationJobsInput {
        return GetReplicationJobsInput(
            maxResults: self.maxResults,
            nextToken: token,
            replicationJobId: self.replicationJobId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getReplicationJobsPaginated`
/// to access the nested member `[SmsClientTypes.ReplicationJob]`
/// - Returns: `[SmsClientTypes.ReplicationJob]`
extension PaginatorSequence where Input == GetReplicationJobsInput, Output == GetReplicationJobsOutputResponse {
    func replicationJobList() async throws -> [SmsClientTypes.ReplicationJob] {
        return try await self.asyncCompactMap { item in item.replicationJobList }
    }
}

/// Paginate over `[GetReplicationRunsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetReplicationRunsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetReplicationRunsOutputResponse`
extension SmsClient {
    public func getReplicationRunsPaginated(input: GetReplicationRunsInput) -> ClientRuntime.PaginatorSequence<GetReplicationRunsInput, GetReplicationRunsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetReplicationRunsInput, GetReplicationRunsOutputResponse>(input: input, inputKey: \GetReplicationRunsInput.nextToken, outputKey: \GetReplicationRunsOutputResponse.nextToken, paginationFunction: self.getReplicationRuns(input:))
    }
}

extension GetReplicationRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetReplicationRunsInput {
        return GetReplicationRunsInput(
            maxResults: self.maxResults,
            nextToken: token,
            replicationJobId: self.replicationJobId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getReplicationRunsPaginated`
/// to access the nested member `[SmsClientTypes.ReplicationRun]`
/// - Returns: `[SmsClientTypes.ReplicationRun]`
extension PaginatorSequence where Input == GetReplicationRunsInput, Output == GetReplicationRunsOutputResponse {
    func replicationRunList() async throws -> [SmsClientTypes.ReplicationRun] {
        return try await self.asyncCompactMap { item in item.replicationRunList }
    }
}

/// Paginate over `[GetServersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetServersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetServersOutputResponse`
extension SmsClient {
    public func getServersPaginated(input: GetServersInput) -> ClientRuntime.PaginatorSequence<GetServersInput, GetServersOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetServersInput, GetServersOutputResponse>(input: input, inputKey: \GetServersInput.nextToken, outputKey: \GetServersOutputResponse.nextToken, paginationFunction: self.getServers(input:))
    }
}

extension GetServersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetServersInput {
        return GetServersInput(
            maxResults: self.maxResults,
            nextToken: token,
            vmServerAddressList: self.vmServerAddressList
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getServersPaginated`
/// to access the nested member `[SmsClientTypes.Server]`
/// - Returns: `[SmsClientTypes.Server]`
extension PaginatorSequence where Input == GetServersInput, Output == GetServersOutputResponse {
    func serverList() async throws -> [SmsClientTypes.Server] {
        return try await self.asyncCompactMap { item in item.serverList }
    }
}
