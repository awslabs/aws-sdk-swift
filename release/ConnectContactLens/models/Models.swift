// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Categories: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case matchedCategories = "MatchedCategories"
        case matchedDetails = "MatchedDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchedCategories = matchedCategories {
            var matchedCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchedCategories)
            for matchedcategories0 in matchedCategories {
                try matchedCategoriesContainer.encode(matchedcategories0)
            }
        }
        if let matchedDetails = matchedDetails {
            var matchedDetailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .matchedDetails)
            for (dictKey0, matcheddetails0) in matchedDetails {
                try matchedDetailsContainer.encode(matcheddetails0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchedCategoriesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .matchedCategories)
        var matchedCategoriesDecoded0:[String]? = nil
        if let matchedCategoriesContainer = matchedCategoriesContainer {
            matchedCategoriesDecoded0 = [String]()
            for string0 in matchedCategoriesContainer {
                if let string0 = string0 {
                    matchedCategoriesDecoded0?.append(string0)
                }
            }
        }
        matchedCategories = matchedCategoriesDecoded0
        let matchedDetailsContainer = try containerValues.decodeIfPresent([String: CategoryDetails?].self, forKey: .matchedDetails)
        var matchedDetailsDecoded0: [String:CategoryDetails]? = nil
        if let matchedDetailsContainer = matchedDetailsContainer {
            matchedDetailsDecoded0 = [String:CategoryDetails]()
            for (key0, categorydetails0) in matchedDetailsContainer {
                if let categorydetails0 = categorydetails0 {
                    matchedDetailsDecoded0?[key0] = categorydetails0
                }
            }
        }
        matchedDetails = matchedDetailsDecoded0
    }
}

extension Categories: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Categories(matchedCategories: \(String(describing: matchedCategories)), matchedDetails: \(String(describing: matchedDetails)))"}
}

/// <p>Provides the category rules that are used to automatically categorize contacts based on
///       uttered keywords and phrases.</p>
public struct Categories: Equatable {
    /// <p>The category rules that have been matched in the analyzed segment.</p>
    public let matchedCategories: [String]?
    /// <p>The category rule that was matched and when it occurred in the transcript.</p>
    public let matchedDetails: [String:CategoryDetails]?

    public init (
        matchedCategories: [String]? = nil,
        matchedDetails: [String:CategoryDetails]? = nil
    )
    {
        self.matchedCategories = matchedCategories
        self.matchedDetails = matchedDetails
    }
}

extension CategoryDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pointsOfInterest = "PointsOfInterest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pointsOfInterest = pointsOfInterest {
            var pointsOfInterestContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pointsOfInterest)
            for pointsofinterest0 in pointsOfInterest {
                try pointsOfInterestContainer.encode(pointsofinterest0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pointsOfInterestContainer = try containerValues.decodeIfPresent([PointOfInterest?].self, forKey: .pointsOfInterest)
        var pointsOfInterestDecoded0:[PointOfInterest]? = nil
        if let pointsOfInterestContainer = pointsOfInterestContainer {
            pointsOfInterestDecoded0 = [PointOfInterest]()
            for structure0 in pointsOfInterestContainer {
                if let structure0 = structure0 {
                    pointsOfInterestDecoded0?.append(structure0)
                }
            }
        }
        pointsOfInterest = pointsOfInterestDecoded0
    }
}

extension CategoryDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CategoryDetails(pointsOfInterest: \(String(describing: pointsOfInterest)))"}
}

/// <p>Provides information about the category rule that was matched.</p>
public struct CategoryDetails: Equatable {
    /// <p>The section of audio where the category rule was detected.</p>
    public let pointsOfInterest: [PointOfInterest]?

    public init (
        pointsOfInterest: [PointOfInterest]? = nil
    )
    {
        self.pointsOfInterest = pointsOfInterest
    }
}

extension CharacterOffsets: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginOffsetChar = "BeginOffsetChar"
        case endOffsetChar = "EndOffsetChar"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if beginOffsetChar != 0 {
            try encodeContainer.encode(beginOffsetChar, forKey: .beginOffsetChar)
        }
        if endOffsetChar != 0 {
            try encodeContainer.encode(endOffsetChar, forKey: .endOffsetChar)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginOffsetCharDecoded = try containerValues.decode(Int.self, forKey: .beginOffsetChar)
        beginOffsetChar = beginOffsetCharDecoded
        let endOffsetCharDecoded = try containerValues.decode(Int.self, forKey: .endOffsetChar)
        endOffsetChar = endOffsetCharDecoded
    }
}

extension CharacterOffsets: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CharacterOffsets(beginOffsetChar: \(String(describing: beginOffsetChar)), endOffsetChar: \(String(describing: endOffsetChar)))"}
}

/// <p>For characters that were detected as issues, where they occur in the transcript.</p>
public struct CharacterOffsets: Equatable {
    /// <p>The beginning of the issue.</p>
    public let beginOffsetChar: Int
    /// <p>The end of the issue.</p>
    public let endOffsetChar: Int

    public init (
        beginOffsetChar: Int = 0,
        endOffsetChar: Int = 0
    )
    {
        self.beginOffsetChar = beginOffsetChar
        self.endOffsetChar = endOffsetChar
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request processing failed due to an error or failure with the service.</p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is not valid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IssueDetected: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case characterOffsets = "CharacterOffsets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let characterOffsets = characterOffsets {
            try encodeContainer.encode(characterOffsets, forKey: .characterOffsets)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let characterOffsetsDecoded = try containerValues.decodeIfPresent(CharacterOffsets.self, forKey: .characterOffsets)
        characterOffsets = characterOffsetsDecoded
    }
}

extension IssueDetected: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IssueDetected(characterOffsets: \(String(describing: characterOffsets)))"}
}

/// <p>Potential issues that are detected based on an artificial intelligence analysis of each
///       turn in the conversation.</p>
public struct IssueDetected: Equatable {
    /// <p>The offset for when the issue was detected in the segment.</p>
    public let characterOffsets: CharacterOffsets?

    public init (
        characterOffsets: CharacterOffsets? = nil
    )
    {
        self.characterOffsets = characterOffsets
    }
}

public struct ListRealtimeContactAnalysisSegmentsInputBodyMiddleware: Middleware {
    public let id: String = "ListRealtimeContactAnalysisSegmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRealtimeContactAnalysisSegmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRealtimeContactAnalysisSegmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRealtimeContactAnalysisSegmentsInput>
    public typealias MOutput = OperationOutput<ListRealtimeContactAnalysisSegmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRealtimeContactAnalysisSegmentsOutputError>
}

extension ListRealtimeContactAnalysisSegmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRealtimeContactAnalysisSegmentsInput(contactId: \(String(describing: contactId)), instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRealtimeContactAnalysisSegmentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRealtimeContactAnalysisSegmentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRealtimeContactAnalysisSegmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRealtimeContactAnalysisSegmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRealtimeContactAnalysisSegmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRealtimeContactAnalysisSegmentsInput>
    public typealias MOutput = OperationOutput<ListRealtimeContactAnalysisSegmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRealtimeContactAnalysisSegmentsOutputError>
}

public struct ListRealtimeContactAnalysisSegmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRealtimeContactAnalysisSegmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRealtimeContactAnalysisSegmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRealtimeContactAnalysisSegmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRealtimeContactAnalysisSegmentsInput>
    public typealias MOutput = OperationOutput<ListRealtimeContactAnalysisSegmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRealtimeContactAnalysisSegmentsOutputError>
}

public struct ListRealtimeContactAnalysisSegmentsInput: Equatable {
    /// <p>The identifier of the contact.</p>
    public let contactId: String?
    /// <p>The identifier of the Amazon Connect instance.</p>
    public let instanceId: String?
    /// <p>The maximimum number of results to return per page.</p>
    public let maxResults: Int
    /// <p>The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        contactId: String? = nil,
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.contactId = contactId
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRealtimeContactAnalysisSegmentsInputBody: Equatable {
    public let instanceId: String?
    public let contactId: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListRealtimeContactAnalysisSegmentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId = "ContactId"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRealtimeContactAnalysisSegmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRealtimeContactAnalysisSegmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRealtimeContactAnalysisSegmentsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRealtimeContactAnalysisSegmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRealtimeContactAnalysisSegmentsOutputResponse(nextToken: \(String(describing: nextToken)), segments: \(String(describing: segments)))"}
}

extension ListRealtimeContactAnalysisSegmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRealtimeContactAnalysisSegmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.segments = output.segments
        } else {
            self.nextToken = nil
            self.segments = nil
        }
    }
}

public struct ListRealtimeContactAnalysisSegmentsOutputResponse: Equatable {
    /// <p>If there are additional results, this is the token for the next set of results. If response includes <code>nextToken</code> there are two possible scenarios:</p>
    ///          <ul>
    ///             <li>
    ///                <p>There are more segments so another call is required to get them.</p>
    ///             </li>
    ///             <li>
    ///                <p>There are no more segments at this time, but more may be available later (real-time
    ///           analysis is in progress) so the client should call the operation again to get new
    ///           segments.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If response does not include <code>nextToken</code>, the analysis is completed (successfully or failed) and there are no more segments to retrieve.</p>
    public let nextToken: String?
    /// <p>An analyzed transcript or category.</p>
    public let segments: [RealtimeContactAnalysisSegment]?

    public init (
        nextToken: String? = nil,
        segments: [RealtimeContactAnalysisSegment]? = nil
    )
    {
        self.nextToken = nextToken
        self.segments = segments
    }
}

struct ListRealtimeContactAnalysisSegmentsOutputResponseBody: Equatable {
    public let segments: [RealtimeContactAnalysisSegment]?
    public let nextToken: String?
}

extension ListRealtimeContactAnalysisSegmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case segments = "Segments"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentsContainer = try containerValues.decodeIfPresent([RealtimeContactAnalysisSegment?].self, forKey: .segments)
        var segmentsDecoded0:[RealtimeContactAnalysisSegment]? = nil
        if let segmentsContainer = segmentsContainer {
            segmentsDecoded0 = [RealtimeContactAnalysisSegment]()
            for structure0 in segmentsContainer {
                if let structure0 = structure0 {
                    segmentsDecoded0?.append(structure0)
                }
            }
        }
        segments = segmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PointOfInterest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginOffsetMillis = "BeginOffsetMillis"
        case endOffsetMillis = "EndOffsetMillis"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if beginOffsetMillis != 0 {
            try encodeContainer.encode(beginOffsetMillis, forKey: .beginOffsetMillis)
        }
        if endOffsetMillis != 0 {
            try encodeContainer.encode(endOffsetMillis, forKey: .endOffsetMillis)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginOffsetMillisDecoded = try containerValues.decode(Int.self, forKey: .beginOffsetMillis)
        beginOffsetMillis = beginOffsetMillisDecoded
        let endOffsetMillisDecoded = try containerValues.decode(Int.self, forKey: .endOffsetMillis)
        endOffsetMillis = endOffsetMillisDecoded
    }
}

extension PointOfInterest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PointOfInterest(beginOffsetMillis: \(String(describing: beginOffsetMillis)), endOffsetMillis: \(String(describing: endOffsetMillis)))"}
}

/// <p>The section of the contact audio where that category rule was detected.</p>
public struct PointOfInterest: Equatable {
    /// <p>The beginning offset in milliseconds where the category rule was detected.</p>
    public let beginOffsetMillis: Int
    /// <p>The ending offset in milliseconds where the category rule was detected.</p>
    public let endOffsetMillis: Int

    public init (
        beginOffsetMillis: Int = 0,
        endOffsetMillis: Int = 0
    )
    {
        self.beginOffsetMillis = beginOffsetMillis
        self.endOffsetMillis = endOffsetMillis
    }
}

extension RealtimeContactAnalysisSegment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case categories = "Categories"
        case transcript = "Transcript"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categories = categories {
            try encodeContainer.encode(categories, forKey: .categories)
        }
        if let transcript = transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(Transcript.self, forKey: .transcript)
        transcript = transcriptDecoded
        let categoriesDecoded = try containerValues.decodeIfPresent(Categories.self, forKey: .categories)
        categories = categoriesDecoded
    }
}

extension RealtimeContactAnalysisSegment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RealtimeContactAnalysisSegment(categories: \(String(describing: categories)), transcript: \(String(describing: transcript)))"}
}

/// <p>An analyzed segment for a real-time analysis session.</p>
public struct RealtimeContactAnalysisSegment: Equatable {
    /// <p>The matched category rules.</p>
    public let categories: Categories?
    /// <p>The analyzed transcript.</p>
    public let transcript: Transcript?

    public init (
        categories: Categories? = nil,
        transcript: Transcript? = nil
    )
    {
        self.categories = categories
        self.transcript = transcript
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SentimentValue {
    case negative
    case neutral
    case positive
    case sdkUnknown(String)
}

extension SentimentValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SentimentValue] {
        return [
            .negative,
            .neutral,
            .positive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .negative: return "NEGATIVE"
        case .neutral: return "NEUTRAL"
        case .positive: return "POSITIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SentimentValue(rawValue: rawValue) ?? SentimentValue.sdkUnknown(rawValue)
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The throttling limit has been exceeded.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Transcript: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginOffsetMillis = "BeginOffsetMillis"
        case content = "Content"
        case endOffsetMillis = "EndOffsetMillis"
        case id = "Id"
        case issuesDetected = "IssuesDetected"
        case participantId = "ParticipantId"
        case participantRole = "ParticipantRole"
        case sentiment = "Sentiment"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if beginOffsetMillis != 0 {
            try encodeContainer.encode(beginOffsetMillis, forKey: .beginOffsetMillis)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if endOffsetMillis != 0 {
            try encodeContainer.encode(endOffsetMillis, forKey: .endOffsetMillis)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let issuesDetected = issuesDetected {
            var issuesDetectedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .issuesDetected)
            for issuesdetected0 in issuesDetected {
                try issuesDetectedContainer.encode(issuesdetected0)
            }
        }
        if let participantId = participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let participantRole = participantRole {
            try encodeContainer.encode(participantRole, forKey: .participantRole)
        }
        if let sentiment = sentiment {
            try encodeContainer.encode(sentiment.rawValue, forKey: .sentiment)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let beginOffsetMillisDecoded = try containerValues.decode(Int.self, forKey: .beginOffsetMillis)
        beginOffsetMillis = beginOffsetMillisDecoded
        let endOffsetMillisDecoded = try containerValues.decode(Int.self, forKey: .endOffsetMillis)
        endOffsetMillis = endOffsetMillisDecoded
        let sentimentDecoded = try containerValues.decodeIfPresent(SentimentValue.self, forKey: .sentiment)
        sentiment = sentimentDecoded
        let issuesDetectedContainer = try containerValues.decodeIfPresent([IssueDetected?].self, forKey: .issuesDetected)
        var issuesDetectedDecoded0:[IssueDetected]? = nil
        if let issuesDetectedContainer = issuesDetectedContainer {
            issuesDetectedDecoded0 = [IssueDetected]()
            for structure0 in issuesDetectedContainer {
                if let structure0 = structure0 {
                    issuesDetectedDecoded0?.append(structure0)
                }
            }
        }
        issuesDetected = issuesDetectedDecoded0
    }
}

extension Transcript: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Transcript(beginOffsetMillis: \(String(describing: beginOffsetMillis)), content: \(String(describing: content)), endOffsetMillis: \(String(describing: endOffsetMillis)), id: \(String(describing: id)), issuesDetected: \(String(describing: issuesDetected)), participantId: \(String(describing: participantId)), participantRole: \(String(describing: participantRole)), sentiment: \(String(describing: sentiment)))"}
}

/// <p>A list of messages in the session.</p>
public struct Transcript: Equatable {
    /// <p>The beginning offset in the contact for this transcript.</p>
    public let beginOffsetMillis: Int
    /// <p>The content of the transcript.</p>
    public let content: String?
    /// <p>The end offset in the contact for this transcript.</p>
    public let endOffsetMillis: Int
    /// <p>The identifier of the transcript.</p>
    public let id: String?
    /// <p>List of positions where issues were detected on the transcript.</p>
    public let issuesDetected: [IssueDetected]?
    /// <p>The identifier of the participant.</p>
    public let participantId: String?
    /// <p>The role of participant. For example, is it a customer, agent, or system.</p>
    public let participantRole: String?
    /// <p>The sentiment of the detected for this piece of transcript.</p>
    public let sentiment: SentimentValue?

    public init (
        beginOffsetMillis: Int = 0,
        content: String? = nil,
        endOffsetMillis: Int = 0,
        id: String? = nil,
        issuesDetected: [IssueDetected]? = nil,
        participantId: String? = nil,
        participantRole: String? = nil,
        sentiment: SentimentValue? = nil
    )
    {
        self.beginOffsetMillis = beginOffsetMillis
        self.content = content
        self.endOffsetMillis = endOffsetMillis
        self.id = id
        self.issuesDetected = issuesDetected
        self.participantId = participantId
        self.participantRole = participantRole
        self.sentiment = sentiment
    }
}
