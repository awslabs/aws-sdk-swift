// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[GetBlueprintRunsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetBlueprintRunsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetBlueprintRunsOutputResponse`
extension GlueClient {
    public func getBlueprintRunsPaginated(input: GetBlueprintRunsInput) -> ClientRuntime.PaginatorSequence<GetBlueprintRunsInput, GetBlueprintRunsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetBlueprintRunsInput, GetBlueprintRunsOutputResponse>(input: input, inputKey: \GetBlueprintRunsInput.nextToken, outputKey: \GetBlueprintRunsOutputResponse.nextToken, paginationFunction: self.getBlueprintRuns(input:))
    }
}

extension GetBlueprintRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBlueprintRunsInput {
        return GetBlueprintRunsInput(
            blueprintName: self.blueprintName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetClassifiersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetClassifiersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetClassifiersOutputResponse`
extension GlueClient {
    public func getClassifiersPaginated(input: GetClassifiersInput) -> ClientRuntime.PaginatorSequence<GetClassifiersInput, GetClassifiersOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetClassifiersInput, GetClassifiersOutputResponse>(input: input, inputKey: \GetClassifiersInput.nextToken, outputKey: \GetClassifiersOutputResponse.nextToken, paginationFunction: self.getClassifiers(input:))
    }
}

extension GetClassifiersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetClassifiersInput {
        return GetClassifiersInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetConnectionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetConnectionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetConnectionsOutputResponse`
extension GlueClient {
    public func getConnectionsPaginated(input: GetConnectionsInput) -> ClientRuntime.PaginatorSequence<GetConnectionsInput, GetConnectionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetConnectionsInput, GetConnectionsOutputResponse>(input: input, inputKey: \GetConnectionsInput.nextToken, outputKey: \GetConnectionsOutputResponse.nextToken, paginationFunction: self.getConnections(input:))
    }
}

extension GetConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetConnectionsInput {
        return GetConnectionsInput(
            catalogId: self.catalogId,
            filter: self.filter,
            hidePassword: self.hidePassword,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetCrawlerMetricsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetCrawlerMetricsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetCrawlerMetricsOutputResponse`
extension GlueClient {
    public func getCrawlerMetricsPaginated(input: GetCrawlerMetricsInput) -> ClientRuntime.PaginatorSequence<GetCrawlerMetricsInput, GetCrawlerMetricsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetCrawlerMetricsInput, GetCrawlerMetricsOutputResponse>(input: input, inputKey: \GetCrawlerMetricsInput.nextToken, outputKey: \GetCrawlerMetricsOutputResponse.nextToken, paginationFunction: self.getCrawlerMetrics(input:))
    }
}

extension GetCrawlerMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCrawlerMetricsInput {
        return GetCrawlerMetricsInput(
            crawlerNameList: self.crawlerNameList,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetCrawlersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetCrawlersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetCrawlersOutputResponse`
extension GlueClient {
    public func getCrawlersPaginated(input: GetCrawlersInput) -> ClientRuntime.PaginatorSequence<GetCrawlersInput, GetCrawlersOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetCrawlersInput, GetCrawlersOutputResponse>(input: input, inputKey: \GetCrawlersInput.nextToken, outputKey: \GetCrawlersOutputResponse.nextToken, paginationFunction: self.getCrawlers(input:))
    }
}

extension GetCrawlersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCrawlersInput {
        return GetCrawlersInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetDatabasesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetDatabasesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetDatabasesOutputResponse`
extension GlueClient {
    public func getDatabasesPaginated(input: GetDatabasesInput) -> ClientRuntime.PaginatorSequence<GetDatabasesInput, GetDatabasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetDatabasesInput, GetDatabasesOutputResponse>(input: input, inputKey: \GetDatabasesInput.nextToken, outputKey: \GetDatabasesOutputResponse.nextToken, paginationFunction: self.getDatabases(input:))
    }
}

extension GetDatabasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDatabasesInput {
        return GetDatabasesInput(
            catalogId: self.catalogId,
            maxResults: self.maxResults,
            nextToken: token,
            resourceShareType: self.resourceShareType
        )}
}

/// Paginate over `[GetDevEndpointsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetDevEndpointsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetDevEndpointsOutputResponse`
extension GlueClient {
    public func getDevEndpointsPaginated(input: GetDevEndpointsInput) -> ClientRuntime.PaginatorSequence<GetDevEndpointsInput, GetDevEndpointsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetDevEndpointsInput, GetDevEndpointsOutputResponse>(input: input, inputKey: \GetDevEndpointsInput.nextToken, outputKey: \GetDevEndpointsOutputResponse.nextToken, paginationFunction: self.getDevEndpoints(input:))
    }
}

extension GetDevEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDevEndpointsInput {
        return GetDevEndpointsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetJobRunsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetJobRunsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetJobRunsOutputResponse`
extension GlueClient {
    public func getJobRunsPaginated(input: GetJobRunsInput) -> ClientRuntime.PaginatorSequence<GetJobRunsInput, GetJobRunsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetJobRunsInput, GetJobRunsOutputResponse>(input: input, inputKey: \GetJobRunsInput.nextToken, outputKey: \GetJobRunsOutputResponse.nextToken, paginationFunction: self.getJobRuns(input:))
    }
}

extension GetJobRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetJobRunsInput {
        return GetJobRunsInput(
            jobName: self.jobName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetJobsOutputResponse`
extension GlueClient {
    public func getJobsPaginated(input: GetJobsInput) -> ClientRuntime.PaginatorSequence<GetJobsInput, GetJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetJobsInput, GetJobsOutputResponse>(input: input, inputKey: \GetJobsInput.nextToken, outputKey: \GetJobsOutputResponse.nextToken, paginationFunction: self.getJobs(input:))
    }
}

extension GetJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetJobsInput {
        return GetJobsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetMLTaskRunsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetMLTaskRunsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetMLTaskRunsOutputResponse`
extension GlueClient {
    public func getMLTaskRunsPaginated(input: GetMLTaskRunsInput) -> ClientRuntime.PaginatorSequence<GetMLTaskRunsInput, GetMLTaskRunsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetMLTaskRunsInput, GetMLTaskRunsOutputResponse>(input: input, inputKey: \GetMLTaskRunsInput.nextToken, outputKey: \GetMLTaskRunsOutputResponse.nextToken, paginationFunction: self.getMLTaskRuns(input:))
    }
}

extension GetMLTaskRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetMLTaskRunsInput {
        return GetMLTaskRunsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort,
            transformId: self.transformId
        )}
}

/// Paginate over `[GetMLTransformsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetMLTransformsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetMLTransformsOutputResponse`
extension GlueClient {
    public func getMLTransformsPaginated(input: GetMLTransformsInput) -> ClientRuntime.PaginatorSequence<GetMLTransformsInput, GetMLTransformsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetMLTransformsInput, GetMLTransformsOutputResponse>(input: input, inputKey: \GetMLTransformsInput.nextToken, outputKey: \GetMLTransformsOutputResponse.nextToken, paginationFunction: self.getMLTransforms(input:))
    }
}

extension GetMLTransformsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetMLTransformsInput {
        return GetMLTransformsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort
        )}
}

/// Paginate over `[GetPartitionIndexesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetPartitionIndexesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetPartitionIndexesOutputResponse`
extension GlueClient {
    public func getPartitionIndexesPaginated(input: GetPartitionIndexesInput) -> ClientRuntime.PaginatorSequence<GetPartitionIndexesInput, GetPartitionIndexesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetPartitionIndexesInput, GetPartitionIndexesOutputResponse>(input: input, inputKey: \GetPartitionIndexesInput.nextToken, outputKey: \GetPartitionIndexesOutputResponse.nextToken, paginationFunction: self.getPartitionIndexes(input:))
    }
}

extension GetPartitionIndexesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPartitionIndexesInput {
        return GetPartitionIndexesInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            nextToken: token,
            tableName: self.tableName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getPartitionIndexesPaginated`
/// to access the nested member `[GlueClientTypes.PartitionIndexDescriptor]`
/// - Returns: `[GlueClientTypes.PartitionIndexDescriptor]`
extension PaginatorSequence where Input == GetPartitionIndexesInput, Output == GetPartitionIndexesOutputResponse {
    public func partitionIndexDescriptorList() async throws -> [GlueClientTypes.PartitionIndexDescriptor] {
        return try await self.asyncCompactMap { item in item.partitionIndexDescriptorList }
    }
}

/// Paginate over `[GetPartitionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetPartitionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetPartitionsOutputResponse`
extension GlueClient {
    public func getPartitionsPaginated(input: GetPartitionsInput) -> ClientRuntime.PaginatorSequence<GetPartitionsInput, GetPartitionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetPartitionsInput, GetPartitionsOutputResponse>(input: input, inputKey: \GetPartitionsInput.nextToken, outputKey: \GetPartitionsOutputResponse.nextToken, paginationFunction: self.getPartitions(input:))
    }
}

extension GetPartitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPartitionsInput {
        return GetPartitionsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            excludeColumnSchema: self.excludeColumnSchema,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            queryAsOfTime: self.queryAsOfTime,
            segment: self.segment,
            tableName: self.tableName,
            transactionId: self.transactionId
        )}
}

/// Paginate over `[GetResourcePoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetResourcePoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetResourcePoliciesOutputResponse`
extension GlueClient {
    public func getResourcePoliciesPaginated(input: GetResourcePoliciesInput) -> ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutputResponse>(input: input, inputKey: \GetResourcePoliciesInput.nextToken, outputKey: \GetResourcePoliciesOutputResponse.nextToken, paginationFunction: self.getResourcePolicies(input:))
    }
}

extension GetResourcePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetResourcePoliciesInput {
        return GetResourcePoliciesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getResourcePoliciesPaginated`
/// to access the nested member `[GlueClientTypes.GluePolicy]`
/// - Returns: `[GlueClientTypes.GluePolicy]`
extension PaginatorSequence where Input == GetResourcePoliciesInput, Output == GetResourcePoliciesOutputResponse {
    public func getResourcePoliciesResponseList() async throws -> [GlueClientTypes.GluePolicy] {
        return try await self.asyncCompactMap { item in item.getResourcePoliciesResponseList }
    }
}

/// Paginate over `[GetSecurityConfigurationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetSecurityConfigurationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetSecurityConfigurationsOutputResponse`
extension GlueClient {
    public func getSecurityConfigurationsPaginated(input: GetSecurityConfigurationsInput) -> ClientRuntime.PaginatorSequence<GetSecurityConfigurationsInput, GetSecurityConfigurationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetSecurityConfigurationsInput, GetSecurityConfigurationsOutputResponse>(input: input, inputKey: \GetSecurityConfigurationsInput.nextToken, outputKey: \GetSecurityConfigurationsOutputResponse.nextToken, paginationFunction: self.getSecurityConfigurations(input:))
    }
}

extension GetSecurityConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSecurityConfigurationsInput {
        return GetSecurityConfigurationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getSecurityConfigurationsPaginated`
/// to access the nested member `[GlueClientTypes.SecurityConfiguration]`
/// - Returns: `[GlueClientTypes.SecurityConfiguration]`
extension PaginatorSequence where Input == GetSecurityConfigurationsInput, Output == GetSecurityConfigurationsOutputResponse {
    public func securityConfigurations() async throws -> [GlueClientTypes.SecurityConfiguration] {
        return try await self.asyncCompactMap { item in item.securityConfigurations }
    }
}

/// Paginate over `[GetTablesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTablesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTablesOutputResponse`
extension GlueClient {
    public func getTablesPaginated(input: GetTablesInput) -> ClientRuntime.PaginatorSequence<GetTablesInput, GetTablesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTablesInput, GetTablesOutputResponse>(input: input, inputKey: \GetTablesInput.nextToken, outputKey: \GetTablesOutputResponse.nextToken, paginationFunction: self.getTables(input:))
    }
}

extension GetTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTablesInput {
        return GetTablesInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            queryAsOfTime: self.queryAsOfTime,
            transactionId: self.transactionId
        )}
}

/// Paginate over `[GetTableVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTableVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTableVersionsOutputResponse`
extension GlueClient {
    public func getTableVersionsPaginated(input: GetTableVersionsInput) -> ClientRuntime.PaginatorSequence<GetTableVersionsInput, GetTableVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTableVersionsInput, GetTableVersionsOutputResponse>(input: input, inputKey: \GetTableVersionsInput.nextToken, outputKey: \GetTableVersionsOutputResponse.nextToken, paginationFunction: self.getTableVersions(input:))
    }
}

extension GetTableVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTableVersionsInput {
        return GetTableVersionsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            tableName: self.tableName
        )}
}

/// Paginate over `[GetTriggersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetTriggersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetTriggersOutputResponse`
extension GlueClient {
    public func getTriggersPaginated(input: GetTriggersInput) -> ClientRuntime.PaginatorSequence<GetTriggersInput, GetTriggersOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetTriggersInput, GetTriggersOutputResponse>(input: input, inputKey: \GetTriggersInput.nextToken, outputKey: \GetTriggersOutputResponse.nextToken, paginationFunction: self.getTriggers(input:))
    }
}

extension GetTriggersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTriggersInput {
        return GetTriggersInput(
            dependentJobName: self.dependentJobName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[GetUnfilteredPartitionsMetadataOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetUnfilteredPartitionsMetadataInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetUnfilteredPartitionsMetadataOutputResponse`
extension GlueClient {
    public func getUnfilteredPartitionsMetadataPaginated(input: GetUnfilteredPartitionsMetadataInput) -> ClientRuntime.PaginatorSequence<GetUnfilteredPartitionsMetadataInput, GetUnfilteredPartitionsMetadataOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetUnfilteredPartitionsMetadataInput, GetUnfilteredPartitionsMetadataOutputResponse>(input: input, inputKey: \GetUnfilteredPartitionsMetadataInput.nextToken, outputKey: \GetUnfilteredPartitionsMetadataOutputResponse.nextToken, paginationFunction: self.getUnfilteredPartitionsMetadata(input:))
    }
}

extension GetUnfilteredPartitionsMetadataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUnfilteredPartitionsMetadataInput {
        return GetUnfilteredPartitionsMetadataInput(
            auditContext: self.auditContext,
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            segment: self.segment,
            supportedPermissionTypes: self.supportedPermissionTypes,
            tableName: self.tableName
        )}
}

/// Paginate over `[GetUserDefinedFunctionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetUserDefinedFunctionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetUserDefinedFunctionsOutputResponse`
extension GlueClient {
    public func getUserDefinedFunctionsPaginated(input: GetUserDefinedFunctionsInput) -> ClientRuntime.PaginatorSequence<GetUserDefinedFunctionsInput, GetUserDefinedFunctionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetUserDefinedFunctionsInput, GetUserDefinedFunctionsOutputResponse>(input: input, inputKey: \GetUserDefinedFunctionsInput.nextToken, outputKey: \GetUserDefinedFunctionsOutputResponse.nextToken, paginationFunction: self.getUserDefinedFunctions(input:))
    }
}

extension GetUserDefinedFunctionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUserDefinedFunctionsInput {
        return GetUserDefinedFunctionsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            pattern: self.pattern
        )}
}

/// Paginate over `[GetWorkflowRunsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetWorkflowRunsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetWorkflowRunsOutputResponse`
extension GlueClient {
    public func getWorkflowRunsPaginated(input: GetWorkflowRunsInput) -> ClientRuntime.PaginatorSequence<GetWorkflowRunsInput, GetWorkflowRunsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetWorkflowRunsInput, GetWorkflowRunsOutputResponse>(input: input, inputKey: \GetWorkflowRunsInput.nextToken, outputKey: \GetWorkflowRunsOutputResponse.nextToken, paginationFunction: self.getWorkflowRuns(input:))
    }
}

extension GetWorkflowRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetWorkflowRunsInput {
        return GetWorkflowRunsInput(
            includeGraph: self.includeGraph,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}

/// Paginate over `[ListBlueprintsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBlueprintsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBlueprintsOutputResponse`
extension GlueClient {
    public func listBlueprintsPaginated(input: ListBlueprintsInput) -> ClientRuntime.PaginatorSequence<ListBlueprintsInput, ListBlueprintsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBlueprintsInput, ListBlueprintsOutputResponse>(input: input, inputKey: \ListBlueprintsInput.nextToken, outputKey: \ListBlueprintsOutputResponse.nextToken, paginationFunction: self.listBlueprints(input:))
    }
}

extension ListBlueprintsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBlueprintsInput {
        return ListBlueprintsInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}

/// Paginate over `[ListCrawlersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCrawlersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCrawlersOutputResponse`
extension GlueClient {
    public func listCrawlersPaginated(input: ListCrawlersInput) -> ClientRuntime.PaginatorSequence<ListCrawlersInput, ListCrawlersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCrawlersInput, ListCrawlersOutputResponse>(input: input, inputKey: \ListCrawlersInput.nextToken, outputKey: \ListCrawlersOutputResponse.nextToken, paginationFunction: self.listCrawlers(input:))
    }
}

extension ListCrawlersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCrawlersInput {
        return ListCrawlersInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}

/// Paginate over `[ListCustomEntityTypesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCustomEntityTypesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCustomEntityTypesOutputResponse`
extension GlueClient {
    public func listCustomEntityTypesPaginated(input: ListCustomEntityTypesInput) -> ClientRuntime.PaginatorSequence<ListCustomEntityTypesInput, ListCustomEntityTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCustomEntityTypesInput, ListCustomEntityTypesOutputResponse>(input: input, inputKey: \ListCustomEntityTypesInput.nextToken, outputKey: \ListCustomEntityTypesOutputResponse.nextToken, paginationFunction: self.listCustomEntityTypes(input:))
    }
}

extension ListCustomEntityTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomEntityTypesInput {
        return ListCustomEntityTypesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListDevEndpointsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDevEndpointsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDevEndpointsOutputResponse`
extension GlueClient {
    public func listDevEndpointsPaginated(input: ListDevEndpointsInput) -> ClientRuntime.PaginatorSequence<ListDevEndpointsInput, ListDevEndpointsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDevEndpointsInput, ListDevEndpointsOutputResponse>(input: input, inputKey: \ListDevEndpointsInput.nextToken, outputKey: \ListDevEndpointsOutputResponse.nextToken, paginationFunction: self.listDevEndpoints(input:))
    }
}

extension ListDevEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevEndpointsInput {
        return ListDevEndpointsInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}

/// Paginate over `[ListJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListJobsOutputResponse`
extension GlueClient {
    public func listJobsPaginated(input: ListJobsInput) -> ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutputResponse>(input: input, inputKey: \ListJobsInput.nextToken, outputKey: \ListJobsOutputResponse.nextToken, paginationFunction: self.listJobs(input:))
    }
}

extension ListJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobsInput {
        return ListJobsInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}

/// Paginate over `[ListMLTransformsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListMLTransformsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListMLTransformsOutputResponse`
extension GlueClient {
    public func listMLTransformsPaginated(input: ListMLTransformsInput) -> ClientRuntime.PaginatorSequence<ListMLTransformsInput, ListMLTransformsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMLTransformsInput, ListMLTransformsOutputResponse>(input: input, inputKey: \ListMLTransformsInput.nextToken, outputKey: \ListMLTransformsOutputResponse.nextToken, paginationFunction: self.listMLTransforms(input:))
    }
}

extension ListMLTransformsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMLTransformsInput {
        return ListMLTransformsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort,
            tags: self.tags
        )}
}

/// Paginate over `[ListRegistriesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListRegistriesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListRegistriesOutputResponse`
extension GlueClient {
    public func listRegistriesPaginated(input: ListRegistriesInput) -> ClientRuntime.PaginatorSequence<ListRegistriesInput, ListRegistriesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRegistriesInput, ListRegistriesOutputResponse>(input: input, inputKey: \ListRegistriesInput.nextToken, outputKey: \ListRegistriesOutputResponse.nextToken, paginationFunction: self.listRegistries(input:))
    }
}

extension ListRegistriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRegistriesInput {
        return ListRegistriesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listRegistriesPaginated`
/// to access the nested member `[GlueClientTypes.RegistryListItem]`
/// - Returns: `[GlueClientTypes.RegistryListItem]`
extension PaginatorSequence where Input == ListRegistriesInput, Output == ListRegistriesOutputResponse {
    public func registries() async throws -> [GlueClientTypes.RegistryListItem] {
        return try await self.asyncCompactMap { item in item.registries }
    }
}

/// Paginate over `[ListSchemasOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSchemasInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSchemasOutputResponse`
extension GlueClient {
    public func listSchemasPaginated(input: ListSchemasInput) -> ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutputResponse>(input: input, inputKey: \ListSchemasInput.nextToken, outputKey: \ListSchemasOutputResponse.nextToken, paginationFunction: self.listSchemas(input:))
    }
}

extension ListSchemasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemasInput {
        return ListSchemasInput(
            maxResults: self.maxResults,
            nextToken: token,
            registryId: self.registryId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSchemasPaginated`
/// to access the nested member `[GlueClientTypes.SchemaListItem]`
/// - Returns: `[GlueClientTypes.SchemaListItem]`
extension PaginatorSequence where Input == ListSchemasInput, Output == ListSchemasOutputResponse {
    public func schemas() async throws -> [GlueClientTypes.SchemaListItem] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}

/// Paginate over `[ListSchemaVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSchemaVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSchemaVersionsOutputResponse`
extension GlueClient {
    public func listSchemaVersionsPaginated(input: ListSchemaVersionsInput) -> ClientRuntime.PaginatorSequence<ListSchemaVersionsInput, ListSchemaVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSchemaVersionsInput, ListSchemaVersionsOutputResponse>(input: input, inputKey: \ListSchemaVersionsInput.nextToken, outputKey: \ListSchemaVersionsOutputResponse.nextToken, paginationFunction: self.listSchemaVersions(input:))
    }
}

extension ListSchemaVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemaVersionsInput {
        return ListSchemaVersionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            schemaId: self.schemaId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSchemaVersionsPaginated`
/// to access the nested member `[GlueClientTypes.SchemaVersionListItem]`
/// - Returns: `[GlueClientTypes.SchemaVersionListItem]`
extension PaginatorSequence where Input == ListSchemaVersionsInput, Output == ListSchemaVersionsOutputResponse {
    public func schemas() async throws -> [GlueClientTypes.SchemaVersionListItem] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}

/// Paginate over `[ListSessionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSessionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSessionsOutputResponse`
extension GlueClient {
    public func listSessionsPaginated(input: ListSessionsInput) -> ClientRuntime.PaginatorSequence<ListSessionsInput, ListSessionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSessionsInput, ListSessionsOutputResponse>(input: input, inputKey: \ListSessionsInput.nextToken, outputKey: \ListSessionsOutputResponse.nextToken, paginationFunction: self.listSessions(input:))
    }
}

extension ListSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSessionsInput {
        return ListSessionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            requestOrigin: self.requestOrigin,
            tags: self.tags
        )}
}

/// Paginate over `[ListTriggersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTriggersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTriggersOutputResponse`
extension GlueClient {
    public func listTriggersPaginated(input: ListTriggersInput) -> ClientRuntime.PaginatorSequence<ListTriggersInput, ListTriggersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTriggersInput, ListTriggersOutputResponse>(input: input, inputKey: \ListTriggersInput.nextToken, outputKey: \ListTriggersOutputResponse.nextToken, paginationFunction: self.listTriggers(input:))
    }
}

extension ListTriggersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTriggersInput {
        return ListTriggersInput(
            dependentJobName: self.dependentJobName,
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}

/// Paginate over `[ListWorkflowsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListWorkflowsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListWorkflowsOutputResponse`
extension GlueClient {
    public func listWorkflowsPaginated(input: ListWorkflowsInput) -> ClientRuntime.PaginatorSequence<ListWorkflowsInput, ListWorkflowsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListWorkflowsInput, ListWorkflowsOutputResponse>(input: input, inputKey: \ListWorkflowsInput.nextToken, outputKey: \ListWorkflowsOutputResponse.nextToken, paginationFunction: self.listWorkflows(input:))
    }
}

extension ListWorkflowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkflowsInput {
        return ListWorkflowsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[SearchTablesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchTablesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchTablesOutputResponse`
extension GlueClient {
    public func searchTablesPaginated(input: SearchTablesInput) -> ClientRuntime.PaginatorSequence<SearchTablesInput, SearchTablesOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchTablesInput, SearchTablesOutputResponse>(input: input, inputKey: \SearchTablesInput.nextToken, outputKey: \SearchTablesOutputResponse.nextToken, paginationFunction: self.searchTables(input:))
    }
}

extension SearchTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchTablesInput {
        return SearchTablesInput(
            catalogId: self.catalogId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resourceShareType: self.resourceShareType,
            searchText: self.searchText,
            sortCriteria: self.sortCriteria
        )}
}
