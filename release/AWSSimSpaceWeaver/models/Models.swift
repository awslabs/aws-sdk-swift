// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    public enum ClockStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case starting
        case stopped
        case stopping
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ClockStatus] {
            return [
                .started,
                .starting,
                .stopped,
                .stopping,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClockStatus(rawValue: rawValue) ?? ClockStatus.sdkUnknown(rawValue)
        }
    }
}

extension SimSpaceWeaverClientTypes {
    public enum ClockTargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ClockTargetStatus] {
            return [
                .started,
                .stopped,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClockTargetStatus(rawValue: rawValue) ?? ClockTargetStatus.sdkUnknown(rawValue)
        }
    }
}

extension SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupArn = "LogGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupArn = self.logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// The Amazon CloudWatch Logs log group for the simulation. For more information about log groups, see [Working with log groups and log streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html) in the Amazon CloudWatch Logs User Guide.
    public struct CloudWatchLogsLogGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log group for the simulation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. For more information about log groups, see [Working with log groups and log streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html) in the Amazon CloudWatch Logs User Guide.
        public var logGroupArn: Swift.String?

        public init (
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteAppInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let app = app else {
                let message = "Creating a URL Query Item failed. app is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let appQueryItem = ClientRuntime.URLQueryItem(name: "app".urlPercentEncoding(), value: Swift.String(app).urlPercentEncoding())
            items.append(appQueryItem)
            guard let simulation = simulation else {
                let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let simulationQueryItem = ClientRuntime.URLQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
            items.append(simulationQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            return items
        }
    }
}

extension DeleteAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteapp"
    }
}

public struct DeleteAppInput: Swift.Equatable {
    /// The name of the app.
    /// This member is required.
    public var app: Swift.String?
    /// The name of the domain of the app.
    /// This member is required.
    public var domain: Swift.String?
    /// The name of the simulation of the app.
    /// This member is required.
    public var simulation: Swift.String?

    public init (
        app: Swift.String? = nil,
        domain: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.app = app
        self.domain = domain
        self.simulation = simulation
    }
}

struct DeleteAppInputBody: Swift.Equatable {
}

extension DeleteAppInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAppOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSimulationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let simulation = simulation else {
                let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let simulationQueryItem = ClientRuntime.URLQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
            items.append(simulationQueryItem)
            return items
        }
    }
}

extension DeleteSimulationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deletesimulation"
    }
}

public struct DeleteSimulationInput: Swift.Equatable {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init (
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

struct DeleteSimulationInputBody: Swift.Equatable {
}

extension DeleteSimulationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSimulationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSimulationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSimulationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSimulationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSimulationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeAppInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let app = app else {
                let message = "Creating a URL Query Item failed. app is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let appQueryItem = ClientRuntime.URLQueryItem(name: "app".urlPercentEncoding(), value: Swift.String(app).urlPercentEncoding())
            items.append(appQueryItem)
            guard let simulation = simulation else {
                let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let simulationQueryItem = ClientRuntime.URLQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
            items.append(simulationQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            return items
        }
    }
}

extension DescribeAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeapp"
    }
}

public struct DescribeAppInput: Swift.Equatable {
    /// The name of the app.
    /// This member is required.
    public var app: Swift.String?
    /// The name of the domain of the app.
    /// This member is required.
    public var domain: Swift.String?
    /// The name of the simulation of the app.
    /// This member is required.
    public var simulation: Swift.String?

    public init (
        app: Swift.String? = nil,
        domain: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.app = app
        self.domain = domain
        self.simulation = simulation
    }
}

struct DescribeAppInputBody: Swift.Equatable {
}

extension DescribeAppInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAppOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.domain = output.domain
            self.endpointInfo = output.endpointInfo
            self.launchOverrides = output.launchOverrides
            self.name = output.name
            self.simulation = output.simulation
            self.status = output.status
            self.targetStatus = output.targetStatus
        } else {
            self.description = nil
            self.domain = nil
            self.endpointInfo = nil
            self.launchOverrides = nil
            self.name = nil
            self.simulation = nil
            self.status = nil
            self.targetStatus = nil
        }
    }
}

public struct DescribeAppOutputResponse: Swift.Equatable {
    /// The description of the app.
    public var description: Swift.String?
    /// The name of the domain of the app.
    public var domain: Swift.String?
    /// Information about the network endpoint for the custom app. You can use the endpoint to connect to the custom app.
    public var endpointInfo: SimSpaceWeaverClientTypes.SimulationAppEndpointInfo?
    /// Options that apply when the app starts. These optiAons override default behavior.
    public var launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides?
    /// The name of the app.
    public var name: Swift.String?
    /// The name of the simulation of the app.
    public var simulation: Swift.String?
    /// The current lifecycle state of the custom app.
    public var status: SimSpaceWeaverClientTypes.SimulationAppStatus?
    /// The desired lifecycle state of the custom app.
    public var targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus?

    public init (
        description: Swift.String? = nil,
        domain: Swift.String? = nil,
        endpointInfo: SimSpaceWeaverClientTypes.SimulationAppEndpointInfo? = nil,
        launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides? = nil,
        name: Swift.String? = nil,
        simulation: Swift.String? = nil,
        status: SimSpaceWeaverClientTypes.SimulationAppStatus? = nil,
        targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus? = nil
    )
    {
        self.description = description
        self.domain = domain
        self.endpointInfo = endpointInfo
        self.launchOverrides = launchOverrides
        self.name = name
        self.simulation = simulation
        self.status = status
        self.targetStatus = targetStatus
    }
}

struct DescribeAppOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let simulation: Swift.String?
    let domain: Swift.String?
    let status: SimSpaceWeaverClientTypes.SimulationAppStatus?
    let targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus?
    let launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides?
    let description: Swift.String?
    let endpointInfo: SimSpaceWeaverClientTypes.SimulationAppEndpointInfo?
}

extension DescribeAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case domain = "Domain"
        case endpointInfo = "EndpointInfo"
        case launchOverrides = "LaunchOverrides"
        case name = "Name"
        case simulation = "Simulation"
        case status = "Status"
        case targetStatus = "TargetStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationAppStatus.self, forKey: .status)
        status = statusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationAppTargetStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
        let launchOverridesDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.LaunchOverrides.self, forKey: .launchOverrides)
        launchOverrides = launchOverridesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let endpointInfoDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationAppEndpointInfo.self, forKey: .endpointInfo)
        endpointInfo = endpointInfoDecoded
    }
}

extension DescribeSimulationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let simulation = simulation else {
                let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let simulationQueryItem = ClientRuntime.URLQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
            items.append(simulationQueryItem)
            return items
        }
    }
}

extension DescribeSimulationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describesimulation"
    }
}

public struct DescribeSimulationInput: Swift.Equatable {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init (
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

struct DescribeSimulationInputBody: Swift.Equatable {
}

extension DescribeSimulationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSimulationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSimulationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSimulationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSimulationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSimulationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.executionId = output.executionId
            self.liveSimulationState = output.liveSimulationState
            self.loggingConfiguration = output.loggingConfiguration
            self.maximumDuration = output.maximumDuration
            self.name = output.name
            self.roleArn = output.roleArn
            self.schemaError = output.schemaError
            self.schemaS3Location = output.schemaS3Location
            self.status = output.status
            self.targetStatus = output.targetStatus
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.executionId = nil
            self.liveSimulationState = nil
            self.loggingConfiguration = nil
            self.maximumDuration = nil
            self.name = nil
            self.roleArn = nil
            self.schemaError = nil
            self.schemaS3Location = nil
            self.status = nil
            self.targetStatus = nil
        }
    }
}

public struct DescribeSimulationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var arn: Swift.String?
    /// The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).
    public var creationTime: ClientRuntime.Date?
    /// The description of the simulation.
    public var description: Swift.String?
    /// A universally unique identifier (UUID) for this simulation.
    public var executionId: Swift.String?
    /// A collection of additional state information, such as domain and clock configuration.
    public var liveSimulationState: SimSpaceWeaverClientTypes.LiveSimulationState?
    /// Settings that control how SimSpace Weaver handles your simulation log data.
    public var loggingConfiguration: SimSpaceWeaverClientTypes.LoggingConfiguration?
    /// The maximum running time of the simulation, specified as a number of months (m or M), hours (h or H), or days (d or D). The simulation stops when it reaches this limit.
    public var maximumDuration: Swift.String?
    /// The name of the simulation.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that the simulation assumes to perform actions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. For more information about IAM roles, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the Identity and Access Management User Guide.
    public var roleArn: Swift.String?
    /// An error message that SimSpace Weaver returns only if there is a problem with the simulation schema.
    public var schemaError: Swift.String?
    /// The location of the simulation schema in Amazon Simple Storage Service (Amazon S3). For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html).
    public var schemaS3Location: SimSpaceWeaverClientTypes.S3Location?
    /// The current lifecycle state of the simulation.
    public var status: SimSpaceWeaverClientTypes.SimulationStatus?
    /// The desired lifecycle state of the simulation.
    public var targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        executionId: Swift.String? = nil,
        liveSimulationState: SimSpaceWeaverClientTypes.LiveSimulationState? = nil,
        loggingConfiguration: SimSpaceWeaverClientTypes.LoggingConfiguration? = nil,
        maximumDuration: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        schemaError: Swift.String? = nil,
        schemaS3Location: SimSpaceWeaverClientTypes.S3Location? = nil,
        status: SimSpaceWeaverClientTypes.SimulationStatus? = nil,
        targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.executionId = executionId
        self.liveSimulationState = liveSimulationState
        self.loggingConfiguration = loggingConfiguration
        self.maximumDuration = maximumDuration
        self.name = name
        self.roleArn = roleArn
        self.schemaError = schemaError
        self.schemaS3Location = schemaS3Location
        self.status = status
        self.targetStatus = targetStatus
    }
}

struct DescribeSimulationOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let executionId: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let status: SimSpaceWeaverClientTypes.SimulationStatus?
    let targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus?
    let schemaS3Location: SimSpaceWeaverClientTypes.S3Location?
    let schemaError: Swift.String?
    let loggingConfiguration: SimSpaceWeaverClientTypes.LoggingConfiguration?
    let liveSimulationState: SimSpaceWeaverClientTypes.LiveSimulationState?
    let maximumDuration: Swift.String?
}

extension DescribeSimulationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case description = "Description"
        case executionId = "ExecutionId"
        case liveSimulationState = "LiveSimulationState"
        case loggingConfiguration = "LoggingConfiguration"
        case maximumDuration = "MaximumDuration"
        case name = "Name"
        case roleArn = "RoleArn"
        case schemaError = "SchemaError"
        case schemaS3Location = "SchemaS3Location"
        case status = "Status"
        case targetStatus = "TargetStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationStatus.self, forKey: .status)
        status = statusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationTargetStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
        let schemaS3LocationDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.S3Location.self, forKey: .schemaS3Location)
        schemaS3Location = schemaS3LocationDecoded
        let schemaErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaError)
        schemaError = schemaErrorDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let liveSimulationStateDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.LiveSimulationState.self, forKey: .liveSimulationState)
        liveSimulationState = liveSimulationStateDecoded
        let maximumDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maximumDuration)
        maximumDuration = maximumDurationDecoded
    }
}

extension SimSpaceWeaverClientTypes.Domain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycle = "Lifecycle"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle.rawValue, forKey: .lifecycle)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.LifecycleManagementStrategy.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of app instances that run the same executable app code and have the same launch options and commands. For more information about domains, see [Key concepts](https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html) in the Amazon Web Services SimSpace Weaver User Guide.
    public struct Domain: Swift.Equatable {
        /// The type of lifecycle management for apps in the domain. This value indicates whether apps in this domain are managed (SimSpace Weaver starts and stops the apps) or unmanaged (you must start and stop the apps). Lifecycle types
        ///
        /// * PerWorker – Managed: SimSpace Weaver starts 1 app on each worker
        ///
        /// * BySpatialSubdivision – Managed: SimSpace Weaver starts 1 app for each spatial partition
        ///
        /// * ByRequest – Unmanaged: You use the StartApp API to start the apps and use the StopApp API to stop the apps.
        ///
        ///
        /// The lifecycle types will change when the service is released for general availability (GA).
        public var lifecycle: SimSpaceWeaverClientTypes.LifecycleManagementStrategy?
        /// The name of the domain.
        public var name: Swift.String?

        public init (
            lifecycle: SimSpaceWeaverClientTypes.LifecycleManagementStrategy? = nil,
            name: Swift.String? = nil
        )
        {
            self.lifecycle = lifecycle
            self.name = name
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SimSpaceWeaverClientTypes.LaunchOverrides: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchCommands = "LaunchCommands"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchCommands = launchCommands {
            var launchCommandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchCommands)
            for nonemptystring0 in launchCommands {
                try launchCommandsContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchCommandsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchCommands)
        var launchCommandsDecoded0:[Swift.String]? = nil
        if let launchCommandsContainer = launchCommandsContainer {
            launchCommandsDecoded0 = [Swift.String]()
            for string0 in launchCommandsContainer {
                if let string0 = string0 {
                    launchCommandsDecoded0?.append(string0)
                }
            }
        }
        launchCommands = launchCommandsDecoded0
    }
}

extension SimSpaceWeaverClientTypes {
    /// Options that apply when the app starts. These optiAons override default behavior.
    public struct LaunchOverrides: Swift.Equatable {
        /// App launch commands and command line parameters that override the launch command configured in the simulation schema.
        public var launchCommands: [Swift.String]?

        public init (
            launchCommands: [Swift.String]? = nil
        )
        {
            self.launchCommands = launchCommands
        }
    }

}

extension SimSpaceWeaverClientTypes {
    public enum LifecycleManagementStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case byrequest
        case byspatialsubdivision
        case perworker
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecycleManagementStrategy] {
            return [
                .byrequest,
                .byspatialsubdivision,
                .perworker,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .byrequest: return "ByRequest"
            case .byspatialsubdivision: return "BySpatialSubdivision"
            case .perworker: return "PerWorker"
            case .unknown: return "Unknown"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifecycleManagementStrategy(rawValue: rawValue) ?? LifecycleManagementStrategy.sdkUnknown(rawValue)
        }
    }
}

extension ListAppsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let simulation = simulation else {
                let message = "Creating a URL Query Item failed. simulation is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let simulationQueryItem = ClientRuntime.URLQueryItem(name: "simulation".urlPercentEncoding(), value: Swift.String(simulation).urlPercentEncoding())
            items.append(simulationQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let domain = domain {
                let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
                items.append(domainQueryItem)
            }
            return items
        }
    }
}

extension ListAppsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listapps"
    }
}

public struct ListAppsInput: Swift.Equatable {
    /// The name of the domain that you want to list apps for.
    public var domain: Swift.String?
    /// The maximum number of apps to list.
    public var maxResults: Swift.Int?
    /// If SimSpace Weaver returns nextToken, there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The name of the simulation that you want to list apps for.
    /// This member is required.
    public var simulation: Swift.String?

    public init (
        domain: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.domain = domain
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.simulation = simulation
    }
}

struct ListAppsInputBody: Swift.Equatable {
}

extension ListAppsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAppsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAppsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apps = output.apps
            self.nextToken = output.nextToken
        } else {
            self.apps = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppsOutputResponse: Swift.Equatable {
    /// The list of apps for the given simulation and domain.
    public var apps: [SimSpaceWeaverClientTypes.SimulationAppMetadata]?
    /// If SimSpace Weaver returns nextToken, there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init (
        apps: [SimSpaceWeaverClientTypes.SimulationAppMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apps = apps
        self.nextToken = nextToken
    }
}

struct ListAppsOutputResponseBody: Swift.Equatable {
    let apps: [SimSpaceWeaverClientTypes.SimulationAppMetadata]?
    let nextToken: Swift.String?
}

extension ListAppsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apps = "Apps"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsContainer = try containerValues.decodeIfPresent([SimSpaceWeaverClientTypes.SimulationAppMetadata?].self, forKey: .apps)
        var appsDecoded0:[SimSpaceWeaverClientTypes.SimulationAppMetadata]? = nil
        if let appsContainer = appsContainer {
            appsDecoded0 = [SimSpaceWeaverClientTypes.SimulationAppMetadata]()
            for structure0 in appsContainer {
                if let structure0 = structure0 {
                    appsDecoded0?.append(structure0)
                }
            }
        }
        apps = appsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSimulationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSimulationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listsimulations"
    }
}

public struct ListSimulationsInput: Swift.Equatable {
    /// The maximum number of simulations to list.
    public var maxResults: Swift.Int?
    /// If SimSpace Weaver returns nextToken, there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSimulationsInputBody: Swift.Equatable {
}

extension ListSimulationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSimulationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSimulationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSimulationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSimulationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSimulationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.simulations = output.simulations
        } else {
            self.nextToken = nil
            self.simulations = nil
        }
    }
}

public struct ListSimulationsOutputResponse: Swift.Equatable {
    /// If SimSpace Weaver returns nextToken, there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The list of simulations.
    public var simulations: [SimSpaceWeaverClientTypes.SimulationMetadata]?

    public init (
        nextToken: Swift.String? = nil,
        simulations: [SimSpaceWeaverClientTypes.SimulationMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.simulations = simulations
    }
}

struct ListSimulationsOutputResponseBody: Swift.Equatable {
    let simulations: [SimSpaceWeaverClientTypes.SimulationMetadata]?
    let nextToken: Swift.String?
}

extension ListSimulationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case simulations = "Simulations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationsContainer = try containerValues.decodeIfPresent([SimSpaceWeaverClientTypes.SimulationMetadata?].self, forKey: .simulations)
        var simulationsDecoded0:[SimSpaceWeaverClientTypes.SimulationMetadata]? = nil
        if let simulationsContainer = simulationsContainer {
            simulationsDecoded0 = [SimSpaceWeaverClientTypes.SimulationMetadata]()
            for structure0 in simulationsContainer {
                if let structure0 = structure0 {
                    simulationsDecoded0?.append(structure0)
                }
            }
        }
        simulations = simulationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SimSpaceWeaverClientTypes.LiveSimulationState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clocks = "Clocks"
        case domains = "Domains"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clocks = clocks {
            var clocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clocks)
            for simulationclock0 in clocks {
                try clocksContainer.encode(simulationclock0)
            }
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for domain0 in domains {
                try domainsContainer.encode(domain0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([SimSpaceWeaverClientTypes.Domain?].self, forKey: .domains)
        var domainsDecoded0:[SimSpaceWeaverClientTypes.Domain]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [SimSpaceWeaverClientTypes.Domain]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let clocksContainer = try containerValues.decodeIfPresent([SimSpaceWeaverClientTypes.SimulationClock?].self, forKey: .clocks)
        var clocksDecoded0:[SimSpaceWeaverClientTypes.SimulationClock]? = nil
        if let clocksContainer = clocksContainer {
            clocksDecoded0 = [SimSpaceWeaverClientTypes.SimulationClock]()
            for structure0 in clocksContainer {
                if let structure0 = structure0 {
                    clocksDecoded0?.append(structure0)
                }
            }
        }
        clocks = clocksDecoded0
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of additional state information, such as domain and clock configuration.
    public struct LiveSimulationState: Swift.Equatable {
        /// A list of simulation clocks. At this time, a simulation has only one clock.
        public var clocks: [SimSpaceWeaverClientTypes.SimulationClock]?
        /// A list of domains for the simulation. For more information about domains, see [Key concepts](https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html) in the Amazon Web Services SimSpace Weaver User Guide.
        public var domains: [SimSpaceWeaverClientTypes.Domain]?

        public init (
            clocks: [SimSpaceWeaverClientTypes.SimulationClock]? = nil,
            domains: [SimSpaceWeaverClientTypes.Domain]? = nil
        )
        {
            self.clocks = clocks
            self.domains = domains
        }
    }

}

extension SimSpaceWeaverClientTypes.LogDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroup = "CloudWatchLogsLogGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroup = self.cloudWatchLogsLogGroup {
            try encodeContainer.encode(cloudWatchLogsLogGroup, forKey: .cloudWatchLogsLogGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsLogGroupDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup.self, forKey: .cloudWatchLogsLogGroup)
        cloudWatchLogsLogGroup = cloudWatchLogsLogGroupDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// The location where SimSpace Weaver sends simulation log data.
    public struct LogDestination: Swift.Equatable {
        /// An Amazon CloudWatch Logs log group that stores simulation log data. For more information about log groups, see [Working with log groups and log streams](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html) in the Amazon CloudWatch Logs User Guide.
        public var cloudWatchLogsLogGroup: SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup?

        public init (
            cloudWatchLogsLogGroup: SimSpaceWeaverClientTypes.CloudWatchLogsLogGroup? = nil
        )
        {
            self.cloudWatchLogsLogGroup = cloudWatchLogsLogGroup
        }
    }

}

extension SimSpaceWeaverClientTypes.LoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "Destinations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for logdestination0 in destinations {
                try destinationsContainer.encode(logdestination0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationsContainer = try containerValues.decodeIfPresent([SimSpaceWeaverClientTypes.LogDestination?].self, forKey: .destinations)
        var destinationsDecoded0:[SimSpaceWeaverClientTypes.LogDestination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [SimSpaceWeaverClientTypes.LogDestination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

extension SimSpaceWeaverClientTypes {
    /// The logging configuration for a simulation.
    public struct LoggingConfiguration: Swift.Equatable {
        /// A list of the locations where SimSpace Weaver sends simulation log data.
        public var destinations: [SimSpaceWeaverClientTypes.LogDestination]?

        public init (
            destinations: [SimSpaceWeaverClientTypes.LogDestination]? = nil
        )
        {
            self.destinations = destinations
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SimSpaceWeaverClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case objectKey = "ObjectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKey = self.objectKey {
            try encodeContainer.encode(objectKey, forKey: .objectKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKey)
        objectKey = objectKeyDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// A location in Amazon Simple Storage Service (Amazon S3) where SimSpace Weaver stores simulation data, such as your app zip files and schema file. For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html).
    public struct S3Location: Swift.Equatable {
        /// The name of an Amazon S3 bucket. For more information about buckets, see [Creating, configuring, and working with Amazon S3 buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-buckets-s3.html) in the Amazon Simple Storage Service User Guide.
        public var bucketName: Swift.String?
        /// The key name of an object in Amazon S3. For more information about Amazon S3 objects and object keys, see [Uploading, downloading, and working with objects in Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/userguide/uploading-downloading-objects.html) in the Amazon Simple Storage Service User Guide.
        public var objectKey: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SimSpaceWeaverClientTypes.SimulationAppEndpointInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case ingressPortMappings = "IngressPortMappings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let ingressPortMappings = ingressPortMappings {
            var ingressPortMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ingressPortMappings)
            for simulationappportmapping0 in ingressPortMappings {
                try ingressPortMappingsContainer.encode(simulationappportmapping0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let ingressPortMappingsContainer = try containerValues.decodeIfPresent([SimSpaceWeaverClientTypes.SimulationAppPortMapping?].self, forKey: .ingressPortMappings)
        var ingressPortMappingsDecoded0:[SimSpaceWeaverClientTypes.SimulationAppPortMapping]? = nil
        if let ingressPortMappingsContainer = ingressPortMappingsContainer {
            ingressPortMappingsDecoded0 = [SimSpaceWeaverClientTypes.SimulationAppPortMapping]()
            for structure0 in ingressPortMappingsContainer {
                if let structure0 = structure0 {
                    ingressPortMappingsDecoded0?.append(structure0)
                }
            }
        }
        ingressPortMappings = ingressPortMappingsDecoded0
    }
}

extension SimSpaceWeaverClientTypes {
    /// Information about the network endpoint that you can use to connect to your custom or service app.
    public struct SimulationAppEndpointInfo: Swift.Equatable {
        /// The IP address of the app. SimSpace Weaver dynamically assigns this IP address when the app starts.
        public var address: Swift.String?
        /// The inbound TCP/UDP port numbers of the app. The combination of an IP address and a port number form a network endpoint.
        public var ingressPortMappings: [SimSpaceWeaverClientTypes.SimulationAppPortMapping]?

        public init (
            address: Swift.String? = nil,
            ingressPortMappings: [SimSpaceWeaverClientTypes.SimulationAppPortMapping]? = nil
        )
        {
            self.address = address
            self.ingressPortMappings = ingressPortMappings
        }
    }

}

extension SimSpaceWeaverClientTypes.SimulationAppMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case name = "Name"
        case simulation = "Simulation"
        case status = "Status"
        case targetStatus = "TargetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetStatus = self.targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationAppStatus.self, forKey: .status)
        status = statusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationAppTargetStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of metadata about an app.
    public struct SimulationAppMetadata: Swift.Equatable {
        /// The domain of the app. For more information about domains, see [Key concepts](https://docs.aws.amazon.com/simspaceweaver/latest/userguide/what-is_key-concepts.html) in the Amazon Web Services SimSpace Weaver User Guide.
        public var domain: Swift.String?
        /// The name of the app.
        public var name: Swift.String?
        /// The name of the simulation of the app.
        public var simulation: Swift.String?
        /// The current status of the app.
        public var status: SimSpaceWeaverClientTypes.SimulationAppStatus?
        /// The desired status of the app.
        public var targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus?

        public init (
            domain: Swift.String? = nil,
            name: Swift.String? = nil,
            simulation: Swift.String? = nil,
            status: SimSpaceWeaverClientTypes.SimulationAppStatus? = nil,
            targetStatus: SimSpaceWeaverClientTypes.SimulationAppTargetStatus? = nil
        )
        {
            self.domain = domain
            self.name = name
            self.simulation = simulation
            self.status = status
            self.targetStatus = targetStatus
        }
    }

}

extension SimSpaceWeaverClientTypes.SimulationAppPortMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actual = "Actual"
        case declared = "Declared"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actual = self.actual {
            try encodeContainer.encode(actual, forKey: .actual)
        }
        if let declared = self.declared {
            try encodeContainer.encode(declared, forKey: .declared)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let declaredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .declared)
        declared = declaredDecoded
        let actualDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .actual)
        actual = actualDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of TCP/UDP ports for a custom or service app.
    public struct SimulationAppPortMapping: Swift.Equatable {
        /// The TCP/UDP port number of the running app. SimSpace Weaver dynamically assigns this port number when the app starts. SimSpace Weaver maps the Declared port to the Actual port. Clients connect to the app using the app's IP address and the Actual port number.
        public var actual: Swift.Int?
        /// The TCP/UDP port number of the app, declared in the simulation schema. SimSpace Weaver maps the Declared port to the Actual port. The source code for the app should bind to the Declared port.
        public var declared: Swift.Int?

        public init (
            actual: Swift.Int? = nil,
            declared: Swift.Int? = nil
        )
        {
            self.actual = actual
            self.declared = declared
        }
    }

}

extension SimSpaceWeaverClientTypes {
    public enum SimulationAppStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case started
        case starting
        case stopped
        case stopping
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationAppStatus] {
            return [
                .error,
                .started,
                .starting,
                .stopped,
                .stopping,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .started: return "STARTED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationAppStatus(rawValue: rawValue) ?? SimulationAppStatus.sdkUnknown(rawValue)
        }
    }
}

extension SimSpaceWeaverClientTypes {
    public enum SimulationAppTargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationAppTargetStatus] {
            return [
                .started,
                .stopped,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationAppTargetStatus(rawValue: rawValue) ?? SimulationAppTargetStatus.sdkUnknown(rawValue)
        }
    }
}

extension SimSpaceWeaverClientTypes.SimulationClock: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case targetStatus = "TargetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetStatus = self.targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.ClockStatus.self, forKey: .status)
        status = statusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.ClockTargetStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// Status information about the simulation clock.
    public struct SimulationClock: Swift.Equatable {
        /// The current status of the simulation clock.
        public var status: SimSpaceWeaverClientTypes.ClockStatus?
        /// The desired status of the simulation clock.
        public var targetStatus: SimSpaceWeaverClientTypes.ClockTargetStatus?

        public init (
            status: SimSpaceWeaverClientTypes.ClockStatus? = nil,
            targetStatus: SimSpaceWeaverClientTypes.ClockTargetStatus? = nil
        )
        {
            self.status = status
            self.targetStatus = targetStatus
        }
    }

}

extension SimSpaceWeaverClientTypes.SimulationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case name = "Name"
        case status = "Status"
        case targetStatus = "TargetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetStatus = self.targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationStatus.self, forKey: .status)
        status = statusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.SimulationTargetStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension SimSpaceWeaverClientTypes {
    /// A collection of data about the simulation.
    public struct SimulationMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).
        public var creationTime: ClientRuntime.Date?
        /// The name of the simulation.
        public var name: Swift.String?
        /// The current status of the simulation.
        public var status: SimSpaceWeaverClientTypes.SimulationStatus?
        /// The desired status of the simulation.
        public var targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: SimSpaceWeaverClientTypes.SimulationStatus? = nil,
            targetStatus: SimSpaceWeaverClientTypes.SimulationTargetStatus? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.name = name
            self.status = status
            self.targetStatus = targetStatus
        }
    }

}

extension SimSpaceWeaverClientTypes {
    public enum SimulationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case deleting
        case failed
        case started
        case starting
        case stopped
        case stopping
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationStatus] {
            return [
                .deleted,
                .deleting,
                .failed,
                .started,
                .starting,
                .stopped,
                .stopping,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .started: return "STARTED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationStatus(rawValue: rawValue) ?? SimulationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SimSpaceWeaverClientTypes {
    public enum SimulationTargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case started
        case stopped
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [SimulationTargetStatus] {
            return [
                .deleted,
                .started,
                .stopped,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SimulationTargetStatus(rawValue: rawValue) ?? SimulationTargetStatus.sdkUnknown(rawValue)
        }
    }
}

extension StartAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAppInput(description: \(Swift.String(describing: description)), domain: \(Swift.String(describing: domain)), launchOverrides: \(Swift.String(describing: launchOverrides)), name: \(Swift.String(describing: name)), simulation: \(Swift.String(describing: simulation)), clientToken: \"CONTENT_REDACTED\")"}
}

extension StartAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case domain = "Domain"
        case launchOverrides = "LaunchOverrides"
        case name = "Name"
        case simulation = "Simulation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let launchOverrides = self.launchOverrides {
            try encodeContainer.encode(launchOverrides, forKey: .launchOverrides)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
    }
}

extension StartAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/startapp"
    }
}

public struct StartAppInput: Swift.Equatable {
    /// A value that you provide to ensure that repeated calls to this API operation using the same parameters complete only once. A ClientToken is also known as an idempotency token. A ClientToken expires after 24 hours.
    public var clientToken: Swift.String?
    /// The description of the app.
    public var description: Swift.String?
    /// The name of the domain of the app.
    /// This member is required.
    public var domain: Swift.String?
    /// Options that apply when the app starts. These optiAons override default behavior.
    public var launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides?
    /// The name of the app.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the simulation of the app.
    /// This member is required.
    public var simulation: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domain: Swift.String? = nil,
        launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides? = nil,
        name: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domain = domain
        self.launchOverrides = launchOverrides
        self.name = name
        self.simulation = simulation
    }
}

struct StartAppInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let simulation: Swift.String?
    let domain: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let launchOverrides: SimSpaceWeaverClientTypes.LaunchOverrides?
}

extension StartAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case domain = "Domain"
        case launchOverrides = "LaunchOverrides"
        case name = "Name"
        case simulation = "Simulation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let launchOverridesDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.LaunchOverrides.self, forKey: .launchOverrides)
        launchOverrides = launchOverridesDecoded
    }
}

extension StartAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartAppOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartAppOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
            self.name = output.name
            self.simulation = output.simulation
        } else {
            self.domain = nil
            self.name = nil
            self.simulation = nil
        }
    }
}

public struct StartAppOutputResponse: Swift.Equatable {
    /// The name of the domain of the app.
    public var domain: Swift.String?
    /// The name of the app.
    public var name: Swift.String?
    /// The name of the simulation of the app.
    public var simulation: Swift.String?

    public init (
        domain: Swift.String? = nil,
        name: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.domain = domain
        self.name = name
        self.simulation = simulation
    }
}

struct StartAppOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let domain: Swift.String?
    let simulation: Swift.String?
}

extension StartAppOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case name = "Name"
        case simulation = "Simulation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
    }
}

extension StartClockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulation = "Simulation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
    }
}

extension StartClockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/startclock"
    }
}

public struct StartClockInput: Swift.Equatable {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init (
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

struct StartClockInputBody: Swift.Equatable {
    let simulation: Swift.String?
}

extension StartClockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulation = "Simulation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
    }
}

extension StartClockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartClockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartClockOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartClockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartClockOutputResponse: Swift.Equatable {

    public init () { }
}

extension StartSimulationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSimulationInput(description: \(Swift.String(describing: description)), maximumDuration: \(Swift.String(describing: maximumDuration)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), schemaS3Location: \(Swift.String(describing: schemaS3Location)), tags: \(Swift.String(describing: tags)), clientToken: \"CONTENT_REDACTED\")"}
}

extension StartSimulationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case maximumDuration = "MaximumDuration"
        case name = "Name"
        case roleArn = "RoleArn"
        case schemaS3Location = "SchemaS3Location"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maximumDuration = self.maximumDuration {
            try encodeContainer.encode(maximumDuration, forKey: .maximumDuration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let schemaS3Location = self.schemaS3Location {
            try encodeContainer.encode(schemaS3Location, forKey: .schemaS3Location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartSimulationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/startsimulation"
    }
}

public struct StartSimulationInput: Swift.Equatable {
    /// A value that you provide to ensure that repeated calls to this API operation using the same parameters complete only once. A ClientToken is also known as an idempotency token. A ClientToken expires after 24 hours.
    public var clientToken: Swift.String?
    /// The description of the simulation.
    public var description: Swift.String?
    /// The maximum running time of the simulation, specified as a number of months (m or M), hours (h or H), or days (d or D). The simulation stops when it reaches this limit.
    public var maximumDuration: Swift.String?
    /// The name of the simulation.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that the simulation assumes to perform actions. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference. For more information about IAM roles, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the Identity and Access Management User Guide.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The location of the simulation schema in Amazon Simple Storage Service (Amazon S3). For more information about Amazon S3, see the [ Amazon Simple Storage Service User Guide ](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html).
    /// This member is required.
    public var schemaS3Location: SimSpaceWeaverClientTypes.S3Location?
    /// A list of tags for the simulation. For more information about tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        maximumDuration: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        schemaS3Location: SimSpaceWeaverClientTypes.S3Location? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.maximumDuration = maximumDuration
        self.name = name
        self.roleArn = roleArn
        self.schemaS3Location = schemaS3Location
        self.tags = tags
    }
}

struct StartSimulationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let schemaS3Location: SimSpaceWeaverClientTypes.S3Location?
    let maximumDuration: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartSimulationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case maximumDuration = "MaximumDuration"
        case name = "Name"
        case roleArn = "RoleArn"
        case schemaS3Location = "SchemaS3Location"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let schemaS3LocationDecoded = try containerValues.decodeIfPresent(SimSpaceWeaverClientTypes.S3Location.self, forKey: .schemaS3Location)
        schemaS3Location = schemaS3LocationDecoded
        let maximumDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maximumDuration)
        maximumDuration = maximumDurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartSimulationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSimulationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartSimulationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSimulationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartSimulationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.executionId = output.executionId
        } else {
            self.arn = nil
            self.creationTime = nil
            self.executionId = nil
        }
    }
}

public struct StartSimulationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the simulation. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    public var arn: Swift.String?
    /// The time when the simulation was created, expressed as the number of seconds and milliseconds in UTC since the Unix epoch (0:0:0.000, January 1, 1970).
    public var creationTime: ClientRuntime.Date?
    /// A universally unique identifier (UUID) for this simulation.
    public var executionId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        executionId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.executionId = executionId
    }
}

struct StartSimulationOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let executionId: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension StartSimulationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case executionId = "ExecutionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension StopAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app = "App"
        case domain = "Domain"
        case simulation = "Simulation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let app = self.app {
            try encodeContainer.encode(app, forKey: .app)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
    }
}

extension StopAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/stopapp"
    }
}

public struct StopAppInput: Swift.Equatable {
    /// The name of the app.
    /// This member is required.
    public var app: Swift.String?
    /// The name of the domain of the app.
    /// This member is required.
    public var domain: Swift.String?
    /// The name of the simulation of the app.
    /// This member is required.
    public var simulation: Swift.String?

    public init (
        app: Swift.String? = nil,
        domain: Swift.String? = nil,
        simulation: Swift.String? = nil
    )
    {
        self.app = app
        self.domain = domain
        self.simulation = simulation
    }
}

struct StopAppInputBody: Swift.Equatable {
    let simulation: Swift.String?
    let domain: Swift.String?
    let app: Swift.String?
}

extension StopAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app = "App"
        case domain = "Domain"
        case simulation = "Simulation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let appDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .app)
        app = appDecoded
    }
}

extension StopAppOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopAppOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopAppOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopAppOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopAppOutputResponse: Swift.Equatable {

    public init () { }
}

extension StopClockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulation = "Simulation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
    }
}

extension StopClockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/stopclock"
    }
}

public struct StopClockInput: Swift.Equatable {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init (
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

struct StopClockInputBody: Swift.Equatable {
    let simulation: Swift.String?
}

extension StopClockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulation = "Simulation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
    }
}

extension StopClockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopClockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopClockOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopClockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopClockOutputResponse: Swift.Equatable {

    public init () { }
}

extension StopSimulationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulation = "Simulation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simulation = self.simulation {
            try encodeContainer.encode(simulation, forKey: .simulation)
        }
    }
}

extension StopSimulationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/stopsimulation"
    }
}

public struct StopSimulationInput: Swift.Equatable {
    /// The name of the simulation.
    /// This member is required.
    public var simulation: Swift.String?

    public init (
        simulation: Swift.String? = nil
    )
    {
        self.simulation = simulation
    }
}

struct StopSimulationInputBody: Swift.Equatable {
    let simulation: Swift.String?
}

extension StopSimulationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simulation = "Simulation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simulationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simulation)
        simulation = simulationDecoded
    }
}

extension StopSimulationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopSimulationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopSimulationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopSimulationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopSimulationOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to add tags to. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags to apply to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
