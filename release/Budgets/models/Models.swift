// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized to use this operation with the given parameters.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionId = "ActionId"
        case actionThreshold = "ActionThreshold"
        case actionType = "ActionType"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case status = "Status"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionThreshold = actionThreshold {
            try encodeContainer.encode(actionThreshold, forKey: .actionThreshold)
        }
        if let actionType = actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let approvalModel = approvalModel {
            try encodeContainer.encode(approvalModel.rawValue, forKey: .approvalModel)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let notificationType = notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationTypeDecoded = try containerValues.decodeIfPresent(NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionThresholdDecoded = try containerValues.decodeIfPresent(ActionThreshold.self, forKey: .actionThreshold)
        actionThreshold = actionThresholdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Definition.self, forKey: .definition)
        definition = definitionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let approvalModelDecoded = try containerValues.decodeIfPresent(ApprovalModel.self, forKey: .approvalModel)
        approvalModel = approvalModelDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ActionStatus.self, forKey: .status)
        status = statusDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Action(actionId: \(String(describing: actionId)), actionThreshold: \(String(describing: actionThreshold)), actionType: \(String(describing: actionType)), approvalModel: \(String(describing: approvalModel)), budgetName: \(String(describing: budgetName)), definition: \(String(describing: definition)), executionRoleArn: \(String(describing: executionRoleArn)), notificationType: \(String(describing: notificationType)), status: \(String(describing: status)), subscribers: \(String(describing: subscribers)))"}
}

/// <p>
/// 			A budget action resource.
/// 		</p>
public struct Action: Equatable {
    /// <p>
    /// 			A system-generated universally unique identifier (UUID) for the action.
    /// 		</p>
    public let actionId: String?
    /// <p>
    /// 			The trigger threshold of the action.
    /// 		</p>
    public let actionThreshold: ActionThreshold?
    /// <p>
    /// 			The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition.
    /// 		</p>
    public let actionType: ActionType?
    /// <p>
    /// 			This specifies if the action needs manual or automatic approval.
    /// 		</p>
    public let approvalModel: ApprovalModel?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?
    /// <p>
    /// 			Where you specify all of the type-specific parameters.
    /// 		</p>
    public let definition: Definition?
    /// <p>
    /// 			The role passed for action execution and reversion. Roles and actions must be in the same account.
    /// 		</p>
    public let executionRoleArn: String?
    /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
    public let notificationType: NotificationType?
    /// <p>
    /// 			The status of action.
    /// 		</p>
    public let status: ActionStatus?
    /// <p> A list of subscribers.</p>
    public let subscribers: [Subscriber]?

    public init (
        actionId: String? = nil,
        actionThreshold: ActionThreshold? = nil,
        actionType: ActionType? = nil,
        approvalModel: ApprovalModel? = nil,
        budgetName: String? = nil,
        definition: Definition? = nil,
        executionRoleArn: String? = nil,
        notificationType: NotificationType? = nil,
        status: ActionStatus? = nil,
        subscribers: [Subscriber]? = nil
    )
    {
        self.actionId = actionId
        self.actionThreshold = actionThreshold
        self.actionType = actionType
        self.approvalModel = approvalModel
        self.budgetName = budgetName
        self.definition = definition
        self.executionRoleArn = executionRoleArn
        self.notificationType = notificationType
        self.status = status
        self.subscribers = subscribers
    }
}

extension ActionHistory: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionHistoryDetails = "ActionHistoryDetails"
        case eventType = "EventType"
        case status = "Status"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionHistoryDetails = actionHistoryDetails {
            try encodeContainer.encode(actionHistoryDetails, forKey: .actionHistoryDetails)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ActionStatus.self, forKey: .status)
        status = statusDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let actionHistoryDetailsDecoded = try containerValues.decodeIfPresent(ActionHistoryDetails.self, forKey: .actionHistoryDetails)
        actionHistoryDetails = actionHistoryDetailsDecoded
    }
}

extension ActionHistory: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionHistory(actionHistoryDetails: \(String(describing: actionHistoryDetails)), eventType: \(String(describing: eventType)), status: \(String(describing: status)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>
/// 			The historical records for a budget action.
/// 		</p>
public struct ActionHistory: Equatable {
    /// <p>
    /// 			The description of details of the event.
    /// 		</p>
    public let actionHistoryDetails: ActionHistoryDetails?
    /// <p>
    /// 			This distinguishes between whether the events are triggered by the user or generated by the system.
    /// 		</p>
    public let eventType: EventType?
    /// <p>
    /// 			The status of action at the time of the event.
    /// 		</p>
    public let status: ActionStatus?
    /// <p> A generic time stamp. In Java, it is transformed to a <code>Date</code> object.</p>
    public let timestamp: Date?

    public init (
        actionHistoryDetails: ActionHistoryDetails? = nil,
        eventType: EventType? = nil,
        status: ActionStatus? = nil,
        timestamp: Date? = nil
    )
    {
        self.actionHistoryDetails = actionHistoryDetails
        self.eventType = eventType
        self.status = status
        self.timestamp = timestamp
    }
}

extension ActionHistoryDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
    }
}

extension ActionHistoryDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionHistoryDetails(action: \(String(describing: action)), message: \(String(describing: message)))"}
}

/// <p>
/// 			The description of details of the event.
/// 		</p>
public struct ActionHistoryDetails: Equatable {
    /// <p>
    /// 			The budget action resource.
    /// 		</p>
    public let action: Action?
    /// <p> A generic string.</p>
    public let message: String?

    public init (
        action: Action? = nil,
        message: String? = nil
    )
    {
        self.action = action
        self.message = message
    }
}

public enum ActionStatus {
    case executionFailure
    case executionInProgress
    case executionSuccess
    case pending
    case resetFailure
    case resetInProgress
    case reverseFailure
    case reverseInProgress
    case reverseSuccess
    case standby
    case sdkUnknown(String)
}

extension ActionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionStatus] {
        return [
            .executionFailure,
            .executionInProgress,
            .executionSuccess,
            .pending,
            .resetFailure,
            .resetInProgress,
            .reverseFailure,
            .reverseInProgress,
            .reverseSuccess,
            .standby,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .executionFailure: return "EXECUTION_FAILURE"
        case .executionInProgress: return "EXECUTION_IN_PROGRESS"
        case .executionSuccess: return "EXECUTION_SUCCESS"
        case .pending: return "PENDING"
        case .resetFailure: return "RESET_FAILURE"
        case .resetInProgress: return "RESET_IN_PROGRESS"
        case .reverseFailure: return "REVERSE_FAILURE"
        case .reverseInProgress: return "REVERSE_IN_PROGRESS"
        case .reverseSuccess: return "REVERSE_SUCCESS"
        case .standby: return "STANDBY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionStatus(rawValue: rawValue) ?? ActionStatus.sdkUnknown(rawValue)
    }
}

public enum ActionSubType {
    case stopEc2
    case stopRds
    case sdkUnknown(String)
}

extension ActionSubType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionSubType] {
        return [
            .stopEc2,
            .stopRds,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .stopEc2: return "STOP_EC2_INSTANCES"
        case .stopRds: return "STOP_RDS_INSTANCES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionSubType(rawValue: rawValue) ?? ActionSubType.sdkUnknown(rawValue)
    }
}

extension ActionThreshold: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionThresholdType = "ActionThresholdType"
        case actionThresholdValue = "ActionThresholdValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionThresholdType = actionThresholdType {
            try encodeContainer.encode(actionThresholdType.rawValue, forKey: .actionThresholdType)
        }
        if actionThresholdValue != 0.0 {
            try encodeContainer.encode(actionThresholdValue, forKey: .actionThresholdValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionThresholdValueDecoded = try containerValues.decode(Double.self, forKey: .actionThresholdValue)
        actionThresholdValue = actionThresholdValueDecoded
        let actionThresholdTypeDecoded = try containerValues.decodeIfPresent(ThresholdType.self, forKey: .actionThresholdType)
        actionThresholdType = actionThresholdTypeDecoded
    }
}

extension ActionThreshold: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionThreshold(actionThresholdType: \(String(describing: actionThresholdType)), actionThresholdValue: \(String(describing: actionThresholdValue)))"}
}

/// <p>
/// 			The trigger threshold of the action.
/// 		</p>
public struct ActionThreshold: Equatable {
    /// <p> The type of threshold for a notification.</p>
    public let actionThresholdType: ThresholdType?
    /// <p> The threshold of a notification.</p>
    public let actionThresholdValue: Double

    public init (
        actionThresholdType: ThresholdType? = nil,
        actionThresholdValue: Double = 0.0
    )
    {
        self.actionThresholdType = actionThresholdType
        self.actionThresholdValue = actionThresholdValue
    }
}

public enum ActionType {
    case iam
    case scp
    case ssm
    case sdkUnknown(String)
}

extension ActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionType] {
        return [
            .iam,
            .scp,
            .ssm,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .iam: return "APPLY_IAM_POLICY"
        case .scp: return "APPLY_SCP_POLICY"
        case .ssm: return "RUN_SSM_DOCUMENTS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
    }
}

public enum ApprovalModel {
    case auto
    case manual
    case sdkUnknown(String)
}

extension ApprovalModel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApprovalModel] {
        return [
            .auto,
            .manual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .auto: return "AUTOMATIC"
        case .manual: return "MANUAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApprovalModel(rawValue: rawValue) ?? ApprovalModel.sdkUnknown(rawValue)
    }
}

extension Budget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case budgetLimit = "BudgetLimit"
        case budgetName = "BudgetName"
        case budgetType = "BudgetType"
        case calculatedSpend = "CalculatedSpend"
        case costFilters = "CostFilters"
        case costTypes = "CostTypes"
        case lastUpdatedTime = "LastUpdatedTime"
        case plannedBudgetLimits = "PlannedBudgetLimits"
        case timePeriod = "TimePeriod"
        case timeUnit = "TimeUnit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetLimit = budgetLimit {
            try encodeContainer.encode(budgetLimit, forKey: .budgetLimit)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let budgetType = budgetType {
            try encodeContainer.encode(budgetType.rawValue, forKey: .budgetType)
        }
        if let calculatedSpend = calculatedSpend {
            try encodeContainer.encode(calculatedSpend, forKey: .calculatedSpend)
        }
        if let costFilters = costFilters {
            var costFiltersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .costFilters)
            for (dictKey0, costfilters0) in costFilters {
                try costFiltersContainer.encode(costfilters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let costTypes = costTypes {
            try encodeContainer.encode(costTypes, forKey: .costTypes)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let plannedBudgetLimits = plannedBudgetLimits {
            var plannedBudgetLimitsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .plannedBudgetLimits)
            for (dictKey0, plannedbudgetlimits0) in plannedBudgetLimits {
                try plannedBudgetLimitsContainer.encode(plannedbudgetlimits0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let timeUnit = timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let budgetLimitDecoded = try containerValues.decodeIfPresent(Spend.self, forKey: .budgetLimit)
        budgetLimit = budgetLimitDecoded
        let plannedBudgetLimitsContainer = try containerValues.decodeIfPresent([String: Spend?].self, forKey: .plannedBudgetLimits)
        var plannedBudgetLimitsDecoded0: [String:Spend]? = nil
        if let plannedBudgetLimitsContainer = plannedBudgetLimitsContainer {
            plannedBudgetLimitsDecoded0 = [String:Spend]()
            for (key0, spend0) in plannedBudgetLimitsContainer {
                if let spend0 = spend0 {
                    plannedBudgetLimitsDecoded0?[key0] = spend0
                }
            }
        }
        plannedBudgetLimits = plannedBudgetLimitsDecoded0
        let costFiltersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .costFilters)
        var costFiltersDecoded0: [String:[String]]? = nil
        if let costFiltersContainer = costFiltersContainer {
            costFiltersDecoded0 = [String:[String]]()
            for (key0, dimensionvalues0) in costFiltersContainer {
                var dimensionvalues0Decoded0: [String]? = nil
                if let dimensionvalues0 = dimensionvalues0 {
                    dimensionvalues0Decoded0 = [String]()
                    for string1 in dimensionvalues0 {
                        if let string1 = string1 {
                            dimensionvalues0Decoded0?.append(string1)
                        }
                    }
                }
                costFiltersDecoded0?[key0] = dimensionvalues0Decoded0
            }
        }
        costFilters = costFiltersDecoded0
        let costTypesDecoded = try containerValues.decodeIfPresent(CostTypes.self, forKey: .costTypes)
        costTypes = costTypesDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let calculatedSpendDecoded = try containerValues.decodeIfPresent(CalculatedSpend.self, forKey: .calculatedSpend)
        calculatedSpend = calculatedSpendDecoded
        let budgetTypeDecoded = try containerValues.decodeIfPresent(BudgetType.self, forKey: .budgetType)
        budgetType = budgetTypeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension Budget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Budget(budgetLimit: \(String(describing: budgetLimit)), budgetName: \(String(describing: budgetName)), budgetType: \(String(describing: budgetType)), calculatedSpend: \(String(describing: calculatedSpend)), costFilters: \(String(describing: costFilters)), costTypes: \(String(describing: costTypes)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), plannedBudgetLimits: \(String(describing: plannedBudgetLimits)), timePeriod: \(String(describing: timePeriod)), timeUnit: \(String(describing: timeUnit)))"}
}

/// <p>Represents the output of the <code>CreateBudget</code> operation. The content consists of the detailed metadata and data file information, and the current status of the <code>budget</code> object.</p>
/// 		       <p>This is the ARN pattern for a budget: </p>
/// 		       <p>
///             <code>arn:aws:budgets::AccountId:budget/budgetName</code>
///          </p>
public struct Budget: Equatable {
    /// <p>The total amount of cost, usage, RI utilization, RI coverage, Savings Plans utilization, or Savings Plans coverage that you want to track with your budget.</p>
    /// 		       <p>
    ///             <code>BudgetLimit</code> is required for cost or usage budgets, but optional for RI or Savings Plans utilization or coverage budgets. RI and Savings Plans utilization or coverage budgets default to <code>100</code>, which is the only valid value for RI or Savings Plans utilization or coverage budgets. You can't use <code>BudgetLimit</code> with <code>PlannedBudgetLimits</code> for <code>CreateBudget</code> and <code>UpdateBudget</code> actions. </p>
    public let budgetLimit: Spend?
    /// <p>The name of a budget. The name must be unique within an account. The <code>:</code> and <code>\</code> characters aren't allowed in <code>BudgetName</code>.</p>
    public let budgetName: String?
    /// <p>Whether this budget tracks costs, usage, RI utilization, RI coverage, Savings Plans utilization, or Savings Plans coverage.</p>
    public let budgetType: BudgetType?
    /// <p>The actual and forecasted cost or usage that the budget tracks.</p>
    public let calculatedSpend: CalculatedSpend?
    /// <p>The cost filters, such as service or tag, that are applied to a budget.</p>
    /// 		       <p>AWS Budgets supports the following services as a filter for RI budgets:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Amazon Elastic Compute Cloud - Compute</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Amazon Redshift</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Amazon Relational Database Service</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Amazon ElastiCache</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Amazon Elasticsearch Service</p>
    /// 			         </li>
    ///          </ul>
    public let costFilters: [String:[String]]?
    /// <p>The types of costs that are included in this <code>COST</code> budget.</p>
    /// 		       <p>
    ///             <code>USAGE</code>, <code>RI_UTILIZATION</code>, <code>RI_COVERAGE</code>, <code>SAVINGS_PLANS_UTILIZATION</code>, and <code>SAVINGS_PLANS_COVERAGE</code> budgets do not have <code>CostTypes</code>.</p>
    public let costTypes: CostTypes?
    /// <p>The last time that you updated this budget.</p>
    public let lastUpdatedTime: Date?
    /// <p>A map containing multiple <code>BudgetLimit</code>, including current or future limits.</p>
    /// 		       <p>
    ///             <code>PlannedBudgetLimits</code> is available for cost or usage budget and supports monthly and quarterly <code>TimeUnit</code>. </p>
    /// 		       <p>For monthly budgets, provide 12 months of <code>PlannedBudgetLimits</code> values. This must start from the current month and include the next 11 months. The <code>key</code> is the start of the month, <code>UTC</code> in epoch seconds. </p>
    /// 		       <p>For quarterly budgets, provide 4 quarters of <code>PlannedBudgetLimits</code> value entries in standard calendar quarter increments. This must start from the current quarter and include the next 3 quarters. The <code>key</code> is the start of the quarter, <code>UTC</code> in epoch seconds. </p>
    /// 		       <p>If the planned budget expires before 12 months for monthly or 4 quarters for quarterly, provide the <code>PlannedBudgetLimits</code> values only for the remaining periods.</p>
    /// 		       <p>If the budget begins at a date in the future, provide <code>PlannedBudgetLimits</code> values from the start date of the budget. </p>
    /// 		       <p>After all of the <code>BudgetLimit</code> values in <code>PlannedBudgetLimits</code> are used, the budget continues to use the last limit as the <code>BudgetLimit</code>. At that point, the planned budget provides the same experience as a fixed budget. </p>
    /// 		       <p>
    ///             <code>DescribeBudget</code> and <code>DescribeBudgets</code> response along with <code>PlannedBudgetLimits</code> will also contain <code>BudgetLimit</code> representing the current month or quarter limit present in <code>PlannedBudgetLimits</code>. This only applies to budgets created with <code>PlannedBudgetLimits</code>. Budgets created without <code>PlannedBudgetLimits</code> will only contain <code>BudgetLimit</code>, and no <code>PlannedBudgetLimits</code>.</p>
    public let plannedBudgetLimits: [String:Spend]?
    /// <p>The period of time that is covered by a budget. The period has a start date and an end date. The start date must come before the end date. The end date must come before <code>06/15/87 00:00 UTC</code>. </p>
    /// 		       <p>If you create your budget and don't specify a start date, AWS defaults to the start of your chosen time period (DAILY, MONTHLY, QUARTERLY, or ANNUALLY). For example, if you created your budget on January 24, 2018, chose <code>DAILY</code>, and didn't set a start date, AWS set your start date to <code>01/24/18 00:00 UTC</code>. If you chose <code>MONTHLY</code>, AWS set your start date to <code>01/01/18 00:00 UTC</code>. If you didn't specify an end date, AWS set your end date to <code>06/15/87 00:00 UTC</code>. The defaults are the same for the AWS Billing and Cost Management console and the API. </p>
    /// 		       <p>You can change either date with the <code>UpdateBudget</code> operation.</p>
    /// 		       <p>After the end date, AWS deletes the budget and all associated notifications and subscribers.</p>
    public let timePeriod: TimePeriod?
    /// <p>The length of time until a budget resets the actual and forecasted spend.</p>
    public let timeUnit: TimeUnit?

    public init (
        budgetLimit: Spend? = nil,
        budgetName: String? = nil,
        budgetType: BudgetType? = nil,
        calculatedSpend: CalculatedSpend? = nil,
        costFilters: [String:[String]]? = nil,
        costTypes: CostTypes? = nil,
        lastUpdatedTime: Date? = nil,
        plannedBudgetLimits: [String:Spend]? = nil,
        timePeriod: TimePeriod? = nil,
        timeUnit: TimeUnit? = nil
    )
    {
        self.budgetLimit = budgetLimit
        self.budgetName = budgetName
        self.budgetType = budgetType
        self.calculatedSpend = calculatedSpend
        self.costFilters = costFilters
        self.costTypes = costTypes
        self.lastUpdatedTime = lastUpdatedTime
        self.plannedBudgetLimits = plannedBudgetLimits
        self.timePeriod = timePeriod
        self.timeUnit = timeUnit
    }
}

extension BudgetPerformanceHistory: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case budgetName = "BudgetName"
        case budgetType = "BudgetType"
        case budgetedAndActualAmountsList = "BudgetedAndActualAmountsList"
        case costFilters = "CostFilters"
        case costTypes = "CostTypes"
        case timeUnit = "TimeUnit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let budgetType = budgetType {
            try encodeContainer.encode(budgetType.rawValue, forKey: .budgetType)
        }
        if let budgetedAndActualAmountsList = budgetedAndActualAmountsList {
            var budgetedAndActualAmountsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .budgetedAndActualAmountsList)
            for budgetedandactualamountslist0 in budgetedAndActualAmountsList {
                try budgetedAndActualAmountsListContainer.encode(budgetedandactualamountslist0)
            }
        }
        if let costFilters = costFilters {
            var costFiltersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .costFilters)
            for (dictKey0, costfilters0) in costFilters {
                try costFiltersContainer.encode(costfilters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let costTypes = costTypes {
            try encodeContainer.encode(costTypes, forKey: .costTypes)
        }
        if let timeUnit = timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let budgetTypeDecoded = try containerValues.decodeIfPresent(BudgetType.self, forKey: .budgetType)
        budgetType = budgetTypeDecoded
        let costFiltersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .costFilters)
        var costFiltersDecoded0: [String:[String]]? = nil
        if let costFiltersContainer = costFiltersContainer {
            costFiltersDecoded0 = [String:[String]]()
            for (key0, dimensionvalues0) in costFiltersContainer {
                var dimensionvalues0Decoded0: [String]? = nil
                if let dimensionvalues0 = dimensionvalues0 {
                    dimensionvalues0Decoded0 = [String]()
                    for string1 in dimensionvalues0 {
                        if let string1 = string1 {
                            dimensionvalues0Decoded0?.append(string1)
                        }
                    }
                }
                costFiltersDecoded0?[key0] = dimensionvalues0Decoded0
            }
        }
        costFilters = costFiltersDecoded0
        let costTypesDecoded = try containerValues.decodeIfPresent(CostTypes.self, forKey: .costTypes)
        costTypes = costTypesDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let budgetedAndActualAmountsListContainer = try containerValues.decodeIfPresent([BudgetedAndActualAmounts?].self, forKey: .budgetedAndActualAmountsList)
        var budgetedAndActualAmountsListDecoded0:[BudgetedAndActualAmounts]? = nil
        if let budgetedAndActualAmountsListContainer = budgetedAndActualAmountsListContainer {
            budgetedAndActualAmountsListDecoded0 = [BudgetedAndActualAmounts]()
            for structure0 in budgetedAndActualAmountsListContainer {
                if let structure0 = structure0 {
                    budgetedAndActualAmountsListDecoded0?.append(structure0)
                }
            }
        }
        budgetedAndActualAmountsList = budgetedAndActualAmountsListDecoded0
    }
}

extension BudgetPerformanceHistory: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BudgetPerformanceHistory(budgetName: \(String(describing: budgetName)), budgetType: \(String(describing: budgetType)), budgetedAndActualAmountsList: \(String(describing: budgetedAndActualAmountsList)), costFilters: \(String(describing: costFilters)), costTypes: \(String(describing: costTypes)), timeUnit: \(String(describing: timeUnit)))"}
}

/// <p>A history of the state of a budget at the end of the budget's specified time period.</p>
public struct BudgetPerformanceHistory: Equatable {
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?
    /// <p> The type of a budget. It must be one of the following types: </p>
    /// 		       <p>
    ///             <code>COST</code>, <code>USAGE</code>, <code>RI_UTILIZATION</code>, <code>RI_COVERAGE</code>, <code>SAVINGS_PLANS_UTILIZATION</code>, or <code>SAVINGS_PLANS_COVERAGE</code>.</p>
    public let budgetType: BudgetType?
    /// <p>A list of amounts of cost or usage that you created budgets for, compared to your actual costs or usage.</p>
    public let budgetedAndActualAmountsList: [BudgetedAndActualAmounts]?
    /// <p>The history of the cost filters for a budget during the specified time period.</p>
    public let costFilters: [String:[String]]?
    /// <p>The history of the cost types for a budget during the specified time period.</p>
    public let costTypes: CostTypes?
    /// <p> The time unit of the budget, such as MONTHLY or QUARTERLY.</p>
    public let timeUnit: TimeUnit?

    public init (
        budgetName: String? = nil,
        budgetType: BudgetType? = nil,
        budgetedAndActualAmountsList: [BudgetedAndActualAmounts]? = nil,
        costFilters: [String:[String]]? = nil,
        costTypes: CostTypes? = nil,
        timeUnit: TimeUnit? = nil
    )
    {
        self.budgetName = budgetName
        self.budgetType = budgetType
        self.budgetedAndActualAmountsList = budgetedAndActualAmountsList
        self.costFilters = costFilters
        self.costTypes = costTypes
        self.timeUnit = timeUnit
    }
}

/// <p> The type of a budget. It must be one of the following types: </p>
/// 		       <p>
///             <code>COST</code>, <code>USAGE</code>, <code>RI_UTILIZATION</code>, <code>RI_COVERAGE</code>, <code>SAVINGS_PLANS_UTILIZATION</code>, or <code>SAVINGS_PLANS_COVERAGE</code>.</p>
public enum BudgetType {
    case cost
    case ricoverage
    case riutilization
    case spcoverage
    case sputilization
    case usage
    case sdkUnknown(String)
}

extension BudgetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BudgetType] {
        return [
            .cost,
            .ricoverage,
            .riutilization,
            .spcoverage,
            .sputilization,
            .usage,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cost: return "COST"
        case .ricoverage: return "RI_COVERAGE"
        case .riutilization: return "RI_UTILIZATION"
        case .spcoverage: return "SAVINGS_PLANS_COVERAGE"
        case .sputilization: return "SAVINGS_PLANS_UTILIZATION"
        case .usage: return "USAGE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BudgetType(rawValue: rawValue) ?? BudgetType.sdkUnknown(rawValue)
    }
}

extension BudgetedAndActualAmounts: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actualAmount = "ActualAmount"
        case budgetedAmount = "BudgetedAmount"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualAmount = actualAmount {
            try encodeContainer.encode(actualAmount, forKey: .actualAmount)
        }
        if let budgetedAmount = budgetedAmount {
            try encodeContainer.encode(budgetedAmount, forKey: .budgetedAmount)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetedAmountDecoded = try containerValues.decodeIfPresent(Spend.self, forKey: .budgetedAmount)
        budgetedAmount = budgetedAmountDecoded
        let actualAmountDecoded = try containerValues.decodeIfPresent(Spend.self, forKey: .actualAmount)
        actualAmount = actualAmountDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
    }
}

extension BudgetedAndActualAmounts: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BudgetedAndActualAmounts(actualAmount: \(String(describing: actualAmount)), budgetedAmount: \(String(describing: budgetedAmount)), timePeriod: \(String(describing: timePeriod)))"}
}

/// <p>The amount of cost or usage that you created the budget for, compared to your actual costs or usage.</p>
public struct BudgetedAndActualAmounts: Equatable {
    /// <p>Your actual costs or usage for a budget period.</p>
    public let actualAmount: Spend?
    /// <p>The amount of cost or usage that you created the budget for.</p>
    public let budgetedAmount: Spend?
    /// <p>The time period covered by this budget comparison.</p>
    public let timePeriod: TimePeriod?

    public init (
        actualAmount: Spend? = nil,
        budgetedAmount: Spend? = nil,
        timePeriod: TimePeriod? = nil
    )
    {
        self.actualAmount = actualAmount
        self.budgetedAmount = budgetedAmount
        self.timePeriod = timePeriod
    }
}

extension CalculatedSpend: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actualSpend = "ActualSpend"
        case forecastedSpend = "ForecastedSpend"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualSpend = actualSpend {
            try encodeContainer.encode(actualSpend, forKey: .actualSpend)
        }
        if let forecastedSpend = forecastedSpend {
            try encodeContainer.encode(forecastedSpend, forKey: .forecastedSpend)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actualSpendDecoded = try containerValues.decodeIfPresent(Spend.self, forKey: .actualSpend)
        actualSpend = actualSpendDecoded
        let forecastedSpendDecoded = try containerValues.decodeIfPresent(Spend.self, forKey: .forecastedSpend)
        forecastedSpend = forecastedSpendDecoded
    }
}

extension CalculatedSpend: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CalculatedSpend(actualSpend: \(String(describing: actualSpend)), forecastedSpend: \(String(describing: forecastedSpend)))"}
}

/// <p>The spend objects that are associated with this budget. The <code>actualSpend</code> tracks how much you've used, cost, usage, RI units, or Savings Plans units and the <code>forecastedSpend</code> tracks how much you are predicted to spend based on your historical usage profile.</p>
/// 		       <p>For example, if it is the 20th of the month and you have spent <code>50</code> dollars on Amazon EC2, your <code>actualSpend</code> is <code>50 USD</code>, and your <code>forecastedSpend</code> is <code>75 USD</code>.</p>
public struct CalculatedSpend: Equatable {
    /// <p>The amount of cost, usage, RI units, or Savings Plans units that you have used.</p>
    public let actualSpend: Spend?
    /// <p>The amount of cost, usage, RI units, or Savings Plans units that you are forecasted to use.</p>
    public let forecastedSpend: Spend?

    public init (
        actualSpend: Spend? = nil,
        forecastedSpend: Spend? = nil
    )
    {
        self.actualSpend = actualSpend
        self.forecastedSpend = forecastedSpend
    }
}

/// <p> The comparison operator of a notification. Currently the service supports the following operators:</p>
/// 		       <p>
///             <code>GREATER_THAN</code>, <code>LESS_THAN</code>, <code>EQUAL_TO</code>
///          </p>
public enum ComparisonOperator {
    case equalTo
    case greaterThan
    case lessThan
    case sdkUnknown(String)
}

extension ComparisonOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComparisonOperator] {
        return [
            .equalTo,
            .greaterThan,
            .lessThan,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .equalTo: return "EQUAL_TO"
        case .greaterThan: return "GREATER_THAN"
        case .lessThan: return "LESS_THAN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
    }
}

extension CostTypes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeCredit = "IncludeCredit"
        case includeDiscount = "IncludeDiscount"
        case includeOtherSubscription = "IncludeOtherSubscription"
        case includeRecurring = "IncludeRecurring"
        case includeRefund = "IncludeRefund"
        case includeSubscription = "IncludeSubscription"
        case includeSupport = "IncludeSupport"
        case includeTax = "IncludeTax"
        case includeUpfront = "IncludeUpfront"
        case useAmortized = "UseAmortized"
        case useBlended = "UseBlended"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeCredit = includeCredit {
            try encodeContainer.encode(includeCredit, forKey: .includeCredit)
        }
        if let includeDiscount = includeDiscount {
            try encodeContainer.encode(includeDiscount, forKey: .includeDiscount)
        }
        if let includeOtherSubscription = includeOtherSubscription {
            try encodeContainer.encode(includeOtherSubscription, forKey: .includeOtherSubscription)
        }
        if let includeRecurring = includeRecurring {
            try encodeContainer.encode(includeRecurring, forKey: .includeRecurring)
        }
        if let includeRefund = includeRefund {
            try encodeContainer.encode(includeRefund, forKey: .includeRefund)
        }
        if let includeSubscription = includeSubscription {
            try encodeContainer.encode(includeSubscription, forKey: .includeSubscription)
        }
        if let includeSupport = includeSupport {
            try encodeContainer.encode(includeSupport, forKey: .includeSupport)
        }
        if let includeTax = includeTax {
            try encodeContainer.encode(includeTax, forKey: .includeTax)
        }
        if let includeUpfront = includeUpfront {
            try encodeContainer.encode(includeUpfront, forKey: .includeUpfront)
        }
        if let useAmortized = useAmortized {
            try encodeContainer.encode(useAmortized, forKey: .useAmortized)
        }
        if let useBlended = useBlended {
            try encodeContainer.encode(useBlended, forKey: .useBlended)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includeTaxDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeTax)
        includeTax = includeTaxDecoded
        let includeSubscriptionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeSubscription)
        includeSubscription = includeSubscriptionDecoded
        let useBlendedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useBlended)
        useBlended = useBlendedDecoded
        let includeRefundDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeRefund)
        includeRefund = includeRefundDecoded
        let includeCreditDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeCredit)
        includeCredit = includeCreditDecoded
        let includeUpfrontDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeUpfront)
        includeUpfront = includeUpfrontDecoded
        let includeRecurringDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeRecurring)
        includeRecurring = includeRecurringDecoded
        let includeOtherSubscriptionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeOtherSubscription)
        includeOtherSubscription = includeOtherSubscriptionDecoded
        let includeSupportDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeSupport)
        includeSupport = includeSupportDecoded
        let includeDiscountDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeDiscount)
        includeDiscount = includeDiscountDecoded
        let useAmortizedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useAmortized)
        useAmortized = useAmortizedDecoded
    }
}

extension CostTypes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CostTypes(includeCredit: \(String(describing: includeCredit)), includeDiscount: \(String(describing: includeDiscount)), includeOtherSubscription: \(String(describing: includeOtherSubscription)), includeRecurring: \(String(describing: includeRecurring)), includeRefund: \(String(describing: includeRefund)), includeSubscription: \(String(describing: includeSubscription)), includeSupport: \(String(describing: includeSupport)), includeTax: \(String(describing: includeTax)), includeUpfront: \(String(describing: includeUpfront)), useAmortized: \(String(describing: useAmortized)), useBlended: \(String(describing: useBlended)))"}
}

/// <p>The types of cost that are included in a <code>COST</code> budget, such as tax and subscriptions.</p>
/// 		       <p>
///             <code>USAGE</code>, <code>RI_UTILIZATION</code>, <code>RI_COVERAGE</code>, <code>SAVINGS_PLANS_UTILIZATION</code>, and <code>SAVINGS_PLANS_COVERAGE</code> budgets do not have <code>CostTypes</code>.</p>
public struct CostTypes: Equatable {
    /// <p>Specifies whether a budget includes credits.</p>
    /// 		       <p>The default value is <code>true</code>.</p>
    public let includeCredit: Bool?
    /// <p>Specifies whether a budget includes discounts.</p>
    /// 		       <p>The default value is <code>true</code>.</p>
    public let includeDiscount: Bool?
    /// <p>Specifies whether a budget includes non-RI subscription costs.</p>
    /// 		       <p>The default value is <code>true</code>.</p>
    public let includeOtherSubscription: Bool?
    /// <p>Specifies whether a budget includes recurring fees such as monthly RI fees.</p>
    /// 		       <p>The default value is <code>true</code>.</p>
    public let includeRecurring: Bool?
    /// <p>Specifies whether a budget includes refunds.</p>
    /// 		       <p>The default value is <code>true</code>.</p>
    public let includeRefund: Bool?
    /// <p>Specifies whether a budget includes subscriptions.</p>
    /// 		       <p>The default value is <code>true</code>.</p>
    public let includeSubscription: Bool?
    /// <p>Specifies whether a budget includes support subscription fees.</p>
    /// 		       <p>The default value is <code>true</code>.</p>
    public let includeSupport: Bool?
    /// <p>Specifies whether a budget includes taxes.</p>
    /// 		       <p>The default value is <code>true</code>.</p>
    public let includeTax: Bool?
    /// <p>Specifies whether a budget includes upfront RI costs.</p>
    /// 		       <p>The default value is <code>true</code>.</p>
    public let includeUpfront: Bool?
    /// <p>Specifies whether a budget uses the amortized rate.</p>
    /// 		       <p>The default value is <code>false</code>.</p>
    public let useAmortized: Bool?
    /// <p>Specifies whether a budget uses a blended rate.</p>
    /// 		       <p>The default value is <code>false</code>.</p>
    public let useBlended: Bool?

    public init (
        includeCredit: Bool? = nil,
        includeDiscount: Bool? = nil,
        includeOtherSubscription: Bool? = nil,
        includeRecurring: Bool? = nil,
        includeRefund: Bool? = nil,
        includeSubscription: Bool? = nil,
        includeSupport: Bool? = nil,
        includeTax: Bool? = nil,
        includeUpfront: Bool? = nil,
        useAmortized: Bool? = nil,
        useBlended: Bool? = nil
    )
    {
        self.includeCredit = includeCredit
        self.includeDiscount = includeDiscount
        self.includeOtherSubscription = includeOtherSubscription
        self.includeRecurring = includeRecurring
        self.includeRefund = includeRefund
        self.includeSubscription = includeSubscription
        self.includeSupport = includeSupport
        self.includeTax = includeTax
        self.includeUpfront = includeUpfront
        self.useAmortized = useAmortized
        self.useBlended = useBlended
    }
}

public struct CreateBudgetActionInputBodyMiddleware: Middleware {
    public let id: String = "CreateBudgetActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBudgetActionInput>
    public typealias MOutput = OperationOutput<CreateBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBudgetActionOutputError>
}

extension CreateBudgetActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBudgetActionInput(accountId: \(String(describing: accountId)), actionThreshold: \(String(describing: actionThreshold)), actionType: \(String(describing: actionType)), approvalModel: \(String(describing: approvalModel)), budgetName: \(String(describing: budgetName)), definition: \(String(describing: definition)), executionRoleArn: \(String(describing: executionRoleArn)), notificationType: \(String(describing: notificationType)), subscribers: \(String(describing: subscribers)))"}
}

extension CreateBudgetActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionThreshold = "ActionThreshold"
        case actionType = "ActionType"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionThreshold = actionThreshold {
            try encodeContainer.encode(actionThreshold, forKey: .actionThreshold)
        }
        if let actionType = actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let approvalModel = approvalModel {
            try encodeContainer.encode(approvalModel.rawValue, forKey: .approvalModel)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let notificationType = notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
    }
}

public struct CreateBudgetActionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBudgetActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBudgetActionInput>
    public typealias MOutput = OperationOutput<CreateBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBudgetActionOutputError>
}

public struct CreateBudgetActionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBudgetActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBudgetActionInput>
    public typealias MOutput = OperationOutput<CreateBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBudgetActionOutputError>
}

public struct CreateBudgetActionInput: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p>
    /// 			The trigger threshold of the action.
    /// 		</p>
    public let actionThreshold: ActionThreshold?
    /// <p>
    ///          The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition.
    ///       </p>
    public let actionType: ActionType?
    /// <p>
    ///          This specifies if the action needs manual or automatic approval.
    ///       </p>
    public let approvalModel: ApprovalModel?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?
    /// <p>
    /// 			Specifies all of the type-specific parameters.
    /// 		</p>
    public let definition: Definition?
    /// <p>
    ///          The role passed for action execution and reversion. Roles and actions must be in the same account.
    ///       </p>
    public let executionRoleArn: String?
    /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
    public let notificationType: NotificationType?
    /// <p> A list of subscribers.</p>
    public let subscribers: [Subscriber]?

    public init (
        accountId: String? = nil,
        actionThreshold: ActionThreshold? = nil,
        actionType: ActionType? = nil,
        approvalModel: ApprovalModel? = nil,
        budgetName: String? = nil,
        definition: Definition? = nil,
        executionRoleArn: String? = nil,
        notificationType: NotificationType? = nil,
        subscribers: [Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.actionThreshold = actionThreshold
        self.actionType = actionType
        self.approvalModel = approvalModel
        self.budgetName = budgetName
        self.definition = definition
        self.executionRoleArn = executionRoleArn
        self.notificationType = notificationType
        self.subscribers = subscribers
    }
}

struct CreateBudgetActionInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let notificationType: NotificationType?
    public let actionType: ActionType?
    public let actionThreshold: ActionThreshold?
    public let definition: Definition?
    public let executionRoleArn: String?
    public let approvalModel: ApprovalModel?
    public let subscribers: [Subscriber]?
}

extension CreateBudgetActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionThreshold = "ActionThreshold"
        case actionType = "ActionType"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationTypeDecoded = try containerValues.decodeIfPresent(NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionThresholdDecoded = try containerValues.decodeIfPresent(ActionThreshold.self, forKey: .actionThreshold)
        actionThreshold = actionThresholdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Definition.self, forKey: .definition)
        definition = definitionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let approvalModelDecoded = try containerValues.decodeIfPresent(ApprovalModel.self, forKey: .approvalModel)
        approvalModel = approvalModelDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension CreateBudgetActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBudgetActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreationLimitExceededException" : self = .creationLimitExceededException(try CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBudgetActionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case creationLimitExceededException(CreationLimitExceededException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBudgetActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBudgetActionOutputResponse(accountId: \(String(describing: accountId)), actionId: \(String(describing: actionId)), budgetName: \(String(describing: budgetName)))"}
}

extension CreateBudgetActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountId = output.accountId
            self.actionId = output.actionId
            self.budgetName = output.budgetName
        } else {
            self.accountId = nil
            self.actionId = nil
            self.budgetName = nil
        }
    }
}

public struct CreateBudgetActionOutputResponse: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?

    public init (
        accountId: String? = nil,
        actionId: String? = nil,
        budgetName: String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

struct CreateBudgetActionOutputResponseBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let actionId: String?
}

extension CreateBudgetActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

public struct CreateBudgetInputBodyMiddleware: Middleware {
    public let id: String = "CreateBudgetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBudgetInput>
    public typealias MOutput = OperationOutput<CreateBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBudgetOutputError>
}

extension CreateBudgetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBudgetInput(accountId: \(String(describing: accountId)), budget: \(String(describing: budget)), notificationsWithSubscribers: \(String(describing: notificationsWithSubscribers)))"}
}

extension CreateBudgetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budget = "Budget"
        case notificationsWithSubscribers = "NotificationsWithSubscribers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budget = budget {
            try encodeContainer.encode(budget, forKey: .budget)
        }
        if let notificationsWithSubscribers = notificationsWithSubscribers {
            var notificationsWithSubscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationsWithSubscribers)
            for notificationwithsubscriberslist0 in notificationsWithSubscribers {
                try notificationsWithSubscribersContainer.encode(notificationwithsubscriberslist0)
            }
        }
    }
}

public struct CreateBudgetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBudgetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBudgetInput>
    public typealias MOutput = OperationOutput<CreateBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBudgetOutputError>
}

public struct CreateBudgetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBudgetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBudgetInput>
    public typealias MOutput = OperationOutput<CreateBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBudgetOutputError>
}

/// <p> Request of CreateBudget </p>
public struct CreateBudgetInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget.</p>
    public let accountId: String?
    /// <p>The budget object that you want to create.</p>
    public let budget: Budget?
    /// <p>A notification that you want to associate with a budget. A budget can have up to five notifications, and each notification can have one SNS subscriber and up to 10 email subscribers. If you include notifications and subscribers in your <code>CreateBudget</code> call, AWS creates the notifications and subscribers for you.</p>
    public let notificationsWithSubscribers: [NotificationWithSubscribers]?

    public init (
        accountId: String? = nil,
        budget: Budget? = nil,
        notificationsWithSubscribers: [NotificationWithSubscribers]? = nil
    )
    {
        self.accountId = accountId
        self.budget = budget
        self.notificationsWithSubscribers = notificationsWithSubscribers
    }
}

struct CreateBudgetInputBody: Equatable {
    public let accountId: String?
    public let budget: Budget?
    public let notificationsWithSubscribers: [NotificationWithSubscribers]?
}

extension CreateBudgetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budget = "Budget"
        case notificationsWithSubscribers = "NotificationsWithSubscribers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetDecoded = try containerValues.decodeIfPresent(Budget.self, forKey: .budget)
        budget = budgetDecoded
        let notificationsWithSubscribersContainer = try containerValues.decodeIfPresent([NotificationWithSubscribers?].self, forKey: .notificationsWithSubscribers)
        var notificationsWithSubscribersDecoded0:[NotificationWithSubscribers]? = nil
        if let notificationsWithSubscribersContainer = notificationsWithSubscribersContainer {
            notificationsWithSubscribersDecoded0 = [NotificationWithSubscribers]()
            for structure0 in notificationsWithSubscribersContainer {
                if let structure0 = structure0 {
                    notificationsWithSubscribersDecoded0?.append(structure0)
                }
            }
        }
        notificationsWithSubscribers = notificationsWithSubscribersDecoded0
    }
}

extension CreateBudgetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBudgetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreationLimitExceededException" : self = .creationLimitExceededException(try CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBudgetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case creationLimitExceededException(CreationLimitExceededException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBudgetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBudgetOutputResponse()"}
}

extension CreateBudgetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of CreateBudget </p>
public struct CreateBudgetOutputResponse: Equatable {

    public init() {}
}

struct CreateBudgetOutputResponseBody: Equatable {
}

extension CreateBudgetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateNotificationInputBodyMiddleware: Middleware {
    public let id: String = "CreateNotificationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNotificationInput>
    public typealias MOutput = OperationOutput<CreateNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNotificationOutputError>
}

extension CreateNotificationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNotificationInput(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)), notification: \(String(describing: notification)), subscribers: \(String(describing: subscribers)))"}
}

extension CreateNotificationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
    }
}

public struct CreateNotificationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateNotificationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNotificationInput>
    public typealias MOutput = OperationOutput<CreateNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNotificationOutputError>
}

public struct CreateNotificationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateNotificationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNotificationInput>
    public typealias MOutput = OperationOutput<CreateNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNotificationOutputError>
}

/// <p> Request of CreateNotification </p>
public struct CreateNotificationInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to create a notification for.</p>
    public let accountId: String?
    /// <p>The name of the budget that you want AWS to notify you about. Budget names must be unique within an account.</p>
    public let budgetName: String?
    /// <p>The notification that you want to create.</p>
    public let notification: Notification?
    /// <p>A list of subscribers that you want to associate with the notification. Each notification can have one SNS subscriber and up to 10 email subscribers.</p>
    public let subscribers: [Subscriber]?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil,
        notification: Notification? = nil,
        subscribers: [Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscribers = subscribers
    }
}

struct CreateNotificationInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let notification: Notification?
    public let subscribers: [Subscriber]?
}

extension CreateNotificationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscribers = "Subscribers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension CreateNotificationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNotificationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreationLimitExceededException" : self = .creationLimitExceededException(try CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNotificationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case creationLimitExceededException(CreationLimitExceededException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNotificationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNotificationOutputResponse()"}
}

extension CreateNotificationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of CreateNotification </p>
public struct CreateNotificationOutputResponse: Equatable {

    public init() {}
}

struct CreateNotificationOutputResponseBody: Equatable {
}

extension CreateNotificationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateSubscriberInputBodyMiddleware: Middleware {
    public let id: String = "CreateSubscriberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubscriberInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubscriberInput>
    public typealias MOutput = OperationOutput<CreateSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubscriberOutputError>
}

extension CreateSubscriberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSubscriberInput(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)), notification: \(String(describing: notification)), subscriber: \(String(describing: subscriber)))"}
}

extension CreateSubscriberInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscriber = subscriber {
            try encodeContainer.encode(subscriber, forKey: .subscriber)
        }
    }
}

public struct CreateSubscriberInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSubscriberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubscriberInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubscriberInput>
    public typealias MOutput = OperationOutput<CreateSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubscriberOutputError>
}

public struct CreateSubscriberInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSubscriberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubscriberInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubscriberInput>
    public typealias MOutput = OperationOutput<CreateSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubscriberOutputError>
}

/// <p> Request of CreateSubscriber </p>
public struct CreateSubscriberInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to create a subscriber for.</p>
    public let accountId: String?
    /// <p>The name of the budget that you want to subscribe to. Budget names must be unique within an account.</p>
    public let budgetName: String?
    /// <p>The notification that you want to create a subscriber for.</p>
    public let notification: Notification?
    /// <p>The subscriber that you want to associate with a budget notification.</p>
    public let subscriber: Subscriber?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil,
        notification: Notification? = nil,
        subscriber: Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscriber = subscriber
    }
}

struct CreateSubscriberInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let notification: Notification?
    public let subscriber: Subscriber?
}

extension CreateSubscriberInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscriberDecoded = try containerValues.decodeIfPresent(Subscriber.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

extension CreateSubscriberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubscriberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreationLimitExceededException" : self = .creationLimitExceededException(try CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSubscriberOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case creationLimitExceededException(CreationLimitExceededException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubscriberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSubscriberOutputResponse()"}
}

extension CreateSubscriberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of CreateSubscriber </p>
public struct CreateSubscriberOutputResponse: Equatable {

    public init() {}
}

struct CreateSubscriberOutputResponseBody: Equatable {
}

extension CreateSubscriberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreationLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreationLimitExceededException(message: \(String(describing: message)))"}
}

extension CreationLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreationLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've exceeded the notification or subscriber limit.</p>
public struct CreationLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CreationLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension CreationLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Definition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iamActionDefinition = "IamActionDefinition"
        case scpActionDefinition = "ScpActionDefinition"
        case ssmActionDefinition = "SsmActionDefinition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamActionDefinition = iamActionDefinition {
            try encodeContainer.encode(iamActionDefinition, forKey: .iamActionDefinition)
        }
        if let scpActionDefinition = scpActionDefinition {
            try encodeContainer.encode(scpActionDefinition, forKey: .scpActionDefinition)
        }
        if let ssmActionDefinition = ssmActionDefinition {
            try encodeContainer.encode(ssmActionDefinition, forKey: .ssmActionDefinition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamActionDefinitionDecoded = try containerValues.decodeIfPresent(IamActionDefinition.self, forKey: .iamActionDefinition)
        iamActionDefinition = iamActionDefinitionDecoded
        let scpActionDefinitionDecoded = try containerValues.decodeIfPresent(ScpActionDefinition.self, forKey: .scpActionDefinition)
        scpActionDefinition = scpActionDefinitionDecoded
        let ssmActionDefinitionDecoded = try containerValues.decodeIfPresent(SsmActionDefinition.self, forKey: .ssmActionDefinition)
        ssmActionDefinition = ssmActionDefinitionDecoded
    }
}

extension Definition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Definition(iamActionDefinition: \(String(describing: iamActionDefinition)), scpActionDefinition: \(String(describing: scpActionDefinition)), ssmActionDefinition: \(String(describing: ssmActionDefinition)))"}
}

/// <p>
/// 			Specifies all of the type-specific parameters.
/// 		</p>
public struct Definition: Equatable {
    /// <p>
    /// 			The AWS Identity and Access Management (IAM) action definition details.
    /// 		</p>
    public let iamActionDefinition: IamActionDefinition?
    /// <p>
    /// 			The service control policies (SCPs) action definition details.
    /// 		</p>
    public let scpActionDefinition: ScpActionDefinition?
    /// <p>
    /// 			The AWS Systems Manager (SSM) action definition details.
    /// 		</p>
    public let ssmActionDefinition: SsmActionDefinition?

    public init (
        iamActionDefinition: IamActionDefinition? = nil,
        scpActionDefinition: ScpActionDefinition? = nil,
        ssmActionDefinition: SsmActionDefinition? = nil
    )
    {
        self.iamActionDefinition = iamActionDefinition
        self.scpActionDefinition = scpActionDefinition
        self.ssmActionDefinition = ssmActionDefinition
    }
}

public struct DeleteBudgetActionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBudgetActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBudgetActionInput>
    public typealias MOutput = OperationOutput<DeleteBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBudgetActionOutputError>
}

extension DeleteBudgetActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBudgetActionInput(accountId: \(String(describing: accountId)), actionId: \(String(describing: actionId)), budgetName: \(String(describing: budgetName)))"}
}

extension DeleteBudgetActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

public struct DeleteBudgetActionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBudgetActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBudgetActionInput>
    public typealias MOutput = OperationOutput<DeleteBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBudgetActionOutputError>
}

public struct DeleteBudgetActionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBudgetActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBudgetActionInput>
    public typealias MOutput = OperationOutput<DeleteBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBudgetActionOutputError>
}

public struct DeleteBudgetActionInput: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?

    public init (
        accountId: String? = nil,
        actionId: String? = nil,
        budgetName: String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

struct DeleteBudgetActionInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let actionId: String?
}

extension DeleteBudgetActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

extension DeleteBudgetActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBudgetActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLockedException" : self = .resourceLockedException(try ResourceLockedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBudgetActionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case resourceLockedException(ResourceLockedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBudgetActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBudgetActionOutputResponse(accountId: \(String(describing: accountId)), action: \(String(describing: action)), budgetName: \(String(describing: budgetName)))"}
}

extension DeleteBudgetActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountId = output.accountId
            self.action = output.action
            self.budgetName = output.budgetName
        } else {
            self.accountId = nil
            self.action = nil
            self.budgetName = nil
        }
    }
}

public struct DeleteBudgetActionOutputResponse: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p>
    /// 			A budget action resource.
    /// 		</p>
    public let action: Action?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?

    public init (
        accountId: String? = nil,
        action: Action? = nil,
        budgetName: String? = nil
    )
    {
        self.accountId = accountId
        self.action = action
        self.budgetName = budgetName
    }
}

struct DeleteBudgetActionOutputResponseBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let action: Action?
}

extension DeleteBudgetActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case action = "Action"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
    }
}

public struct DeleteBudgetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBudgetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBudgetInput>
    public typealias MOutput = OperationOutput<DeleteBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBudgetOutputError>
}

extension DeleteBudgetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBudgetInput(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)))"}
}

extension DeleteBudgetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

public struct DeleteBudgetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBudgetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBudgetInput>
    public typealias MOutput = OperationOutput<DeleteBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBudgetOutputError>
}

public struct DeleteBudgetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBudgetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBudgetInput>
    public typealias MOutput = OperationOutput<DeleteBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBudgetOutputError>
}

/// <p> Request of DeleteBudget </p>
public struct DeleteBudgetInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to delete.</p>
    public let accountId: String?
    /// <p>The name of the budget that you want to delete.</p>
    public let budgetName: String?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
    }
}

struct DeleteBudgetInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
}

extension DeleteBudgetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension DeleteBudgetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBudgetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBudgetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBudgetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBudgetOutputResponse()"}
}

extension DeleteBudgetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of DeleteBudget </p>
public struct DeleteBudgetOutputResponse: Equatable {

    public init() {}
}

struct DeleteBudgetOutputResponseBody: Equatable {
}

extension DeleteBudgetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteNotificationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteNotificationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNotificationInput>
    public typealias MOutput = OperationOutput<DeleteNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNotificationOutputError>
}

extension DeleteNotificationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNotificationInput(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)), notification: \(String(describing: notification)))"}
}

extension DeleteNotificationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
    }
}

public struct DeleteNotificationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteNotificationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNotificationInput>
    public typealias MOutput = OperationOutput<DeleteNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNotificationOutputError>
}

public struct DeleteNotificationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteNotificationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNotificationInput>
    public typealias MOutput = OperationOutput<DeleteNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNotificationOutputError>
}

/// <p> Request of DeleteNotification </p>
public struct DeleteNotificationInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget whose notification you want to delete.</p>
    public let accountId: String?
    /// <p>The name of the budget whose notification you want to delete.</p>
    public let budgetName: String?
    /// <p>The notification that you want to delete.</p>
    public let notification: Notification?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil,
        notification: Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
    }
}

struct DeleteNotificationInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let notification: Notification?
}

extension DeleteNotificationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
    }
}

extension DeleteNotificationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNotificationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNotificationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNotificationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNotificationOutputResponse()"}
}

extension DeleteNotificationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of DeleteNotification </p>
public struct DeleteNotificationOutputResponse: Equatable {

    public init() {}
}

struct DeleteNotificationOutputResponseBody: Equatable {
}

extension DeleteNotificationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSubscriberInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSubscriberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSubscriberInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSubscriberInput>
    public typealias MOutput = OperationOutput<DeleteSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSubscriberOutputError>
}

extension DeleteSubscriberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSubscriberInput(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)), notification: \(String(describing: notification)), subscriber: \(String(describing: subscriber)))"}
}

extension DeleteSubscriberInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscriber = subscriber {
            try encodeContainer.encode(subscriber, forKey: .subscriber)
        }
    }
}

public struct DeleteSubscriberInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSubscriberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSubscriberInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSubscriberInput>
    public typealias MOutput = OperationOutput<DeleteSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSubscriberOutputError>
}

public struct DeleteSubscriberInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSubscriberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSubscriberInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSubscriberInput>
    public typealias MOutput = OperationOutput<DeleteSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSubscriberOutputError>
}

/// <p> Request of DeleteSubscriber </p>
public struct DeleteSubscriberInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget whose subscriber you want to delete.</p>
    public let accountId: String?
    /// <p>The name of the budget whose subscriber you want to delete.</p>
    public let budgetName: String?
    /// <p>The notification whose subscriber you want to delete.</p>
    public let notification: Notification?
    /// <p>The subscriber that you want to delete.</p>
    public let subscriber: Subscriber?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil,
        notification: Notification? = nil,
        subscriber: Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscriber = subscriber
    }
}

struct DeleteSubscriberInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let notification: Notification?
    public let subscriber: Subscriber?
}

extension DeleteSubscriberInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscriberDecoded = try containerValues.decodeIfPresent(Subscriber.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

extension DeleteSubscriberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubscriberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSubscriberOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubscriberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSubscriberOutputResponse()"}
}

extension DeleteSubscriberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of DeleteSubscriber </p>
public struct DeleteSubscriberOutputResponse: Equatable {

    public init() {}
}

struct DeleteSubscriberOutputResponseBody: Equatable {
}

extension DeleteSubscriberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeBudgetActionHistoriesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBudgetActionHistoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetActionHistoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetActionHistoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetActionHistoriesInput>
    public typealias MOutput = OperationOutput<DescribeBudgetActionHistoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetActionHistoriesOutputError>
}

extension DescribeBudgetActionHistoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetActionHistoriesInput(accountId: \(String(describing: accountId)), actionId: \(String(describing: actionId)), budgetName: \(String(describing: budgetName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), timePeriod: \(String(describing: timePeriod)))"}
}

extension DescribeBudgetActionHistoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct DescribeBudgetActionHistoriesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBudgetActionHistoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetActionHistoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetActionHistoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetActionHistoriesInput>
    public typealias MOutput = OperationOutput<DescribeBudgetActionHistoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetActionHistoriesOutputError>
}

public struct DescribeBudgetActionHistoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBudgetActionHistoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetActionHistoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetActionHistoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetActionHistoriesInput>
    public typealias MOutput = OperationOutput<DescribeBudgetActionHistoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetActionHistoriesOutputError>
}

public struct DescribeBudgetActionHistoriesInput: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Int?
    /// <p> A generic string.</p>
    public let nextToken: String?
    /// <p>The period of time that is covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date. </p>
    public let timePeriod: TimePeriod?

    public init (
        accountId: String? = nil,
        actionId: String? = nil,
        budgetName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        timePeriod: TimePeriod? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timePeriod = timePeriod
    }
}

struct DescribeBudgetActionHistoriesInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let actionId: String?
    public let timePeriod: TimePeriod?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeBudgetActionHistoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionHistoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetActionHistoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetActionHistoriesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetActionHistoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetActionHistoriesOutputResponse(actionHistories: \(String(describing: actionHistories)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBudgetActionHistoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBudgetActionHistoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actionHistories = output.actionHistories
            self.nextToken = output.nextToken
        } else {
            self.actionHistories = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetActionHistoriesOutputResponse: Equatable {
    /// <p>
    ///          The historical record of the budget action resource.
    ///       </p>
    public let actionHistories: [ActionHistory]?
    /// <p> A generic string.</p>
    public let nextToken: String?

    public init (
        actionHistories: [ActionHistory]? = nil,
        nextToken: String? = nil
    )
    {
        self.actionHistories = actionHistories
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionHistoriesOutputResponseBody: Equatable {
    public let actionHistories: [ActionHistory]?
    public let nextToken: String?
}

extension DescribeBudgetActionHistoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionHistories = "ActionHistories"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionHistoriesContainer = try containerValues.decodeIfPresent([ActionHistory?].self, forKey: .actionHistories)
        var actionHistoriesDecoded0:[ActionHistory]? = nil
        if let actionHistoriesContainer = actionHistoriesContainer {
            actionHistoriesDecoded0 = [ActionHistory]()
            for structure0 in actionHistoriesContainer {
                if let structure0 = structure0 {
                    actionHistoriesDecoded0?.append(structure0)
                }
            }
        }
        actionHistories = actionHistoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeBudgetActionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBudgetActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetActionInput>
    public typealias MOutput = OperationOutput<DescribeBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetActionOutputError>
}

extension DescribeBudgetActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetActionInput(accountId: \(String(describing: accountId)), actionId: \(String(describing: actionId)), budgetName: \(String(describing: budgetName)))"}
}

extension DescribeBudgetActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

public struct DescribeBudgetActionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBudgetActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetActionInput>
    public typealias MOutput = OperationOutput<DescribeBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetActionOutputError>
}

public struct DescribeBudgetActionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBudgetActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetActionInput>
    public typealias MOutput = OperationOutput<DescribeBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetActionOutputError>
}

public struct DescribeBudgetActionInput: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?

    public init (
        accountId: String? = nil,
        actionId: String? = nil,
        budgetName: String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

struct DescribeBudgetActionInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let actionId: String?
}

extension DescribeBudgetActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

extension DescribeBudgetActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetActionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetActionOutputResponse(accountId: \(String(describing: accountId)), action: \(String(describing: action)), budgetName: \(String(describing: budgetName)))"}
}

extension DescribeBudgetActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountId = output.accountId
            self.action = output.action
            self.budgetName = output.budgetName
        } else {
            self.accountId = nil
            self.action = nil
            self.budgetName = nil
        }
    }
}

public struct DescribeBudgetActionOutputResponse: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p>
    ///          A budget action resource.
    ///       </p>
    public let action: Action?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?

    public init (
        accountId: String? = nil,
        action: Action? = nil,
        budgetName: String? = nil
    )
    {
        self.accountId = accountId
        self.action = action
        self.budgetName = budgetName
    }
}

struct DescribeBudgetActionOutputResponseBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let action: Action?
}

extension DescribeBudgetActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case action = "Action"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
    }
}

public struct DescribeBudgetActionsForAccountInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBudgetActionsForAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetActionsForAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetActionsForAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetActionsForAccountInput>
    public typealias MOutput = OperationOutput<DescribeBudgetActionsForAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetActionsForAccountOutputError>
}

extension DescribeBudgetActionsForAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetActionsForAccountInput(accountId: \(String(describing: accountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBudgetActionsForAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeBudgetActionsForAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBudgetActionsForAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetActionsForAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetActionsForAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetActionsForAccountInput>
    public typealias MOutput = OperationOutput<DescribeBudgetActionsForAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetActionsForAccountOutputError>
}

public struct DescribeBudgetActionsForAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBudgetActionsForAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetActionsForAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetActionsForAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetActionsForAccountInput>
    public typealias MOutput = OperationOutput<DescribeBudgetActionsForAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetActionsForAccountOutputError>
}

public struct DescribeBudgetActionsForAccountInput: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Int?
    /// <p> A generic string.</p>
    public let nextToken: String?

    public init (
        accountId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForAccountInputBody: Equatable {
    public let accountId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeBudgetActionsForAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionsForAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetActionsForAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetActionsForAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetActionsForAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetActionsForAccountOutputResponse(actions: \(String(describing: actions)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBudgetActionsForAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBudgetActionsForAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetActionsForAccountOutputResponse: Equatable {
    /// <p>
    ///          A list of the budget action resources information.
    ///       </p>
    public let actions: [Action]?
    /// <p> A generic string.</p>
    public let nextToken: String?

    public init (
        actions: [Action]? = nil,
        nextToken: String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForAccountOutputResponseBody: Equatable {
    public let actions: [Action]?
    public let nextToken: String?
}

extension DescribeBudgetActionsForAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeBudgetActionsForBudgetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBudgetActionsForBudgetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetActionsForBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetActionsForBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetActionsForBudgetInput>
    public typealias MOutput = OperationOutput<DescribeBudgetActionsForBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetActionsForBudgetOutputError>
}

extension DescribeBudgetActionsForBudgetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetActionsForBudgetInput(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBudgetActionsForBudgetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeBudgetActionsForBudgetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBudgetActionsForBudgetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetActionsForBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetActionsForBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetActionsForBudgetInput>
    public typealias MOutput = OperationOutput<DescribeBudgetActionsForBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetActionsForBudgetOutputError>
}

public struct DescribeBudgetActionsForBudgetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBudgetActionsForBudgetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetActionsForBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetActionsForBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetActionsForBudgetInput>
    public typealias MOutput = OperationOutput<DescribeBudgetActionsForBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetActionsForBudgetOutputError>
}

public struct DescribeBudgetActionsForBudgetInput: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Int?
    /// <p> A generic string.</p>
    public let nextToken: String?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForBudgetInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeBudgetActionsForBudgetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionsForBudgetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetActionsForBudgetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetActionsForBudgetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetActionsForBudgetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetActionsForBudgetOutputResponse(actions: \(String(describing: actions)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBudgetActionsForBudgetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBudgetActionsForBudgetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetActionsForBudgetOutputResponse: Equatable {
    /// <p>
    ///          A list of the budget action resources information.
    ///       </p>
    public let actions: [Action]?
    /// <p> A generic string.</p>
    public let nextToken: String?

    public init (
        actions: [Action]? = nil,
        nextToken: String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForBudgetOutputResponseBody: Equatable {
    public let actions: [Action]?
    public let nextToken: String?
}

extension DescribeBudgetActionsForBudgetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeBudgetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBudgetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetInput>
    public typealias MOutput = OperationOutput<DescribeBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetOutputError>
}

extension DescribeBudgetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetInput(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)))"}
}

extension DescribeBudgetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

public struct DescribeBudgetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBudgetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetInput>
    public typealias MOutput = OperationOutput<DescribeBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetOutputError>
}

public struct DescribeBudgetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBudgetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetInput>
    public typealias MOutput = OperationOutput<DescribeBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetOutputError>
}

/// <p> Request of DescribeBudget </p>
public struct DescribeBudgetInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget that you want a description of.</p>
    public let accountId: String?
    /// <p>The name of the budget that you want a description of.</p>
    public let budgetName: String?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
    }
}

struct DescribeBudgetInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
}

extension DescribeBudgetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension DescribeBudgetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetOutputResponse(budget: \(String(describing: budget)))"}
}

extension DescribeBudgetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBudgetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.budget = output.budget
        } else {
            self.budget = nil
        }
    }
}

/// <p> Response of DescribeBudget </p>
public struct DescribeBudgetOutputResponse: Equatable {
    /// <p>The description of the budget.</p>
    public let budget: Budget?

    public init (
        budget: Budget? = nil
    )
    {
        self.budget = budget
    }
}

struct DescribeBudgetOutputResponseBody: Equatable {
    public let budget: Budget?
}

extension DescribeBudgetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case budget = "Budget"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetDecoded = try containerValues.decodeIfPresent(Budget.self, forKey: .budget)
        budget = budgetDecoded
    }
}

public struct DescribeBudgetPerformanceHistoryInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBudgetPerformanceHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetPerformanceHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetPerformanceHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetPerformanceHistoryInput>
    public typealias MOutput = OperationOutput<DescribeBudgetPerformanceHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetPerformanceHistoryOutputError>
}

extension DescribeBudgetPerformanceHistoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetPerformanceHistoryInput(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), timePeriod: \(String(describing: timePeriod)))"}
}

extension DescribeBudgetPerformanceHistoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct DescribeBudgetPerformanceHistoryInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBudgetPerformanceHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetPerformanceHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetPerformanceHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetPerformanceHistoryInput>
    public typealias MOutput = OperationOutput<DescribeBudgetPerformanceHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetPerformanceHistoryOutputError>
}

public struct DescribeBudgetPerformanceHistoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBudgetPerformanceHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetPerformanceHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetPerformanceHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetPerformanceHistoryInput>
    public typealias MOutput = OperationOutput<DescribeBudgetPerformanceHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetPerformanceHistoryOutputError>
}

public struct DescribeBudgetPerformanceHistoryInput: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Int?
    /// <p> A generic string.</p>
    public let nextToken: String?
    /// <p>Retrieves how often the budget went into an <code>ALARM</code> state for the specified time period.</p>
    public let timePeriod: TimePeriod?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        timePeriod: TimePeriod? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timePeriod = timePeriod
    }
}

struct DescribeBudgetPerformanceHistoryInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let timePeriod: TimePeriod?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeBudgetPerformanceHistoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetPerformanceHistoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetPerformanceHistoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetPerformanceHistoryOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetPerformanceHistoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetPerformanceHistoryOutputResponse(budgetPerformanceHistory: \(String(describing: budgetPerformanceHistory)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBudgetPerformanceHistoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBudgetPerformanceHistoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.budgetPerformanceHistory = output.budgetPerformanceHistory
            self.nextToken = output.nextToken
        } else {
            self.budgetPerformanceHistory = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetPerformanceHistoryOutputResponse: Equatable {
    /// <p>The history of how often the budget has gone into an <code>ALARM</code> state.</p>
    ///          <p>For <code>DAILY</code> budgets, the history saves the state of the budget for the last 60 days. For <code>MONTHLY</code> budgets, the history saves the state of the budget for the current month plus the last 12 months. For <code>QUARTERLY</code> budgets, the history saves the state of the budget for the last four quarters.</p>
    public let budgetPerformanceHistory: BudgetPerformanceHistory?
    /// <p> A generic string.</p>
    public let nextToken: String?

    public init (
        budgetPerformanceHistory: BudgetPerformanceHistory? = nil,
        nextToken: String? = nil
    )
    {
        self.budgetPerformanceHistory = budgetPerformanceHistory
        self.nextToken = nextToken
    }
}

struct DescribeBudgetPerformanceHistoryOutputResponseBody: Equatable {
    public let budgetPerformanceHistory: BudgetPerformanceHistory?
    public let nextToken: String?
}

extension DescribeBudgetPerformanceHistoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case budgetPerformanceHistory = "BudgetPerformanceHistory"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetPerformanceHistoryDecoded = try containerValues.decodeIfPresent(BudgetPerformanceHistory.self, forKey: .budgetPerformanceHistory)
        budgetPerformanceHistory = budgetPerformanceHistoryDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeBudgetsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBudgetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetsInput>
    public typealias MOutput = OperationOutput<DescribeBudgetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetsOutputError>
}

extension DescribeBudgetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetsInput(accountId: \(String(describing: accountId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBudgetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeBudgetsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBudgetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetsInput>
    public typealias MOutput = OperationOutput<DescribeBudgetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetsOutputError>
}

public struct DescribeBudgetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBudgetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBudgetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBudgetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBudgetsInput>
    public typealias MOutput = OperationOutput<DescribeBudgetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBudgetsOutputError>
}

/// <p> Request of DescribeBudgets </p>
public struct DescribeBudgetsInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budgets that you want descriptions of.</p>
    public let accountId: String?
    /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Int?
    /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
    public let nextToken: String?

    public init (
        accountId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetsInputBody: Equatable {
    public let accountId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeBudgetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBudgetsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBudgetsOutputResponse(budgets: \(String(describing: budgets)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBudgetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBudgetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.budgets = output.budgets
            self.nextToken = output.nextToken
        } else {
            self.budgets = nil
            self.nextToken = nil
        }
    }
}

/// <p> Response of DescribeBudgets </p>
public struct DescribeBudgetsOutputResponse: Equatable {
    /// <p>A list of budgets.</p>
    public let budgets: [Budget]?
    /// <p>The pagination token in the service response that indicates the next set of results that you can retrieve.</p>
    public let nextToken: String?

    public init (
        budgets: [Budget]? = nil,
        nextToken: String? = nil
    )
    {
        self.budgets = budgets
        self.nextToken = nextToken
    }
}

struct DescribeBudgetsOutputResponseBody: Equatable {
    public let budgets: [Budget]?
    public let nextToken: String?
}

extension DescribeBudgetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case budgets = "Budgets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetsContainer = try containerValues.decodeIfPresent([Budget?].self, forKey: .budgets)
        var budgetsDecoded0:[Budget]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [Budget]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeNotificationsForBudgetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeNotificationsForBudgetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNotificationsForBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNotificationsForBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNotificationsForBudgetInput>
    public typealias MOutput = OperationOutput<DescribeNotificationsForBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNotificationsForBudgetOutputError>
}

extension DescribeNotificationsForBudgetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNotificationsForBudgetInput(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeNotificationsForBudgetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeNotificationsForBudgetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeNotificationsForBudgetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNotificationsForBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNotificationsForBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNotificationsForBudgetInput>
    public typealias MOutput = OperationOutput<DescribeNotificationsForBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNotificationsForBudgetOutputError>
}

public struct DescribeNotificationsForBudgetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeNotificationsForBudgetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNotificationsForBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNotificationsForBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNotificationsForBudgetInput>
    public typealias MOutput = OperationOutput<DescribeNotificationsForBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNotificationsForBudgetOutputError>
}

/// <p> Request of DescribeNotificationsForBudget </p>
public struct DescribeNotificationsForBudgetInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget whose notifications you want descriptions of.</p>
    public let accountId: String?
    /// <p>The name of the budget whose notifications you want descriptions of.</p>
    public let budgetName: String?
    /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Int?
    /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
    public let nextToken: String?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeNotificationsForBudgetInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeNotificationsForBudgetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeNotificationsForBudgetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNotificationsForBudgetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNotificationsForBudgetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNotificationsForBudgetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNotificationsForBudgetOutputResponse(nextToken: \(String(describing: nextToken)), notifications: \(String(describing: notifications)))"}
}

extension DescribeNotificationsForBudgetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeNotificationsForBudgetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.notifications = output.notifications
        } else {
            self.nextToken = nil
            self.notifications = nil
        }
    }
}

/// <p> Response of GetNotificationsForBudget </p>
public struct DescribeNotificationsForBudgetOutputResponse: Equatable {
    /// <p>The pagination token in the service response that indicates the next set of results that you can retrieve.</p>
    public let nextToken: String?
    /// <p>A list of notifications that are associated with a budget.</p>
    public let notifications: [Notification]?

    public init (
        nextToken: String? = nil,
        notifications: [Notification]? = nil
    )
    {
        self.nextToken = nextToken
        self.notifications = notifications
    }
}

struct DescribeNotificationsForBudgetOutputResponseBody: Equatable {
    public let notifications: [Notification]?
    public let nextToken: String?
}

extension DescribeNotificationsForBudgetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case notifications = "Notifications"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationsContainer = try containerValues.decodeIfPresent([Notification?].self, forKey: .notifications)
        var notificationsDecoded0:[Notification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [Notification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeSubscribersForNotificationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSubscribersForNotificationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSubscribersForNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSubscribersForNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSubscribersForNotificationInput>
    public typealias MOutput = OperationOutput<DescribeSubscribersForNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSubscribersForNotificationOutputError>
}

extension DescribeSubscribersForNotificationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSubscribersForNotificationInput(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), notification: \(String(describing: notification)))"}
}

extension DescribeSubscribersForNotificationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case notification = "Notification"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
    }
}

public struct DescribeSubscribersForNotificationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSubscribersForNotificationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSubscribersForNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSubscribersForNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSubscribersForNotificationInput>
    public typealias MOutput = OperationOutput<DescribeSubscribersForNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSubscribersForNotificationOutputError>
}

public struct DescribeSubscribersForNotificationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSubscribersForNotificationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSubscribersForNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSubscribersForNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSubscribersForNotificationInput>
    public typealias MOutput = OperationOutput<DescribeSubscribersForNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSubscribersForNotificationOutputError>
}

/// <p> Request of DescribeSubscribersForNotification </p>
public struct DescribeSubscribersForNotificationInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget whose subscribers you want descriptions of.</p>
    public let accountId: String?
    /// <p>The name of the budget whose subscribers you want descriptions of.</p>
    public let budgetName: String?
    /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    public let maxResults: Int?
    /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
    public let nextToken: String?
    /// <p>The notification whose subscribers you want to list.</p>
    public let notification: Notification?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        notification: Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notification = notification
    }
}

struct DescribeSubscribersForNotificationInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let notification: Notification?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeSubscribersForNotificationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case notification = "Notification"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSubscribersForNotificationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSubscribersForNotificationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSubscribersForNotificationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSubscribersForNotificationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSubscribersForNotificationOutputResponse(nextToken: \(String(describing: nextToken)), subscribers: \(String(describing: subscribers)))"}
}

extension DescribeSubscribersForNotificationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSubscribersForNotificationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.subscribers = output.subscribers
        } else {
            self.nextToken = nil
            self.subscribers = nil
        }
    }
}

/// <p> Response of DescribeSubscribersForNotification </p>
public struct DescribeSubscribersForNotificationOutputResponse: Equatable {
    /// <p>The pagination token in the service response that indicates the next set of results that you can retrieve.</p>
    public let nextToken: String?
    /// <p>A list of subscribers that are associated with a notification.</p>
    public let subscribers: [Subscriber]?

    public init (
        nextToken: String? = nil,
        subscribers: [Subscriber]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscribers = subscribers
    }
}

struct DescribeSubscribersForNotificationOutputResponseBody: Equatable {
    public let subscribers: [Subscriber]?
    public let nextToken: String?
}

extension DescribeSubscribersForNotificationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case subscribers = "Subscribers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscribersContainer = try containerValues.decodeIfPresent([Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DuplicateRecordException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateRecordException(message: \(String(describing: message)))"}
}

extension DuplicateRecordException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DuplicateRecordExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The budget name already exists. Budget names must be unique within an account.</p>
public struct DuplicateRecordException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateRecordExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateRecordExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum EventType {
    case createaction
    case deleteaction
    case executeaction
    case system
    case updateaction
    case sdkUnknown(String)
}

extension EventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventType] {
        return [
            .createaction,
            .deleteaction,
            .executeaction,
            .system,
            .updateaction,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createaction: return "CREATE_ACTION"
        case .deleteaction: return "DELETE_ACTION"
        case .executeaction: return "EXECUTE_ACTION"
        case .system: return "SYSTEM"
        case .updateaction: return "UPDATE_ACTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
    }
}

public struct ExecuteBudgetActionInputBodyMiddleware: Middleware {
    public let id: String = "ExecuteBudgetActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteBudgetActionInput>
    public typealias MOutput = OperationOutput<ExecuteBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteBudgetActionOutputError>
}

extension ExecuteBudgetActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteBudgetActionInput(accountId: \(String(describing: accountId)), actionId: \(String(describing: actionId)), budgetName: \(String(describing: budgetName)), executionType: \(String(describing: executionType)))"}
}

extension ExecuteBudgetActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case executionType = "ExecutionType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let executionType = executionType {
            try encodeContainer.encode(executionType.rawValue, forKey: .executionType)
        }
    }
}

public struct ExecuteBudgetActionInputHeadersMiddleware: Middleware {
    public let id: String = "ExecuteBudgetActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteBudgetActionInput>
    public typealias MOutput = OperationOutput<ExecuteBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteBudgetActionOutputError>
}

public struct ExecuteBudgetActionInputQueryItemMiddleware: Middleware {
    public let id: String = "ExecuteBudgetActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExecuteBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<ExecuteBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExecuteBudgetActionInput>
    public typealias MOutput = OperationOutput<ExecuteBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExecuteBudgetActionOutputError>
}

public struct ExecuteBudgetActionInput: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?
    /// <p>
    ///          The type of execution.
    ///       </p>
    public let executionType: ExecutionType?

    public init (
        accountId: String? = nil,
        actionId: String? = nil,
        budgetName: String? = nil,
        executionType: ExecutionType? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.executionType = executionType
    }
}

struct ExecuteBudgetActionInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let actionId: String?
    public let executionType: ExecutionType?
}

extension ExecuteBudgetActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case executionType = "ExecutionType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(ExecutionType.self, forKey: .executionType)
        executionType = executionTypeDecoded
    }
}

extension ExecuteBudgetActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteBudgetActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLockedException" : self = .resourceLockedException(try ResourceLockedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteBudgetActionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case resourceLockedException(ResourceLockedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteBudgetActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecuteBudgetActionOutputResponse(accountId: \(String(describing: accountId)), actionId: \(String(describing: actionId)), budgetName: \(String(describing: budgetName)), executionType: \(String(describing: executionType)))"}
}

extension ExecuteBudgetActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExecuteBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountId = output.accountId
            self.actionId = output.actionId
            self.budgetName = output.budgetName
            self.executionType = output.executionType
        } else {
            self.accountId = nil
            self.actionId = nil
            self.budgetName = nil
            self.executionType = nil
        }
    }
}

public struct ExecuteBudgetActionOutputResponse: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?
    /// <p>
    ///          The type of execution.
    ///       </p>
    public let executionType: ExecutionType?

    public init (
        accountId: String? = nil,
        actionId: String? = nil,
        budgetName: String? = nil,
        executionType: ExecutionType? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.executionType = executionType
    }
}

struct ExecuteBudgetActionOutputResponseBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let actionId: String?
    public let executionType: ExecutionType?
}

extension ExecuteBudgetActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case executionType = "ExecutionType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(ExecutionType.self, forKey: .executionType)
        executionType = executionTypeDecoded
    }
}

public enum ExecutionType {
    case approvebudgetaction
    case resetbudgetaction
    case retrybudgetaction
    case reversebudgetaction
    case sdkUnknown(String)
}

extension ExecutionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExecutionType] {
        return [
            .approvebudgetaction,
            .resetbudgetaction,
            .retrybudgetaction,
            .reversebudgetaction,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approvebudgetaction: return "APPROVE_BUDGET_ACTION"
        case .resetbudgetaction: return "RESET_BUDGET_ACTION"
        case .retrybudgetaction: return "RETRY_BUDGET_ACTION"
        case .reversebudgetaction: return "REVERSE_BUDGET_ACTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExecutionType(rawValue: rawValue) ?? ExecutionType.sdkUnknown(rawValue)
    }
}

extension ExpiredNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpiredNextTokenException(message: \(String(describing: message)))"}
}

extension ExpiredNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExpiredNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pagination token expired.</p>
public struct ExpiredNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension ExpiredNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IamActionDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case policyArn = "PolicyArn"
        case roles = "Roles"
        case users = "Users"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for groups0 in groups {
                try groupsContainer.encode(groups0)
            }
        }
        if let policyArn = policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for roles0 in roles {
                try rolesContainer.encode(roles0)
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for users0 in users {
                try usersContainer.encode(users0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let rolesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .roles)
        var rolesDecoded0:[String]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [String]()
            for string0 in rolesContainer {
                if let string0 = string0 {
                    rolesDecoded0?.append(string0)
                }
            }
        }
        roles = rolesDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .groups)
        var groupsDecoded0:[String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .users)
        var usersDecoded0:[String]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [String]()
            for string0 in usersContainer {
                if let string0 = string0 {
                    usersDecoded0?.append(string0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension IamActionDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IamActionDefinition(groups: \(String(describing: groups)), policyArn: \(String(describing: policyArn)), roles: \(String(describing: roles)), users: \(String(describing: users)))"}
}

/// <p>
/// 			The AWS Identity and Access Management (IAM) action definition details.
/// 		</p>
public struct IamActionDefinition: Equatable {
    /// <p>
    /// 			A list of groups to be attached. There must be at least one group.
    /// 		</p>
    public let groups: [String]?
    /// <p>
    /// 			The Amazon Resource Name (ARN) of the policy to be attached.
    /// 		</p>
    public let policyArn: String?
    /// <p>
    /// 			A list of roles to be attached. There must be at least one role.
    /// 		</p>
    public let roles: [String]?
    /// <p>
    /// 			A list of users to be attached. There must be at least one user.
    /// 		</p>
    public let users: [String]?

    public init (
        groups: [String]? = nil,
        policyArn: String? = nil,
        roles: [String]? = nil,
        users: [String]? = nil
    )
    {
        self.groups = groups
        self.policyArn = policyArn
        self.roles = roles
        self.users = users
    }
}

extension InternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalErrorException(message: \(String(describing: message)))"}
}

extension InternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error on the server occurred during the processing of your request. Try again later.</p>
public struct InternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The error message the exception carries.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pagination token is invalid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error on the client occurred. Typically, the cause is an invalid input value.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We can’t locate the resource that you specified.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Notification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case notificationState = "NotificationState"
        case notificationType = "NotificationType"
        case threshold = "Threshold"
        case thresholdType = "ThresholdType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let notificationState = notificationState {
            try encodeContainer.encode(notificationState.rawValue, forKey: .notificationState)
        }
        if let notificationType = notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if threshold != 0.0 {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let thresholdType = thresholdType {
            try encodeContainer.encode(thresholdType.rawValue, forKey: .thresholdType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationTypeDecoded = try containerValues.decodeIfPresent(NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let thresholdDecoded = try containerValues.decode(Double.self, forKey: .threshold)
        threshold = thresholdDecoded
        let thresholdTypeDecoded = try containerValues.decodeIfPresent(ThresholdType.self, forKey: .thresholdType)
        thresholdType = thresholdTypeDecoded
        let notificationStateDecoded = try containerValues.decodeIfPresent(NotificationState.self, forKey: .notificationState)
        notificationState = notificationStateDecoded
    }
}

extension Notification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Notification(comparisonOperator: \(String(describing: comparisonOperator)), notificationState: \(String(describing: notificationState)), notificationType: \(String(describing: notificationType)), threshold: \(String(describing: threshold)), thresholdType: \(String(describing: thresholdType)))"}
}

/// <p>A notification that is associated with a budget. A budget can have up to ten notifications. </p>
/// 		       <p>Each notification must have at least one subscriber. A notification can have one SNS subscriber and up to 10 email subscribers, for a total of 11 subscribers.</p>
/// 		       <p>For example, if you have a budget for 200 dollars and you want to be notified when you go over 160 dollars, create a notification with the following parameters:</p>
/// 		       <ul>
///             <li>
/// 				           <p>A notificationType of <code>ACTUAL</code>
///                </p>
/// 			         </li>
///             <li>
/// 				           <p>A <code>thresholdType</code> of <code>PERCENTAGE</code>
///                </p>
/// 			         </li>
///             <li>
/// 				           <p>A <code>comparisonOperator</code> of <code>GREATER_THAN</code>
///                </p>
/// 			         </li>
///             <li>
/// 				           <p>A notification <code>threshold</code> of <code>80</code>
///                </p>
/// 			         </li>
///          </ul>
public struct Notification: Equatable {
    /// <p>The comparison that is used for this notification.</p>
    public let comparisonOperator: ComparisonOperator?
    /// <p>Whether this notification is in alarm. If a budget notification is in the <code>ALARM</code> state, you have passed the set threshold for the budget.</p>
    public let notificationState: NotificationState?
    /// <p>Whether the notification is for how much you have spent (<code>ACTUAL</code>) or for how much you're forecasted to spend (<code>FORECASTED</code>).</p>
    public let notificationType: NotificationType?
    /// <p>The threshold that is associated with a notification. Thresholds are always a percentage, and many customers find value being alerted between 50% - 200% of the budgeted amount. The maximum limit for your threshold is 1,000,000% above the budgeted amount.</p>
    public let threshold: Double
    /// <p>The type of threshold for a notification. For <code>ABSOLUTE_VALUE</code> thresholds, AWS notifies you when you go over or are forecasted to go over your total cost threshold. For <code>PERCENTAGE</code> thresholds, AWS notifies you when you go over or are forecasted to go over a certain percentage of your forecasted spend. For example, if you have a budget for 200 dollars and you have a <code>PERCENTAGE</code> threshold of 80%, AWS notifies you when you go over 160 dollars.</p>
    public let thresholdType: ThresholdType?

    public init (
        comparisonOperator: ComparisonOperator? = nil,
        notificationState: NotificationState? = nil,
        notificationType: NotificationType? = nil,
        threshold: Double = 0.0,
        thresholdType: ThresholdType? = nil
    )
    {
        self.comparisonOperator = comparisonOperator
        self.notificationState = notificationState
        self.notificationType = notificationType
        self.threshold = threshold
        self.thresholdType = thresholdType
    }
}

public enum NotificationState {
    case alarm
    case ok
    case sdkUnknown(String)
}

extension NotificationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NotificationState] {
        return [
            .alarm,
            .ok,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alarm: return "ALARM"
        case .ok: return "OK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NotificationState(rawValue: rawValue) ?? NotificationState.sdkUnknown(rawValue)
    }
}

/// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
public enum NotificationType {
    case actual
    case forecasted
    case sdkUnknown(String)
}

extension NotificationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NotificationType] {
        return [
            .actual,
            .forecasted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .actual: return "ACTUAL"
        case .forecasted: return "FORECASTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
    }
}

extension NotificationWithSubscribers: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case notification = "Notification"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension NotificationWithSubscribers: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationWithSubscribers(notification: \(String(describing: notification)), subscribers: \(String(describing: subscribers)))"}
}

/// <p>A notification with subscribers. A notification can have one SNS subscriber and up to 10 email subscribers, for a total of 11 subscribers.</p>
public struct NotificationWithSubscribers: Equatable {
    /// <p>The notification that is associated with a budget.</p>
    public let notification: Notification?
    /// <p>A list of subscribers who are subscribed to this notification.</p>
    public let subscribers: [Subscriber]?

    public init (
        notification: Notification? = nil,
        subscribers: [Subscriber]? = nil
    )
    {
        self.notification = notification
        self.subscribers = subscribers
    }
}

extension ResourceLockedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceLockedException(message: \(String(describing: message)))"}
}

extension ResourceLockedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceLockedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The request was received and recognized by the server, but the server rejected that
///       particular method for the requested resource. </p>
public struct ResourceLockedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message the exception carries.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLockedExceptionBody: Equatable {
    public let message: String?
}

extension ResourceLockedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ScpActionDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyId = "PolicyId"
        case targetIds = "TargetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let targetIds = targetIds {
            var targetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIds)
            for targetids0 in targetIds {
                try targetIdsContainer.encode(targetids0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let targetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetIds)
        var targetIdsDecoded0:[String]? = nil
        if let targetIdsContainer = targetIdsContainer {
            targetIdsDecoded0 = [String]()
            for string0 in targetIdsContainer {
                if let string0 = string0 {
                    targetIdsDecoded0?.append(string0)
                }
            }
        }
        targetIds = targetIdsDecoded0
    }
}

extension ScpActionDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScpActionDefinition(policyId: \(String(describing: policyId)), targetIds: \(String(describing: targetIds)))"}
}

/// <p>
/// 			The service control policies (SCP) action definition details.
/// 		</p>
public struct ScpActionDefinition: Equatable {
    /// <p>
    /// 			The policy ID attached.
    /// 		</p>
    public let policyId: String?
    /// <p>
    /// 			A list of target IDs.
    /// 		</p>
    public let targetIds: [String]?

    public init (
        policyId: String? = nil,
        targetIds: [String]? = nil
    )
    {
        self.policyId = policyId
        self.targetIds = targetIds
    }
}

extension Spend: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amount = "Amount"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amount)
        amount = amountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension Spend: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Spend(amount: \(String(describing: amount)), unit: \(String(describing: unit)))"}
}

/// <p>The amount of cost or usage that is measured for a budget.</p>
/// 		       <p>For example, a <code>Spend</code> for <code>3 GB</code> of S3 usage would have the following parameters:</p>
/// 		       <ul>
///             <li>
/// 				           <p>An <code>Amount</code> of <code>3</code>
///                </p>
/// 			         </li>
///             <li>
/// 				           <p>A <code>unit</code> of <code>GB</code>
///                </p>
/// 			         </li>
///          </ul>
public struct Spend: Equatable {
    /// <p>The cost or usage amount that is associated with a budget forecast, actual spend, or budget threshold.</p>
    public let amount: String?
    /// <p>The unit of measurement that is used for the budget forecast, actual spend, or budget threshold, such as dollars or GB.</p>
    public let unit: String?

    public init (
        amount: String? = nil,
        unit: String? = nil
    )
    {
        self.amount = amount
        self.unit = unit
    }
}

extension SsmActionDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionSubType = "ActionSubType"
        case instanceIds = "InstanceIds"
        case region = "Region"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionSubType = actionSubType {
            try encodeContainer.encode(actionSubType.rawValue, forKey: .actionSubType)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceids0 in instanceIds {
                try instanceIdsContainer.encode(instanceids0)
            }
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionSubTypeDecoded = try containerValues.decodeIfPresent(ActionSubType.self, forKey: .actionSubType)
        actionSubType = actionSubTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension SsmActionDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SsmActionDefinition(actionSubType: \(String(describing: actionSubType)), instanceIds: \(String(describing: instanceIds)), region: \(String(describing: region)))"}
}

/// <p>
/// 			The AWS Systems Manager (SSM) action definition details.
/// 		</p>
public struct SsmActionDefinition: Equatable {
    /// <p>
    /// 			The action subType.
    /// 		</p>
    public let actionSubType: ActionSubType?
    /// <p>
    /// 			The EC2 and RDS instance IDs.
    /// 		</p>
    public let instanceIds: [String]?
    /// <p>
    /// 			The Region to run the SSM document.
    /// 		</p>
    public let region: String?

    public init (
        actionSubType: ActionSubType? = nil,
        instanceIds: [String]? = nil,
        region: String? = nil
    )
    {
        self.actionSubType = actionSubType
        self.instanceIds = instanceIds
        self.region = region
    }
}

extension Subscriber: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case subscriptionType = "SubscriptionType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let subscriptionType = subscriptionType {
            try encodeContainer.encode(subscriptionType.rawValue, forKey: .subscriptionType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
    }
}

extension Subscriber: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Subscriber(address: \(String(describing: address)), subscriptionType: \(String(describing: subscriptionType)))"}
}

/// <p>The subscriber to a budget notification. The subscriber consists of a subscription type and either an Amazon SNS topic or an email address.</p>
/// 		       <p>For example, an email subscriber would have the following parameters:</p>
/// 		       <ul>
///             <li>
/// 				           <p>A <code>subscriptionType</code> of <code>EMAIL</code>
///                </p>
/// 			         </li>
///             <li>
/// 				           <p>An <code>address</code> of <code>example@example.com</code>
///                </p>
/// 			         </li>
///          </ul>
public struct Subscriber: Equatable {
    /// <p>The address that AWS sends budget notifications to, either an SNS topic or an email.</p>
    /// 		       <p>When you create a subscriber, the value of <code>Address</code> can't contain line breaks.</p>
    public let address: String?
    /// <p>The type of notification that AWS sends to a subscriber.</p>
    public let subscriptionType: SubscriptionType?

    public init (
        address: String? = nil,
        subscriptionType: SubscriptionType? = nil
    )
    {
        self.address = address
        self.subscriptionType = subscriptionType
    }
}

/// <p> The subscription type of the subscriber. It can be SMS or EMAIL.</p>
public enum SubscriptionType {
    case email
    case sns
    case sdkUnknown(String)
}

extension SubscriptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SubscriptionType] {
        return [
            .email,
            .sns,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .email: return "EMAIL"
        case .sns: return "SNS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SubscriptionType(rawValue: rawValue) ?? SubscriptionType.sdkUnknown(rawValue)
    }
}

/// <p> The type of threshold for a notification.</p>
public enum ThresholdType {
    case absoluteValue
    case percentage
    case sdkUnknown(String)
}

extension ThresholdType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThresholdType] {
        return [
            .absoluteValue,
            .percentage,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .absoluteValue: return "ABSOLUTE_VALUE"
        case .percentage: return "PERCENTAGE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThresholdType(rawValue: rawValue) ?? ThresholdType.sdkUnknown(rawValue)
    }
}

extension TimePeriod: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = end {
            try encodeContainer.encode(end.timeIntervalSince1970, forKey: .end)
        }
        if let start = start {
            try encodeContainer.encode(start.timeIntervalSince1970, forKey: .start)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .end)
        end = endDecoded
    }
}

extension TimePeriod: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimePeriod(end: \(String(describing: end)), start: \(String(describing: start)))"}
}

/// <p>The period of time that is covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date. </p>
public struct TimePeriod: Equatable {
    /// <p>The end date for a budget. If you didn't specify an end date, AWS set your end date to <code>06/15/87 00:00 UTC</code>. The defaults are the same for the AWS Billing and Cost Management console and the API.</p>
    /// 		       <p>After the end date, AWS deletes the budget and all associated notifications and subscribers. You can change your end date with the <code>UpdateBudget</code> operation.</p>
    public let end: Date?
    /// <p>The start date for a budget. If you created your budget and didn't specify a start date, AWS defaults to the start of your chosen time period (DAILY, MONTHLY, QUARTERLY, or ANNUALLY). For example, if you created your budget on January 24, 2018, chose <code>DAILY</code>, and didn't set a start date, AWS set your start date to <code>01/24/18 00:00 UTC</code>. If you chose <code>MONTHLY</code>, AWS set your start date to <code>01/01/18 00:00 UTC</code>. The defaults are the same for the AWS Billing and Cost Management console and the API.</p>
    /// 		       <p>You can change your start date with the <code>UpdateBudget</code> operation.</p>
    public let start: Date?

    public init (
        end: Date? = nil,
        start: Date? = nil
    )
    {
        self.end = end
        self.start = start
    }
}

/// <p> The time unit of the budget, such as MONTHLY or QUARTERLY.</p>
public enum TimeUnit {
    case annually
    case daily
    case monthly
    case quarterly
    case sdkUnknown(String)
}

extension TimeUnit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TimeUnit] {
        return [
            .annually,
            .daily,
            .monthly,
            .quarterly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .annually: return "ANNUALLY"
        case .daily: return "DAILY"
        case .monthly: return "MONTHLY"
        case .quarterly: return "QUARTERLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TimeUnit(rawValue: rawValue) ?? TimeUnit.sdkUnknown(rawValue)
    }
}

public struct UpdateBudgetActionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBudgetActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBudgetActionInput>
    public typealias MOutput = OperationOutput<UpdateBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBudgetActionOutputError>
}

extension UpdateBudgetActionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBudgetActionInput(accountId: \(String(describing: accountId)), actionId: \(String(describing: actionId)), actionThreshold: \(String(describing: actionThreshold)), approvalModel: \(String(describing: approvalModel)), budgetName: \(String(describing: budgetName)), definition: \(String(describing: definition)), executionRoleArn: \(String(describing: executionRoleArn)), notificationType: \(String(describing: notificationType)), subscribers: \(String(describing: subscribers)))"}
}

extension UpdateBudgetActionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case actionThreshold = "ActionThreshold"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionThreshold = actionThreshold {
            try encodeContainer.encode(actionThreshold, forKey: .actionThreshold)
        }
        if let approvalModel = approvalModel {
            try encodeContainer.encode(approvalModel.rawValue, forKey: .approvalModel)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let notificationType = notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
    }
}

public struct UpdateBudgetActionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBudgetActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBudgetActionInput>
    public typealias MOutput = OperationOutput<UpdateBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBudgetActionOutputError>
}

public struct UpdateBudgetActionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBudgetActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBudgetActionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBudgetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBudgetActionInput>
    public typealias MOutput = OperationOutput<UpdateBudgetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBudgetActionOutputError>
}

public struct UpdateBudgetActionInput: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p>
    ///          A system-generated universally unique identifier (UUID) for the action.
    ///       </p>
    public let actionId: String?
    /// <p>
    /// 			The trigger threshold of the action.
    /// 		</p>
    public let actionThreshold: ActionThreshold?
    /// <p>
    ///          This specifies if the action needs manual or automatic approval.
    ///       </p>
    public let approvalModel: ApprovalModel?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?
    /// <p>
    /// 			Specifies all of the type-specific parameters.
    /// 		</p>
    public let definition: Definition?
    /// <p>
    ///          The role passed for action execution and reversion. Roles and actions must be in the same account.
    ///       </p>
    public let executionRoleArn: String?
    /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
    public let notificationType: NotificationType?
    /// <p> A list of subscribers.</p>
    public let subscribers: [Subscriber]?

    public init (
        accountId: String? = nil,
        actionId: String? = nil,
        actionThreshold: ActionThreshold? = nil,
        approvalModel: ApprovalModel? = nil,
        budgetName: String? = nil,
        definition: Definition? = nil,
        executionRoleArn: String? = nil,
        notificationType: NotificationType? = nil,
        subscribers: [Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.actionThreshold = actionThreshold
        self.approvalModel = approvalModel
        self.budgetName = budgetName
        self.definition = definition
        self.executionRoleArn = executionRoleArn
        self.notificationType = notificationType
        self.subscribers = subscribers
    }
}

struct UpdateBudgetActionInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let actionId: String?
    public let notificationType: NotificationType?
    public let actionThreshold: ActionThreshold?
    public let definition: Definition?
    public let executionRoleArn: String?
    public let approvalModel: ApprovalModel?
    public let subscribers: [Subscriber]?
}

extension UpdateBudgetActionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case actionThreshold = "ActionThreshold"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let notificationTypeDecoded = try containerValues.decodeIfPresent(NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let actionThresholdDecoded = try containerValues.decodeIfPresent(ActionThreshold.self, forKey: .actionThreshold)
        actionThreshold = actionThresholdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Definition.self, forKey: .definition)
        definition = definitionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let approvalModelDecoded = try containerValues.decodeIfPresent(ApprovalModel.self, forKey: .approvalModel)
        approvalModel = approvalModelDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension UpdateBudgetActionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBudgetActionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLockedException" : self = .resourceLockedException(try ResourceLockedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBudgetActionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case resourceLockedException(ResourceLockedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBudgetActionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBudgetActionOutputResponse(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)), newAction: \(String(describing: newAction)), oldAction: \(String(describing: oldAction)))"}
}

extension UpdateBudgetActionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountId = output.accountId
            self.budgetName = output.budgetName
            self.newAction = output.newAction
            self.oldAction = output.oldAction
        } else {
            self.accountId = nil
            self.budgetName = nil
            self.newAction = nil
            self.oldAction = nil
        }
    }
}

public struct UpdateBudgetActionOutputResponse: Equatable {
    /// <p>The account ID of the user. It should be a 12-digit number.</p>
    public let accountId: String?
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    public let budgetName: String?
    /// <p>
    ///          The updated action resource information.
    ///       </p>
    public let newAction: Action?
    /// <p>
    ///          The previous action resource information.
    ///       </p>
    public let oldAction: Action?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil,
        newAction: Action? = nil,
        oldAction: Action? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newAction = newAction
        self.oldAction = oldAction
    }
}

struct UpdateBudgetActionOutputResponseBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let oldAction: Action?
    public let newAction: Action?
}

extension UpdateBudgetActionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newAction = "NewAction"
        case oldAction = "OldAction"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let oldActionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .oldAction)
        oldAction = oldActionDecoded
        let newActionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .newAction)
        newAction = newActionDecoded
    }
}

public struct UpdateBudgetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBudgetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBudgetInput>
    public typealias MOutput = OperationOutput<UpdateBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBudgetOutputError>
}

extension UpdateBudgetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBudgetInput(accountId: \(String(describing: accountId)), newBudget: \(String(describing: newBudget)))"}
}

extension UpdateBudgetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case newBudget = "NewBudget"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let newBudget = newBudget {
            try encodeContainer.encode(newBudget, forKey: .newBudget)
        }
    }
}

public struct UpdateBudgetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBudgetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBudgetInput>
    public typealias MOutput = OperationOutput<UpdateBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBudgetOutputError>
}

public struct UpdateBudgetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBudgetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBudgetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBudgetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBudgetInput>
    public typealias MOutput = OperationOutput<UpdateBudgetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBudgetOutputError>
}

/// <p> Request of UpdateBudget </p>
public struct UpdateBudgetInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to update.</p>
    public let accountId: String?
    /// <p>The budget that you want to update your budget to.</p>
    public let newBudget: Budget?

    public init (
        accountId: String? = nil,
        newBudget: Budget? = nil
    )
    {
        self.accountId = accountId
        self.newBudget = newBudget
    }
}

struct UpdateBudgetInputBody: Equatable {
    public let accountId: String?
    public let newBudget: Budget?
}

extension UpdateBudgetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case newBudget = "NewBudget"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let newBudgetDecoded = try containerValues.decodeIfPresent(Budget.self, forKey: .newBudget)
        newBudget = newBudgetDecoded
    }
}

extension UpdateBudgetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBudgetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBudgetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBudgetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBudgetOutputResponse()"}
}

extension UpdateBudgetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of UpdateBudget </p>
public struct UpdateBudgetOutputResponse: Equatable {

    public init() {}
}

struct UpdateBudgetOutputResponseBody: Equatable {
}

extension UpdateBudgetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateNotificationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateNotificationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNotificationInput>
    public typealias MOutput = OperationOutput<UpdateNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNotificationOutputError>
}

extension UpdateNotificationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNotificationInput(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)), newNotification: \(String(describing: newNotification)), oldNotification: \(String(describing: oldNotification)))"}
}

extension UpdateNotificationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newNotification = "NewNotification"
        case oldNotification = "OldNotification"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let newNotification = newNotification {
            try encodeContainer.encode(newNotification, forKey: .newNotification)
        }
        if let oldNotification = oldNotification {
            try encodeContainer.encode(oldNotification, forKey: .oldNotification)
        }
    }
}

public struct UpdateNotificationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateNotificationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNotificationInput>
    public typealias MOutput = OperationOutput<UpdateNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNotificationOutputError>
}

public struct UpdateNotificationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateNotificationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateNotificationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateNotificationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateNotificationInput>
    public typealias MOutput = OperationOutput<UpdateNotificationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateNotificationOutputError>
}

/// <p> Request of UpdateNotification </p>
public struct UpdateNotificationInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget whose notification you want to update.</p>
    public let accountId: String?
    /// <p>The name of the budget whose notification you want to update.</p>
    public let budgetName: String?
    /// <p>The updated notification to be associated with a budget.</p>
    public let newNotification: Notification?
    /// <p>The previous notification that is associated with a budget.</p>
    public let oldNotification: Notification?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil,
        newNotification: Notification? = nil,
        oldNotification: Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newNotification = newNotification
        self.oldNotification = oldNotification
    }
}

struct UpdateNotificationInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let oldNotification: Notification?
    public let newNotification: Notification?
}

extension UpdateNotificationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newNotification = "NewNotification"
        case oldNotification = "OldNotification"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let oldNotificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .oldNotification)
        oldNotification = oldNotificationDecoded
        let newNotificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .newNotification)
        newNotification = newNotificationDecoded
    }
}

extension UpdateNotificationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNotificationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNotificationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNotificationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNotificationOutputResponse()"}
}

extension UpdateNotificationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of UpdateNotification </p>
public struct UpdateNotificationOutputResponse: Equatable {

    public init() {}
}

struct UpdateNotificationOutputResponseBody: Equatable {
}

extension UpdateNotificationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateSubscriberInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSubscriberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubscriberInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubscriberInput>
    public typealias MOutput = OperationOutput<UpdateSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubscriberOutputError>
}

extension UpdateSubscriberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSubscriberInput(accountId: \(String(describing: accountId)), budgetName: \(String(describing: budgetName)), newSubscriber: \(String(describing: newSubscriber)), notification: \(String(describing: notification)), oldSubscriber: \(String(describing: oldSubscriber)))"}
}

extension UpdateSubscriberInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newSubscriber = "NewSubscriber"
        case notification = "Notification"
        case oldSubscriber = "OldSubscriber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let newSubscriber = newSubscriber {
            try encodeContainer.encode(newSubscriber, forKey: .newSubscriber)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let oldSubscriber = oldSubscriber {
            try encodeContainer.encode(oldSubscriber, forKey: .oldSubscriber)
        }
    }
}

public struct UpdateSubscriberInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSubscriberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubscriberInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubscriberInput>
    public typealias MOutput = OperationOutput<UpdateSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubscriberOutputError>
}

public struct UpdateSubscriberInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSubscriberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubscriberInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubscriberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubscriberInput>
    public typealias MOutput = OperationOutput<UpdateSubscriberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubscriberOutputError>
}

/// <p> Request of UpdateSubscriber </p>
public struct UpdateSubscriberInput: Equatable {
    /// <p>The <code>accountId</code> that is associated with the budget whose subscriber you want to update.</p>
    public let accountId: String?
    /// <p>The name of the budget whose subscriber you want to update.</p>
    public let budgetName: String?
    /// <p>The updated subscriber that is associated with a budget notification.</p>
    public let newSubscriber: Subscriber?
    /// <p>The notification whose subscriber you want to update.</p>
    public let notification: Notification?
    /// <p>The previous subscriber that is associated with a budget notification.</p>
    public let oldSubscriber: Subscriber?

    public init (
        accountId: String? = nil,
        budgetName: String? = nil,
        newSubscriber: Subscriber? = nil,
        notification: Notification? = nil,
        oldSubscriber: Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newSubscriber = newSubscriber
        self.notification = notification
        self.oldSubscriber = oldSubscriber
    }
}

struct UpdateSubscriberInputBody: Equatable {
    public let accountId: String?
    public let budgetName: String?
    public let notification: Notification?
    public let oldSubscriber: Subscriber?
    public let newSubscriber: Subscriber?
}

extension UpdateSubscriberInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newSubscriber = "NewSubscriber"
        case notification = "Notification"
        case oldSubscriber = "OldSubscriber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
        let oldSubscriberDecoded = try containerValues.decodeIfPresent(Subscriber.self, forKey: .oldSubscriber)
        oldSubscriber = oldSubscriberDecoded
        let newSubscriberDecoded = try containerValues.decodeIfPresent(Subscriber.self, forKey: .newSubscriber)
        newSubscriber = newSubscriberDecoded
    }
}

extension UpdateSubscriberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubscriberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSubscriberOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubscriberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSubscriberOutputResponse()"}
}

extension UpdateSubscriberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p> Response of UpdateSubscriber </p>
public struct UpdateSubscriberOutputResponse: Equatable {

    public init() {}
}

struct UpdateSubscriberOutputResponseBody: Equatable {
}

extension UpdateSubscriberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
