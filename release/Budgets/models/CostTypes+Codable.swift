// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension CostTypes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeCredit = "IncludeCredit"
        case includeDiscount = "IncludeDiscount"
        case includeOtherSubscription = "IncludeOtherSubscription"
        case includeRecurring = "IncludeRecurring"
        case includeRefund = "IncludeRefund"
        case includeSubscription = "IncludeSubscription"
        case includeSupport = "IncludeSupport"
        case includeTax = "IncludeTax"
        case includeUpfront = "IncludeUpfront"
        case useAmortized = "UseAmortized"
        case useBlended = "UseBlended"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeCredit = includeCredit {
            try encodeContainer.encode(includeCredit, forKey: .includeCredit)
        }
        if let includeDiscount = includeDiscount {
            try encodeContainer.encode(includeDiscount, forKey: .includeDiscount)
        }
        if let includeOtherSubscription = includeOtherSubscription {
            try encodeContainer.encode(includeOtherSubscription, forKey: .includeOtherSubscription)
        }
        if let includeRecurring = includeRecurring {
            try encodeContainer.encode(includeRecurring, forKey: .includeRecurring)
        }
        if let includeRefund = includeRefund {
            try encodeContainer.encode(includeRefund, forKey: .includeRefund)
        }
        if let includeSubscription = includeSubscription {
            try encodeContainer.encode(includeSubscription, forKey: .includeSubscription)
        }
        if let includeSupport = includeSupport {
            try encodeContainer.encode(includeSupport, forKey: .includeSupport)
        }
        if let includeTax = includeTax {
            try encodeContainer.encode(includeTax, forKey: .includeTax)
        }
        if let includeUpfront = includeUpfront {
            try encodeContainer.encode(includeUpfront, forKey: .includeUpfront)
        }
        if let useAmortized = useAmortized {
            try encodeContainer.encode(useAmortized, forKey: .useAmortized)
        }
        if let useBlended = useBlended {
            try encodeContainer.encode(useBlended, forKey: .useBlended)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includeTaxDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeTax)
        includeTax = includeTaxDecoded
        let includeSubscriptionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeSubscription)
        includeSubscription = includeSubscriptionDecoded
        let useBlendedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useBlended)
        useBlended = useBlendedDecoded
        let includeRefundDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeRefund)
        includeRefund = includeRefundDecoded
        let includeCreditDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeCredit)
        includeCredit = includeCreditDecoded
        let includeUpfrontDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeUpfront)
        includeUpfront = includeUpfrontDecoded
        let includeRecurringDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeRecurring)
        includeRecurring = includeRecurringDecoded
        let includeOtherSubscriptionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeOtherSubscription)
        includeOtherSubscription = includeOtherSubscriptionDecoded
        let includeSupportDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeSupport)
        includeSupport = includeSupportDecoded
        let includeDiscountDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeDiscount)
        includeDiscount = includeDiscountDecoded
        let useAmortizedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useAmortized)
        useAmortized = useAmortizedDecoded
    }
}
