// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension InstancesCount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assigning = "Assigning"
        case booting = "Booting"
        case connectionLost = "ConnectionLost"
        case deregistering = "Deregistering"
        case online = "Online"
        case pending = "Pending"
        case rebooting = "Rebooting"
        case registered = "Registered"
        case registering = "Registering"
        case requested = "Requested"
        case runningSetup = "RunningSetup"
        case setupFailed = "SetupFailed"
        case shuttingDown = "ShuttingDown"
        case startFailed = "StartFailed"
        case stopFailed = "StopFailed"
        case stopped = "Stopped"
        case stopping = "Stopping"
        case terminated = "Terminated"
        case terminating = "Terminating"
        case unassigning = "Unassigning"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assigning = assigning {
            try encodeContainer.encode(assigning, forKey: .assigning)
        }
        if let booting = booting {
            try encodeContainer.encode(booting, forKey: .booting)
        }
        if let connectionLost = connectionLost {
            try encodeContainer.encode(connectionLost, forKey: .connectionLost)
        }
        if let deregistering = deregistering {
            try encodeContainer.encode(deregistering, forKey: .deregistering)
        }
        if let online = online {
            try encodeContainer.encode(online, forKey: .online)
        }
        if let pending = pending {
            try encodeContainer.encode(pending, forKey: .pending)
        }
        if let rebooting = rebooting {
            try encodeContainer.encode(rebooting, forKey: .rebooting)
        }
        if let registered = registered {
            try encodeContainer.encode(registered, forKey: .registered)
        }
        if let registering = registering {
            try encodeContainer.encode(registering, forKey: .registering)
        }
        if let requested = requested {
            try encodeContainer.encode(requested, forKey: .requested)
        }
        if let runningSetup = runningSetup {
            try encodeContainer.encode(runningSetup, forKey: .runningSetup)
        }
        if let setupFailed = setupFailed {
            try encodeContainer.encode(setupFailed, forKey: .setupFailed)
        }
        if let shuttingDown = shuttingDown {
            try encodeContainer.encode(shuttingDown, forKey: .shuttingDown)
        }
        if let startFailed = startFailed {
            try encodeContainer.encode(startFailed, forKey: .startFailed)
        }
        if let stopFailed = stopFailed {
            try encodeContainer.encode(stopFailed, forKey: .stopFailed)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped, forKey: .stopped)
        }
        if let stopping = stopping {
            try encodeContainer.encode(stopping, forKey: .stopping)
        }
        if let terminated = terminated {
            try encodeContainer.encode(terminated, forKey: .terminated)
        }
        if let terminating = terminating {
            try encodeContainer.encode(terminating, forKey: .terminating)
        }
        if let unassigning = unassigning {
            try encodeContainer.encode(unassigning, forKey: .unassigning)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assigningDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .assigning)
        assigning = assigningDecoded
        let bootingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .booting)
        booting = bootingDecoded
        let connectionLostDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .connectionLost)
        connectionLost = connectionLostDecoded
        let deregisteringDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .deregistering)
        deregistering = deregisteringDecoded
        let onlineDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .online)
        online = onlineDecoded
        let pendingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pending)
        pending = pendingDecoded
        let rebootingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .rebooting)
        rebooting = rebootingDecoded
        let registeredDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .registered)
        registered = registeredDecoded
        let registeringDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .registering)
        registering = registeringDecoded
        let requestedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .requested)
        requested = requestedDecoded
        let runningSetupDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .runningSetup)
        runningSetup = runningSetupDecoded
        let setupFailedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .setupFailed)
        setupFailed = setupFailedDecoded
        let shuttingDownDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .shuttingDown)
        shuttingDown = shuttingDownDecoded
        let startFailedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startFailed)
        startFailed = startFailedDecoded
        let stopFailedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stopFailed)
        stopFailed = stopFailedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stopped)
        stopped = stoppedDecoded
        let stoppingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stopping)
        stopping = stoppingDecoded
        let terminatedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .terminated)
        terminated = terminatedDecoded
        let terminatingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .terminating)
        terminating = terminatingDecoded
        let unassigningDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .unassigning)
        unassigning = unassigningDecoded
    }
}
