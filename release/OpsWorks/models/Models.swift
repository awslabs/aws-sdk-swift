// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AgentVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationManager = "ConfigurationManager"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationManager = configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
    }
}

extension AgentVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AgentVersion(configurationManager: \(String(describing: configurationManager)), version: \(String(describing: version)))"}
}

/// <p>Describes an agent version.</p>
public struct AgentVersion: Equatable {
    /// <p>The configuration manager.</p>
    public let configurationManager: StackConfigurationManager?
    /// <p>The agent version.</p>
    public let version: String?

    public init (
        configurationManager: StackConfigurationManager? = nil,
        version: String? = nil
    )
    {
        self.configurationManager = configurationManager
        self.version = version
    }
}

extension App: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId = "AppId"
        case appSource = "AppSource"
        case attributes = "Attributes"
        case createdAt = "CreatedAt"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case shortname = "Shortname"
        case sslConfiguration = "SslConfiguration"
        case stackId = "StackId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appSource = appSource {
            try encodeContainer.encode(appSource, forKey: .appSource)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, appattributes0) in attributes {
                try attributesContainer.encode(appattributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasources0 in dataSources {
                try dataSourcesContainer.encode(datasources0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for strings0 in domains {
                try domainsContainer.encode(strings0)
            }
        }
        if let enableSsl = enableSsl {
            try encodeContainer.encode(enableSsl, forKey: .enableSsl)
        }
        if let environment = environment {
            var environmentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environment)
            for environmentvariables0 in environment {
                try environmentContainer.encode(environmentvariables0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let shortname = shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let sslConfiguration = sslConfiguration {
            try encodeContainer.encode(sslConfiguration, forKey: .sslConfiguration)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourcesContainer = try containerValues.decodeIfPresent([DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(AppType.self, forKey: .type)
        type = typeDecoded
        let appSourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .appSource)
        appSource = appSourceDecoded
        let domainsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .domains)
        var domainsDecoded0:[String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
        let enableSslDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableSsl)
        enableSsl = enableSslDecoded
        let sslConfigurationDecoded = try containerValues.decodeIfPresent(SslConfiguration.self, forKey: .sslConfiguration)
        sslConfiguration = sslConfigurationDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let environmentContainer = try containerValues.decodeIfPresent([EnvironmentVariable?].self, forKey: .environment)
        var environmentDecoded0:[EnvironmentVariable]? = nil
        if let environmentContainer = environmentContainer {
            environmentDecoded0 = [EnvironmentVariable]()
            for structure0 in environmentContainer {
                if let structure0 = structure0 {
                    environmentDecoded0?.append(structure0)
                }
            }
        }
        environment = environmentDecoded0
    }
}

extension App: CustomDebugStringConvertible {
    public var debugDescription: String {
        "App(appId: \(String(describing: appId)), appSource: \(String(describing: appSource)), attributes: \(String(describing: attributes)), createdAt: \(String(describing: createdAt)), dataSources: \(String(describing: dataSources)), description: \(String(describing: description)), domains: \(String(describing: domains)), enableSsl: \(String(describing: enableSsl)), environment: \(String(describing: environment)), name: \(String(describing: name)), shortname: \(String(describing: shortname)), sslConfiguration: \(String(describing: sslConfiguration)), stackId: \(String(describing: stackId)), type: \(String(describing: type)))"}
}

/// <p>A description of the app.</p>
public struct App: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>A <code>Source</code> object that describes the app repository.</p>
    public let appSource: Source?
    /// <p>The stack attributes.</p>
    public let attributes: [String:String]?
    /// <p>When the app was created.</p>
    public let createdAt: String?
    /// <p>The app's data sources.</p>
    public let dataSources: [DataSource]?
    /// <p>A description of the app.</p>
    public let description: String?
    /// <p>The app vhost settings with multiple domains separated by commas. For example:
    ///         <code>'www.example.com, example.com'</code>
    ///          </p>
    public let domains: [String]?
    /// <p>Whether to enable SSL for the app.</p>
    public let enableSsl: Bool?
    /// <p>An array of <code>EnvironmentVariable</code> objects that specify environment variables to be
    ///       associated with the app. After you deploy the app, these variables are defined on the
    ///       associated app server instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-environment"> Environment Variables</a>. </p>
    ///          <note>
    ///             <p>There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variable names, values, and protected flag values - cannot exceed 20 KB. This limit should accommodate most if not all use cases, but if you do exceed it, you will cause an exception (API) with an "Environment: is too large (maximum is 20 KB)" message.</p>
    ///          </note>
    public let environment: [EnvironmentVariable]?
    /// <p>The app name.</p>
    public let name: String?
    /// <p>The app's short name.</p>
    public let shortname: String?
    /// <p>An <code>SslConfiguration</code> object with the SSL configuration.</p>
    public let sslConfiguration: SslConfiguration?
    /// <p>The app stack ID.</p>
    public let stackId: String?
    /// <p>The app type.</p>
    public let type: AppType?

    public init (
        appId: String? = nil,
        appSource: Source? = nil,
        attributes: [String:String]? = nil,
        createdAt: String? = nil,
        dataSources: [DataSource]? = nil,
        description: String? = nil,
        domains: [String]? = nil,
        enableSsl: Bool? = nil,
        environment: [EnvironmentVariable]? = nil,
        name: String? = nil,
        shortname: String? = nil,
        sslConfiguration: SslConfiguration? = nil,
        stackId: String? = nil,
        type: AppType? = nil
    )
    {
        self.appId = appId
        self.appSource = appSource
        self.attributes = attributes
        self.createdAt = createdAt
        self.dataSources = dataSources
        self.description = description
        self.domains = domains
        self.enableSsl = enableSsl
        self.environment = environment
        self.name = name
        self.shortname = shortname
        self.sslConfiguration = sslConfiguration
        self.stackId = stackId
        self.type = type
    }
}

public enum AppAttributesKeys {
    case autobundleondeploy
    case awsflowrubysettings
    case documentroot
    case railsenv
    case sdkUnknown(String)
}

extension AppAttributesKeys : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AppAttributesKeys] {
        return [
            .autobundleondeploy,
            .awsflowrubysettings,
            .documentroot,
            .railsenv,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .autobundleondeploy: return "AutoBundleOnDeploy"
        case .awsflowrubysettings: return "AwsFlowRubySettings"
        case .documentroot: return "DocumentRoot"
        case .railsenv: return "RailsEnv"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AppAttributesKeys(rawValue: rawValue) ?? AppAttributesKeys.sdkUnknown(rawValue)
    }
}

public enum AppType {
    case awsFlowRuby
    case java
    case nodejs
    case other
    case php
    case rails
    case `static`
    case sdkUnknown(String)
}

extension AppType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AppType] {
        return [
            .awsFlowRuby,
            .java,
            .nodejs,
            .other,
            .php,
            .rails,
            .static,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsFlowRuby: return "aws-flow-ruby"
        case .java: return "java"
        case .nodejs: return "nodejs"
        case .other: return "other"
        case .php: return "php"
        case .rails: return "rails"
        case .static: return "static"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AppType(rawValue: rawValue) ?? AppType.sdkUnknown(rawValue)
    }
}

public enum Architecture {
    case i386
    case x8664
    case sdkUnknown(String)
}

extension Architecture : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Architecture] {
        return [
            .i386,
            .x8664,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .i386: return "i386"
        case .x8664: return "x86_64"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Architecture(rawValue: rawValue) ?? Architecture.sdkUnknown(rawValue)
    }
}

public struct AssignInstanceInputBodyMiddleware: Middleware {
    public let id: String = "AssignInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssignInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssignInstanceInput>
    public typealias MOutput = OperationOutput<AssignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssignInstanceOutputError>
}

extension AssignInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssignInstanceInput(instanceId: \(String(describing: instanceId)), layerIds: \(String(describing: layerIds)))"}
}

extension AssignInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case layerIds = "LayerIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
    }
}

public struct AssignInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "AssignInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssignInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssignInstanceInput>
    public typealias MOutput = OperationOutput<AssignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssignInstanceOutputError>
}

public struct AssignInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "AssignInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssignInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssignInstanceInput>
    public typealias MOutput = OperationOutput<AssignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssignInstanceOutputError>
}

public struct AssignInstanceInput: Equatable {
    /// <p>The instance ID.</p>
    public let instanceId: String?
    /// <p>The layer ID, which must correspond to a custom layer. You cannot assign a registered instance to a built-in layer.</p>
    public let layerIds: [String]?

    public init (
        instanceId: String? = nil,
        layerIds: [String]? = nil
    )
    {
        self.instanceId = instanceId
        self.layerIds = layerIds
    }
}

struct AssignInstanceInputBody: Equatable {
    public let instanceId: String?
    public let layerIds: [String]?
}

extension AssignInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case layerIds = "LayerIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
    }
}

extension AssignInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssignInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssignInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssignInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssignInstanceOutputResponse()"}
}

extension AssignInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssignInstanceOutputResponse: Equatable {

    public init() {}
}

struct AssignInstanceOutputResponseBody: Equatable {
}

extension AssignInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssignVolumeInputBodyMiddleware: Middleware {
    public let id: String = "AssignVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssignVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<AssignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssignVolumeInput>
    public typealias MOutput = OperationOutput<AssignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssignVolumeOutputError>
}

extension AssignVolumeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssignVolumeInput(instanceId: \(String(describing: instanceId)), volumeId: \(String(describing: volumeId)))"}
}

extension AssignVolumeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case volumeId = "VolumeId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }
}

public struct AssignVolumeInputHeadersMiddleware: Middleware {
    public let id: String = "AssignVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssignVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<AssignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssignVolumeInput>
    public typealias MOutput = OperationOutput<AssignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssignVolumeOutputError>
}

public struct AssignVolumeInputQueryItemMiddleware: Middleware {
    public let id: String = "AssignVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssignVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<AssignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssignVolumeInput>
    public typealias MOutput = OperationOutput<AssignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssignVolumeOutputError>
}

public struct AssignVolumeInput: Equatable {
    /// <p>The instance ID.</p>
    public let instanceId: String?
    /// <p>The volume ID.</p>
    public let volumeId: String?

    public init (
        instanceId: String? = nil,
        volumeId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.volumeId = volumeId
    }
}

struct AssignVolumeInputBody: Equatable {
    public let volumeId: String?
    public let instanceId: String?
}

extension AssignVolumeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case volumeId = "VolumeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension AssignVolumeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssignVolumeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssignVolumeOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssignVolumeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssignVolumeOutputResponse()"}
}

extension AssignVolumeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssignVolumeOutputResponse: Equatable {

    public init() {}
}

struct AssignVolumeOutputResponseBody: Equatable {
}

extension AssignVolumeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateElasticIpInputBodyMiddleware: Middleware {
    public let id: String = "AssociateElasticIpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateElasticIpInput>
    public typealias MOutput = OperationOutput<AssociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateElasticIpOutputError>
}

extension AssociateElasticIpInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateElasticIpInput(elasticIp: \(String(describing: elasticIp)), instanceId: \(String(describing: instanceId)))"}
}

extension AssociateElasticIpInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct AssociateElasticIpInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateElasticIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateElasticIpInput>
    public typealias MOutput = OperationOutput<AssociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateElasticIpOutputError>
}

public struct AssociateElasticIpInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateElasticIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateElasticIpInput>
    public typealias MOutput = OperationOutput<AssociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateElasticIpOutputError>
}

public struct AssociateElasticIpInput: Equatable {
    /// <p>The Elastic IP address.</p>
    public let elasticIp: String?
    /// <p>The instance ID.</p>
    public let instanceId: String?

    public init (
        elasticIp: String? = nil,
        instanceId: String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.instanceId = instanceId
    }
}

struct AssociateElasticIpInputBody: Equatable {
    public let elasticIp: String?
    public let instanceId: String?
}

extension AssociateElasticIpInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension AssociateElasticIpOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateElasticIpOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateElasticIpOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateElasticIpOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateElasticIpOutputResponse()"}
}

extension AssociateElasticIpOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateElasticIpOutputResponse: Equatable {

    public init() {}
}

struct AssociateElasticIpOutputResponseBody: Equatable {
}

extension AssociateElasticIpOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AttachElasticLoadBalancerInputBodyMiddleware: Middleware {
    public let id: String = "AttachElasticLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachElasticLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachElasticLoadBalancerInput>
    public typealias MOutput = OperationOutput<AttachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachElasticLoadBalancerOutputError>
}

extension AttachElasticLoadBalancerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachElasticLoadBalancerInput(elasticLoadBalancerName: \(String(describing: elasticLoadBalancerName)), layerId: \(String(describing: layerId)))"}
}

extension AttachElasticLoadBalancerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticLoadBalancerName = elasticLoadBalancerName {
            try encodeContainer.encode(elasticLoadBalancerName, forKey: .elasticLoadBalancerName)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
    }
}

public struct AttachElasticLoadBalancerInputHeadersMiddleware: Middleware {
    public let id: String = "AttachElasticLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachElasticLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachElasticLoadBalancerInput>
    public typealias MOutput = OperationOutput<AttachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachElasticLoadBalancerOutputError>
}

public struct AttachElasticLoadBalancerInputQueryItemMiddleware: Middleware {
    public let id: String = "AttachElasticLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AttachElasticLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<AttachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AttachElasticLoadBalancerInput>
    public typealias MOutput = OperationOutput<AttachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AttachElasticLoadBalancerOutputError>
}

public struct AttachElasticLoadBalancerInput: Equatable {
    /// <p>The Elastic Load Balancing instance's name.</p>
    public let elasticLoadBalancerName: String?
    /// <p>The ID of the layer to which the Elastic Load Balancing instance is to be attached.</p>
    public let layerId: String?

    public init (
        elasticLoadBalancerName: String? = nil,
        layerId: String? = nil
    )
    {
        self.elasticLoadBalancerName = elasticLoadBalancerName
        self.layerId = layerId
    }
}

struct AttachElasticLoadBalancerInputBody: Equatable {
    public let elasticLoadBalancerName: String?
    public let layerId: String?
}

extension AttachElasticLoadBalancerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticLoadBalancerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticLoadBalancerName)
        elasticLoadBalancerName = elasticLoadBalancerNameDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

extension AttachElasticLoadBalancerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AttachElasticLoadBalancerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AttachElasticLoadBalancerOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachElasticLoadBalancerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachElasticLoadBalancerOutputResponse()"}
}

extension AttachElasticLoadBalancerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AttachElasticLoadBalancerOutputResponse: Equatable {

    public init() {}
}

struct AttachElasticLoadBalancerOutputResponseBody: Equatable {
}

extension AttachElasticLoadBalancerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AutoScalingThresholds: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarms = "Alarms"
        case cpuThreshold = "CpuThreshold"
        case ignoreMetricsTime = "IgnoreMetricsTime"
        case instanceCount = "InstanceCount"
        case loadThreshold = "LoadThreshold"
        case memoryThreshold = "MemoryThreshold"
        case thresholdsWaitTime = "ThresholdsWaitTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarms = alarms {
            var alarmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alarms)
            for strings0 in alarms {
                try alarmsContainer.encode(strings0)
            }
        }
        if let cpuThreshold = cpuThreshold {
            try encodeContainer.encode(cpuThreshold, forKey: .cpuThreshold)
        }
        if let ignoreMetricsTime = ignoreMetricsTime {
            try encodeContainer.encode(ignoreMetricsTime, forKey: .ignoreMetricsTime)
        }
        if let instanceCount = instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let loadThreshold = loadThreshold {
            try encodeContainer.encode(loadThreshold, forKey: .loadThreshold)
        }
        if let memoryThreshold = memoryThreshold {
            try encodeContainer.encode(memoryThreshold, forKey: .memoryThreshold)
        }
        if let thresholdsWaitTime = thresholdsWaitTime {
            try encodeContainer.encode(thresholdsWaitTime, forKey: .thresholdsWaitTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let thresholdsWaitTimeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .thresholdsWaitTime)
        thresholdsWaitTime = thresholdsWaitTimeDecoded
        let ignoreMetricsTimeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .ignoreMetricsTime)
        ignoreMetricsTime = ignoreMetricsTimeDecoded
        let cpuThresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .cpuThreshold)
        cpuThreshold = cpuThresholdDecoded
        let memoryThresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .memoryThreshold)
        memoryThreshold = memoryThresholdDecoded
        let loadThresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .loadThreshold)
        loadThreshold = loadThresholdDecoded
        let alarmsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .alarms)
        var alarmsDecoded0:[String]? = nil
        if let alarmsContainer = alarmsContainer {
            alarmsDecoded0 = [String]()
            for string0 in alarmsContainer {
                if let string0 = string0 {
                    alarmsDecoded0?.append(string0)
                }
            }
        }
        alarms = alarmsDecoded0
    }
}

extension AutoScalingThresholds: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutoScalingThresholds(alarms: \(String(describing: alarms)), cpuThreshold: \(String(describing: cpuThreshold)), ignoreMetricsTime: \(String(describing: ignoreMetricsTime)), instanceCount: \(String(describing: instanceCount)), loadThreshold: \(String(describing: loadThreshold)), memoryThreshold: \(String(describing: memoryThreshold)), thresholdsWaitTime: \(String(describing: thresholdsWaitTime)))"}
}

/// <p>Describes a load-based auto scaling upscaling or downscaling threshold configuration, which specifies when AWS OpsWorks Stacks starts or stops load-based instances.</p>
public struct AutoScalingThresholds: Equatable {
    /// <p>Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names,
    ///           which are case sensitive and must be in the same region as the stack.</p>
    ///          <note>
    ///             <p>To use custom alarms, you must update your service role to allow
    ///         <code>cloudwatch:DescribeAlarms</code>. You can either have AWS OpsWorks Stacks update the role for
    ///       you when you first use this feature or you can edit the role manually. For more information,
    ///       see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/opsworks-security-servicerole.html">Allowing AWS OpsWorks Stacks to Act on Your Behalf</a>.</p>
    ///          </note>
    public let alarms: [String]?
    /// <p>The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.</p>
    public let cpuThreshold: Double?
    /// <p>The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics
    ///       and suppress additional scaling events. For example, AWS OpsWorks Stacks adds new instances following
    ///       an upscaling event but the instances won't start reducing the load until they have been booted
    ///       and configured. There is no point in raising additional scaling events during that operation,
    ///       which typically takes several minutes. <code>IgnoreMetricsTime</code> allows you to direct
    ///       AWS OpsWorks Stacks to suppress scaling events long enough to get the new instances online.</p>
    public let ignoreMetricsTime: Int?
    /// <p>The number of instances to add or remove when the load exceeds a threshold.</p>
    public let instanceCount: Int?
    /// <p>The load threshold. A value of -1 disables the threshold. For more information about how load is computed, see <a href="http://en.wikipedia.org/wiki/Load_%28computing%29">Load (computing)</a>.</p>
    public let loadThreshold: Double?
    /// <p>The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.</p>
    public let memoryThreshold: Double?
    /// <p>The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.</p>
    public let thresholdsWaitTime: Int?

    public init (
        alarms: [String]? = nil,
        cpuThreshold: Double? = nil,
        ignoreMetricsTime: Int? = nil,
        instanceCount: Int? = nil,
        loadThreshold: Double? = nil,
        memoryThreshold: Double? = nil,
        thresholdsWaitTime: Int? = nil
    )
    {
        self.alarms = alarms
        self.cpuThreshold = cpuThreshold
        self.ignoreMetricsTime = ignoreMetricsTime
        self.instanceCount = instanceCount
        self.loadThreshold = loadThreshold
        self.memoryThreshold = memoryThreshold
        self.thresholdsWaitTime = thresholdsWaitTime
    }
}

public enum AutoScalingType {
    case load
    case timer
    case sdkUnknown(String)
}

extension AutoScalingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AutoScalingType] {
        return [
            .load,
            .timer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .load: return "load"
        case .timer: return "timer"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AutoScalingType(rawValue: rawValue) ?? AutoScalingType.sdkUnknown(rawValue)
    }
}

extension BlockDeviceMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceName = "DeviceName"
        case ebs = "Ebs"
        case noDevice = "NoDevice"
        case virtualName = "VirtualName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let ebs = ebs {
            try encodeContainer.encode(ebs, forKey: .ebs)
        }
        if let noDevice = noDevice {
            try encodeContainer.encode(noDevice, forKey: .noDevice)
        }
        if let virtualName = virtualName {
            try encodeContainer.encode(virtualName, forKey: .virtualName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let noDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .noDevice)
        noDevice = noDeviceDecoded
        let virtualNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualName)
        virtualName = virtualNameDecoded
        let ebsDecoded = try containerValues.decodeIfPresent(EbsBlockDevice.self, forKey: .ebs)
        ebs = ebsDecoded
    }
}

extension BlockDeviceMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BlockDeviceMapping(deviceName: \(String(describing: deviceName)), ebs: \(String(describing: ebs)), noDevice: \(String(describing: noDevice)), virtualName: \(String(describing: virtualName)))"}
}

/// <p>Describes a block device mapping. This data type maps directly to the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_BlockDeviceMapping.html">BlockDeviceMapping</a> data type. </p>
public struct BlockDeviceMapping: Equatable {
    /// <p>The device name that is exposed to the instance, such as <code>/dev/sdh</code>. For the root
    ///       device, you can use the explicit device name or you can set this parameter to
    ///         <code>ROOT_DEVICE</code> and AWS OpsWorks Stacks will provide the correct device name.</p>
    public let deviceName: String?
    /// <p>An <code>EBSBlockDevice</code> that defines how to configure an Amazon EBS volume when the
    ///       instance is launched.</p>
    public let ebs: EbsBlockDevice?
    /// <p>Suppresses the specified device included in the AMI's block device mapping.</p>
    public let noDevice: String?
    /// <p>The virtual device name. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_BlockDeviceMapping.html">BlockDeviceMapping</a>.</p>
    public let virtualName: String?

    public init (
        deviceName: String? = nil,
        ebs: EbsBlockDevice? = nil,
        noDevice: String? = nil,
        virtualName: String? = nil
    )
    {
        self.deviceName = deviceName
        self.ebs = ebs
        self.noDevice = noDevice
        self.virtualName = virtualName
    }
}

extension ChefConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case berkshelfVersion = "BerkshelfVersion"
        case manageBerkshelf = "ManageBerkshelf"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let berkshelfVersion = berkshelfVersion {
            try encodeContainer.encode(berkshelfVersion, forKey: .berkshelfVersion)
        }
        if let manageBerkshelf = manageBerkshelf {
            try encodeContainer.encode(manageBerkshelf, forKey: .manageBerkshelf)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manageBerkshelfDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .manageBerkshelf)
        manageBerkshelf = manageBerkshelfDecoded
        let berkshelfVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .berkshelfVersion)
        berkshelfVersion = berkshelfVersionDecoded
    }
}

extension ChefConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChefConfiguration(berkshelfVersion: \(String(describing: berkshelfVersion)), manageBerkshelf: \(String(describing: manageBerkshelf)))"}
}

/// <p>Describes the Chef configuration.</p>
public struct ChefConfiguration: Equatable {
    /// <p>The Berkshelf version.</p>
    public let berkshelfVersion: String?
    /// <p>Whether to enable Berkshelf.</p>
    public let manageBerkshelf: Bool?

    public init (
        berkshelfVersion: String? = nil,
        manageBerkshelf: Bool? = nil
    )
    {
        self.berkshelfVersion = berkshelfVersion
        self.manageBerkshelf = manageBerkshelf
    }
}

public struct CloneStackInputBodyMiddleware: Middleware {
    public let id: String = "CloneStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CloneStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CloneStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CloneStackInput>
    public typealias MOutput = OperationOutput<CloneStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CloneStackOutputError>
}

extension CloneStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloneStackInput(agentVersion: \(String(describing: agentVersion)), attributes: \(String(describing: attributes)), chefConfiguration: \(String(describing: chefConfiguration)), cloneAppIds: \(String(describing: cloneAppIds)), clonePermissions: \(String(describing: clonePermissions)), configurationManager: \(String(describing: configurationManager)), customCookbooksSource: \(String(describing: customCookbooksSource)), customJson: \(String(describing: customJson)), defaultAvailabilityZone: \(String(describing: defaultAvailabilityZone)), defaultInstanceProfileArn: \(String(describing: defaultInstanceProfileArn)), defaultOs: \(String(describing: defaultOs)), defaultRootDeviceType: \(String(describing: defaultRootDeviceType)), defaultSshKeyName: \(String(describing: defaultSshKeyName)), defaultSubnetId: \(String(describing: defaultSubnetId)), hostnameTheme: \(String(describing: hostnameTheme)), name: \(String(describing: name)), region: \(String(describing: region)), serviceRoleArn: \(String(describing: serviceRoleArn)), sourceStackId: \(String(describing: sourceStackId)), useCustomCookbooks: \(String(describing: useCustomCookbooks)), useOpsworksSecurityGroups: \(String(describing: useOpsworksSecurityGroups)), vpcId: \(String(describing: vpcId)))"}
}

extension CloneStackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case cloneAppIds = "CloneAppIds"
        case clonePermissions = "ClonePermissions"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case sourceStackId = "SourceStackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, stackattributes0) in attributes {
                try attributesContainer.encode(stackattributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let chefConfiguration = chefConfiguration {
            try encodeContainer.encode(chefConfiguration, forKey: .chefConfiguration)
        }
        if let cloneAppIds = cloneAppIds {
            var cloneAppIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloneAppIds)
            for strings0 in cloneAppIds {
                try cloneAppIdsContainer.encode(strings0)
            }
        }
        if let clonePermissions = clonePermissions {
            try encodeContainer.encode(clonePermissions, forKey: .clonePermissions)
        }
        if let configurationManager = configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let customCookbooksSource = customCookbooksSource {
            try encodeContainer.encode(customCookbooksSource, forKey: .customCookbooksSource)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let defaultAvailabilityZone = defaultAvailabilityZone {
            try encodeContainer.encode(defaultAvailabilityZone, forKey: .defaultAvailabilityZone)
        }
        if let defaultInstanceProfileArn = defaultInstanceProfileArn {
            try encodeContainer.encode(defaultInstanceProfileArn, forKey: .defaultInstanceProfileArn)
        }
        if let defaultOs = defaultOs {
            try encodeContainer.encode(defaultOs, forKey: .defaultOs)
        }
        if let defaultRootDeviceType = defaultRootDeviceType {
            try encodeContainer.encode(defaultRootDeviceType.rawValue, forKey: .defaultRootDeviceType)
        }
        if let defaultSshKeyName = defaultSshKeyName {
            try encodeContainer.encode(defaultSshKeyName, forKey: .defaultSshKeyName)
        }
        if let defaultSubnetId = defaultSubnetId {
            try encodeContainer.encode(defaultSubnetId, forKey: .defaultSubnetId)
        }
        if let hostnameTheme = hostnameTheme {
            try encodeContainer.encode(hostnameTheme, forKey: .hostnameTheme)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let sourceStackId = sourceStackId {
            try encodeContainer.encode(sourceStackId, forKey: .sourceStackId)
        }
        if let useCustomCookbooks = useCustomCookbooks {
            try encodeContainer.encode(useCustomCookbooks, forKey: .useCustomCookbooks)
        }
        if let useOpsworksSecurityGroups = useOpsworksSecurityGroups {
            try encodeContainer.encode(useOpsworksSecurityGroups, forKey: .useOpsworksSecurityGroups)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

public struct CloneStackInputHeadersMiddleware: Middleware {
    public let id: String = "CloneStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CloneStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CloneStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CloneStackInput>
    public typealias MOutput = OperationOutput<CloneStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CloneStackOutputError>
}

public struct CloneStackInputQueryItemMiddleware: Middleware {
    public let id: String = "CloneStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CloneStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CloneStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CloneStackInput>
    public typealias MOutput = OperationOutput<CloneStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CloneStackOutputError>
}

public struct CloneStackInput: Equatable {
    /// <p>The default AWS OpsWorks Stacks agent version. You have the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Auto-update - Set this parameter to <code>LATEST</code>. AWS OpsWorks Stacks
    ///       automatically installs new agent versions on the stack's instances as soon as
    ///       they are available.</p>
    ///             </li>
    ///             <li>
    ///                <p>Fixed version - Set this parameter to your preferred agent version. To update
    ///              the agent version, you must edit the stack configuration and specify a new version.
    ///              AWS OpsWorks Stacks then automatically installs that version on the stack's instances.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The default setting is <code>LATEST</code>. To specify an agent version,
    ///       you must use the complete version number, not the abbreviated number shown on the console.
    ///       For a list of available agent version numbers, call <a>DescribeAgentVersions</a>. AgentVersion cannot be set to Chef 12.2.</p>
    ///          <note>
    ///             <p>You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.</p>
    ///          </note>
    public let agentVersion: String?
    /// <p>A list of stack attributes and values as key/value pairs to be added to the cloned stack.</p>
    public let attributes: [String:String]?
    /// <p>A <code>ChefConfiguration</code> object that specifies whether to enable Berkshelf and the
    ///       Berkshelf version on Chef 11.10 stacks. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New Stack</a>.</p>
    public let chefConfiguration: ChefConfiguration?
    /// <p>A list of source stack app IDs to be included in the cloned stack.</p>
    public let cloneAppIds: [String]?
    /// <p>Whether to clone the source stack's permissions.</p>
    public let clonePermissions: Bool?
    /// <p>The configuration manager. When you clone a stack we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.</p>
    public let configurationManager: StackConfigurationManager?
    /// <p>Contains the information required to retrieve an app or cookbook from a repository. For more information,
    ///             see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html">Adding Apps</a> or <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html">Cookbooks and Recipes</a>.</p>
    public let customCookbooksSource: Source?
    /// <p>A string that contains user-defined, custom JSON. It is used to override the corresponding default stack configuration JSON values. The string should be in the following format:</p>
    ///          <p>
    ///             <code>"{\"key1\": \"value1\", \"key2\": \"value2\",...}"</code>
    ///          </p>
    ///          <p>For more information about custom JSON, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html">Use Custom JSON to
    ///         Modify the Stack Configuration Attributes</a>
    ///          </p>
    public let customJson: String?
    /// <p>The cloned stack's default Availability Zone, which must be in the specified region. For more
    ///       information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and
    ///         Endpoints</a>. If you also specify a value for <code>DefaultSubnetId</code>, the subnet must
    ///       be in the same zone. For more information, see the <code>VpcId</code> parameter description.
    ///     </p>
    public let defaultAvailabilityZone: String?
    /// <p>The Amazon Resource Name (ARN) of an IAM profile that is the default profile for all of the stack's EC2 instances.
    ///       For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers</a>.</p>
    public let defaultInstanceProfileArn: String?
    /// <p>The stack's operating system, which must be set to one of the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>A supported Linux operating system: An Amazon Linux version, such as <code>Amazon Linux 2018.03</code>, <code>Amazon Linux 2017.09</code>, <code>Amazon Linux 2017.03</code>, <code>Amazon Linux
    ///         2016.09</code>, <code>Amazon Linux 2016.03</code>, <code>Amazon Linux 2015.09</code>, or <code>Amazon Linux 2015.03</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>A supported Ubuntu operating system, such as <code>Ubuntu 16.04 LTS</code>, <code>Ubuntu 14.04 LTS</code>, or <code>Ubuntu 12.04 LTS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CentOS Linux 7</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Red Hat Enterprise Linux 7</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Microsoft Windows Server 2012 R2 Base</code>, <code>Microsoft Windows Server 2012 R2 with SQL Server Express</code>,
    ///               <code>Microsoft Windows Server 2012 R2 with SQL Server Standard</code>, or <code>Microsoft Windows Server 2012 R2 with SQL Server Web</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>A custom AMI: <code>Custom</code>. You specify the custom AMI you want to use when
    ///         you create instances. For more information about how to use custom AMIs with OpsWorks, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">Using
    ///           Custom AMIs</a>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The default option is the parent stack's operating system.
    ///       For more information about supported operating systems,
    ///       see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">AWS OpsWorks Stacks Operating Systems</a>.</p>
    ///          <note>
    ///             <p>You can specify a different Linux operating system for the cloned stack, but you cannot change from Linux to Windows or Windows to Linux.</p>
    ///          </note>
    public let defaultOs: String?
    /// <p>The default root device type. This value is used by default for all instances in the cloned
    ///       stack, but you can override it when you create an instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device">Storage for the Root Device</a>.</p>
    public let defaultRootDeviceType: RootDeviceType?
    /// <p>A default Amazon EC2 key pair name. The default value is none. If you specify a key pair name, AWS
    ///       OpsWorks installs the public key on the instance and you can use the private key with an SSH
    ///       client to log in to the instance. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-ssh.html"> Using SSH to
    ///         Communicate with an Instance</a> and <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/security-ssh-access.html"> Managing SSH
    ///         Access</a>. You can override this setting by specifying a different key pair, or no key
    ///       pair, when you <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-add.html">
    ///         create an instance</a>. </p>
    public let defaultSshKeyName: String?
    /// <p>The stack's default VPC subnet ID. This parameter is required if you specify a value for the
    ///         <code>VpcId</code> parameter. All instances are launched into this subnet unless you specify
    ///       otherwise when you create the instance. If you also specify a value for
    ///         <code>DefaultAvailabilityZone</code>, the subnet must be in that zone. For information on
    ///       default values and when this parameter is required, see the <code>VpcId</code> parameter
    ///       description. </p>
    public let defaultSubnetId: String?
    /// <p>The stack's host name theme, with spaces are replaced by underscores. The theme is used to
    ///       generate host names for the stack's instances. By default, <code>HostnameTheme</code> is set
    ///       to <code>Layer_Dependent</code>, which creates host names by appending integers to the layer's
    ///       short name. The other themes are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Baked_Goods</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Clouds</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Europe_Cities</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fruits</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Greek_Deities_and_Titans</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Legendary_creatures_from_Japan</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Planets_and_Moons</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Roman_Deities</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Scottish_Islands</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>US_Cities</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Wild_Cats</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To obtain a generated host name, call <code>GetHostNameSuggestion</code>, which returns a
    ///       host name based on the current theme.</p>
    public let hostnameTheme: String?
    /// <p>The cloned stack name.</p>
    public let name: String?
    /// <p>The cloned stack AWS region, such as "ap-northeast-2". For more information about AWS regions, see
    ///         <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints</a>.</p>
    public let region: String?
    /// <p>The stack AWS Identity and Access Management (IAM) role, which allows AWS OpsWorks Stacks to work with AWS
    ///       resources on your behalf. You must set this parameter to the Amazon Resource Name (ARN) for an
    ///       existing IAM role. If you create a stack by using the AWS OpsWorks Stacks console, it creates the role for
    ///       you. You can obtain an existing stack's IAM ARN programmatically by calling
    ///         <a>DescribePermissions</a>. For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers</a>.</p>
    ///          <note>
    ///             <p>You must set this parameter to a valid service role ARN or the action will fail; there is no default value. You can specify the source stack's service role ARN, if you prefer, but you must do so explicitly.</p>
    ///          </note>
    public let serviceRoleArn: String?
    /// <p>The source stack ID.</p>
    public let sourceStackId: String?
    /// <p>Whether to use custom cookbooks.</p>
    public let useCustomCookbooks: Bool?
    /// <p>Whether to associate the AWS OpsWorks Stacks built-in security groups with the stack's layers.</p>
    ///          <p>AWS OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are
    ///       associated with layers by default. With <code>UseOpsworksSecurityGroups</code> you can instead
    ///       provide your own custom security groups. <code>UseOpsworksSecurityGroups</code> has the
    ///       following settings: </p>
    ///          <ul>
    ///             <li>
    ///                <p>True - AWS OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it but you cannot delete the built-in security group.</p>
    ///             </li>
    ///             <li>
    ///                <p>False - AWS OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate Amazon Elastic Compute Cloud (Amazon EC2) security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on creation; custom security groups are required only for those layers that need custom settings.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New
    ///         Stack</a>.</p>
    public let useOpsworksSecurityGroups: Bool?
    /// <p>The ID of the VPC that the cloned stack is to be launched into. It must be in the specified region. All
    ///           instances are launched into this VPC, and you cannot change the ID later.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If your account supports EC2 Classic, the default value is no VPC.</p>
    ///             </li>
    ///             <li>
    ///                <p>If your account does not support EC2 Classic, the default value is the default VPC for the specified region.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If the VPC ID corresponds to a default VPC and you have specified either the
    ///         <code>DefaultAvailabilityZone</code> or the <code>DefaultSubnetId</code> parameter only,
    ///       AWS OpsWorks Stacks infers the value of the other parameter. If you specify neither parameter, AWS OpsWorks Stacks sets
    ///       these parameters to the first valid Availability Zone for the specified region and the
    ///       corresponding default VPC subnet ID, respectively. </p>
    ///          <p>If you specify a nondefault VPC ID, note the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>It must belong to a VPC in your account that is in the specified region.</p>
    ///             </li>
    ///             <li>
    ///                <p>You must specify a value for <code>DefaultSubnetId</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about how to use AWS OpsWorks Stacks with a VPC, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-vpc.html">Running a Stack in a
    ///         VPC</a>. For more information about default VPC and EC2 Classic, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported
    ///         Platforms</a>. </p>
    public let vpcId: String?

    public init (
        agentVersion: String? = nil,
        attributes: [String:String]? = nil,
        chefConfiguration: ChefConfiguration? = nil,
        cloneAppIds: [String]? = nil,
        clonePermissions: Bool? = nil,
        configurationManager: StackConfigurationManager? = nil,
        customCookbooksSource: Source? = nil,
        customJson: String? = nil,
        defaultAvailabilityZone: String? = nil,
        defaultInstanceProfileArn: String? = nil,
        defaultOs: String? = nil,
        defaultRootDeviceType: RootDeviceType? = nil,
        defaultSshKeyName: String? = nil,
        defaultSubnetId: String? = nil,
        hostnameTheme: String? = nil,
        name: String? = nil,
        region: String? = nil,
        serviceRoleArn: String? = nil,
        sourceStackId: String? = nil,
        useCustomCookbooks: Bool? = nil,
        useOpsworksSecurityGroups: Bool? = nil,
        vpcId: String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.cloneAppIds = cloneAppIds
        self.clonePermissions = clonePermissions
        self.configurationManager = configurationManager
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.region = region
        self.serviceRoleArn = serviceRoleArn
        self.sourceStackId = sourceStackId
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
        self.vpcId = vpcId
    }
}

struct CloneStackInputBody: Equatable {
    public let sourceStackId: String?
    public let name: String?
    public let region: String?
    public let vpcId: String?
    public let attributes: [String:String]?
    public let serviceRoleArn: String?
    public let defaultInstanceProfileArn: String?
    public let defaultOs: String?
    public let hostnameTheme: String?
    public let defaultAvailabilityZone: String?
    public let defaultSubnetId: String?
    public let customJson: String?
    public let configurationManager: StackConfigurationManager?
    public let chefConfiguration: ChefConfiguration?
    public let useCustomCookbooks: Bool?
    public let useOpsworksSecurityGroups: Bool?
    public let customCookbooksSource: Source?
    public let defaultSshKeyName: String?
    public let clonePermissions: Bool?
    public let cloneAppIds: [String]?
    public let defaultRootDeviceType: RootDeviceType?
    public let agentVersion: String?
}

extension CloneStackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case cloneAppIds = "CloneAppIds"
        case clonePermissions = "ClonePermissions"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case sourceStackId = "SourceStackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceStackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceStackId)
        sourceStackId = sourceStackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let defaultInstanceProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultInstanceProfileArn)
        defaultInstanceProfileArn = defaultInstanceProfileArnDecoded
        let defaultOsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultOs)
        defaultOs = defaultOsDecoded
        let hostnameThemeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostnameTheme)
        hostnameTheme = hostnameThemeDecoded
        let defaultAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAvailabilityZone)
        defaultAvailabilityZone = defaultAvailabilityZoneDecoded
        let defaultSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubnetId)
        defaultSubnetId = defaultSubnetIdDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
        let chefConfigurationDecoded = try containerValues.decodeIfPresent(ChefConfiguration.self, forKey: .chefConfiguration)
        chefConfiguration = chefConfigurationDecoded
        let useCustomCookbooksDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useCustomCookbooks)
        useCustomCookbooks = useCustomCookbooksDecoded
        let useOpsworksSecurityGroupsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useOpsworksSecurityGroups)
        useOpsworksSecurityGroups = useOpsworksSecurityGroupsDecoded
        let customCookbooksSourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .customCookbooksSource)
        customCookbooksSource = customCookbooksSourceDecoded
        let defaultSshKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSshKeyName)
        defaultSshKeyName = defaultSshKeyNameDecoded
        let clonePermissionsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .clonePermissions)
        clonePermissions = clonePermissionsDecoded
        let cloneAppIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cloneAppIds)
        var cloneAppIdsDecoded0:[String]? = nil
        if let cloneAppIdsContainer = cloneAppIdsContainer {
            cloneAppIdsDecoded0 = [String]()
            for string0 in cloneAppIdsContainer {
                if let string0 = string0 {
                    cloneAppIdsDecoded0?.append(string0)
                }
            }
        }
        cloneAppIds = cloneAppIdsDecoded0
        let defaultRootDeviceTypeDecoded = try containerValues.decodeIfPresent(RootDeviceType.self, forKey: .defaultRootDeviceType)
        defaultRootDeviceType = defaultRootDeviceTypeDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension CloneStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CloneStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CloneStackOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CloneStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloneStackOutputResponse(stackId: \(String(describing: stackId)))"}
}

extension CloneStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloneStackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackId = output.stackId
        } else {
            self.stackId = nil
        }
    }
}

/// <p>Contains the response to a <code>CloneStack</code> request.</p>
public struct CloneStackOutputResponse: Equatable {
    /// <p>The cloned stack ID.</p>
    public let stackId: String?

    public init (
        stackId: String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct CloneStackOutputResponseBody: Equatable {
    public let stackId: String?
}

extension CloneStackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension CloudWatchLogsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case logStreams = "LogStreams"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let logStreams = logStreams {
            var logStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logStreams)
            for cloudwatchlogslogstreams0 in logStreams {
                try logStreamsContainer.encode(cloudwatchlogslogstreams0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logStreamsContainer = try containerValues.decodeIfPresent([CloudWatchLogsLogStream?].self, forKey: .logStreams)
        var logStreamsDecoded0:[CloudWatchLogsLogStream]? = nil
        if let logStreamsContainer = logStreamsContainer {
            logStreamsDecoded0 = [CloudWatchLogsLogStream]()
            for structure0 in logStreamsContainer {
                if let structure0 = structure0 {
                    logStreamsDecoded0?.append(structure0)
                }
            }
        }
        logStreams = logStreamsDecoded0
    }
}

extension CloudWatchLogsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLogsConfiguration(enabled: \(String(describing: enabled)), logStreams: \(String(describing: logStreams)))"}
}

/// <p>Describes the Amazon CloudWatch logs configuration for a layer.</p>
public struct CloudWatchLogsConfiguration: Equatable {
    /// <p>Whether CloudWatch Logs is enabled for a layer.</p>
    public let enabled: Bool?
    /// <p>A list of configuration options for CloudWatch Logs.</p>
    public let logStreams: [CloudWatchLogsLogStream]?

    public init (
        enabled: Bool? = nil,
        logStreams: [CloudWatchLogsLogStream]? = nil
    )
    {
        self.enabled = enabled
        self.logStreams = logStreams
    }
}

/// <p>Specifies the encoding of the log file so that the file can be read correctly. The default is <code>utf_8</code>. Encodings supported by Python <code>codecs.decode()</code> can be used here.</p>
public enum CloudWatchLogsEncoding {
    case ascii
    case big5
    case big5hkscs
    case cp037
    case cp1006
    case cp1026
    case cp1140
    case cp1250
    case cp1251
    case cp1252
    case cp1253
    case cp1254
    case cp1255
    case cp1256
    case cp1257
    case cp1258
    case cp424
    case cp437
    case cp500
    case cp720
    case cp737
    case cp775
    case cp850
    case cp852
    case cp855
    case cp856
    case cp857
    case cp858
    case cp860
    case cp861
    case cp862
    case cp863
    case cp864
    case cp865
    case cp866
    case cp869
    case cp874
    case cp875
    case cp932
    case cp949
    case cp950
    case eucJis2004
    case eucJisx0213
    case eucJp
    case eucKr
    case gb18030
    case gb2312
    case gbk
    case hz
    case iso2022Jp
    case iso2022Jp1
    case iso2022Jp2
    case iso2022Jp2004
    case iso2022Jp3
    case iso2022JpExt
    case iso2022Kr
    case iso885910
    case iso885913
    case iso885914
    case iso885915
    case iso885916
    case iso88592
    case iso88593
    case iso88594
    case iso88595
    case iso88596
    case iso88597
    case iso88598
    case iso88599
    case johab
    case koi8R
    case koi8U
    case latin1
    case macCyrillic
    case macGreek
    case macIceland
    case macLatin2
    case macRoman
    case macTurkish
    case ptcp154
    case shiftJis
    case shiftJis2004
    case shiftJisx0213
    case utf16
    case utf16Be
    case utf16Le
    case utf32
    case utf32Be
    case utf32Le
    case utf7
    case utf8
    case utf8Sig
    case sdkUnknown(String)
}

extension CloudWatchLogsEncoding : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CloudWatchLogsEncoding] {
        return [
            .ascii,
            .big5,
            .big5hkscs,
            .cp037,
            .cp1006,
            .cp1026,
            .cp1140,
            .cp1250,
            .cp1251,
            .cp1252,
            .cp1253,
            .cp1254,
            .cp1255,
            .cp1256,
            .cp1257,
            .cp1258,
            .cp424,
            .cp437,
            .cp500,
            .cp720,
            .cp737,
            .cp775,
            .cp850,
            .cp852,
            .cp855,
            .cp856,
            .cp857,
            .cp858,
            .cp860,
            .cp861,
            .cp862,
            .cp863,
            .cp864,
            .cp865,
            .cp866,
            .cp869,
            .cp874,
            .cp875,
            .cp932,
            .cp949,
            .cp950,
            .eucJis2004,
            .eucJisx0213,
            .eucJp,
            .eucKr,
            .gb18030,
            .gb2312,
            .gbk,
            .hz,
            .iso2022Jp,
            .iso2022Jp1,
            .iso2022Jp2,
            .iso2022Jp2004,
            .iso2022Jp3,
            .iso2022JpExt,
            .iso2022Kr,
            .iso885910,
            .iso885913,
            .iso885914,
            .iso885915,
            .iso885916,
            .iso88592,
            .iso88593,
            .iso88594,
            .iso88595,
            .iso88596,
            .iso88597,
            .iso88598,
            .iso88599,
            .johab,
            .koi8R,
            .koi8U,
            .latin1,
            .macCyrillic,
            .macGreek,
            .macIceland,
            .macLatin2,
            .macRoman,
            .macTurkish,
            .ptcp154,
            .shiftJis,
            .shiftJis2004,
            .shiftJisx0213,
            .utf16,
            .utf16Be,
            .utf16Le,
            .utf32,
            .utf32Be,
            .utf32Le,
            .utf7,
            .utf8,
            .utf8Sig,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascii: return "ascii"
        case .big5: return "big5"
        case .big5hkscs: return "big5hkscs"
        case .cp037: return "cp037"
        case .cp1006: return "cp1006"
        case .cp1026: return "cp1026"
        case .cp1140: return "cp1140"
        case .cp1250: return "cp1250"
        case .cp1251: return "cp1251"
        case .cp1252: return "cp1252"
        case .cp1253: return "cp1253"
        case .cp1254: return "cp1254"
        case .cp1255: return "cp1255"
        case .cp1256: return "cp1256"
        case .cp1257: return "cp1257"
        case .cp1258: return "cp1258"
        case .cp424: return "cp424"
        case .cp437: return "cp437"
        case .cp500: return "cp500"
        case .cp720: return "cp720"
        case .cp737: return "cp737"
        case .cp775: return "cp775"
        case .cp850: return "cp850"
        case .cp852: return "cp852"
        case .cp855: return "cp855"
        case .cp856: return "cp856"
        case .cp857: return "cp857"
        case .cp858: return "cp858"
        case .cp860: return "cp860"
        case .cp861: return "cp861"
        case .cp862: return "cp862"
        case .cp863: return "cp863"
        case .cp864: return "cp864"
        case .cp865: return "cp865"
        case .cp866: return "cp866"
        case .cp869: return "cp869"
        case .cp874: return "cp874"
        case .cp875: return "cp875"
        case .cp932: return "cp932"
        case .cp949: return "cp949"
        case .cp950: return "cp950"
        case .eucJis2004: return "euc_jis_2004"
        case .eucJisx0213: return "euc_jisx0213"
        case .eucJp: return "euc_jp"
        case .eucKr: return "euc_kr"
        case .gb18030: return "gb18030"
        case .gb2312: return "gb2312"
        case .gbk: return "gbk"
        case .hz: return "hz"
        case .iso2022Jp: return "iso2022_jp"
        case .iso2022Jp1: return "iso2022_jp_1"
        case .iso2022Jp2: return "iso2022_jp_2"
        case .iso2022Jp2004: return "iso2022_jp_2004"
        case .iso2022Jp3: return "iso2022_jp_3"
        case .iso2022JpExt: return "iso2022_jp_ext"
        case .iso2022Kr: return "iso2022_kr"
        case .iso885910: return "iso8859_10"
        case .iso885913: return "iso8859_13"
        case .iso885914: return "iso8859_14"
        case .iso885915: return "iso8859_15"
        case .iso885916: return "iso8859_16"
        case .iso88592: return "iso8859_2"
        case .iso88593: return "iso8859_3"
        case .iso88594: return "iso8859_4"
        case .iso88595: return "iso8859_5"
        case .iso88596: return "iso8859_6"
        case .iso88597: return "iso8859_7"
        case .iso88598: return "iso8859_8"
        case .iso88599: return "iso8859_9"
        case .johab: return "johab"
        case .koi8R: return "koi8_r"
        case .koi8U: return "koi8_u"
        case .latin1: return "latin_1"
        case .macCyrillic: return "mac_cyrillic"
        case .macGreek: return "mac_greek"
        case .macIceland: return "mac_iceland"
        case .macLatin2: return "mac_latin2"
        case .macRoman: return "mac_roman"
        case .macTurkish: return "mac_turkish"
        case .ptcp154: return "ptcp154"
        case .shiftJis: return "shift_jis"
        case .shiftJis2004: return "shift_jis_2004"
        case .shiftJisx0213: return "shift_jisx0213"
        case .utf16: return "utf_16"
        case .utf16Be: return "utf_16_be"
        case .utf16Le: return "utf_16_le"
        case .utf32: return "utf_32"
        case .utf32Be: return "utf_32_be"
        case .utf32Le: return "utf_32_le"
        case .utf7: return "utf_7"
        case .utf8: return "utf_8"
        case .utf8Sig: return "utf_8_sig"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CloudWatchLogsEncoding(rawValue: rawValue) ?? CloudWatchLogsEncoding.sdkUnknown(rawValue)
    }
}

/// <p>Specifies where to start to read data (start_of_file or end_of_file). The default is start_of_file. It's only used if there is no state persisted for that log stream.</p>
public enum CloudWatchLogsInitialPosition {
    case endOfFile
    case startOfFile
    case sdkUnknown(String)
}

extension CloudWatchLogsInitialPosition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CloudWatchLogsInitialPosition] {
        return [
            .endOfFile,
            .startOfFile,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .endOfFile: return "end_of_file"
        case .startOfFile: return "start_of_file"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CloudWatchLogsInitialPosition(rawValue: rawValue) ?? CloudWatchLogsInitialPosition.sdkUnknown(rawValue)
    }
}

extension CloudWatchLogsLogStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchCount = "BatchCount"
        case batchSize = "BatchSize"
        case bufferDuration = "BufferDuration"
        case datetimeFormat = "DatetimeFormat"
        case encoding = "Encoding"
        case file = "File"
        case fileFingerprintLines = "FileFingerprintLines"
        case initialPosition = "InitialPosition"
        case logGroupName = "LogGroupName"
        case multiLineStartPattern = "MultiLineStartPattern"
        case timeZone = "TimeZone"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchCount = batchCount {
            try encodeContainer.encode(batchCount, forKey: .batchCount)
        }
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bufferDuration = bufferDuration {
            try encodeContainer.encode(bufferDuration, forKey: .bufferDuration)
        }
        if let datetimeFormat = datetimeFormat {
            try encodeContainer.encode(datetimeFormat, forKey: .datetimeFormat)
        }
        if let encoding = encoding {
            try encodeContainer.encode(encoding.rawValue, forKey: .encoding)
        }
        if let file = file {
            try encodeContainer.encode(file, forKey: .file)
        }
        if let fileFingerprintLines = fileFingerprintLines {
            try encodeContainer.encode(fileFingerprintLines, forKey: .fileFingerprintLines)
        }
        if let initialPosition = initialPosition {
            try encodeContainer.encode(initialPosition.rawValue, forKey: .initialPosition)
        }
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let multiLineStartPattern = multiLineStartPattern {
            try encodeContainer.encode(multiLineStartPattern, forKey: .multiLineStartPattern)
        }
        if let timeZone = timeZone {
            try encodeContainer.encode(timeZone.rawValue, forKey: .timeZone)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let datetimeFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datetimeFormat)
        datetimeFormat = datetimeFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(CloudWatchLogsTimeZone.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let fileDecoded = try containerValues.decodeIfPresent(String.self, forKey: .file)
        file = fileDecoded
        let fileFingerprintLinesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileFingerprintLines)
        fileFingerprintLines = fileFingerprintLinesDecoded
        let multiLineStartPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .multiLineStartPattern)
        multiLineStartPattern = multiLineStartPatternDecoded
        let initialPositionDecoded = try containerValues.decodeIfPresent(CloudWatchLogsInitialPosition.self, forKey: .initialPosition)
        initialPosition = initialPositionDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(CloudWatchLogsEncoding.self, forKey: .encoding)
        encoding = encodingDecoded
        let bufferDurationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .bufferDuration)
        bufferDuration = bufferDurationDecoded
        let batchCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .batchCount)
        batchCount = batchCountDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
    }
}

extension CloudWatchLogsLogStream: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLogsLogStream(batchCount: \(String(describing: batchCount)), batchSize: \(String(describing: batchSize)), bufferDuration: \(String(describing: bufferDuration)), datetimeFormat: \(String(describing: datetimeFormat)), encoding: \(String(describing: encoding)), file: \(String(describing: file)), fileFingerprintLines: \(String(describing: fileFingerprintLines)), initialPosition: \(String(describing: initialPosition)), logGroupName: \(String(describing: logGroupName)), multiLineStartPattern: \(String(describing: multiLineStartPattern)), timeZone: \(String(describing: timeZone)))"}
}

/// <p>Describes the Amazon CloudWatch logs configuration for a layer. For detailed information about members of this data type, see the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html">CloudWatch Logs Agent Reference</a>.</p>
public struct CloudWatchLogsLogStream: Equatable {
    /// <p>Specifies the max number of log events in a batch, up to 10000. The default value is 1000.</p>
    public let batchCount: Int?
    /// <p>Specifies the maximum size of log events in a batch, in bytes, up to 1048576 bytes.
    ///             The default value is 32768 bytes. This size is calculated as the sum of all event messages
    ///             in UTF-8, plus 26 bytes for each log event.</p>
    public let batchSize: Int?
    /// <p>Specifies the time duration for the batching of log events. The minimum value is 5000ms and default value is 5000ms.</p>
    public let bufferDuration: Int?
    /// <p>Specifies how the time stamp is extracted from logs. For more information, see the
    ///             <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html">CloudWatch Logs Agent Reference</a>.</p>
    public let datetimeFormat: String?
    /// <p>Specifies the encoding of the log file so that the file can be read correctly.
    ///             The default is <code>utf_8</code>. Encodings supported by Python <code>codecs.decode()</code> can be used here.</p>
    public let encoding: CloudWatchLogsEncoding?
    /// <p>Specifies log files that you want to push to CloudWatch Logs.</p>
    ///         <p>
    ///             <code>File</code> can point to a specific file or multiple files (by using wild card characters such as <code>/var/log/system.log*</code>).
    ///             Only the latest file is pushed to CloudWatch Logs, based on file modification time. We recommend that you use wild card characters to specify a series
    ///             of files of the same type, such as <code>access_log.2014-06-01-01</code>, <code>access_log.2014-06-01-02</code>, and so on
    ///             by using a pattern like <code>access_log.*</code>. Don't use a wildcard to match multiple file types,
    ///             such as <code>access_log_80</code> and <code>access_log_443</code>. To specify multiple, different file types, add another
    ///             log stream entry to the configuration file, so that each log file type is stored in a different log group.</p>
    ///         <p>Zipped files are not supported.</p>
    public let file: String?
    /// <p>Specifies the range of lines for identifying a file. The valid values are one number, or two dash-delimited numbers,
    ///             such as '1', '2-5'. The default value is '1', meaning the first line is used to calculate the fingerprint. Fingerprint lines are
    ///             not sent to CloudWatch Logs unless all specified lines are available.</p>
    public let fileFingerprintLines: String?
    /// <p>Specifies where to start to read data (start_of_file or end_of_file). The default is start_of_file.
    ///             This setting is only used if there is no state persisted for that log stream.</p>
    public let initialPosition: CloudWatchLogsInitialPosition?
    /// <p>Specifies the destination log group. A log group is created automatically if it doesn't already exist.
    ///             Log group names can be between 1 and 512 characters long. Allowed characters include a-z, A-Z, 0-9, '_' (underscore),
    ///             '-' (hyphen), '/' (forward slash), and '.' (period).</p>
    public let logGroupName: String?
    /// <p>Specifies the pattern for identifying the start of a log message.</p>
    public let multiLineStartPattern: String?
    /// <p>Specifies the time zone of log event time stamps.</p>
    public let timeZone: CloudWatchLogsTimeZone?

    public init (
        batchCount: Int? = nil,
        batchSize: Int? = nil,
        bufferDuration: Int? = nil,
        datetimeFormat: String? = nil,
        encoding: CloudWatchLogsEncoding? = nil,
        file: String? = nil,
        fileFingerprintLines: String? = nil,
        initialPosition: CloudWatchLogsInitialPosition? = nil,
        logGroupName: String? = nil,
        multiLineStartPattern: String? = nil,
        timeZone: CloudWatchLogsTimeZone? = nil
    )
    {
        self.batchCount = batchCount
        self.batchSize = batchSize
        self.bufferDuration = bufferDuration
        self.datetimeFormat = datetimeFormat
        self.encoding = encoding
        self.file = file
        self.fileFingerprintLines = fileFingerprintLines
        self.initialPosition = initialPosition
        self.logGroupName = logGroupName
        self.multiLineStartPattern = multiLineStartPattern
        self.timeZone = timeZone
    }
}

/// <p>The preferred time zone for logs streamed to CloudWatch Logs. Valid values are <code>LOCAL</code> and <code>UTC</code>, for Coordinated Universal Time.</p>
public enum CloudWatchLogsTimeZone {
    case local
    case utc
    case sdkUnknown(String)
}

extension CloudWatchLogsTimeZone : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CloudWatchLogsTimeZone] {
        return [
            .local,
            .utc,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .local: return "LOCAL"
        case .utc: return "UTC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CloudWatchLogsTimeZone(rawValue: rawValue) ?? CloudWatchLogsTimeZone.sdkUnknown(rawValue)
    }
}

extension Command: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acknowledgedAt = "AcknowledgedAt"
        case commandId = "CommandId"
        case completedAt = "CompletedAt"
        case createdAt = "CreatedAt"
        case deploymentId = "DeploymentId"
        case exitCode = "ExitCode"
        case instanceId = "InstanceId"
        case logUrl = "LogUrl"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgedAt = acknowledgedAt {
            try encodeContainer.encode(acknowledgedAt, forKey: .acknowledgedAt)
        }
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let completedAt = completedAt {
            try encodeContainer.encode(completedAt, forKey: .completedAt)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let exitCode = exitCode {
            try encodeContainer.encode(exitCode, forKey: .exitCode)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let logUrl = logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let acknowledgedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acknowledgedAt)
        acknowledgedAt = acknowledgedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let exitCodeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .exitCode)
        exitCode = exitCodeDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension Command: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Command(acknowledgedAt: \(String(describing: acknowledgedAt)), commandId: \(String(describing: commandId)), completedAt: \(String(describing: completedAt)), createdAt: \(String(describing: createdAt)), deploymentId: \(String(describing: deploymentId)), exitCode: \(String(describing: exitCode)), instanceId: \(String(describing: instanceId)), logUrl: \(String(describing: logUrl)), status: \(String(describing: status)), type: \(String(describing: type)))"}
}

/// <p>Describes a command.</p>
public struct Command: Equatable {
    /// <p>Date and time when the command was acknowledged.</p>
    public let acknowledgedAt: String?
    /// <p>The command ID.</p>
    public let commandId: String?
    /// <p>Date when the command completed.</p>
    public let completedAt: String?
    /// <p>Date and time when the command was run.</p>
    public let createdAt: String?
    /// <p>The command deployment ID.</p>
    public let deploymentId: String?
    /// <p>The command exit code.</p>
    public let exitCode: Int?
    /// <p>The ID of the instance where the command was executed.</p>
    public let instanceId: String?
    /// <p>The URL of the command log.</p>
    public let logUrl: String?
    /// <p>The command status:</p>
    ///          <ul>
    ///             <li>
    ///                <p>failed</p>
    ///             </li>
    ///             <li>
    ///                <p>successful</p>
    ///             </li>
    ///             <li>
    ///                <p>skipped</p>
    ///             </li>
    ///             <li>
    ///                <p>pending</p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The command type:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>configure</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deploy</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>execute_recipes</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>install_dependencies</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>restart</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rollback</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>setup</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>start</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>stop</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>undeploy</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>update_custom_cookbooks</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>update_dependencies</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let type: String?

    public init (
        acknowledgedAt: String? = nil,
        commandId: String? = nil,
        completedAt: String? = nil,
        createdAt: String? = nil,
        deploymentId: String? = nil,
        exitCode: Int? = nil,
        instanceId: String? = nil,
        logUrl: String? = nil,
        status: String? = nil,
        type: String? = nil
    )
    {
        self.acknowledgedAt = acknowledgedAt
        self.commandId = commandId
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.deploymentId = deploymentId
        self.exitCode = exitCode
        self.instanceId = instanceId
        self.logUrl = logUrl
        self.status = status
        self.type = type
    }
}

public struct CreateAppInputBodyMiddleware: Middleware {
    public let id: String = "CreateAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppInput>
    public typealias MOutput = OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppOutputError>
}

extension CreateAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAppInput(appSource: \(String(describing: appSource)), attributes: \(String(describing: attributes)), dataSources: \(String(describing: dataSources)), description: \(String(describing: description)), domains: \(String(describing: domains)), enableSsl: \(String(describing: enableSsl)), environment: \(String(describing: environment)), name: \(String(describing: name)), shortname: \(String(describing: shortname)), sslConfiguration: \(String(describing: sslConfiguration)), stackId: \(String(describing: stackId)), type: \(String(describing: type)))"}
}

extension CreateAppInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appSource = "AppSource"
        case attributes = "Attributes"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case shortname = "Shortname"
        case sslConfiguration = "SslConfiguration"
        case stackId = "StackId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSource = appSource {
            try encodeContainer.encode(appSource, forKey: .appSource)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, appattributes0) in attributes {
                try attributesContainer.encode(appattributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasources0 in dataSources {
                try dataSourcesContainer.encode(datasources0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for strings0 in domains {
                try domainsContainer.encode(strings0)
            }
        }
        if let enableSsl = enableSsl {
            try encodeContainer.encode(enableSsl, forKey: .enableSsl)
        }
        if let environment = environment {
            var environmentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environment)
            for environmentvariables0 in environment {
                try environmentContainer.encode(environmentvariables0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let shortname = shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let sslConfiguration = sslConfiguration {
            try encodeContainer.encode(sslConfiguration, forKey: .sslConfiguration)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateAppInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppInput>
    public typealias MOutput = OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppOutputError>
}

public struct CreateAppInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppInput>
    public typealias MOutput = OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppOutputError>
}

public struct CreateAppInput: Equatable {
    /// <p>A <code>Source</code> object that specifies the app repository.</p>
    public let appSource: Source?
    /// <p>One or more user-defined key/value pairs to be added to the stack attributes.</p>
    public let attributes: [String:String]?
    /// <p>The app's data source.</p>
    public let dataSources: [DataSource]?
    /// <p>A description of the app.</p>
    public let description: String?
    /// <p>The app virtual host settings, with multiple domains separated by commas. For example:
    ///         <code>'www.example.com, example.com'</code>
    ///          </p>
    public let domains: [String]?
    /// <p>Whether to enable SSL for the app.</p>
    public let enableSsl: Bool?
    /// <p>An array of <code>EnvironmentVariable</code> objects that specify environment variables to be
    ///       associated with the app. After you deploy the app, these variables are defined on the
    ///       associated app server instance. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-environment"> Environment Variables</a>.</p>
    ///          <p>There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variables' names, values, and protected flag values - cannot exceed 20 KB. This limit should accommodate most if not all use cases. Exceeding it will cause an exception with the message, "Environment: is too large (maximum is 20KB)."</p>
    ///          <note>
    ///             <p>If you have specified one or more environment variables, you cannot modify the stack's Chef version.</p>
    ///          </note>
    public let environment: [EnvironmentVariable]?
    /// <p>The app name.</p>
    public let name: String?
    /// <p>The app's short name.</p>
    public let shortname: String?
    /// <p>An <code>SslConfiguration</code> object with the SSL configuration.</p>
    public let sslConfiguration: SslConfiguration?
    /// <p>The stack ID.</p>
    public let stackId: String?
    /// <p>The app type. Each supported type is associated with a particular layer. For example, PHP
    ///       applications are associated with a PHP layer. AWS OpsWorks Stacks deploys an application to those instances
    ///       that are members of the corresponding layer. If your app isn't one of the standard types, or
    ///       you prefer to implement your own Deploy recipes, specify <code>other</code>.</p>
    public let type: AppType?

    public init (
        appSource: Source? = nil,
        attributes: [String:String]? = nil,
        dataSources: [DataSource]? = nil,
        description: String? = nil,
        domains: [String]? = nil,
        enableSsl: Bool? = nil,
        environment: [EnvironmentVariable]? = nil,
        name: String? = nil,
        shortname: String? = nil,
        sslConfiguration: SslConfiguration? = nil,
        stackId: String? = nil,
        type: AppType? = nil
    )
    {
        self.appSource = appSource
        self.attributes = attributes
        self.dataSources = dataSources
        self.description = description
        self.domains = domains
        self.enableSsl = enableSsl
        self.environment = environment
        self.name = name
        self.shortname = shortname
        self.sslConfiguration = sslConfiguration
        self.stackId = stackId
        self.type = type
    }
}

struct CreateAppInputBody: Equatable {
    public let stackId: String?
    public let shortname: String?
    public let name: String?
    public let description: String?
    public let dataSources: [DataSource]?
    public let type: AppType?
    public let appSource: Source?
    public let domains: [String]?
    public let enableSsl: Bool?
    public let sslConfiguration: SslConfiguration?
    public let attributes: [String:String]?
    public let environment: [EnvironmentVariable]?
}

extension CreateAppInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appSource = "AppSource"
        case attributes = "Attributes"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case shortname = "Shortname"
        case sslConfiguration = "SslConfiguration"
        case stackId = "StackId"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourcesContainer = try containerValues.decodeIfPresent([DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(AppType.self, forKey: .type)
        type = typeDecoded
        let appSourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .appSource)
        appSource = appSourceDecoded
        let domainsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .domains)
        var domainsDecoded0:[String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
        let enableSslDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableSsl)
        enableSsl = enableSslDecoded
        let sslConfigurationDecoded = try containerValues.decodeIfPresent(SslConfiguration.self, forKey: .sslConfiguration)
        sslConfiguration = sslConfigurationDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let environmentContainer = try containerValues.decodeIfPresent([EnvironmentVariable?].self, forKey: .environment)
        var environmentDecoded0:[EnvironmentVariable]? = nil
        if let environmentContainer = environmentContainer {
            environmentDecoded0 = [EnvironmentVariable]()
            for structure0 in environmentContainer {
                if let structure0 = structure0 {
                    environmentDecoded0?.append(structure0)
                }
            }
        }
        environment = environmentDecoded0
    }
}

extension CreateAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAppOutputResponse(appId: \(String(describing: appId)))"}
}

extension CreateAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAppOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
        } else {
            self.appId = nil
        }
    }
}

/// <p>Contains the response to a <code>CreateApp</code> request.</p>
public struct CreateAppOutputResponse: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct CreateAppOutputResponseBody: Equatable {
    public let appId: String?
}

extension CreateAppOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "AppId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

public struct CreateDeploymentInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

extension CreateDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentInput(appId: \(String(describing: appId)), command: \(String(describing: command)), comment: \(String(describing: comment)), customJson: \(String(describing: customJson)), instanceIds: \(String(describing: instanceIds)), layerIds: \(String(describing: layerIds)), stackId: \(String(describing: stackId)))"}
}

extension CreateDeploymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId = "AppId"
        case command = "Command"
        case comment = "Comment"
        case customJson = "CustomJson"
        case instanceIds = "InstanceIds"
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let command = command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for strings0 in instanceIds {
                try instanceIdsContainer.encode(strings0)
            }
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct CreateDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInput: Equatable {
    /// <p>The app ID. This parameter is required for app deployments, but not for other deployment commands.</p>
    public let appId: String?
    /// <p>A <code>DeploymentCommand</code> object that specifies the deployment command and any
    ///       associated arguments.</p>
    public let command: DeploymentCommand?
    /// <p>A user-defined comment.</p>
    public let comment: String?
    /// <p>A string that contains user-defined, custom JSON. You can use this parameter to override some corresponding default stack configuration JSON values. The string should be in the following format:</p>
    ///          <p>
    ///             <code>"{\"key1\": \"value1\", \"key2\": \"value2\",...}"</code>
    ///          </p>
    ///          <p>For more information about custom JSON, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html">Use Custom JSON to
    ///           Modify the Stack Configuration Attributes</a> and
    ///           <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook-json-override.html">Overriding Attributes With Custom JSON</a>.</p>
    public let customJson: String?
    /// <p>The instance IDs for the deployment targets.</p>
    public let instanceIds: [String]?
    /// <p>The layer IDs for the deployment targets.</p>
    public let layerIds: [String]?
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        appId: String? = nil,
        command: DeploymentCommand? = nil,
        comment: String? = nil,
        customJson: String? = nil,
        instanceIds: [String]? = nil,
        layerIds: [String]? = nil,
        stackId: String? = nil
    )
    {
        self.appId = appId
        self.command = command
        self.comment = comment
        self.customJson = customJson
        self.instanceIds = instanceIds
        self.layerIds = layerIds
        self.stackId = stackId
    }
}

struct CreateDeploymentInputBody: Equatable {
    public let stackId: String?
    public let appId: String?
    public let instanceIds: [String]?
    public let layerIds: [String]?
    public let command: DeploymentCommand?
    public let comment: String?
    public let customJson: String?
}

extension CreateDeploymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "AppId"
        case command = "Command"
        case comment = "Comment"
        case customJson = "CustomJson"
        case instanceIds = "InstanceIds"
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let layerIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
        let commandDecoded = try containerValues.decodeIfPresent(DeploymentCommand.self, forKey: .command)
        command = commandDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customJson)
        customJson = customJsonDecoded
    }
}

extension CreateDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentOutputResponse(deploymentId: \(String(describing: deploymentId)))"}
}

extension CreateDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deploymentId = output.deploymentId
        } else {
            self.deploymentId = nil
        }
    }
}

/// <p>Contains the response to a <code>CreateDeployment</code> request.</p>
public struct CreateDeploymentOutputResponse: Equatable {
    /// <p>The deployment ID, which can be used with other requests to identify the deployment.</p>
    public let deploymentId: String?

    public init (
        deploymentId: String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct CreateDeploymentOutputResponseBody: Equatable {
    public let deploymentId: String?
}

extension CreateDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentId = "DeploymentId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

public struct CreateInstanceInputBodyMiddleware: Middleware {
    public let id: String = "CreateInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceInput>
    public typealias MOutput = OperationOutput<CreateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceOutputError>
}

extension CreateInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInstanceInput(agentVersion: \(String(describing: agentVersion)), amiId: \(String(describing: amiId)), architecture: \(String(describing: architecture)), autoScalingType: \(String(describing: autoScalingType)), availabilityZone: \(String(describing: availabilityZone)), blockDeviceMappings: \(String(describing: blockDeviceMappings)), ebsOptimized: \(String(describing: ebsOptimized)), hostname: \(String(describing: hostname)), installUpdatesOnBoot: \(String(describing: installUpdatesOnBoot)), instanceType: \(String(describing: instanceType)), layerIds: \(String(describing: layerIds)), os: \(String(describing: os)), rootDeviceType: \(String(describing: rootDeviceType)), sshKeyName: \(String(describing: sshKeyName)), stackId: \(String(describing: stackId)), subnetId: \(String(describing: subnetId)), tenancy: \(String(describing: tenancy)), virtualizationType: \(String(describing: virtualizationType)))"}
}

extension CreateInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case autoScalingType = "AutoScalingType"
        case availabilityZone = "AvailabilityZone"
        case blockDeviceMappings = "BlockDeviceMappings"
        case ebsOptimized = "EbsOptimized"
        case hostname = "Hostname"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceType = "InstanceType"
        case layerIds = "LayerIds"
        case os = "Os"
        case rootDeviceType = "RootDeviceType"
        case sshKeyName = "SshKeyName"
        case stackId = "StackId"
        case subnetId = "SubnetId"
        case tenancy = "Tenancy"
        case virtualizationType = "VirtualizationType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let autoScalingType = autoScalingType {
            try encodeContainer.encode(autoScalingType.rawValue, forKey: .autoScalingType)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for blockdevicemappings0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(blockdevicemappings0)
            }
        }
        if let ebsOptimized = ebsOptimized {
            try encodeContainer.encode(ebsOptimized, forKey: .ebsOptimized)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let installUpdatesOnBoot = installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
        if let os = os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if let rootDeviceType = rootDeviceType {
            try encodeContainer.encode(rootDeviceType.rawValue, forKey: .rootDeviceType)
        }
        if let sshKeyName = sshKeyName {
            try encodeContainer.encode(sshKeyName, forKey: .sshKeyName)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tenancy = tenancy {
            try encodeContainer.encode(tenancy, forKey: .tenancy)
        }
        if let virtualizationType = virtualizationType {
            try encodeContainer.encode(virtualizationType, forKey: .virtualizationType)
        }
    }
}

public struct CreateInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceInput>
    public typealias MOutput = OperationOutput<CreateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceOutputError>
}

public struct CreateInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInstanceInput>
    public typealias MOutput = OperationOutput<CreateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInstanceOutputError>
}

public struct CreateInstanceInput: Equatable {
    /// <p>The default AWS OpsWorks Stacks agent version. You have the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INHERIT</code> - Use the stack's default agent version setting.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>version_number</i> - Use the specified agent version.
    ///         This value overrides the stack's default setting.
    ///         To update the agent version, edit the instance configuration and specify a
    ///         new version.
    ///         AWS OpsWorks Stacks then automatically installs that version on the instance.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The default setting is <code>INHERIT</code>. To specify an agent version,
    ///       you must use the complete version number, not the abbreviated number shown on the console.
    ///       For a list of available agent version numbers, call <a>DescribeAgentVersions</a>. AgentVersion cannot be set to Chef 12.2.</p>
    public let agentVersion: String?
    /// <p>A custom AMI ID to be used to create the instance. The AMI should be based on one of the
    ///       supported operating systems.
    ///       For more information, see
    ///       <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">Using Custom AMIs</a>.</p>
    ///          <note>
    ///             <p>If you specify a custom AMI, you must set <code>Os</code> to <code>Custom</code>.</p>
    ///          </note>
    public let amiId: String?
    /// <p>The instance architecture. The default option is <code>x86_64</code>. Instance types do not
    ///       necessarily support both architectures. For a list of the architectures that are supported by
    ///       the different instance types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Families and
    ///         Types</a>.</p>
    public let architecture: Architecture?
    /// <p>For load-based or time-based instances, the type. Windows stacks can use only time-based instances.</p>
    public let autoScalingType: AutoScalingType?
    /// <p>The instance Availability Zone. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints</a>.</p>
    public let availabilityZone: String?
    /// <p>An array of <code>BlockDeviceMapping</code> objects that specify the instance's block
    ///       devices. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html">Block
    ///         Device Mapping</a>. Note that block device mappings are not supported for custom AMIs.</p>
    public let blockDeviceMappings: [BlockDeviceMapping]?
    /// <p>Whether to create an Amazon EBS-optimized instance.</p>
    public let ebsOptimized: Bool?
    /// <p>The instance host name.</p>
    public let hostname: String?
    /// <p>Whether to install operating system and package updates when the instance boots. The default
    ///       value is <code>true</code>. To control when updates are installed, set this value to
    ///         <code>false</code>. You must then update your instances manually by using
    ///         <a>CreateDeployment</a> to run the <code>update_dependencies</code> stack command or
    ///       by manually running <code>yum</code> (Amazon Linux) or <code>apt-get</code> (Ubuntu) on the
    ///       instances. </p>
    ///          <note>
    ///             <p>We strongly recommend using the default value of <code>true</code> to ensure that your
    ///         instances have the latest security updates.</p>
    ///          </note>
    public let installUpdatesOnBoot: Bool?
    /// <p>The instance type, such as <code>t2.micro</code>. For a list of supported instance types,
    ///       open the stack in the console, choose <b>Instances</b>, and choose <b>+ Instance</b>.
    ///       The <b>Size</b> list contains the currently supported types. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance
    ///         Families and Types</a>. The parameter values that you use to specify the various types are
    ///       in the <b>API Name</b> column of the <b>Available Instance Types</b> table.</p>
    public let instanceType: String?
    /// <p>An array that contains the instance's layer IDs.</p>
    public let layerIds: [String]?
    /// <p>The instance's operating system, which must be set to one of the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>A supported Linux operating system: An Amazon Linux version, such as <code>Amazon Linux 2018.03</code>, <code>Amazon Linux 2017.09</code>, <code>Amazon Linux 2017.03</code>, <code>Amazon Linux 2016.09</code>,
    ///               <code>Amazon Linux 2016.03</code>, <code>Amazon Linux 2015.09</code>, or <code>Amazon Linux 2015.03</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>A supported Ubuntu operating system, such as <code>Ubuntu 16.04 LTS</code>, <code>Ubuntu 14.04 LTS</code>, or <code>Ubuntu 12.04 LTS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CentOS Linux 7</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Red Hat Enterprise Linux 7</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>A supported Windows operating system, such as <code>Microsoft Windows Server 2012 R2 Base</code>, <code>Microsoft Windows Server 2012 R2 with SQL Server Express</code>,
    /// 			   <code>Microsoft Windows Server 2012 R2 with SQL Server Standard</code>, or <code>Microsoft Windows Server 2012 R2 with SQL Server Web</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>A custom AMI: <code>Custom</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about the supported operating systems,
    ///       see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">AWS OpsWorks Stacks Operating Systems</a>.</p>
    ///          <p>The default option is the current Amazon Linux version. If you set this parameter to
    ///         <code>Custom</code>, you must use the <a>CreateInstance</a> action's AmiId parameter to
    ///       specify the custom AMI that you want to use. Block device mappings are not supported if the value is <code>Custom</code>. For more information about supported operating
    ///       systems, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">Operating Systems</a>For more information about how to use custom AMIs with AWS OpsWorks Stacks, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">Using
    ///         Custom AMIs</a>.</p>
    public let os: String?
    /// <p>The instance root device type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device">Storage for the Root Device</a>.</p>
    public let rootDeviceType: RootDeviceType?
    /// <p>The instance's Amazon EC2 key-pair name.</p>
    public let sshKeyName: String?
    /// <p>The stack ID.</p>
    public let stackId: String?
    /// <p>The ID of the instance's subnet. If the stack is running in a VPC, you can use this parameter to override the stack's default subnet ID value and direct AWS OpsWorks Stacks to launch the instance in a different subnet.</p>
    public let subnetId: String?
    /// <p>The instance's tenancy option. The default option is no tenancy, or if the instance is running in a VPC, inherit tenancy settings from the VPC. The following are valid values for this parameter:  <code>dedicated</code>, <code>default</code>, or <code>host</code>. Because there are costs associated with changes in tenancy options, we recommend that you research tenancy options before choosing them for your instances. For more information about dedicated hosts, see <a href="http://aws.amazon.com/ec2/dedicated-hosts/">Dedicated Hosts Overview</a> and <a href="http://aws.amazon.com/ec2/dedicated-hosts/">Amazon EC2 Dedicated Hosts</a>. For more information about dedicated instances, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/dedicated-instance.html">Dedicated Instances</a> and <a href="http://aws.amazon.com/ec2/purchasing-options/dedicated-instances/">Amazon EC2 Dedicated Instances</a>.</p>
    public let tenancy: String?
    /// <p>The instance's virtualization type, <code>paravirtual</code> or <code>hvm</code>.</p>
    public let virtualizationType: String?

    public init (
        agentVersion: String? = nil,
        amiId: String? = nil,
        architecture: Architecture? = nil,
        autoScalingType: AutoScalingType? = nil,
        availabilityZone: String? = nil,
        blockDeviceMappings: [BlockDeviceMapping]? = nil,
        ebsOptimized: Bool? = nil,
        hostname: String? = nil,
        installUpdatesOnBoot: Bool? = nil,
        instanceType: String? = nil,
        layerIds: [String]? = nil,
        os: String? = nil,
        rootDeviceType: RootDeviceType? = nil,
        sshKeyName: String? = nil,
        stackId: String? = nil,
        subnetId: String? = nil,
        tenancy: String? = nil,
        virtualizationType: String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.amiId = amiId
        self.architecture = architecture
        self.autoScalingType = autoScalingType
        self.availabilityZone = availabilityZone
        self.blockDeviceMappings = blockDeviceMappings
        self.ebsOptimized = ebsOptimized
        self.hostname = hostname
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.instanceType = instanceType
        self.layerIds = layerIds
        self.os = os
        self.rootDeviceType = rootDeviceType
        self.sshKeyName = sshKeyName
        self.stackId = stackId
        self.subnetId = subnetId
        self.tenancy = tenancy
        self.virtualizationType = virtualizationType
    }
}

struct CreateInstanceInputBody: Equatable {
    public let stackId: String?
    public let layerIds: [String]?
    public let instanceType: String?
    public let autoScalingType: AutoScalingType?
    public let hostname: String?
    public let os: String?
    public let amiId: String?
    public let sshKeyName: String?
    public let availabilityZone: String?
    public let virtualizationType: String?
    public let subnetId: String?
    public let architecture: Architecture?
    public let rootDeviceType: RootDeviceType?
    public let blockDeviceMappings: [BlockDeviceMapping]?
    public let installUpdatesOnBoot: Bool?
    public let ebsOptimized: Bool?
    public let agentVersion: String?
    public let tenancy: String?
}

extension CreateInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case autoScalingType = "AutoScalingType"
        case availabilityZone = "AvailabilityZone"
        case blockDeviceMappings = "BlockDeviceMappings"
        case ebsOptimized = "EbsOptimized"
        case hostname = "Hostname"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceType = "InstanceType"
        case layerIds = "LayerIds"
        case os = "Os"
        case rootDeviceType = "RootDeviceType"
        case sshKeyName = "SshKeyName"
        case stackId = "StackId"
        case subnetId = "SubnetId"
        case tenancy = "Tenancy"
        case virtualizationType = "VirtualizationType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let autoScalingTypeDecoded = try containerValues.decodeIfPresent(AutoScalingType.self, forKey: .autoScalingType)
        autoScalingType = autoScalingTypeDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let osDecoded = try containerValues.decodeIfPresent(String.self, forKey: .os)
        os = osDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let sshKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshKeyName)
        sshKeyName = sshKeyNameDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let virtualizationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualizationType)
        virtualizationType = virtualizationTypeDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let rootDeviceTypeDecoded = try containerValues.decodeIfPresent(RootDeviceType.self, forKey: .rootDeviceType)
        rootDeviceType = rootDeviceTypeDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([BlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[BlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [BlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tenancy)
        tenancy = tenancyDecoded
    }
}

extension CreateInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInstanceOutputResponse(instanceId: \(String(describing: instanceId)))"}
}

extension CreateInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceId = output.instanceId
        } else {
            self.instanceId = nil
        }
    }
}

/// <p>Contains the response to a <code>CreateInstance</code> request.</p>
public struct CreateInstanceOutputResponse: Equatable {
    /// <p>The instance ID.</p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct CreateInstanceOutputResponseBody: Equatable {
    public let instanceId: String?
}

extension CreateInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

public struct CreateLayerInputBodyMiddleware: Middleware {
    public let id: String = "CreateLayerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLayerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLayerInput>
    public typealias MOutput = OperationOutput<CreateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLayerOutputError>
}

extension CreateLayerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLayerInput(attributes: \(String(describing: attributes)), autoAssignElasticIps: \(String(describing: autoAssignElasticIps)), autoAssignPublicIps: \(String(describing: autoAssignPublicIps)), cloudWatchLogsConfiguration: \(String(describing: cloudWatchLogsConfiguration)), customInstanceProfileArn: \(String(describing: customInstanceProfileArn)), customJson: \(String(describing: customJson)), customRecipes: \(String(describing: customRecipes)), customSecurityGroupIds: \(String(describing: customSecurityGroupIds)), enableAutoHealing: \(String(describing: enableAutoHealing)), installUpdatesOnBoot: \(String(describing: installUpdatesOnBoot)), lifecycleEventConfiguration: \(String(describing: lifecycleEventConfiguration)), name: \(String(describing: name)), packages: \(String(describing: packages)), shortname: \(String(describing: shortname)), stackId: \(String(describing: stackId)), type: \(String(describing: type)), useEbsOptimizedInstances: \(String(describing: useEbsOptimizedInstances)), volumeConfigurations: \(String(describing: volumeConfigurations)))"}
}

extension CreateLayerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case stackId = "StackId"
        case type = "Type"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, layerattributes0) in attributes {
                try attributesContainer.encode(layerattributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let autoAssignElasticIps = autoAssignElasticIps {
            try encodeContainer.encode(autoAssignElasticIps, forKey: .autoAssignElasticIps)
        }
        if let autoAssignPublicIps = autoAssignPublicIps {
            try encodeContainer.encode(autoAssignPublicIps, forKey: .autoAssignPublicIps)
        }
        if let cloudWatchLogsConfiguration = cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let customInstanceProfileArn = customInstanceProfileArn {
            try encodeContainer.encode(customInstanceProfileArn, forKey: .customInstanceProfileArn)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let customRecipes = customRecipes {
            try encodeContainer.encode(customRecipes, forKey: .customRecipes)
        }
        if let customSecurityGroupIds = customSecurityGroupIds {
            var customSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customSecurityGroupIds)
            for strings0 in customSecurityGroupIds {
                try customSecurityGroupIdsContainer.encode(strings0)
            }
        }
        if let enableAutoHealing = enableAutoHealing {
            try encodeContainer.encode(enableAutoHealing, forKey: .enableAutoHealing)
        }
        if let installUpdatesOnBoot = installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let lifecycleEventConfiguration = lifecycleEventConfiguration {
            try encodeContainer.encode(lifecycleEventConfiguration, forKey: .lifecycleEventConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packages = packages {
            var packagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .packages)
            for strings0 in packages {
                try packagesContainer.encode(strings0)
            }
        }
        if let shortname = shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let useEbsOptimizedInstances = useEbsOptimizedInstances {
            try encodeContainer.encode(useEbsOptimizedInstances, forKey: .useEbsOptimizedInstances)
        }
        if let volumeConfigurations = volumeConfigurations {
            var volumeConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeConfigurations)
            for volumeconfigurations0 in volumeConfigurations {
                try volumeConfigurationsContainer.encode(volumeconfigurations0)
            }
        }
    }
}

public struct CreateLayerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLayerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLayerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLayerInput>
    public typealias MOutput = OperationOutput<CreateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLayerOutputError>
}

public struct CreateLayerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLayerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLayerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLayerInput>
    public typealias MOutput = OperationOutput<CreateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLayerOutputError>
}

public struct CreateLayerInput: Equatable {
    /// <p>One or more user-defined key-value pairs to be added to the stack attributes.</p>
    ///          <p>To create a cluster layer, set the <code>EcsClusterArn</code> attribute to the cluster's ARN.</p>
    public let attributes: [String:String]?
    /// <p>Whether to automatically assign an <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP
    ///         address</a> to the layer's instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html">How to Edit
    ///         a Layer</a>.</p>
    public let autoAssignElasticIps: Bool?
    /// <p>For stacks that are running in a VPC, whether to automatically assign a public IP address to
    ///       the layer's instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html">How to Edit
    ///         a Layer</a>.</p>
    public let autoAssignPublicIps: Bool?
    /// <p>Specifies CloudWatch Logs configuration options for the layer. For more information, see <a>CloudWatchLogsLogStream</a>.</p>
    public let cloudWatchLogsConfiguration: CloudWatchLogsConfiguration?
    /// <p>The ARN of an IAM profile to be used for the layer's EC2 instances. For more information
    ///       about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using Identifiers</a>.</p>
    public let customInstanceProfileArn: String?
    /// <p>A JSON-formatted string containing custom stack configuration and deployment attributes
    ///      to be installed on the layer's instances. For more information, see
    ///       <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook-json-override.html">
    ///         Using Custom JSON</a>. This feature is supported as of version 1.7.42 of the AWS CLI.
    ///     </p>
    public let customJson: String?
    /// <p>A <code>LayerCustomRecipes</code> object that specifies the layer custom recipes.</p>
    public let customRecipes: Recipes?
    /// <p>An array containing the layer custom security group IDs.</p>
    public let customSecurityGroupIds: [String]?
    /// <p>Whether to disable auto healing for the layer.</p>
    public let enableAutoHealing: Bool?
    /// <p>Whether to install operating system and package updates when the instance boots. The default
    ///       value is <code>true</code>. To control when updates are installed, set this value to
    ///         <code>false</code>. You must then update your instances manually by using
    ///         <a>CreateDeployment</a> to run the <code>update_dependencies</code> stack command or
    ///       by manually running <code>yum</code> (Amazon Linux) or <code>apt-get</code> (Ubuntu) on the
    ///       instances. </p>
    ///          <note>
    ///             <p>To ensure that your
    ///         instances have the latest security updates, we strongly recommend using the default value of <code>true</code>.</p>
    ///          </note>
    public let installUpdatesOnBoot: Bool?
    /// <p>A <code>LifeCycleEventConfiguration</code> object that you can use to configure the Shutdown event to
    ///       specify an execution timeout and enable or disable Elastic Load Balancer connection
    ///       draining.</p>
    public let lifecycleEventConfiguration: LifecycleEventConfiguration?
    /// <p>The layer name, which is used by the console.</p>
    public let name: String?
    /// <p>An array of <code>Package</code> objects that describes the layer packages.</p>
    public let packages: [String]?
    /// <p>For custom layers only, use this parameter to specify the layer's short name, which is used internally by AWS OpsWorks Stacks and by Chef recipes. The short name is also used as the name for the directory where your app files are installed. It can have a maximum of 200 characters, which are limited to the alphanumeric characters, '-', '_', and '.'.</p>
    ///          <p>The built-in layers' short names are defined by AWS OpsWorks Stacks. For more information, see the <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/layers.html">Layer Reference</a>.</p>
    public let shortname: String?
    /// <p>The layer stack ID.</p>
    public let stackId: String?
    /// <p>The layer type. A stack cannot have more than one built-in layer of the same type. It can have any number of custom layers. Built-in layers are not available in Chef 12 stacks.</p>
    public let type: LayerType?
    /// <p>Whether to use Amazon EBS-optimized instances.</p>
    public let useEbsOptimizedInstances: Bool?
    /// <p>A <code>VolumeConfigurations</code> object that describes the layer's Amazon EBS volumes.</p>
    public let volumeConfigurations: [VolumeConfiguration]?

    public init (
        attributes: [String:String]? = nil,
        autoAssignElasticIps: Bool? = nil,
        autoAssignPublicIps: Bool? = nil,
        cloudWatchLogsConfiguration: CloudWatchLogsConfiguration? = nil,
        customInstanceProfileArn: String? = nil,
        customJson: String? = nil,
        customRecipes: Recipes? = nil,
        customSecurityGroupIds: [String]? = nil,
        enableAutoHealing: Bool? = nil,
        installUpdatesOnBoot: Bool? = nil,
        lifecycleEventConfiguration: LifecycleEventConfiguration? = nil,
        name: String? = nil,
        packages: [String]? = nil,
        shortname: String? = nil,
        stackId: String? = nil,
        type: LayerType? = nil,
        useEbsOptimizedInstances: Bool? = nil,
        volumeConfigurations: [VolumeConfiguration]? = nil
    )
    {
        self.attributes = attributes
        self.autoAssignElasticIps = autoAssignElasticIps
        self.autoAssignPublicIps = autoAssignPublicIps
        self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
        self.customInstanceProfileArn = customInstanceProfileArn
        self.customJson = customJson
        self.customRecipes = customRecipes
        self.customSecurityGroupIds = customSecurityGroupIds
        self.enableAutoHealing = enableAutoHealing
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.lifecycleEventConfiguration = lifecycleEventConfiguration
        self.name = name
        self.packages = packages
        self.shortname = shortname
        self.stackId = stackId
        self.type = type
        self.useEbsOptimizedInstances = useEbsOptimizedInstances
        self.volumeConfigurations = volumeConfigurations
    }
}

struct CreateLayerInputBody: Equatable {
    public let stackId: String?
    public let type: LayerType?
    public let name: String?
    public let shortname: String?
    public let attributes: [String:String]?
    public let cloudWatchLogsConfiguration: CloudWatchLogsConfiguration?
    public let customInstanceProfileArn: String?
    public let customJson: String?
    public let customSecurityGroupIds: [String]?
    public let packages: [String]?
    public let volumeConfigurations: [VolumeConfiguration]?
    public let enableAutoHealing: Bool?
    public let autoAssignElasticIps: Bool?
    public let autoAssignPublicIps: Bool?
    public let customRecipes: Recipes?
    public let installUpdatesOnBoot: Bool?
    public let useEbsOptimizedInstances: Bool?
    public let lifecycleEventConfiguration: LifecycleEventConfiguration?
}

extension CreateLayerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case stackId = "StackId"
        case type = "Type"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(LayerType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(CloudWatchLogsConfiguration.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let customInstanceProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customInstanceProfileArn)
        customInstanceProfileArn = customInstanceProfileArnDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let customSecurityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .customSecurityGroupIds)
        var customSecurityGroupIdsDecoded0:[String]? = nil
        if let customSecurityGroupIdsContainer = customSecurityGroupIdsContainer {
            customSecurityGroupIdsDecoded0 = [String]()
            for string0 in customSecurityGroupIdsContainer {
                if let string0 = string0 {
                    customSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        customSecurityGroupIds = customSecurityGroupIdsDecoded0
        let packagesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .packages)
        var packagesDecoded0:[String]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [String]()
            for string0 in packagesContainer {
                if let string0 = string0 {
                    packagesDecoded0?.append(string0)
                }
            }
        }
        packages = packagesDecoded0
        let volumeConfigurationsContainer = try containerValues.decodeIfPresent([VolumeConfiguration?].self, forKey: .volumeConfigurations)
        var volumeConfigurationsDecoded0:[VolumeConfiguration]? = nil
        if let volumeConfigurationsContainer = volumeConfigurationsContainer {
            volumeConfigurationsDecoded0 = [VolumeConfiguration]()
            for structure0 in volumeConfigurationsContainer {
                if let structure0 = structure0 {
                    volumeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        volumeConfigurations = volumeConfigurationsDecoded0
        let enableAutoHealingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoHealing)
        enableAutoHealing = enableAutoHealingDecoded
        let autoAssignElasticIpsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoAssignElasticIps)
        autoAssignElasticIps = autoAssignElasticIpsDecoded
        let autoAssignPublicIpsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoAssignPublicIps)
        autoAssignPublicIps = autoAssignPublicIpsDecoded
        let customRecipesDecoded = try containerValues.decodeIfPresent(Recipes.self, forKey: .customRecipes)
        customRecipes = customRecipesDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let useEbsOptimizedInstancesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useEbsOptimizedInstances)
        useEbsOptimizedInstances = useEbsOptimizedInstancesDecoded
        let lifecycleEventConfigurationDecoded = try containerValues.decodeIfPresent(LifecycleEventConfiguration.self, forKey: .lifecycleEventConfiguration)
        lifecycleEventConfiguration = lifecycleEventConfigurationDecoded
    }
}

extension CreateLayerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLayerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLayerOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLayerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLayerOutputResponse(layerId: \(String(describing: layerId)))"}
}

extension CreateLayerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLayerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.layerId = output.layerId
        } else {
            self.layerId = nil
        }
    }
}

/// <p>Contains the response to a <code>CreateLayer</code> request.</p>
public struct CreateLayerOutputResponse: Equatable {
    /// <p>The layer ID.</p>
    public let layerId: String?

    public init (
        layerId: String? = nil
    )
    {
        self.layerId = layerId
    }
}

struct CreateLayerOutputResponseBody: Equatable {
    public let layerId: String?
}

extension CreateLayerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerId = "LayerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

public struct CreateStackInputBodyMiddleware: Middleware {
    public let id: String = "CreateStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackInput>
    public typealias MOutput = OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackOutputError>
}

extension CreateStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStackInput(agentVersion: \(String(describing: agentVersion)), attributes: \(String(describing: attributes)), chefConfiguration: \(String(describing: chefConfiguration)), configurationManager: \(String(describing: configurationManager)), customCookbooksSource: \(String(describing: customCookbooksSource)), customJson: \(String(describing: customJson)), defaultAvailabilityZone: \(String(describing: defaultAvailabilityZone)), defaultInstanceProfileArn: \(String(describing: defaultInstanceProfileArn)), defaultOs: \(String(describing: defaultOs)), defaultRootDeviceType: \(String(describing: defaultRootDeviceType)), defaultSshKeyName: \(String(describing: defaultSshKeyName)), defaultSubnetId: \(String(describing: defaultSubnetId)), hostnameTheme: \(String(describing: hostnameTheme)), name: \(String(describing: name)), region: \(String(describing: region)), serviceRoleArn: \(String(describing: serviceRoleArn)), useCustomCookbooks: \(String(describing: useCustomCookbooks)), useOpsworksSecurityGroups: \(String(describing: useOpsworksSecurityGroups)), vpcId: \(String(describing: vpcId)))"}
}

extension CreateStackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, stackattributes0) in attributes {
                try attributesContainer.encode(stackattributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let chefConfiguration = chefConfiguration {
            try encodeContainer.encode(chefConfiguration, forKey: .chefConfiguration)
        }
        if let configurationManager = configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let customCookbooksSource = customCookbooksSource {
            try encodeContainer.encode(customCookbooksSource, forKey: .customCookbooksSource)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let defaultAvailabilityZone = defaultAvailabilityZone {
            try encodeContainer.encode(defaultAvailabilityZone, forKey: .defaultAvailabilityZone)
        }
        if let defaultInstanceProfileArn = defaultInstanceProfileArn {
            try encodeContainer.encode(defaultInstanceProfileArn, forKey: .defaultInstanceProfileArn)
        }
        if let defaultOs = defaultOs {
            try encodeContainer.encode(defaultOs, forKey: .defaultOs)
        }
        if let defaultRootDeviceType = defaultRootDeviceType {
            try encodeContainer.encode(defaultRootDeviceType.rawValue, forKey: .defaultRootDeviceType)
        }
        if let defaultSshKeyName = defaultSshKeyName {
            try encodeContainer.encode(defaultSshKeyName, forKey: .defaultSshKeyName)
        }
        if let defaultSubnetId = defaultSubnetId {
            try encodeContainer.encode(defaultSubnetId, forKey: .defaultSubnetId)
        }
        if let hostnameTheme = hostnameTheme {
            try encodeContainer.encode(hostnameTheme, forKey: .hostnameTheme)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let useCustomCookbooks = useCustomCookbooks {
            try encodeContainer.encode(useCustomCookbooks, forKey: .useCustomCookbooks)
        }
        if let useOpsworksSecurityGroups = useOpsworksSecurityGroups {
            try encodeContainer.encode(useOpsworksSecurityGroups, forKey: .useOpsworksSecurityGroups)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

public struct CreateStackInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackInput>
    public typealias MOutput = OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackOutputError>
}

public struct CreateStackInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStackInput>
    public typealias MOutput = OperationOutput<CreateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStackOutputError>
}

public struct CreateStackInput: Equatable {
    /// <p>The default AWS OpsWorks Stacks agent version. You have the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Auto-update - Set this parameter to <code>LATEST</code>. AWS OpsWorks Stacks
    ///         automatically installs new agent versions on the stack's instances as soon as
    ///         they are available.</p>
    ///             </li>
    ///             <li>
    ///                <p>Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. AWS OpsWorks Stacks then automatically installs that version on the stack's instances.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The default setting is the most recent release of the agent. To specify an agent version,
    ///       you must use the complete version number, not the abbreviated number shown on the console.
    ///       For a list of available agent version numbers, call <a>DescribeAgentVersions</a>. AgentVersion cannot be set to Chef 12.2.</p>
    ///          <note>
    ///             <p>You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.</p>
    ///          </note>
    public let agentVersion: String?
    /// <p>One or more user-defined key-value pairs to be added to the stack attributes.</p>
    public let attributes: [String:String]?
    /// <p>A <code>ChefConfiguration</code> object that specifies whether to enable Berkshelf and the
    ///       Berkshelf version on Chef 11.10 stacks. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New Stack</a>.</p>
    public let chefConfiguration: ChefConfiguration?
    /// <p>The configuration manager. When you create a stack we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.</p>
    public let configurationManager: StackConfigurationManager?
    /// <p>Contains the information required to retrieve an app or cookbook from a repository. For more information,
    ///             see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html">Adding Apps</a> or
    ///             <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html">Cookbooks and Recipes</a>.</p>
    public let customCookbooksSource: Source?
    /// <p>A string that contains user-defined, custom JSON. It can be used to override the corresponding default stack configuration attribute values or to pass data to recipes. The string should be in the following format:</p>
    ///          <p>
    ///             <code>"{\"key1\": \"value1\", \"key2\": \"value2\",...}"</code>
    ///          </p>
    ///          <p>For more information about custom JSON, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html">Use Custom JSON to
    ///         Modify the Stack Configuration Attributes</a>.</p>
    public let customJson: String?
    /// <p>The stack's default Availability Zone, which must be in the specified region. For more
    ///       information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and
    ///         Endpoints</a>. If you also specify a value for <code>DefaultSubnetId</code>, the subnet must
    ///       be in the same zone. For more information, see the <code>VpcId</code> parameter description.
    ///     </p>
    public let defaultAvailabilityZone: String?
    /// <p>The Amazon Resource Name (ARN) of an IAM profile that is the default profile for all of the stack's EC2 instances.
    ///       For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers</a>.</p>
    public let defaultInstanceProfileArn: String?
    /// <p>The stack's default operating system, which is installed on every instance unless you specify a different operating system when you create the instance. You can specify one of the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>A supported Linux operating system: An Amazon Linux version, such as <code>Amazon Linux 2018.03</code>, <code>Amazon Linux 2017.09</code>, <code>Amazon Linux 2017.03</code>, <code>Amazon Linux 2016.09</code>,
    ///               <code>Amazon Linux 2016.03</code>, <code>Amazon Linux 2015.09</code>, or <code>Amazon Linux 2015.03</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>A supported Ubuntu operating system, such as <code>Ubuntu 16.04 LTS</code>, <code>Ubuntu 14.04 LTS</code>, or <code>Ubuntu 12.04 LTS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CentOS Linux 7</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Red Hat Enterprise Linux 7</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>A supported Windows operating system, such as <code>Microsoft Windows Server 2012 R2 Base</code>,
    ///               <code>Microsoft Windows Server 2012 R2 with SQL Server Express</code>,
    ///               <code>Microsoft Windows Server 2012 R2 with SQL Server Standard</code>, or
    ///               <code>Microsoft Windows Server 2012 R2 with SQL Server Web</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>A custom AMI: <code>Custom</code>. You specify the custom AMI you want to use when
    ///         you create instances. For more
    ///         information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">
    ///         Using Custom AMIs</a>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The default option is the current Amazon Linux version.
    ///       For more information about supported operating systems,
    ///       see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">AWS OpsWorks Stacks Operating Systems</a>.</p>
    public let defaultOs: String?
    /// <p>The default root device type. This value is the default for all instances in the stack,
    ///       but you can override it when you create an instance. The default option is
    ///         <code>instance-store</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device">Storage for the Root Device</a>.</p>
    public let defaultRootDeviceType: RootDeviceType?
    /// <p>A default Amazon EC2 key pair name. The default value is none. If you specify a key pair name, AWS
    ///       OpsWorks installs the public key on the instance and you can use the private key with an SSH
    ///       client to log in to the instance. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-ssh.html"> Using SSH to
    ///         Communicate with an Instance</a> and <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/security-ssh-access.html"> Managing SSH
    ///         Access</a>. You can override this setting by specifying a different key pair, or no key
    ///       pair, when you <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-add.html">
    ///         create an instance</a>. </p>
    public let defaultSshKeyName: String?
    /// <p>The stack's default VPC subnet ID. This parameter is required if you specify a value for the
    ///         <code>VpcId</code> parameter. All instances are launched into this subnet unless you specify
    ///       otherwise when you create the instance. If you also specify a value for
    ///         <code>DefaultAvailabilityZone</code>, the subnet must be in that zone. For information on
    ///       default values and when this parameter is required, see the <code>VpcId</code> parameter
    ///       description. </p>
    public let defaultSubnetId: String?
    /// <p>The stack's host name theme, with spaces replaced by underscores. The theme is used to
    ///       generate host names for the stack's instances. By default, <code>HostnameTheme</code> is set
    ///       to <code>Layer_Dependent</code>, which creates host names by appending integers to the layer's
    ///       short name. The other themes are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Baked_Goods</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Clouds</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Europe_Cities</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fruits</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Greek_Deities_and_Titans</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Legendary_creatures_from_Japan</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Planets_and_Moons</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Roman_Deities</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Scottish_Islands</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>US_Cities</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Wild_Cats</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To obtain a generated host name, call <code>GetHostNameSuggestion</code>, which returns a
    ///       host name based on the current theme.</p>
    public let hostnameTheme: String?
    /// <p>The stack name.</p>
    public let name: String?
    /// <p>The stack's AWS region, such as <code>ap-south-1</code>. For more information about
    ///             Amazon regions, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints</a>.</p>
    ///          <note>
    ///             <p>In the AWS CLI, this API maps to the <code>--stack-region</code> parameter. If the
    ///                     <code>--stack-region</code> parameter and the AWS CLI common parameter
    ///                     <code>--region</code> are set to the same value, the stack uses a
    ///                     <i>regional</i> endpoint. If the <code>--stack-region</code>
    ///                 parameter is not set, but the AWS CLI <code>--region</code> parameter is, this also
    ///                 results in a stack with a <i>regional</i> endpoint. However, if the
    ///                     <code>--region</code> parameter is set to <code>us-east-1</code>, and the
    ///                     <code>--stack-region</code> parameter is set to one of the following, then the
    ///                 stack uses a legacy or <i>classic</i> region: <code>us-west-1,
    ///                     us-west-2, sa-east-1, eu-central-1, eu-west-1, ap-northeast-1, ap-southeast-1,
    ///                     ap-southeast-2</code>. In this case, the actual API endpoint of the stack is in
    ///                     <code>us-east-1</code>. Only the preceding regions are supported as classic
    ///                 regions in the <code>us-east-1</code> API endpoint. Because it is a best practice to
    ///                 choose the regional endpoint that is closest to where you manage AWS, we recommend
    ///                 that you use regional endpoints for new stacks. The AWS CLI common
    ///                     <code>--region</code> parameter always specifies a regional API endpoint; it
    ///                 cannot be used to specify a classic AWS OpsWorks Stacks region.</p>
    ///          </note>
    public let region: String?
    /// <p>The stack's AWS Identity and Access Management (IAM) role, which allows AWS OpsWorks Stacks to work with AWS
    ///       resources on your behalf. You must set this parameter to the Amazon Resource Name (ARN) for an
    ///       existing IAM role. For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers</a>.</p>
    public let serviceRoleArn: String?
    /// <p>Whether the stack uses custom cookbooks.</p>
    public let useCustomCookbooks: Bool?
    /// <p>Whether to associate the AWS OpsWorks Stacks built-in security groups with the stack's layers.</p>
    ///          <p>AWS OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are
    ///       associated with layers by default. With <code>UseOpsworksSecurityGroups</code> you can instead
    ///       provide your own custom security groups. <code>UseOpsworksSecurityGroups</code> has the
    ///       following settings: </p>
    ///          <ul>
    ///             <li>
    ///                <p>True - AWS OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it, but you cannot delete the built-in security group.</p>
    ///             </li>
    ///             <li>
    ///                <p>False - AWS OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on creation; custom security groups are required only for those layers that need custom settings.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New
    ///         Stack</a>.</p>
    public let useOpsworksSecurityGroups: Bool?
    /// <p>The ID of the VPC that the stack is to be launched into. The VPC must be in the stack's region. All instances are launched into this VPC. You cannot change the ID later.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If your account supports EC2-Classic, the default value is <code>no VPC</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If your account does not support EC2-Classic, the default value is the default VPC for the specified region.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If the VPC ID corresponds to a default VPC and you have specified either the
    ///         <code>DefaultAvailabilityZone</code> or the <code>DefaultSubnetId</code> parameter only,
    ///       AWS OpsWorks Stacks infers the value of the
    ///       other parameter. If you specify neither parameter, AWS OpsWorks Stacks sets
    ///       these parameters to the first valid Availability Zone for the specified region and the
    ///       corresponding default VPC subnet ID, respectively.</p>
    ///          <p>If you specify a nondefault VPC ID, note the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>It must belong to a VPC in your account that is in the specified region.</p>
    ///             </li>
    ///             <li>
    ///                <p>You must specify a value for <code>DefaultSubnetId</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about how to use AWS OpsWorks Stacks with a VPC, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-vpc.html">Running a Stack in a
    ///         VPC</a>. For more information about default VPC and EC2-Classic, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported
    ///         Platforms</a>. </p>
    public let vpcId: String?

    public init (
        agentVersion: String? = nil,
        attributes: [String:String]? = nil,
        chefConfiguration: ChefConfiguration? = nil,
        configurationManager: StackConfigurationManager? = nil,
        customCookbooksSource: Source? = nil,
        customJson: String? = nil,
        defaultAvailabilityZone: String? = nil,
        defaultInstanceProfileArn: String? = nil,
        defaultOs: String? = nil,
        defaultRootDeviceType: RootDeviceType? = nil,
        defaultSshKeyName: String? = nil,
        defaultSubnetId: String? = nil,
        hostnameTheme: String? = nil,
        name: String? = nil,
        region: String? = nil,
        serviceRoleArn: String? = nil,
        useCustomCookbooks: Bool? = nil,
        useOpsworksSecurityGroups: Bool? = nil,
        vpcId: String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.configurationManager = configurationManager
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.region = region
        self.serviceRoleArn = serviceRoleArn
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
        self.vpcId = vpcId
    }
}

struct CreateStackInputBody: Equatable {
    public let name: String?
    public let region: String?
    public let vpcId: String?
    public let attributes: [String:String]?
    public let serviceRoleArn: String?
    public let defaultInstanceProfileArn: String?
    public let defaultOs: String?
    public let hostnameTheme: String?
    public let defaultAvailabilityZone: String?
    public let defaultSubnetId: String?
    public let customJson: String?
    public let configurationManager: StackConfigurationManager?
    public let chefConfiguration: ChefConfiguration?
    public let useCustomCookbooks: Bool?
    public let useOpsworksSecurityGroups: Bool?
    public let customCookbooksSource: Source?
    public let defaultSshKeyName: String?
    public let defaultRootDeviceType: RootDeviceType?
    public let agentVersion: String?
}

extension CreateStackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let defaultInstanceProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultInstanceProfileArn)
        defaultInstanceProfileArn = defaultInstanceProfileArnDecoded
        let defaultOsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultOs)
        defaultOs = defaultOsDecoded
        let hostnameThemeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostnameTheme)
        hostnameTheme = hostnameThemeDecoded
        let defaultAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAvailabilityZone)
        defaultAvailabilityZone = defaultAvailabilityZoneDecoded
        let defaultSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubnetId)
        defaultSubnetId = defaultSubnetIdDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
        let chefConfigurationDecoded = try containerValues.decodeIfPresent(ChefConfiguration.self, forKey: .chefConfiguration)
        chefConfiguration = chefConfigurationDecoded
        let useCustomCookbooksDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useCustomCookbooks)
        useCustomCookbooks = useCustomCookbooksDecoded
        let useOpsworksSecurityGroupsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useOpsworksSecurityGroups)
        useOpsworksSecurityGroups = useOpsworksSecurityGroupsDecoded
        let customCookbooksSourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .customCookbooksSource)
        customCookbooksSource = customCookbooksSourceDecoded
        let defaultSshKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSshKeyName)
        defaultSshKeyName = defaultSshKeyNameDecoded
        let defaultRootDeviceTypeDecoded = try containerValues.decodeIfPresent(RootDeviceType.self, forKey: .defaultRootDeviceType)
        defaultRootDeviceType = defaultRootDeviceTypeDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension CreateStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStackOutputError: Swift.Error, Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStackOutputResponse(stackId: \(String(describing: stackId)))"}
}

extension CreateStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackId = output.stackId
        } else {
            self.stackId = nil
        }
    }
}

/// <p>Contains the response to a <code>CreateStack</code> request.</p>
public struct CreateStackOutputResponse: Equatable {
    /// <p>The stack ID, which is an opaque string that you use to identify the stack when performing
    ///       actions such as <code>DescribeStacks</code>.</p>
    public let stackId: String?

    public init (
        stackId: String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct CreateStackOutputResponseBody: Equatable {
    public let stackId: String?
}

extension CreateStackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

public struct CreateUserProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserProfileInput>
    public typealias MOutput = OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserProfileOutputError>
}

extension CreateUserProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserProfileInput(allowSelfManagement: \(String(describing: allowSelfManagement)), iamUserArn: \(String(describing: iamUserArn)), sshPublicKey: \(String(describing: sshPublicKey)), sshUsername: \(String(describing: sshUsername)))"}
}

extension CreateUserProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSelfManagement = allowSelfManagement {
            try encodeContainer.encode(allowSelfManagement, forKey: .allowSelfManagement)
        }
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let sshUsername = sshUsername {
            try encodeContainer.encode(sshUsername, forKey: .sshUsername)
        }
    }
}

public struct CreateUserProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserProfileInput>
    public typealias MOutput = OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserProfileOutputError>
}

public struct CreateUserProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserProfileInput>
    public typealias MOutput = OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserProfileOutputError>
}

public struct CreateUserProfileInput: Equatable {
    /// <p>Whether users can specify their own SSH public key through the My Settings page. For more
    ///       information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/security-settingsshkey.html">Setting an IAM
    ///         User's Public SSH Key</a>.</p>
    public let allowSelfManagement: Bool?
    /// <p>The user's IAM ARN; this can also be a federated user's ARN.</p>
    public let iamUserArn: String?
    /// <p>The user's public SSH key.</p>
    public let sshPublicKey: String?
    /// <p>The user's SSH user name. The allowable characters are [a-z], [A-Z], [0-9], '-', and '_'. If
    ///       the specified name includes other punctuation marks, AWS OpsWorks Stacks removes them. For example,
    ///         <code>my.name</code> will be changed to <code>myname</code>. If you do not specify an SSH
    ///       user name, AWS OpsWorks Stacks generates one from the IAM user name. </p>
    public let sshUsername: String?

    public init (
        allowSelfManagement: Bool? = nil,
        iamUserArn: String? = nil,
        sshPublicKey: String? = nil,
        sshUsername: String? = nil
    )
    {
        self.allowSelfManagement = allowSelfManagement
        self.iamUserArn = iamUserArn
        self.sshPublicKey = sshPublicKey
        self.sshUsername = sshUsername
    }
}

struct CreateUserProfileInputBody: Equatable {
    public let iamUserArn: String?
    public let sshUsername: String?
    public let sshPublicKey: String?
    public let allowSelfManagement: Bool?
}

extension CreateUserProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let sshUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshUsername)
        sshUsername = sshUsernameDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let allowSelfManagementDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSelfManagement)
        allowSelfManagement = allowSelfManagementDecoded
    }
}

extension CreateUserProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserProfileOutputError: Swift.Error, Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserProfileOutputResponse(iamUserArn: \(String(describing: iamUserArn)))"}
}

extension CreateUserProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.iamUserArn = output.iamUserArn
        } else {
            self.iamUserArn = nil
        }
    }
}

/// <p>Contains the response to a <code>CreateUserProfile</code> request.</p>
public struct CreateUserProfileOutputResponse: Equatable {
    /// <p>The user's IAM ARN.</p>
    public let iamUserArn: String?

    public init (
        iamUserArn: String? = nil
    )
    {
        self.iamUserArn = iamUserArn
    }
}

struct CreateUserProfileOutputResponseBody: Equatable {
    public let iamUserArn: String?
}

extension CreateUserProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iamUserArn = "IamUserArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
    }
}

extension DataSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case databaseName = "DatabaseName"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension DataSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSource(arn: \(String(describing: arn)), databaseName: \(String(describing: databaseName)), type: \(String(describing: type)))"}
}

/// <p>Describes an app's data source.</p>
public struct DataSource: Equatable {
    /// <p>The data source's ARN.</p>
    public let arn: String?
    /// <p>The database name.</p>
    public let databaseName: String?
    /// <p>The data source's type, <code>AutoSelectOpsworksMysqlInstance</code>,
    ///         <code>OpsworksMysqlInstance</code>, <code>RdsDbInstance</code>, or <code>None</code>.</p>
    public let type: String?

    public init (
        arn: String? = nil,
        databaseName: String? = nil,
        type: String? = nil
    )
    {
        self.arn = arn
        self.databaseName = databaseName
        self.type = type
    }
}

public struct DeleteAppInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppInput>
    public typealias MOutput = OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppOutputError>
}

extension DeleteAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppInput(appId: \(String(describing: appId)))"}
}

extension DeleteAppInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId = "AppId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct DeleteAppInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppInput>
    public typealias MOutput = OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppOutputError>
}

public struct DeleteAppInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppInput>
    public typealias MOutput = OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppOutputError>
}

public struct DeleteAppInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct DeleteAppInputBody: Equatable {
    public let appId: String?
}

extension DeleteAppInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "AppId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension DeleteAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppOutputResponse()"}
}

extension DeleteAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppOutputResponse: Equatable {

    public init() {}
}

struct DeleteAppOutputResponseBody: Equatable {
}

extension DeleteAppOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteInstanceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceInput>
    public typealias MOutput = OperationOutput<DeleteInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceOutputError>
}

extension DeleteInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInstanceInput(deleteElasticIp: \(String(describing: deleteElasticIp)), deleteVolumes: \(String(describing: deleteVolumes)), instanceId: \(String(describing: instanceId)))"}
}

extension DeleteInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteElasticIp = "DeleteElasticIp"
        case deleteVolumes = "DeleteVolumes"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteElasticIp = deleteElasticIp {
            try encodeContainer.encode(deleteElasticIp, forKey: .deleteElasticIp)
        }
        if let deleteVolumes = deleteVolumes {
            try encodeContainer.encode(deleteVolumes, forKey: .deleteVolumes)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct DeleteInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceInput>
    public typealias MOutput = OperationOutput<DeleteInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceOutputError>
}

public struct DeleteInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInstanceInput>
    public typealias MOutput = OperationOutput<DeleteInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInstanceOutputError>
}

public struct DeleteInstanceInput: Equatable {
    /// <p>Whether to delete the instance Elastic IP address.</p>
    public let deleteElasticIp: Bool?
    /// <p>Whether to delete the instance's Amazon EBS volumes.</p>
    public let deleteVolumes: Bool?
    /// <p>The instance ID.</p>
    public let instanceId: String?

    public init (
        deleteElasticIp: Bool? = nil,
        deleteVolumes: Bool? = nil,
        instanceId: String? = nil
    )
    {
        self.deleteElasticIp = deleteElasticIp
        self.deleteVolumes = deleteVolumes
        self.instanceId = instanceId
    }
}

struct DeleteInstanceInputBody: Equatable {
    public let instanceId: String?
    public let deleteElasticIp: Bool?
    public let deleteVolumes: Bool?
}

extension DeleteInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deleteElasticIp = "DeleteElasticIp"
        case deleteVolumes = "DeleteVolumes"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let deleteElasticIpDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deleteElasticIp)
        deleteElasticIp = deleteElasticIpDecoded
        let deleteVolumesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deleteVolumes)
        deleteVolumes = deleteVolumesDecoded
    }
}

extension DeleteInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInstanceOutputResponse()"}
}

extension DeleteInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInstanceOutputResponse: Equatable {

    public init() {}
}

struct DeleteInstanceOutputResponseBody: Equatable {
}

extension DeleteInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteLayerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLayerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLayerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLayerInput>
    public typealias MOutput = OperationOutput<DeleteLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLayerOutputError>
}

extension DeleteLayerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLayerInput(layerId: \(String(describing: layerId)))"}
}

extension DeleteLayerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerId = "LayerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
    }
}

public struct DeleteLayerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLayerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLayerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLayerInput>
    public typealias MOutput = OperationOutput<DeleteLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLayerOutputError>
}

public struct DeleteLayerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLayerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLayerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLayerInput>
    public typealias MOutput = OperationOutput<DeleteLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLayerOutputError>
}

public struct DeleteLayerInput: Equatable {
    /// <p>The layer ID.</p>
    public let layerId: String?

    public init (
        layerId: String? = nil
    )
    {
        self.layerId = layerId
    }
}

struct DeleteLayerInputBody: Equatable {
    public let layerId: String?
}

extension DeleteLayerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerId = "LayerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

extension DeleteLayerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLayerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLayerOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLayerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLayerOutputResponse()"}
}

extension DeleteLayerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLayerOutputResponse: Equatable {

    public init() {}
}

struct DeleteLayerOutputResponseBody: Equatable {
}

extension DeleteLayerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteStackInputBodyMiddleware: Middleware {
    public let id: String = "DeleteStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackInput>
    public typealias MOutput = OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackOutputError>
}

extension DeleteStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStackInput(stackId: \(String(describing: stackId)))"}
}

extension DeleteStackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DeleteStackInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackInput>
    public typealias MOutput = OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackOutputError>
}

public struct DeleteStackInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStackInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStackInput>
    public typealias MOutput = OperationOutput<DeleteStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStackOutputError>
}

public struct DeleteStackInput: Equatable {
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        stackId: String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct DeleteStackInputBody: Equatable {
    public let stackId: String?
}

extension DeleteStackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension DeleteStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStackOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStackOutputResponse()"}
}

extension DeleteStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStackOutputResponse: Equatable {

    public init() {}
}

struct DeleteStackOutputResponseBody: Equatable {
}

extension DeleteStackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserProfileInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserProfileInput>
    public typealias MOutput = OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserProfileOutputError>
}

extension DeleteUserProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserProfileInput(iamUserArn: \(String(describing: iamUserArn)))"}
}

extension DeleteUserProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iamUserArn = "IamUserArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
    }
}

public struct DeleteUserProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserProfileInput>
    public typealias MOutput = OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserProfileOutputError>
}

public struct DeleteUserProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserProfileInput>
    public typealias MOutput = OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserProfileOutputError>
}

public struct DeleteUserProfileInput: Equatable {
    /// <p>The user's IAM ARN. This can also be a federated user's ARN.</p>
    public let iamUserArn: String?

    public init (
        iamUserArn: String? = nil
    )
    {
        self.iamUserArn = iamUserArn
    }
}

struct DeleteUserProfileInputBody: Equatable {
    public let iamUserArn: String?
}

extension DeleteUserProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iamUserArn = "IamUserArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
    }
}

extension DeleteUserProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserProfileOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserProfileOutputResponse()"}
}

extension DeleteUserProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserProfileOutputResponseBody: Equatable {
}

extension DeleteUserProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Deployment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId = "AppId"
        case command = "Command"
        case comment = "Comment"
        case completedAt = "CompletedAt"
        case createdAt = "CreatedAt"
        case customJson = "CustomJson"
        case deploymentId = "DeploymentId"
        case duration = "Duration"
        case iamUserArn = "IamUserArn"
        case instanceIds = "InstanceIds"
        case stackId = "StackId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let command = command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let completedAt = completedAt {
            try encodeContainer.encode(completedAt, forKey: .completedAt)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for strings0 in instanceIds {
                try instanceIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .duration)
        duration = durationDecoded
        let iamUserArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let commandDecoded = try containerValues.decodeIfPresent(DeploymentCommand.self, forKey: .command)
        command = commandDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension Deployment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Deployment(appId: \(String(describing: appId)), command: \(String(describing: command)), comment: \(String(describing: comment)), completedAt: \(String(describing: completedAt)), createdAt: \(String(describing: createdAt)), customJson: \(String(describing: customJson)), deploymentId: \(String(describing: deploymentId)), duration: \(String(describing: duration)), iamUserArn: \(String(describing: iamUserArn)), instanceIds: \(String(describing: instanceIds)), stackId: \(String(describing: stackId)), status: \(String(describing: status)))"}
}

/// <p>Describes a deployment of a stack or app.</p>
public struct Deployment: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>Used to specify a stack or deployment command.</p>
    public let command: DeploymentCommand?
    /// <p>A user-defined comment.</p>
    public let comment: String?
    /// <p>Date when the deployment completed.</p>
    public let completedAt: String?
    /// <p>Date when the deployment was created.</p>
    public let createdAt: String?
    /// <p>A string that contains user-defined custom JSON. It can be used to override the corresponding default stack configuration attribute values for stack or to pass data to recipes. The string should be in the following format:</p>
    ///          <p>
    ///             <code>"{\"key1\": \"value1\", \"key2\": \"value2\",...}"</code>
    ///          </p>
    ///          <p>For more information on custom JSON, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html">Use Custom JSON to
    ///         Modify the Stack Configuration Attributes</a>.</p>
    public let customJson: String?
    /// <p>The deployment ID.</p>
    public let deploymentId: String?
    /// <p>The deployment duration.</p>
    public let duration: Int?
    /// <p>The user's IAM ARN.</p>
    public let iamUserArn: String?
    /// <p>The IDs of the target instances.</p>
    public let instanceIds: [String]?
    /// <p>The stack ID.</p>
    public let stackId: String?
    /// <p>The deployment status:</p>
    ///          <ul>
    ///             <li>
    ///                <p>running</p>
    ///             </li>
    ///             <li>
    ///                <p>successful</p>
    ///             </li>
    ///             <li>
    ///                <p>failed</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        appId: String? = nil,
        command: DeploymentCommand? = nil,
        comment: String? = nil,
        completedAt: String? = nil,
        createdAt: String? = nil,
        customJson: String? = nil,
        deploymentId: String? = nil,
        duration: Int? = nil,
        iamUserArn: String? = nil,
        instanceIds: [String]? = nil,
        stackId: String? = nil,
        status: String? = nil
    )
    {
        self.appId = appId
        self.command = command
        self.comment = comment
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.customJson = customJson
        self.deploymentId = deploymentId
        self.duration = duration
        self.iamUserArn = iamUserArn
        self.instanceIds = instanceIds
        self.stackId = stackId
        self.status = status
    }
}

extension DeploymentCommand: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case args = "Args"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let args = args {
            var argsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .args)
            for (dictKey0, deploymentcommandargs0) in args {
                try argsContainer.encode(deploymentcommandargs0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(DeploymentCommandName.self, forKey: .name)
        name = nameDecoded
        let argsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .args)
        var argsDecoded0: [String:[String]]? = nil
        if let argsContainer = argsContainer {
            argsDecoded0 = [String:[String]]()
            for (key0, strings0) in argsContainer {
                var strings0Decoded0: [String]? = nil
                if let strings0 = strings0 {
                    strings0Decoded0 = [String]()
                    for string1 in strings0 {
                        if let string1 = string1 {
                            strings0Decoded0?.append(string1)
                        }
                    }
                }
                argsDecoded0?[key0] = strings0Decoded0
            }
        }
        args = argsDecoded0
    }
}

extension DeploymentCommand: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentCommand(args: \(String(describing: args)), name: \(String(describing: name)))"}
}

/// <p>Used to specify a stack or deployment command.</p>
public struct DeploymentCommand: Equatable {
    /// <p>The arguments of those commands that take arguments. It should be set to a JSON object with the following format:</p>
    ///          <p>
    ///             <code>{"arg_name1" : ["value1", "value2", ...], "arg_name2" : ["value1", "value2", ...],
    ///         ...}</code>
    ///          </p>
    ///          <p>The <code>update_dependencies</code> command takes two arguments:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>upgrade_os_to</code> - Specifies the desired Amazon Linux version for instances
    ///         whose OS you want to upgrade, such as <code>Amazon Linux 2016.09</code>. You must also set
    ///         the <code>allow_reboot</code> argument to true.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>allow_reboot</code> - Specifies whether to allow AWS OpsWorks Stacks to reboot the instances if
    ///         necessary, after installing the updates. This argument can be set to either
    ///           <code>true</code> or <code>false</code>. The default value is <code>false</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, to upgrade an instance to Amazon Linux 2016.09, set <code>Args</code> to the
    ///       following.</p>
    ///          <p>
    ///             <code> { "upgrade_os_to":["Amazon Linux 2016.09"], "allow_reboot":["true"] } </code>
    ///          </p>
    public let args: [String:[String]]?
    /// <p>Specifies the operation. You can specify only one command.</p>
    ///          <p>For stacks, the following commands are available:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>execute_recipes</code>: Execute one or more recipes. To specify the recipes, set an
    ///           <code>Args</code> parameter named <code>recipes</code> to the list of recipes to be
    ///         executed. For example, to execute <code>phpapp::appsetup</code>, set <code>Args</code> to
    ///           <code>{"recipes":["phpapp::appsetup"]}</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>install_dependencies</code>: Install the stack's dependencies.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>update_custom_cookbooks</code>: Update the stack's custom cookbooks.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>update_dependencies</code>: Update the stack's dependencies.</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>The update_dependencies and install_dependencies commands are supported only for Linux instances. You can run the commands successfully on Windows instances, but they do nothing.</p>
    ///          </note>
    ///          <p>For apps, the following commands are available:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>deploy</code>: Deploy an app. Ruby on Rails apps have an optional <code>Args</code>
    ///         parameter named <code>migrate</code>. Set <code>Args</code> to {"migrate":["true"]} to
    ///         migrate the database. The default setting is {"migrate":["false"]}.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rollback</code> Roll the app back to the previous version. When you update an app,
    ///         AWS OpsWorks Stacks stores the previous version, up to a maximum of five versions. You can use this
    ///         command to roll an app back as many as four versions.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>start</code>: Start the app's web or application server.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>stop</code>: Stop the app's web or application server.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>restart</code>: Restart the app's web or application server.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>undeploy</code>: Undeploy the app.</p>
    ///             </li>
    ///          </ul>
    public let name: DeploymentCommandName?

    public init (
        args: [String:[String]]? = nil,
        name: DeploymentCommandName? = nil
    )
    {
        self.args = args
        self.name = name
    }
}

public enum DeploymentCommandName {
    case configure
    case deploy
    case executeRecipes
    case installDependencies
    case restart
    case rollback
    case setup
    case start
    case stop
    case undeploy
    case updateCustomCookbooks
    case updateDependencies
    case sdkUnknown(String)
}

extension DeploymentCommandName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentCommandName] {
        return [
            .configure,
            .deploy,
            .executeRecipes,
            .installDependencies,
            .restart,
            .rollback,
            .setup,
            .start,
            .stop,
            .undeploy,
            .updateCustomCookbooks,
            .updateDependencies,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .configure: return "configure"
        case .deploy: return "deploy"
        case .executeRecipes: return "execute_recipes"
        case .installDependencies: return "install_dependencies"
        case .restart: return "restart"
        case .rollback: return "rollback"
        case .setup: return "setup"
        case .start: return "start"
        case .stop: return "stop"
        case .undeploy: return "undeploy"
        case .updateCustomCookbooks: return "update_custom_cookbooks"
        case .updateDependencies: return "update_dependencies"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentCommandName(rawValue: rawValue) ?? DeploymentCommandName.sdkUnknown(rawValue)
    }
}

public struct DeregisterEcsClusterInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterEcsClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterEcsClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterEcsClusterInput>
    public typealias MOutput = OperationOutput<DeregisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterEcsClusterOutputError>
}

extension DeregisterEcsClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterEcsClusterInput(ecsClusterArn: \(String(describing: ecsClusterArn)))"}
}

extension DeregisterEcsClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ecsClusterArn = "EcsClusterArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecsClusterArn = ecsClusterArn {
            try encodeContainer.encode(ecsClusterArn, forKey: .ecsClusterArn)
        }
    }
}

public struct DeregisterEcsClusterInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterEcsClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterEcsClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterEcsClusterInput>
    public typealias MOutput = OperationOutput<DeregisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterEcsClusterOutputError>
}

public struct DeregisterEcsClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterEcsClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterEcsClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterEcsClusterInput>
    public typealias MOutput = OperationOutput<DeregisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterEcsClusterOutputError>
}

public struct DeregisterEcsClusterInput: Equatable {
    /// <p>The cluster's Amazon Resource Number (ARN).</p>
    public let ecsClusterArn: String?

    public init (
        ecsClusterArn: String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
    }
}

struct DeregisterEcsClusterInputBody: Equatable {
    public let ecsClusterArn: String?
}

extension DeregisterEcsClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ecsClusterArn = "EcsClusterArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
    }
}

extension DeregisterEcsClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterEcsClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterEcsClusterOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterEcsClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterEcsClusterOutputResponse()"}
}

extension DeregisterEcsClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterEcsClusterOutputResponse: Equatable {

    public init() {}
}

struct DeregisterEcsClusterOutputResponseBody: Equatable {
}

extension DeregisterEcsClusterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterElasticIpInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterElasticIpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterElasticIpInput>
    public typealias MOutput = OperationOutput<DeregisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterElasticIpOutputError>
}

extension DeregisterElasticIpInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterElasticIpInput(elasticIp: \(String(describing: elasticIp)))"}
}

extension DeregisterElasticIpInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
    }
}

public struct DeregisterElasticIpInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterElasticIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterElasticIpInput>
    public typealias MOutput = OperationOutput<DeregisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterElasticIpOutputError>
}

public struct DeregisterElasticIpInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterElasticIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterElasticIpInput>
    public typealias MOutput = OperationOutput<DeregisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterElasticIpOutputError>
}

public struct DeregisterElasticIpInput: Equatable {
    /// <p>The Elastic IP address.</p>
    public let elasticIp: String?

    public init (
        elasticIp: String? = nil
    )
    {
        self.elasticIp = elasticIp
    }
}

struct DeregisterElasticIpInputBody: Equatable {
    public let elasticIp: String?
}

extension DeregisterElasticIpInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
    }
}

extension DeregisterElasticIpOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterElasticIpOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterElasticIpOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterElasticIpOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterElasticIpOutputResponse()"}
}

extension DeregisterElasticIpOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterElasticIpOutputResponse: Equatable {

    public init() {}
}

struct DeregisterElasticIpOutputResponseBody: Equatable {
}

extension DeregisterElasticIpOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterInstanceInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterInstanceOutputError>
}

extension DeregisterInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterInstanceInput(instanceId: \(String(describing: instanceId)))"}
}

extension DeregisterInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct DeregisterInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterInstanceOutputError>
}

public struct DeregisterInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterInstanceInput>
    public typealias MOutput = OperationOutput<DeregisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterInstanceOutputError>
}

public struct DeregisterInstanceInput: Equatable {
    /// <p>The instance ID.</p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DeregisterInstanceInputBody: Equatable {
    public let instanceId: String?
}

extension DeregisterInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension DeregisterInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterInstanceOutputResponse()"}
}

extension DeregisterInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterInstanceOutputResponse: Equatable {

    public init() {}
}

struct DeregisterInstanceOutputResponseBody: Equatable {
}

extension DeregisterInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterRdsDbInstanceInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterRdsDbInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterRdsDbInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterRdsDbInstanceInput>
    public typealias MOutput = OperationOutput<DeregisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterRdsDbInstanceOutputError>
}

extension DeregisterRdsDbInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterRdsDbInstanceInput(rdsDbInstanceArn: \(String(describing: rdsDbInstanceArn)))"}
}

extension DeregisterRdsDbInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rdsDbInstanceArn = "RdsDbInstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rdsDbInstanceArn = rdsDbInstanceArn {
            try encodeContainer.encode(rdsDbInstanceArn, forKey: .rdsDbInstanceArn)
        }
    }
}

public struct DeregisterRdsDbInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterRdsDbInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterRdsDbInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterRdsDbInstanceInput>
    public typealias MOutput = OperationOutput<DeregisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterRdsDbInstanceOutputError>
}

public struct DeregisterRdsDbInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterRdsDbInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterRdsDbInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterRdsDbInstanceInput>
    public typealias MOutput = OperationOutput<DeregisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterRdsDbInstanceOutputError>
}

public struct DeregisterRdsDbInstanceInput: Equatable {
    /// <p>The Amazon RDS instance's ARN.</p>
    public let rdsDbInstanceArn: String?

    public init (
        rdsDbInstanceArn: String? = nil
    )
    {
        self.rdsDbInstanceArn = rdsDbInstanceArn
    }
}

struct DeregisterRdsDbInstanceInputBody: Equatable {
    public let rdsDbInstanceArn: String?
}

extension DeregisterRdsDbInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rdsDbInstanceArn = "RdsDbInstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsDbInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rdsDbInstanceArn)
        rdsDbInstanceArn = rdsDbInstanceArnDecoded
    }
}

extension DeregisterRdsDbInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterRdsDbInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterRdsDbInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterRdsDbInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterRdsDbInstanceOutputResponse()"}
}

extension DeregisterRdsDbInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterRdsDbInstanceOutputResponse: Equatable {

    public init() {}
}

struct DeregisterRdsDbInstanceOutputResponseBody: Equatable {
}

extension DeregisterRdsDbInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterVolumeInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterVolumeInput>
    public typealias MOutput = OperationOutput<DeregisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterVolumeOutputError>
}

extension DeregisterVolumeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterVolumeInput(volumeId: \(String(describing: volumeId)))"}
}

extension DeregisterVolumeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case volumeId = "VolumeId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }
}

public struct DeregisterVolumeInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterVolumeInput>
    public typealias MOutput = OperationOutput<DeregisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterVolumeOutputError>
}

public struct DeregisterVolumeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterVolumeInput>
    public typealias MOutput = OperationOutput<DeregisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterVolumeOutputError>
}

public struct DeregisterVolumeInput: Equatable {
    /// <p>The AWS OpsWorks Stacks volume ID, which is the GUID that AWS OpsWorks Stacks assigned to the instance when you registered the volume with the stack, not the Amazon EC2 volume ID.</p>
    public let volumeId: String?

    public init (
        volumeId: String? = nil
    )
    {
        self.volumeId = volumeId
    }
}

struct DeregisterVolumeInputBody: Equatable {
    public let volumeId: String?
}

extension DeregisterVolumeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeId = "VolumeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
    }
}

extension DeregisterVolumeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterVolumeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterVolumeOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterVolumeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterVolumeOutputResponse()"}
}

extension DeregisterVolumeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterVolumeOutputResponse: Equatable {

    public init() {}
}

struct DeregisterVolumeOutputResponseBody: Equatable {
}

extension DeregisterVolumeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAgentVersionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAgentVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAgentVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAgentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAgentVersionsInput>
    public typealias MOutput = OperationOutput<DescribeAgentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAgentVersionsOutputError>
}

extension DescribeAgentVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAgentVersionsInput(configurationManager: \(String(describing: configurationManager)), stackId: \(String(describing: stackId)))"}
}

extension DescribeAgentVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationManager = "ConfigurationManager"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationManager = configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeAgentVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAgentVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAgentVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAgentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAgentVersionsInput>
    public typealias MOutput = OperationOutput<DescribeAgentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAgentVersionsOutputError>
}

public struct DescribeAgentVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAgentVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAgentVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAgentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAgentVersionsInput>
    public typealias MOutput = OperationOutput<DescribeAgentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAgentVersionsOutputError>
}

public struct DescribeAgentVersionsInput: Equatable {
    /// <p>The configuration manager.</p>
    public let configurationManager: StackConfigurationManager?
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        configurationManager: StackConfigurationManager? = nil,
        stackId: String? = nil
    )
    {
        self.configurationManager = configurationManager
        self.stackId = stackId
    }
}

struct DescribeAgentVersionsInputBody: Equatable {
    public let stackId: String?
    public let configurationManager: StackConfigurationManager?
}

extension DescribeAgentVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationManager = "ConfigurationManager"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
    }
}

extension DescribeAgentVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAgentVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAgentVersionsOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAgentVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAgentVersionsOutputResponse(agentVersions: \(String(describing: agentVersions)))"}
}

extension DescribeAgentVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAgentVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.agentVersions = output.agentVersions
        } else {
            self.agentVersions = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeAgentVersions</code> request.</p>
public struct DescribeAgentVersionsOutputResponse: Equatable {
    /// <p>The agent versions for the specified stack or configuration manager. Note that this value is the complete version number, not the abbreviated number used by the console.</p>
    public let agentVersions: [AgentVersion]?

    public init (
        agentVersions: [AgentVersion]? = nil
    )
    {
        self.agentVersions = agentVersions
    }
}

struct DescribeAgentVersionsOutputResponseBody: Equatable {
    public let agentVersions: [AgentVersion]?
}

extension DescribeAgentVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentVersions = "AgentVersions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionsContainer = try containerValues.decodeIfPresent([AgentVersion?].self, forKey: .agentVersions)
        var agentVersionsDecoded0:[AgentVersion]? = nil
        if let agentVersionsContainer = agentVersionsContainer {
            agentVersionsDecoded0 = [AgentVersion]()
            for structure0 in agentVersionsContainer {
                if let structure0 = structure0 {
                    agentVersionsDecoded0?.append(structure0)
                }
            }
        }
        agentVersions = agentVersionsDecoded0
    }
}

public struct DescribeAppsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAppsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAppsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAppsInput>
    public typealias MOutput = OperationOutput<DescribeAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAppsOutputError>
}

extension DescribeAppsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAppsInput(appIds: \(String(describing: appIds)), stackId: \(String(describing: stackId)))"}
}

extension DescribeAppsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appIds = "AppIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIds = appIds {
            var appIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appIds)
            for strings0 in appIds {
                try appIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeAppsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAppsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAppsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAppsInput>
    public typealias MOutput = OperationOutput<DescribeAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAppsOutputError>
}

public struct DescribeAppsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAppsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAppsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAppsInput>
    public typealias MOutput = OperationOutput<DescribeAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAppsOutputError>
}

public struct DescribeAppsInput: Equatable {
    /// <p>An array of app IDs for the apps to be described. If you use this parameter,
    ///         <code>DescribeApps</code> returns a description of the specified apps. Otherwise, it returns
    ///       a description of every app.</p>
    public let appIds: [String]?
    /// <p>The app stack ID. If you use this parameter, <code>DescribeApps</code> returns a description
    ///       of the apps in the specified stack.</p>
    public let stackId: String?

    public init (
        appIds: [String]? = nil,
        stackId: String? = nil
    )
    {
        self.appIds = appIds
        self.stackId = stackId
    }
}

struct DescribeAppsInputBody: Equatable {
    public let stackId: String?
    public let appIds: [String]?
}

extension DescribeAppsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appIds = "AppIds"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let appIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .appIds)
        var appIdsDecoded0:[String]? = nil
        if let appIdsContainer = appIdsContainer {
            appIdsDecoded0 = [String]()
            for string0 in appIdsContainer {
                if let string0 = string0 {
                    appIdsDecoded0?.append(string0)
                }
            }
        }
        appIds = appIdsDecoded0
    }
}

extension DescribeAppsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppsOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAppsOutputResponse(apps: \(String(describing: apps)))"}
}

extension DescribeAppsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAppsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apps = output.apps
        } else {
            self.apps = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeApps</code> request.</p>
public struct DescribeAppsOutputResponse: Equatable {
    /// <p>An array of <code>App</code> objects that describe the specified apps. </p>
    public let apps: [App]?

    public init (
        apps: [App]? = nil
    )
    {
        self.apps = apps
    }
}

struct DescribeAppsOutputResponseBody: Equatable {
    public let apps: [App]?
}

extension DescribeAppsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apps = "Apps"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsContainer = try containerValues.decodeIfPresent([App?].self, forKey: .apps)
        var appsDecoded0:[App]? = nil
        if let appsContainer = appsContainer {
            appsDecoded0 = [App]()
            for structure0 in appsContainer {
                if let structure0 = structure0 {
                    appsDecoded0?.append(structure0)
                }
            }
        }
        apps = appsDecoded0
    }
}

public struct DescribeCommandsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCommandsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCommandsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCommandsInput>
    public typealias MOutput = OperationOutput<DescribeCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCommandsOutputError>
}

extension DescribeCommandsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCommandsInput(commandIds: \(String(describing: commandIds)), deploymentId: \(String(describing: deploymentId)), instanceId: \(String(describing: instanceId)))"}
}

extension DescribeCommandsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commandIds = "CommandIds"
        case deploymentId = "DeploymentId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandIds = commandIds {
            var commandIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .commandIds)
            for strings0 in commandIds {
                try commandIdsContainer.encode(strings0)
            }
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct DescribeCommandsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCommandsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCommandsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCommandsInput>
    public typealias MOutput = OperationOutput<DescribeCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCommandsOutputError>
}

public struct DescribeCommandsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCommandsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCommandsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCommandsInput>
    public typealias MOutput = OperationOutput<DescribeCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCommandsOutputError>
}

public struct DescribeCommandsInput: Equatable {
    /// <p>An array of command IDs. If you include this parameter, <code>DescribeCommands</code> returns
    ///       a description of the specified commands. Otherwise, it returns a description of every
    ///       command.</p>
    public let commandIds: [String]?
    /// <p>The deployment ID. If you include this parameter, <code>DescribeCommands</code> returns a
    ///       description of the commands associated with the specified deployment.</p>
    public let deploymentId: String?
    /// <p>The instance ID. If you include this parameter, <code>DescribeCommands</code> returns a
    ///       description of the commands associated with the specified instance.</p>
    public let instanceId: String?

    public init (
        commandIds: [String]? = nil,
        deploymentId: String? = nil,
        instanceId: String? = nil
    )
    {
        self.commandIds = commandIds
        self.deploymentId = deploymentId
        self.instanceId = instanceId
    }
}

struct DescribeCommandsInputBody: Equatable {
    public let deploymentId: String?
    public let instanceId: String?
    public let commandIds: [String]?
}

extension DescribeCommandsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commandIds = "CommandIds"
        case deploymentId = "DeploymentId"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let commandIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .commandIds)
        var commandIdsDecoded0:[String]? = nil
        if let commandIdsContainer = commandIdsContainer {
            commandIdsDecoded0 = [String]()
            for string0 in commandIdsContainer {
                if let string0 = string0 {
                    commandIdsDecoded0?.append(string0)
                }
            }
        }
        commandIds = commandIdsDecoded0
    }
}

extension DescribeCommandsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCommandsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCommandsOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCommandsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCommandsOutputResponse(commands: \(String(describing: commands)))"}
}

extension DescribeCommandsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCommandsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commands = output.commands
        } else {
            self.commands = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeCommands</code> request.</p>
public struct DescribeCommandsOutputResponse: Equatable {
    /// <p>An array of <code>Command</code> objects that describe each of the specified commands.</p>
    public let commands: [Command]?

    public init (
        commands: [Command]? = nil
    )
    {
        self.commands = commands
    }
}

struct DescribeCommandsOutputResponseBody: Equatable {
    public let commands: [Command]?
}

extension DescribeCommandsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commands = "Commands"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandsContainer = try containerValues.decodeIfPresent([Command?].self, forKey: .commands)
        var commandsDecoded0:[Command]? = nil
        if let commandsContainer = commandsContainer {
            commandsDecoded0 = [Command]()
            for structure0 in commandsContainer {
                if let structure0 = structure0 {
                    commandsDecoded0?.append(structure0)
                }
            }
        }
        commands = commandsDecoded0
    }
}

public struct DescribeDeploymentsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDeploymentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeploymentsInput>
    public typealias MOutput = OperationOutput<DescribeDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeploymentsOutputError>
}

extension DescribeDeploymentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDeploymentsInput(appId: \(String(describing: appId)), deploymentIds: \(String(describing: deploymentIds)), stackId: \(String(describing: stackId)))"}
}

extension DescribeDeploymentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId = "AppId"
        case deploymentIds = "DeploymentIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let deploymentIds = deploymentIds {
            var deploymentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploymentIds)
            for strings0 in deploymentIds {
                try deploymentIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeDeploymentsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeploymentsInput>
    public typealias MOutput = OperationOutput<DescribeDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeploymentsOutputError>
}

public struct DescribeDeploymentsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeploymentsInput>
    public typealias MOutput = OperationOutput<DescribeDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeploymentsOutputError>
}

public struct DescribeDeploymentsInput: Equatable {
    /// <p>The app ID. If you include this parameter, the command returns a
    ///       description of the commands associated with the specified app.</p>
    public let appId: String?
    /// <p>An array of deployment IDs to be described. If you include this parameter,
    ///         the command returns a description of the specified deployments.
    ///       Otherwise, it returns a description of every deployment.</p>
    public let deploymentIds: [String]?
    /// <p>The stack ID. If you include this parameter, the command returns a
    ///       description of the commands associated with the specified stack.</p>
    public let stackId: String?

    public init (
        appId: String? = nil,
        deploymentIds: [String]? = nil,
        stackId: String? = nil
    )
    {
        self.appId = appId
        self.deploymentIds = deploymentIds
        self.stackId = stackId
    }
}

struct DescribeDeploymentsInputBody: Equatable {
    public let stackId: String?
    public let appId: String?
    public let deploymentIds: [String]?
}

extension DescribeDeploymentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "AppId"
        case deploymentIds = "DeploymentIds"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let deploymentIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deploymentIds)
        var deploymentIdsDecoded0:[String]? = nil
        if let deploymentIdsContainer = deploymentIdsContainer {
            deploymentIdsDecoded0 = [String]()
            for string0 in deploymentIdsContainer {
                if let string0 = string0 {
                    deploymentIdsDecoded0?.append(string0)
                }
            }
        }
        deploymentIds = deploymentIdsDecoded0
    }
}

extension DescribeDeploymentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeploymentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDeploymentsOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeploymentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDeploymentsOutputResponse(deployments: \(String(describing: deployments)))"}
}

extension DescribeDeploymentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deployments = output.deployments
        } else {
            self.deployments = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeDeployments</code> request.</p>
public struct DescribeDeploymentsOutputResponse: Equatable {
    /// <p>An array of <code>Deployment</code> objects that describe the deployments.</p>
    public let deployments: [Deployment]?

    public init (
        deployments: [Deployment]? = nil
    )
    {
        self.deployments = deployments
    }
}

struct DescribeDeploymentsOutputResponseBody: Equatable {
    public let deployments: [Deployment]?
}

extension DescribeDeploymentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deployments = "Deployments"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([Deployment?].self, forKey: .deployments)
        var deploymentsDecoded0:[Deployment]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [Deployment]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
    }
}

public struct DescribeEcsClustersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEcsClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEcsClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEcsClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEcsClustersInput>
    public typealias MOutput = OperationOutput<DescribeEcsClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEcsClustersOutputError>
}

extension DescribeEcsClustersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEcsClustersInput(ecsClusterArns: \(String(describing: ecsClusterArns)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), stackId: \(String(describing: stackId)))"}
}

extension DescribeEcsClustersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ecsClusterArns = "EcsClusterArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecsClusterArns = ecsClusterArns {
            var ecsClusterArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecsClusterArns)
            for strings0 in ecsClusterArns {
                try ecsClusterArnsContainer.encode(strings0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeEcsClustersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEcsClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEcsClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEcsClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEcsClustersInput>
    public typealias MOutput = OperationOutput<DescribeEcsClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEcsClustersOutputError>
}

public struct DescribeEcsClustersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEcsClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEcsClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEcsClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEcsClustersInput>
    public typealias MOutput = OperationOutput<DescribeEcsClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEcsClustersOutputError>
}

public struct DescribeEcsClustersInput: Equatable {
    /// <p>A list of ARNs, one for each cluster to be described.</p>
    public let ecsClusterArns: [String]?
    /// <p>To receive a paginated response, use this parameter to specify the maximum number
    ///       of results to be returned with a single call. If the number of available results exceeds this maximum, the
    ///       response includes a <code>NextToken</code> value that you can assign
    ///       to the <code>NextToken</code> request parameter to get the next set of results.</p>
    public let maxResults: Int?
    /// <p>If the previous paginated request did not return all of the remaining results,
    ///       the response object's<code>NextToken</code> parameter value is set to a token.
    ///       To retrieve the next set of results, call <code>DescribeEcsClusters</code>
    ///       again and assign that token to the request object's <code>NextToken</code> parameter.
    ///       If there are no remaining results, the previous response
    ///       object's <code>NextToken</code> parameter is set to <code>null</code>.</p>
    public let nextToken: String?
    /// <p>A stack ID.
    ///       <code>DescribeEcsClusters</code> returns a description of the cluster that is registered with the stack.</p>
    public let stackId: String?

    public init (
        ecsClusterArns: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        stackId: String? = nil
    )
    {
        self.ecsClusterArns = ecsClusterArns
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackId = stackId
    }
}

struct DescribeEcsClustersInputBody: Equatable {
    public let ecsClusterArns: [String]?
    public let stackId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeEcsClustersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ecsClusterArns = "EcsClusterArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ecsClusterArns)
        var ecsClusterArnsDecoded0:[String]? = nil
        if let ecsClusterArnsContainer = ecsClusterArnsContainer {
            ecsClusterArnsDecoded0 = [String]()
            for string0 in ecsClusterArnsContainer {
                if let string0 = string0 {
                    ecsClusterArnsDecoded0?.append(string0)
                }
            }
        }
        ecsClusterArns = ecsClusterArnsDecoded0
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeEcsClustersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEcsClustersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEcsClustersOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEcsClustersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEcsClustersOutputResponse(ecsClusters: \(String(describing: ecsClusters)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEcsClustersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEcsClustersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ecsClusters = output.ecsClusters
            self.nextToken = output.nextToken
        } else {
            self.ecsClusters = nil
            self.nextToken = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeEcsClusters</code> request.</p>
public struct DescribeEcsClustersOutputResponse: Equatable {
    /// <p>A list of <code>EcsCluster</code> objects containing the cluster descriptions.</p>
    public let ecsClusters: [EcsCluster]?
    /// <p>If a paginated request does not return all of the remaining results, this parameter is set to a token that
    ///       you can assign to the request object's <code>NextToken</code> parameter to retrieve the next set of results.
    ///       If the previous paginated request returned all of the remaining results,
    ///       this parameter is set to <code>null</code>.</p>
    public let nextToken: String?

    public init (
        ecsClusters: [EcsCluster]? = nil,
        nextToken: String? = nil
    )
    {
        self.ecsClusters = ecsClusters
        self.nextToken = nextToken
    }
}

struct DescribeEcsClustersOutputResponseBody: Equatable {
    public let ecsClusters: [EcsCluster]?
    public let nextToken: String?
}

extension DescribeEcsClustersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ecsClusters = "EcsClusters"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClustersContainer = try containerValues.decodeIfPresent([EcsCluster?].self, forKey: .ecsClusters)
        var ecsClustersDecoded0:[EcsCluster]? = nil
        if let ecsClustersContainer = ecsClustersContainer {
            ecsClustersDecoded0 = [EcsCluster]()
            for structure0 in ecsClustersContainer {
                if let structure0 = structure0 {
                    ecsClustersDecoded0?.append(structure0)
                }
            }
        }
        ecsClusters = ecsClustersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeElasticIpsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeElasticIpsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeElasticIpsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeElasticIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeElasticIpsInput>
    public typealias MOutput = OperationOutput<DescribeElasticIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeElasticIpsOutputError>
}

extension DescribeElasticIpsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeElasticIpsInput(instanceId: \(String(describing: instanceId)), ips: \(String(describing: ips)), stackId: \(String(describing: stackId)))"}
}

extension DescribeElasticIpsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case ips = "Ips"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let ips = ips {
            var ipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ips)
            for strings0 in ips {
                try ipsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeElasticIpsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeElasticIpsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeElasticIpsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeElasticIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeElasticIpsInput>
    public typealias MOutput = OperationOutput<DescribeElasticIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeElasticIpsOutputError>
}

public struct DescribeElasticIpsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeElasticIpsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeElasticIpsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeElasticIpsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeElasticIpsInput>
    public typealias MOutput = OperationOutput<DescribeElasticIpsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeElasticIpsOutputError>
}

public struct DescribeElasticIpsInput: Equatable {
    /// <p>The instance ID. If you include this parameter, <code>DescribeElasticIps</code> returns a
    ///       description of the Elastic IP addresses associated with the specified instance.</p>
    public let instanceId: String?
    /// <p>An array of Elastic IP addresses to be described. If you include this parameter,
    ///         <code>DescribeElasticIps</code> returns a description of the specified Elastic IP addresses.
    ///       Otherwise, it returns a description of every Elastic IP address.</p>
    public let ips: [String]?
    /// <p>A stack ID. If you include this parameter, <code>DescribeElasticIps</code> returns a
    ///       description of the Elastic IP addresses that are registered with the specified stack.</p>
    public let stackId: String?

    public init (
        instanceId: String? = nil,
        ips: [String]? = nil,
        stackId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.ips = ips
        self.stackId = stackId
    }
}

struct DescribeElasticIpsInputBody: Equatable {
    public let instanceId: String?
    public let stackId: String?
    public let ips: [String]?
}

extension DescribeElasticIpsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case ips = "Ips"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let ipsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ips)
        var ipsDecoded0:[String]? = nil
        if let ipsContainer = ipsContainer {
            ipsDecoded0 = [String]()
            for string0 in ipsContainer {
                if let string0 = string0 {
                    ipsDecoded0?.append(string0)
                }
            }
        }
        ips = ipsDecoded0
    }
}

extension DescribeElasticIpsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeElasticIpsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeElasticIpsOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeElasticIpsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeElasticIpsOutputResponse(elasticIps: \(String(describing: elasticIps)))"}
}

extension DescribeElasticIpsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeElasticIpsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.elasticIps = output.elasticIps
        } else {
            self.elasticIps = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeElasticIps</code> request.</p>
public struct DescribeElasticIpsOutputResponse: Equatable {
    /// <p>An <code>ElasticIps</code> object that describes the specified Elastic IP addresses.</p>
    public let elasticIps: [ElasticIp]?

    public init (
        elasticIps: [ElasticIp]? = nil
    )
    {
        self.elasticIps = elasticIps
    }
}

struct DescribeElasticIpsOutputResponseBody: Equatable {
    public let elasticIps: [ElasticIp]?
}

extension DescribeElasticIpsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case elasticIps = "ElasticIps"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpsContainer = try containerValues.decodeIfPresent([ElasticIp?].self, forKey: .elasticIps)
        var elasticIpsDecoded0:[ElasticIp]? = nil
        if let elasticIpsContainer = elasticIpsContainer {
            elasticIpsDecoded0 = [ElasticIp]()
            for structure0 in elasticIpsContainer {
                if let structure0 = structure0 {
                    elasticIpsDecoded0?.append(structure0)
                }
            }
        }
        elasticIps = elasticIpsDecoded0
    }
}

public struct DescribeElasticLoadBalancersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeElasticLoadBalancersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeElasticLoadBalancersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeElasticLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeElasticLoadBalancersInput>
    public typealias MOutput = OperationOutput<DescribeElasticLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeElasticLoadBalancersOutputError>
}

extension DescribeElasticLoadBalancersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeElasticLoadBalancersInput(layerIds: \(String(describing: layerIds)), stackId: \(String(describing: stackId)))"}
}

extension DescribeElasticLoadBalancersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeElasticLoadBalancersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeElasticLoadBalancersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeElasticLoadBalancersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeElasticLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeElasticLoadBalancersInput>
    public typealias MOutput = OperationOutput<DescribeElasticLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeElasticLoadBalancersOutputError>
}

public struct DescribeElasticLoadBalancersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeElasticLoadBalancersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeElasticLoadBalancersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeElasticLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeElasticLoadBalancersInput>
    public typealias MOutput = OperationOutput<DescribeElasticLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeElasticLoadBalancersOutputError>
}

public struct DescribeElasticLoadBalancersInput: Equatable {
    /// <p>A list of layer IDs. The action describes the Elastic Load Balancing instances for the specified layers.</p>
    public let layerIds: [String]?
    /// <p>A stack ID. The action describes the stack's Elastic Load Balancing instances.</p>
    public let stackId: String?

    public init (
        layerIds: [String]? = nil,
        stackId: String? = nil
    )
    {
        self.layerIds = layerIds
        self.stackId = stackId
    }
}

struct DescribeElasticLoadBalancersInputBody: Equatable {
    public let stackId: String?
    public let layerIds: [String]?
}

extension DescribeElasticLoadBalancersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
    }
}

extension DescribeElasticLoadBalancersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeElasticLoadBalancersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeElasticLoadBalancersOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeElasticLoadBalancersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeElasticLoadBalancersOutputResponse(elasticLoadBalancers: \(String(describing: elasticLoadBalancers)))"}
}

extension DescribeElasticLoadBalancersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeElasticLoadBalancersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.elasticLoadBalancers = output.elasticLoadBalancers
        } else {
            self.elasticLoadBalancers = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeElasticLoadBalancers</code> request.</p>
public struct DescribeElasticLoadBalancersOutputResponse: Equatable {
    /// <p>A list of <code>ElasticLoadBalancer</code> objects that describe the specified Elastic Load Balancing
    ///       instances.</p>
    public let elasticLoadBalancers: [ElasticLoadBalancer]?

    public init (
        elasticLoadBalancers: [ElasticLoadBalancer]? = nil
    )
    {
        self.elasticLoadBalancers = elasticLoadBalancers
    }
}

struct DescribeElasticLoadBalancersOutputResponseBody: Equatable {
    public let elasticLoadBalancers: [ElasticLoadBalancer]?
}

extension DescribeElasticLoadBalancersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case elasticLoadBalancers = "ElasticLoadBalancers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticLoadBalancersContainer = try containerValues.decodeIfPresent([ElasticLoadBalancer?].self, forKey: .elasticLoadBalancers)
        var elasticLoadBalancersDecoded0:[ElasticLoadBalancer]? = nil
        if let elasticLoadBalancersContainer = elasticLoadBalancersContainer {
            elasticLoadBalancersDecoded0 = [ElasticLoadBalancer]()
            for structure0 in elasticLoadBalancersContainer {
                if let structure0 = structure0 {
                    elasticLoadBalancersDecoded0?.append(structure0)
                }
            }
        }
        elasticLoadBalancers = elasticLoadBalancersDecoded0
    }
}

public struct DescribeInstancesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancesInput>
    public typealias MOutput = OperationOutput<DescribeInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancesOutputError>
}

extension DescribeInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstancesInput(instanceIds: \(String(describing: instanceIds)), layerId: \(String(describing: layerId)), stackId: \(String(describing: stackId)))"}
}

extension DescribeInstancesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceIds = "InstanceIds"
        case layerId = "LayerId"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for strings0 in instanceIds {
                try instanceIdsContainer.encode(strings0)
            }
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancesInput>
    public typealias MOutput = OperationOutput<DescribeInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancesOutputError>
}

public struct DescribeInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancesInput>
    public typealias MOutput = OperationOutput<DescribeInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancesOutputError>
}

public struct DescribeInstancesInput: Equatable {
    /// <p>An array of instance IDs to be described. If you use this parameter,
    ///         <code>DescribeInstances</code> returns a description of the specified instances. Otherwise,
    ///       it returns a description of every instance.</p>
    public let instanceIds: [String]?
    /// <p>A layer ID. If you use this parameter, <code>DescribeInstances</code> returns descriptions of
    ///       the instances associated with the specified layer.</p>
    public let layerId: String?
    /// <p>A stack ID. If you use this parameter, <code>DescribeInstances</code> returns descriptions of
    ///       the instances associated with the specified stack.</p>
    public let stackId: String?

    public init (
        instanceIds: [String]? = nil,
        layerId: String? = nil,
        stackId: String? = nil
    )
    {
        self.instanceIds = instanceIds
        self.layerId = layerId
        self.stackId = stackId
    }
}

struct DescribeInstancesInputBody: Equatable {
    public let stackId: String?
    public let layerId: String?
    public let instanceIds: [String]?
}

extension DescribeInstancesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceIds = "InstanceIds"
        case layerId = "LayerId"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension DescribeInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstancesOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstancesOutputResponse(instances: \(String(describing: instances)))"}
}

extension DescribeInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instances = output.instances
        } else {
            self.instances = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeInstances</code> request.</p>
public struct DescribeInstancesOutputResponse: Equatable {
    /// <p>An array of <code>Instance</code> objects that describe the instances.</p>
    public let instances: [Instance]?

    public init (
        instances: [Instance]? = nil
    )
    {
        self.instances = instances
    }
}

struct DescribeInstancesOutputResponseBody: Equatable {
    public let instances: [Instance]?
}

extension DescribeInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instances = "Instances"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([Instance?].self, forKey: .instances)
        var instancesDecoded0:[Instance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [Instance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
    }
}

public struct DescribeLayersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLayersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLayersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLayersInput>
    public typealias MOutput = OperationOutput<DescribeLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLayersOutputError>
}

extension DescribeLayersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLayersInput(layerIds: \(String(describing: layerIds)), stackId: \(String(describing: stackId)))"}
}

extension DescribeLayersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeLayersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLayersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLayersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLayersInput>
    public typealias MOutput = OperationOutput<DescribeLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLayersOutputError>
}

public struct DescribeLayersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLayersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLayersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLayersInput>
    public typealias MOutput = OperationOutput<DescribeLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLayersOutputError>
}

public struct DescribeLayersInput: Equatable {
    /// <p>An array of layer IDs that specify the layers to be described. If you omit this parameter,
    ///         <code>DescribeLayers</code> returns a description of every layer in the specified stack.</p>
    public let layerIds: [String]?
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        layerIds: [String]? = nil,
        stackId: String? = nil
    )
    {
        self.layerIds = layerIds
        self.stackId = stackId
    }
}

struct DescribeLayersInputBody: Equatable {
    public let stackId: String?
    public let layerIds: [String]?
}

extension DescribeLayersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
    }
}

extension DescribeLayersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLayersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLayersOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLayersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLayersOutputResponse(layers: \(String(describing: layers)))"}
}

extension DescribeLayersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLayersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.layers = output.layers
        } else {
            self.layers = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeLayers</code> request.</p>
public struct DescribeLayersOutputResponse: Equatable {
    /// <p>An array of <code>Layer</code> objects that describe the layers.</p>
    public let layers: [Layer]?

    public init (
        layers: [Layer]? = nil
    )
    {
        self.layers = layers
    }
}

struct DescribeLayersOutputResponseBody: Equatable {
    public let layers: [Layer]?
}

extension DescribeLayersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layers = "Layers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layersContainer = try containerValues.decodeIfPresent([Layer?].self, forKey: .layers)
        var layersDecoded0:[Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
    }
}

public struct DescribeLoadBasedAutoScalingInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLoadBasedAutoScalingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBasedAutoScalingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBasedAutoScalingInput>
    public typealias MOutput = OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBasedAutoScalingOutputError>
}

extension DescribeLoadBasedAutoScalingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBasedAutoScalingInput(layerIds: \(String(describing: layerIds)))"}
}

extension DescribeLoadBasedAutoScalingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerIds = "LayerIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
    }
}

public struct DescribeLoadBasedAutoScalingInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoadBasedAutoScalingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBasedAutoScalingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBasedAutoScalingInput>
    public typealias MOutput = OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBasedAutoScalingOutputError>
}

public struct DescribeLoadBasedAutoScalingInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoadBasedAutoScalingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBasedAutoScalingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBasedAutoScalingInput>
    public typealias MOutput = OperationOutput<DescribeLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBasedAutoScalingOutputError>
}

public struct DescribeLoadBasedAutoScalingInput: Equatable {
    /// <p>An array of layer IDs.</p>
    public let layerIds: [String]?

    public init (
        layerIds: [String]? = nil
    )
    {
        self.layerIds = layerIds
    }
}

struct DescribeLoadBasedAutoScalingInputBody: Equatable {
    public let layerIds: [String]?
}

extension DescribeLoadBasedAutoScalingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerIds = "LayerIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
    }
}

extension DescribeLoadBasedAutoScalingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoadBasedAutoScalingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoadBasedAutoScalingOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBasedAutoScalingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBasedAutoScalingOutputResponse(loadBasedAutoScalingConfigurations: \(String(describing: loadBasedAutoScalingConfigurations)))"}
}

extension DescribeLoadBasedAutoScalingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLoadBasedAutoScalingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loadBasedAutoScalingConfigurations = output.loadBasedAutoScalingConfigurations
        } else {
            self.loadBasedAutoScalingConfigurations = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeLoadBasedAutoScaling</code> request.</p>
public struct DescribeLoadBasedAutoScalingOutputResponse: Equatable {
    /// <p>An array of <code>LoadBasedAutoScalingConfiguration</code> objects that describe each layer's
    ///       configuration.</p>
    public let loadBasedAutoScalingConfigurations: [LoadBasedAutoScalingConfiguration]?

    public init (
        loadBasedAutoScalingConfigurations: [LoadBasedAutoScalingConfiguration]? = nil
    )
    {
        self.loadBasedAutoScalingConfigurations = loadBasedAutoScalingConfigurations
    }
}

struct DescribeLoadBasedAutoScalingOutputResponseBody: Equatable {
    public let loadBasedAutoScalingConfigurations: [LoadBasedAutoScalingConfiguration]?
}

extension DescribeLoadBasedAutoScalingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loadBasedAutoScalingConfigurations = "LoadBasedAutoScalingConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBasedAutoScalingConfigurationsContainer = try containerValues.decodeIfPresent([LoadBasedAutoScalingConfiguration?].self, forKey: .loadBasedAutoScalingConfigurations)
        var loadBasedAutoScalingConfigurationsDecoded0:[LoadBasedAutoScalingConfiguration]? = nil
        if let loadBasedAutoScalingConfigurationsContainer = loadBasedAutoScalingConfigurationsContainer {
            loadBasedAutoScalingConfigurationsDecoded0 = [LoadBasedAutoScalingConfiguration]()
            for structure0 in loadBasedAutoScalingConfigurationsContainer {
                if let structure0 = structure0 {
                    loadBasedAutoScalingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        loadBasedAutoScalingConfigurations = loadBasedAutoScalingConfigurationsDecoded0
    }
}

extension DescribeMyUserProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMyUserProfileInput()"}
}

extension DescribeMyUserProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeMyUserProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMyUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMyUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMyUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMyUserProfileInput>
    public typealias MOutput = OperationOutput<DescribeMyUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMyUserProfileOutputError>
}

public struct DescribeMyUserProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMyUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMyUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMyUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMyUserProfileInput>
    public typealias MOutput = OperationOutput<DescribeMyUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMyUserProfileOutputError>
}

public struct DescribeMyUserProfileInput: Equatable {

    public init() {}
}

struct DescribeMyUserProfileInputBody: Equatable {
}

extension DescribeMyUserProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeMyUserProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMyUserProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMyUserProfileOutputError: Swift.Error, Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMyUserProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMyUserProfileOutputResponse(userProfile: \(String(describing: userProfile)))"}
}

extension DescribeMyUserProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMyUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userProfile = output.userProfile
        } else {
            self.userProfile = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeMyUserProfile</code> request.</p>
public struct DescribeMyUserProfileOutputResponse: Equatable {
    /// <p>A <code>UserProfile</code> object that describes the user's SSH information.</p>
    public let userProfile: SelfUserProfile?

    public init (
        userProfile: SelfUserProfile? = nil
    )
    {
        self.userProfile = userProfile
    }
}

struct DescribeMyUserProfileOutputResponseBody: Equatable {
    public let userProfile: SelfUserProfile?
}

extension DescribeMyUserProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userProfile = "UserProfile"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userProfileDecoded = try containerValues.decodeIfPresent(SelfUserProfile.self, forKey: .userProfile)
        userProfile = userProfileDecoded
    }
}

extension DescribeOperatingSystemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOperatingSystemsInput()"}
}

extension DescribeOperatingSystemsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeOperatingSystemsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOperatingSystemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOperatingSystemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOperatingSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOperatingSystemsInput>
    public typealias MOutput = OperationOutput<DescribeOperatingSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOperatingSystemsOutputError>
}

public struct DescribeOperatingSystemsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOperatingSystemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOperatingSystemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOperatingSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOperatingSystemsInput>
    public typealias MOutput = OperationOutput<DescribeOperatingSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOperatingSystemsOutputError>
}

public struct DescribeOperatingSystemsInput: Equatable {

    public init() {}
}

struct DescribeOperatingSystemsInputBody: Equatable {
}

extension DescribeOperatingSystemsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeOperatingSystemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOperatingSystemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOperatingSystemsOutputError: Swift.Error, Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOperatingSystemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOperatingSystemsOutputResponse(operatingSystems: \(String(describing: operatingSystems)))"}
}

extension DescribeOperatingSystemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOperatingSystemsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.operatingSystems = output.operatingSystems
        } else {
            self.operatingSystems = nil
        }
    }
}

/// <p>The response to a <code>DescribeOperatingSystems</code> request.</p>
public struct DescribeOperatingSystemsOutputResponse: Equatable {
    /// <p>Contains information in response to a <code>DescribeOperatingSystems</code> request.</p>
    public let operatingSystems: [OperatingSystem]?

    public init (
        operatingSystems: [OperatingSystem]? = nil
    )
    {
        self.operatingSystems = operatingSystems
    }
}

struct DescribeOperatingSystemsOutputResponseBody: Equatable {
    public let operatingSystems: [OperatingSystem]?
}

extension DescribeOperatingSystemsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operatingSystems = "OperatingSystems"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemsContainer = try containerValues.decodeIfPresent([OperatingSystem?].self, forKey: .operatingSystems)
        var operatingSystemsDecoded0:[OperatingSystem]? = nil
        if let operatingSystemsContainer = operatingSystemsContainer {
            operatingSystemsDecoded0 = [OperatingSystem]()
            for structure0 in operatingSystemsContainer {
                if let structure0 = structure0 {
                    operatingSystemsDecoded0?.append(structure0)
                }
            }
        }
        operatingSystems = operatingSystemsDecoded0
    }
}

public struct DescribePermissionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePermissionsInput>
    public typealias MOutput = OperationOutput<DescribePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePermissionsOutputError>
}

extension DescribePermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePermissionsInput(iamUserArn: \(String(describing: iamUserArn)), stackId: \(String(describing: stackId)))"}
}

extension DescribePermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iamUserArn = "IamUserArn"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribePermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePermissionsInput>
    public typealias MOutput = OperationOutput<DescribePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePermissionsOutputError>
}

public struct DescribePermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePermissionsInput>
    public typealias MOutput = OperationOutput<DescribePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePermissionsOutputError>
}

public struct DescribePermissionsInput: Equatable {
    /// <p>The user's IAM ARN. This can also be a federated user's ARN. For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers</a>.</p>
    public let iamUserArn: String?
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        iamUserArn: String? = nil,
        stackId: String? = nil
    )
    {
        self.iamUserArn = iamUserArn
        self.stackId = stackId
    }
}

struct DescribePermissionsInputBody: Equatable {
    public let iamUserArn: String?
    public let stackId: String?
}

extension DescribePermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iamUserArn = "IamUserArn"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension DescribePermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePermissionsOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePermissionsOutputResponse(permissions: \(String(describing: permissions)))"}
}

extension DescribePermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.permissions = output.permissions
        } else {
            self.permissions = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribePermissions</code> request.</p>
public struct DescribePermissionsOutputResponse: Equatable {
    /// <p>An array of <code>Permission</code> objects that describe the stack permissions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the request object contains only a stack ID, the array contains a
    ///           <code>Permission</code> object with permissions for each of the stack IAM ARNs.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the request object contains only an IAM ARN, the array contains a
    ///           <code>Permission</code> object with permissions for each of the user's stack IDs.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the request contains a stack ID and an IAM ARN, the array contains a single
    ///           <code>Permission</code> object with permissions for the specified stack and IAM ARN.</p>
    ///             </li>
    ///          </ul>
    public let permissions: [Permission]?

    public init (
        permissions: [Permission]? = nil
    )
    {
        self.permissions = permissions
    }
}

struct DescribePermissionsOutputResponseBody: Equatable {
    public let permissions: [Permission]?
}

extension DescribePermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case permissions = "Permissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

public struct DescribeRaidArraysInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRaidArraysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRaidArraysInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRaidArraysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRaidArraysInput>
    public typealias MOutput = OperationOutput<DescribeRaidArraysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRaidArraysOutputError>
}

extension DescribeRaidArraysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRaidArraysInput(instanceId: \(String(describing: instanceId)), raidArrayIds: \(String(describing: raidArrayIds)), stackId: \(String(describing: stackId)))"}
}

extension DescribeRaidArraysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case raidArrayIds = "RaidArrayIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let raidArrayIds = raidArrayIds {
            var raidArrayIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .raidArrayIds)
            for strings0 in raidArrayIds {
                try raidArrayIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeRaidArraysInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRaidArraysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRaidArraysInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRaidArraysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRaidArraysInput>
    public typealias MOutput = OperationOutput<DescribeRaidArraysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRaidArraysOutputError>
}

public struct DescribeRaidArraysInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRaidArraysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRaidArraysInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRaidArraysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRaidArraysInput>
    public typealias MOutput = OperationOutput<DescribeRaidArraysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRaidArraysOutputError>
}

public struct DescribeRaidArraysInput: Equatable {
    /// <p>The instance ID. If you use this parameter, <code>DescribeRaidArrays</code> returns
    ///       descriptions of the RAID arrays associated with the specified instance. </p>
    public let instanceId: String?
    /// <p>An array of RAID array IDs. If you use this parameter, <code>DescribeRaidArrays</code>
    ///       returns descriptions of the specified arrays. Otherwise, it returns a description of every
    ///       array.</p>
    public let raidArrayIds: [String]?
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        instanceId: String? = nil,
        raidArrayIds: [String]? = nil,
        stackId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.raidArrayIds = raidArrayIds
        self.stackId = stackId
    }
}

struct DescribeRaidArraysInputBody: Equatable {
    public let instanceId: String?
    public let stackId: String?
    public let raidArrayIds: [String]?
}

extension DescribeRaidArraysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case raidArrayIds = "RaidArrayIds"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let raidArrayIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .raidArrayIds)
        var raidArrayIdsDecoded0:[String]? = nil
        if let raidArrayIdsContainer = raidArrayIdsContainer {
            raidArrayIdsDecoded0 = [String]()
            for string0 in raidArrayIdsContainer {
                if let string0 = string0 {
                    raidArrayIdsDecoded0?.append(string0)
                }
            }
        }
        raidArrayIds = raidArrayIdsDecoded0
    }
}

extension DescribeRaidArraysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRaidArraysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRaidArraysOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRaidArraysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRaidArraysOutputResponse(raidArrays: \(String(describing: raidArrays)))"}
}

extension DescribeRaidArraysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRaidArraysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.raidArrays = output.raidArrays
        } else {
            self.raidArrays = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeRaidArrays</code> request.</p>
public struct DescribeRaidArraysOutputResponse: Equatable {
    /// <p>A <code>RaidArrays</code> object that describes the specified RAID arrays.</p>
    public let raidArrays: [RaidArray]?

    public init (
        raidArrays: [RaidArray]? = nil
    )
    {
        self.raidArrays = raidArrays
    }
}

struct DescribeRaidArraysOutputResponseBody: Equatable {
    public let raidArrays: [RaidArray]?
}

extension DescribeRaidArraysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case raidArrays = "RaidArrays"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let raidArraysContainer = try containerValues.decodeIfPresent([RaidArray?].self, forKey: .raidArrays)
        var raidArraysDecoded0:[RaidArray]? = nil
        if let raidArraysContainer = raidArraysContainer {
            raidArraysDecoded0 = [RaidArray]()
            for structure0 in raidArraysContainer {
                if let structure0 = structure0 {
                    raidArraysDecoded0?.append(structure0)
                }
            }
        }
        raidArrays = raidArraysDecoded0
    }
}

public struct DescribeRdsDbInstancesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRdsDbInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRdsDbInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRdsDbInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRdsDbInstancesInput>
    public typealias MOutput = OperationOutput<DescribeRdsDbInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRdsDbInstancesOutputError>
}

extension DescribeRdsDbInstancesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRdsDbInstancesInput(rdsDbInstanceArns: \(String(describing: rdsDbInstanceArns)), stackId: \(String(describing: stackId)))"}
}

extension DescribeRdsDbInstancesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rdsDbInstanceArns = "RdsDbInstanceArns"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rdsDbInstanceArns = rdsDbInstanceArns {
            var rdsDbInstanceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rdsDbInstanceArns)
            for strings0 in rdsDbInstanceArns {
                try rdsDbInstanceArnsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeRdsDbInstancesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRdsDbInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRdsDbInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRdsDbInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRdsDbInstancesInput>
    public typealias MOutput = OperationOutput<DescribeRdsDbInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRdsDbInstancesOutputError>
}

public struct DescribeRdsDbInstancesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRdsDbInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRdsDbInstancesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRdsDbInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRdsDbInstancesInput>
    public typealias MOutput = OperationOutput<DescribeRdsDbInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRdsDbInstancesOutputError>
}

public struct DescribeRdsDbInstancesInput: Equatable {
    /// <p>An array containing the ARNs of the instances to be described.</p>
    public let rdsDbInstanceArns: [String]?
    /// <p>The ID of the stack with which the instances are registered. The operation returns descriptions of all registered Amazon RDS instances.</p>
    public let stackId: String?

    public init (
        rdsDbInstanceArns: [String]? = nil,
        stackId: String? = nil
    )
    {
        self.rdsDbInstanceArns = rdsDbInstanceArns
        self.stackId = stackId
    }
}

struct DescribeRdsDbInstancesInputBody: Equatable {
    public let stackId: String?
    public let rdsDbInstanceArns: [String]?
}

extension DescribeRdsDbInstancesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rdsDbInstanceArns = "RdsDbInstanceArns"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let rdsDbInstanceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rdsDbInstanceArns)
        var rdsDbInstanceArnsDecoded0:[String]? = nil
        if let rdsDbInstanceArnsContainer = rdsDbInstanceArnsContainer {
            rdsDbInstanceArnsDecoded0 = [String]()
            for string0 in rdsDbInstanceArnsContainer {
                if let string0 = string0 {
                    rdsDbInstanceArnsDecoded0?.append(string0)
                }
            }
        }
        rdsDbInstanceArns = rdsDbInstanceArnsDecoded0
    }
}

extension DescribeRdsDbInstancesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRdsDbInstancesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRdsDbInstancesOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRdsDbInstancesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRdsDbInstancesOutputResponse(rdsDbInstances: \(String(describing: rdsDbInstances)))"}
}

extension DescribeRdsDbInstancesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRdsDbInstancesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rdsDbInstances = output.rdsDbInstances
        } else {
            self.rdsDbInstances = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeRdsDbInstances</code> request.</p>
public struct DescribeRdsDbInstancesOutputResponse: Equatable {
    /// <p>An a array of <code>RdsDbInstance</code> objects that describe the instances.</p>
    public let rdsDbInstances: [RdsDbInstance]?

    public init (
        rdsDbInstances: [RdsDbInstance]? = nil
    )
    {
        self.rdsDbInstances = rdsDbInstances
    }
}

struct DescribeRdsDbInstancesOutputResponseBody: Equatable {
    public let rdsDbInstances: [RdsDbInstance]?
}

extension DescribeRdsDbInstancesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rdsDbInstances = "RdsDbInstances"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsDbInstancesContainer = try containerValues.decodeIfPresent([RdsDbInstance?].self, forKey: .rdsDbInstances)
        var rdsDbInstancesDecoded0:[RdsDbInstance]? = nil
        if let rdsDbInstancesContainer = rdsDbInstancesContainer {
            rdsDbInstancesDecoded0 = [RdsDbInstance]()
            for structure0 in rdsDbInstancesContainer {
                if let structure0 = structure0 {
                    rdsDbInstancesDecoded0?.append(structure0)
                }
            }
        }
        rdsDbInstances = rdsDbInstancesDecoded0
    }
}

public struct DescribeServiceErrorsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeServiceErrorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceErrorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceErrorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceErrorsInput>
    public typealias MOutput = OperationOutput<DescribeServiceErrorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceErrorsOutputError>
}

extension DescribeServiceErrorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServiceErrorsInput(instanceId: \(String(describing: instanceId)), serviceErrorIds: \(String(describing: serviceErrorIds)), stackId: \(String(describing: stackId)))"}
}

extension DescribeServiceErrorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case serviceErrorIds = "ServiceErrorIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceErrorIds = serviceErrorIds {
            var serviceErrorIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceErrorIds)
            for strings0 in serviceErrorIds {
                try serviceErrorIdsContainer.encode(strings0)
            }
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeServiceErrorsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeServiceErrorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceErrorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceErrorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceErrorsInput>
    public typealias MOutput = OperationOutput<DescribeServiceErrorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceErrorsOutputError>
}

public struct DescribeServiceErrorsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeServiceErrorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServiceErrorsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServiceErrorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServiceErrorsInput>
    public typealias MOutput = OperationOutput<DescribeServiceErrorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServiceErrorsOutputError>
}

public struct DescribeServiceErrorsInput: Equatable {
    /// <p>The instance ID. If you use this parameter, <code>DescribeServiceErrors</code> returns
    ///       descriptions of the errors associated with the specified instance.</p>
    public let instanceId: String?
    /// <p>An array of service error IDs. If you use this parameter, <code>DescribeServiceErrors</code>
    ///       returns descriptions of the specified errors. Otherwise, it returns a description of every
    ///       error.</p>
    public let serviceErrorIds: [String]?
    /// <p>The stack ID. If you use this parameter, <code>DescribeServiceErrors</code> returns
    ///       descriptions of the errors associated with the specified stack.</p>
    public let stackId: String?

    public init (
        instanceId: String? = nil,
        serviceErrorIds: [String]? = nil,
        stackId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceErrorIds = serviceErrorIds
        self.stackId = stackId
    }
}

struct DescribeServiceErrorsInputBody: Equatable {
    public let stackId: String?
    public let instanceId: String?
    public let serviceErrorIds: [String]?
}

extension DescribeServiceErrorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case serviceErrorIds = "ServiceErrorIds"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let serviceErrorIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .serviceErrorIds)
        var serviceErrorIdsDecoded0:[String]? = nil
        if let serviceErrorIdsContainer = serviceErrorIdsContainer {
            serviceErrorIdsDecoded0 = [String]()
            for string0 in serviceErrorIdsContainer {
                if let string0 = string0 {
                    serviceErrorIdsDecoded0?.append(string0)
                }
            }
        }
        serviceErrorIds = serviceErrorIdsDecoded0
    }
}

extension DescribeServiceErrorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServiceErrorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceErrorsOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceErrorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServiceErrorsOutputResponse(serviceErrors: \(String(describing: serviceErrors)))"}
}

extension DescribeServiceErrorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeServiceErrorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceErrors = output.serviceErrors
        } else {
            self.serviceErrors = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeServiceErrors</code> request.</p>
public struct DescribeServiceErrorsOutputResponse: Equatable {
    /// <p>An array of <code>ServiceError</code> objects that describe the specified service errors.</p>
    public let serviceErrors: [ServiceError]?

    public init (
        serviceErrors: [ServiceError]? = nil
    )
    {
        self.serviceErrors = serviceErrors
    }
}

struct DescribeServiceErrorsOutputResponseBody: Equatable {
    public let serviceErrors: [ServiceError]?
}

extension DescribeServiceErrorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceErrors = "ServiceErrors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceErrorsContainer = try containerValues.decodeIfPresent([ServiceError?].self, forKey: .serviceErrors)
        var serviceErrorsDecoded0:[ServiceError]? = nil
        if let serviceErrorsContainer = serviceErrorsContainer {
            serviceErrorsDecoded0 = [ServiceError]()
            for structure0 in serviceErrorsContainer {
                if let structure0 = structure0 {
                    serviceErrorsDecoded0?.append(structure0)
                }
            }
        }
        serviceErrors = serviceErrorsDecoded0
    }
}

public struct DescribeStackProvisioningParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStackProvisioningParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackProvisioningParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackProvisioningParametersInput>
    public typealias MOutput = OperationOutput<DescribeStackProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackProvisioningParametersOutputError>
}

extension DescribeStackProvisioningParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackProvisioningParametersInput(stackId: \(String(describing: stackId)))"}
}

extension DescribeStackProvisioningParametersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeStackProvisioningParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStackProvisioningParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackProvisioningParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackProvisioningParametersInput>
    public typealias MOutput = OperationOutput<DescribeStackProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackProvisioningParametersOutputError>
}

public struct DescribeStackProvisioningParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStackProvisioningParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackProvisioningParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackProvisioningParametersInput>
    public typealias MOutput = OperationOutput<DescribeStackProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackProvisioningParametersOutputError>
}

public struct DescribeStackProvisioningParametersInput: Equatable {
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        stackId: String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct DescribeStackProvisioningParametersInputBody: Equatable {
    public let stackId: String?
}

extension DescribeStackProvisioningParametersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension DescribeStackProvisioningParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStackProvisioningParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStackProvisioningParametersOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStackProvisioningParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackProvisioningParametersOutputResponse(agentInstallerUrl: \(String(describing: agentInstallerUrl)), parameters: \(String(describing: parameters)))"}
}

extension DescribeStackProvisioningParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStackProvisioningParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.agentInstallerUrl = output.agentInstallerUrl
            self.parameters = output.parameters
        } else {
            self.agentInstallerUrl = nil
            self.parameters = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeStackProvisioningParameters</code> request.</p>
public struct DescribeStackProvisioningParametersOutputResponse: Equatable {
    /// <p>The AWS OpsWorks Stacks agent installer's URL.</p>
    public let agentInstallerUrl: String?
    /// <p>An embedded object that contains the provisioning parameters.</p>
    public let parameters: [String:String]?

    public init (
        agentInstallerUrl: String? = nil,
        parameters: [String:String]? = nil
    )
    {
        self.agentInstallerUrl = agentInstallerUrl
        self.parameters = parameters
    }
}

struct DescribeStackProvisioningParametersOutputResponseBody: Equatable {
    public let agentInstallerUrl: String?
    public let parameters: [String:String]?
}

extension DescribeStackProvisioningParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentInstallerUrl = "AgentInstallerUrl"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentInstallerUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentInstallerUrl)
        agentInstallerUrl = agentInstallerUrlDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, string0) in parametersContainer {
                if let string0 = string0 {
                    parametersDecoded0?[key0] = string0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

public struct DescribeStackSummaryInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStackSummaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackSummaryInput>
    public typealias MOutput = OperationOutput<DescribeStackSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackSummaryOutputError>
}

extension DescribeStackSummaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackSummaryInput(stackId: \(String(describing: stackId)))"}
}

extension DescribeStackSummaryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct DescribeStackSummaryInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStackSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackSummaryInput>
    public typealias MOutput = OperationOutput<DescribeStackSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackSummaryOutputError>
}

public struct DescribeStackSummaryInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStackSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStackSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStackSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStackSummaryInput>
    public typealias MOutput = OperationOutput<DescribeStackSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStackSummaryOutputError>
}

public struct DescribeStackSummaryInput: Equatable {
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        stackId: String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct DescribeStackSummaryInputBody: Equatable {
    public let stackId: String?
}

extension DescribeStackSummaryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension DescribeStackSummaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStackSummaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStackSummaryOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStackSummaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStackSummaryOutputResponse(stackSummary: \(String(describing: stackSummary)))"}
}

extension DescribeStackSummaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStackSummaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stackSummary = output.stackSummary
        } else {
            self.stackSummary = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeStackSummary</code> request.</p>
public struct DescribeStackSummaryOutputResponse: Equatable {
    /// <p>A <code>StackSummary</code> object that contains the results.</p>
    public let stackSummary: StackSummary?

    public init (
        stackSummary: StackSummary? = nil
    )
    {
        self.stackSummary = stackSummary
    }
}

struct DescribeStackSummaryOutputResponseBody: Equatable {
    public let stackSummary: StackSummary?
}

extension DescribeStackSummaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackSummary = "StackSummary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSummaryDecoded = try containerValues.decodeIfPresent(StackSummary.self, forKey: .stackSummary)
        stackSummary = stackSummaryDecoded
    }
}

public struct DescribeStacksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeStacksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStacksOutputError>
}

extension DescribeStacksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStacksInput(stackIds: \(String(describing: stackIds)))"}
}

extension DescribeStacksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackIds = "StackIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackIds = stackIds {
            var stackIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackIds)
            for strings0 in stackIds {
                try stackIdsContainer.encode(strings0)
            }
        }
    }
}

public struct DescribeStacksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeStacksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStacksOutputError>
}

public struct DescribeStacksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeStacksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeStacksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeStacksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeStacksInput>
    public typealias MOutput = OperationOutput<DescribeStacksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeStacksOutputError>
}

public struct DescribeStacksInput: Equatable {
    /// <p>An array of stack IDs that specify the stacks to be described. If you omit this parameter,
    ///         <code>DescribeStacks</code> returns a description of every stack.</p>
    public let stackIds: [String]?

    public init (
        stackIds: [String]? = nil
    )
    {
        self.stackIds = stackIds
    }
}

struct DescribeStacksInputBody: Equatable {
    public let stackIds: [String]?
}

extension DescribeStacksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackIds = "StackIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .stackIds)
        var stackIdsDecoded0:[String]? = nil
        if let stackIdsContainer = stackIdsContainer {
            stackIdsDecoded0 = [String]()
            for string0 in stackIdsContainer {
                if let string0 = string0 {
                    stackIdsDecoded0?.append(string0)
                }
            }
        }
        stackIds = stackIdsDecoded0
    }
}

extension DescribeStacksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStacksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStacksOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStacksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeStacksOutputResponse(stacks: \(String(describing: stacks)))"}
}

extension DescribeStacksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeStacksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stacks = output.stacks
        } else {
            self.stacks = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeStacks</code> request.</p>
public struct DescribeStacksOutputResponse: Equatable {
    /// <p>An array of <code>Stack</code> objects that describe the stacks.</p>
    public let stacks: [Stack]?

    public init (
        stacks: [Stack]? = nil
    )
    {
        self.stacks = stacks
    }
}

struct DescribeStacksOutputResponseBody: Equatable {
    public let stacks: [Stack]?
}

extension DescribeStacksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stacks = "Stacks"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stacksContainer = try containerValues.decodeIfPresent([Stack?].self, forKey: .stacks)
        var stacksDecoded0:[Stack]? = nil
        if let stacksContainer = stacksContainer {
            stacksDecoded0 = [Stack]()
            for structure0 in stacksContainer {
                if let structure0 = structure0 {
                    stacksDecoded0?.append(structure0)
                }
            }
        }
        stacks = stacksDecoded0
    }
}

public struct DescribeTimeBasedAutoScalingInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTimeBasedAutoScalingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTimeBasedAutoScalingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTimeBasedAutoScalingInput>
    public typealias MOutput = OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTimeBasedAutoScalingOutputError>
}

extension DescribeTimeBasedAutoScalingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTimeBasedAutoScalingInput(instanceIds: \(String(describing: instanceIds)))"}
}

extension DescribeTimeBasedAutoScalingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceIds = "InstanceIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for strings0 in instanceIds {
                try instanceIdsContainer.encode(strings0)
            }
        }
    }
}

public struct DescribeTimeBasedAutoScalingInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTimeBasedAutoScalingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTimeBasedAutoScalingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTimeBasedAutoScalingInput>
    public typealias MOutput = OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTimeBasedAutoScalingOutputError>
}

public struct DescribeTimeBasedAutoScalingInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTimeBasedAutoScalingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTimeBasedAutoScalingInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTimeBasedAutoScalingInput>
    public typealias MOutput = OperationOutput<DescribeTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTimeBasedAutoScalingOutputError>
}

public struct DescribeTimeBasedAutoScalingInput: Equatable {
    /// <p>An array of instance IDs.</p>
    public let instanceIds: [String]?

    public init (
        instanceIds: [String]? = nil
    )
    {
        self.instanceIds = instanceIds
    }
}

struct DescribeTimeBasedAutoScalingInputBody: Equatable {
    public let instanceIds: [String]?
}

extension DescribeTimeBasedAutoScalingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceIds = "InstanceIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension DescribeTimeBasedAutoScalingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTimeBasedAutoScalingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTimeBasedAutoScalingOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTimeBasedAutoScalingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTimeBasedAutoScalingOutputResponse(timeBasedAutoScalingConfigurations: \(String(describing: timeBasedAutoScalingConfigurations)))"}
}

extension DescribeTimeBasedAutoScalingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTimeBasedAutoScalingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.timeBasedAutoScalingConfigurations = output.timeBasedAutoScalingConfigurations
        } else {
            self.timeBasedAutoScalingConfigurations = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeTimeBasedAutoScaling</code> request.</p>
public struct DescribeTimeBasedAutoScalingOutputResponse: Equatable {
    /// <p>An array of <code>TimeBasedAutoScalingConfiguration</code> objects that describe the
    ///       configuration for the specified instances.</p>
    public let timeBasedAutoScalingConfigurations: [TimeBasedAutoScalingConfiguration]?

    public init (
        timeBasedAutoScalingConfigurations: [TimeBasedAutoScalingConfiguration]? = nil
    )
    {
        self.timeBasedAutoScalingConfigurations = timeBasedAutoScalingConfigurations
    }
}

struct DescribeTimeBasedAutoScalingOutputResponseBody: Equatable {
    public let timeBasedAutoScalingConfigurations: [TimeBasedAutoScalingConfiguration]?
}

extension DescribeTimeBasedAutoScalingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case timeBasedAutoScalingConfigurations = "TimeBasedAutoScalingConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeBasedAutoScalingConfigurationsContainer = try containerValues.decodeIfPresent([TimeBasedAutoScalingConfiguration?].self, forKey: .timeBasedAutoScalingConfigurations)
        var timeBasedAutoScalingConfigurationsDecoded0:[TimeBasedAutoScalingConfiguration]? = nil
        if let timeBasedAutoScalingConfigurationsContainer = timeBasedAutoScalingConfigurationsContainer {
            timeBasedAutoScalingConfigurationsDecoded0 = [TimeBasedAutoScalingConfiguration]()
            for structure0 in timeBasedAutoScalingConfigurationsContainer {
                if let structure0 = structure0 {
                    timeBasedAutoScalingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        timeBasedAutoScalingConfigurations = timeBasedAutoScalingConfigurationsDecoded0
    }
}

public struct DescribeUserProfilesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUserProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserProfilesInput>
    public typealias MOutput = OperationOutput<DescribeUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserProfilesOutputError>
}

extension DescribeUserProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserProfilesInput(iamUserArns: \(String(describing: iamUserArns)))"}
}

extension DescribeUserProfilesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iamUserArns = "IamUserArns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamUserArns = iamUserArns {
            var iamUserArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iamUserArns)
            for strings0 in iamUserArns {
                try iamUserArnsContainer.encode(strings0)
            }
        }
    }
}

public struct DescribeUserProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserProfilesInput>
    public typealias MOutput = OperationOutput<DescribeUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserProfilesOutputError>
}

public struct DescribeUserProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserProfilesInput>
    public typealias MOutput = OperationOutput<DescribeUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserProfilesOutputError>
}

public struct DescribeUserProfilesInput: Equatable {
    /// <p>An array of IAM or federated user ARNs that identify the users to be described.</p>
    public let iamUserArns: [String]?

    public init (
        iamUserArns: [String]? = nil
    )
    {
        self.iamUserArns = iamUserArns
    }
}

struct DescribeUserProfilesInputBody: Equatable {
    public let iamUserArns: [String]?
}

extension DescribeUserProfilesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iamUserArns = "IamUserArns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .iamUserArns)
        var iamUserArnsDecoded0:[String]? = nil
        if let iamUserArnsContainer = iamUserArnsContainer {
            iamUserArnsDecoded0 = [String]()
            for string0 in iamUserArnsContainer {
                if let string0 = string0 {
                    iamUserArnsDecoded0?.append(string0)
                }
            }
        }
        iamUserArns = iamUserArnsDecoded0
    }
}

extension DescribeUserProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserProfilesOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserProfilesOutputResponse(userProfiles: \(String(describing: userProfiles)))"}
}

extension DescribeUserProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userProfiles = output.userProfiles
        } else {
            self.userProfiles = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeUserProfiles</code> request.</p>
public struct DescribeUserProfilesOutputResponse: Equatable {
    /// <p>A <code>Users</code> object that describes the specified users.</p>
    public let userProfiles: [UserProfile]?

    public init (
        userProfiles: [UserProfile]? = nil
    )
    {
        self.userProfiles = userProfiles
    }
}

struct DescribeUserProfilesOutputResponseBody: Equatable {
    public let userProfiles: [UserProfile]?
}

extension DescribeUserProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userProfiles = "UserProfiles"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userProfilesContainer = try containerValues.decodeIfPresent([UserProfile?].self, forKey: .userProfiles)
        var userProfilesDecoded0:[UserProfile]? = nil
        if let userProfilesContainer = userProfilesContainer {
            userProfilesDecoded0 = [UserProfile]()
            for structure0 in userProfilesContainer {
                if let structure0 = structure0 {
                    userProfilesDecoded0?.append(structure0)
                }
            }
        }
        userProfiles = userProfilesDecoded0
    }
}

public struct DescribeVolumesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeVolumesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVolumesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVolumesInput>
    public typealias MOutput = OperationOutput<DescribeVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVolumesOutputError>
}

extension DescribeVolumesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVolumesInput(instanceId: \(String(describing: instanceId)), raidArrayId: \(String(describing: raidArrayId)), stackId: \(String(describing: stackId)), volumeIds: \(String(describing: volumeIds)))"}
}

extension DescribeVolumesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case raidArrayId = "RaidArrayId"
        case stackId = "StackId"
        case volumeIds = "VolumeIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let raidArrayId = raidArrayId {
            try encodeContainer.encode(raidArrayId, forKey: .raidArrayId)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let volumeIds = volumeIds {
            var volumeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeIds)
            for strings0 in volumeIds {
                try volumeIdsContainer.encode(strings0)
            }
        }
    }
}

public struct DescribeVolumesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeVolumesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVolumesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVolumesInput>
    public typealias MOutput = OperationOutput<DescribeVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVolumesOutputError>
}

public struct DescribeVolumesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeVolumesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVolumesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVolumesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVolumesInput>
    public typealias MOutput = OperationOutput<DescribeVolumesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVolumesOutputError>
}

public struct DescribeVolumesInput: Equatable {
    /// <p>The instance ID. If you use this parameter, <code>DescribeVolumes</code> returns descriptions
    ///       of the volumes associated with the specified instance.</p>
    public let instanceId: String?
    /// <p>The RAID array ID. If you use this parameter, <code>DescribeVolumes</code> returns
    ///       descriptions of the volumes associated with the specified RAID array.</p>
    public let raidArrayId: String?
    /// <p>A stack ID. The action describes the stack's registered Amazon EBS volumes.</p>
    public let stackId: String?
    /// <p>Am array of volume IDs. If you use this parameter, <code>DescribeVolumes</code> returns
    ///       descriptions of the specified volumes. Otherwise, it returns a description of every
    ///       volume.</p>
    public let volumeIds: [String]?

    public init (
        instanceId: String? = nil,
        raidArrayId: String? = nil,
        stackId: String? = nil,
        volumeIds: [String]? = nil
    )
    {
        self.instanceId = instanceId
        self.raidArrayId = raidArrayId
        self.stackId = stackId
        self.volumeIds = volumeIds
    }
}

struct DescribeVolumesInputBody: Equatable {
    public let instanceId: String?
    public let stackId: String?
    public let raidArrayId: String?
    public let volumeIds: [String]?
}

extension DescribeVolumesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case raidArrayId = "RaidArrayId"
        case stackId = "StackId"
        case volumeIds = "VolumeIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let raidArrayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .raidArrayId)
        raidArrayId = raidArrayIdDecoded
        let volumeIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .volumeIds)
        var volumeIdsDecoded0:[String]? = nil
        if let volumeIdsContainer = volumeIdsContainer {
            volumeIdsDecoded0 = [String]()
            for string0 in volumeIdsContainer {
                if let string0 = string0 {
                    volumeIdsDecoded0?.append(string0)
                }
            }
        }
        volumeIds = volumeIdsDecoded0
    }
}

extension DescribeVolumesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVolumesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVolumesOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVolumesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVolumesOutputResponse(volumes: \(String(describing: volumes)))"}
}

extension DescribeVolumesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeVolumesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.volumes = output.volumes
        } else {
            self.volumes = nil
        }
    }
}

/// <p>Contains the response to a <code>DescribeVolumes</code> request.</p>
public struct DescribeVolumesOutputResponse: Equatable {
    /// <p>An array of volume IDs.</p>
    public let volumes: [Volume]?

    public init (
        volumes: [Volume]? = nil
    )
    {
        self.volumes = volumes
    }
}

struct DescribeVolumesOutputResponseBody: Equatable {
    public let volumes: [Volume]?
}

extension DescribeVolumesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumes = "Volumes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumesContainer = try containerValues.decodeIfPresent([Volume?].self, forKey: .volumes)
        var volumesDecoded0:[Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
    }
}

public struct DetachElasticLoadBalancerInputBodyMiddleware: Middleware {
    public let id: String = "DetachElasticLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachElasticLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachElasticLoadBalancerInput>
    public typealias MOutput = OperationOutput<DetachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachElasticLoadBalancerOutputError>
}

extension DetachElasticLoadBalancerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachElasticLoadBalancerInput(elasticLoadBalancerName: \(String(describing: elasticLoadBalancerName)), layerId: \(String(describing: layerId)))"}
}

extension DetachElasticLoadBalancerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticLoadBalancerName = elasticLoadBalancerName {
            try encodeContainer.encode(elasticLoadBalancerName, forKey: .elasticLoadBalancerName)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
    }
}

public struct DetachElasticLoadBalancerInputHeadersMiddleware: Middleware {
    public let id: String = "DetachElasticLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachElasticLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachElasticLoadBalancerInput>
    public typealias MOutput = OperationOutput<DetachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachElasticLoadBalancerOutputError>
}

public struct DetachElasticLoadBalancerInputQueryItemMiddleware: Middleware {
    public let id: String = "DetachElasticLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetachElasticLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DetachElasticLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetachElasticLoadBalancerInput>
    public typealias MOutput = OperationOutput<DetachElasticLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetachElasticLoadBalancerOutputError>
}

public struct DetachElasticLoadBalancerInput: Equatable {
    /// <p>The Elastic Load Balancing instance's name.</p>
    public let elasticLoadBalancerName: String?
    /// <p>The ID of the layer that the Elastic Load Balancing instance is attached to.</p>
    public let layerId: String?

    public init (
        elasticLoadBalancerName: String? = nil,
        layerId: String? = nil
    )
    {
        self.elasticLoadBalancerName = elasticLoadBalancerName
        self.layerId = layerId
    }
}

struct DetachElasticLoadBalancerInputBody: Equatable {
    public let elasticLoadBalancerName: String?
    public let layerId: String?
}

extension DetachElasticLoadBalancerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticLoadBalancerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticLoadBalancerName)
        elasticLoadBalancerName = elasticLoadBalancerNameDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

extension DetachElasticLoadBalancerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetachElasticLoadBalancerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetachElasticLoadBalancerOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachElasticLoadBalancerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetachElasticLoadBalancerOutputResponse()"}
}

extension DetachElasticLoadBalancerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DetachElasticLoadBalancerOutputResponse: Equatable {

    public init() {}
}

struct DetachElasticLoadBalancerOutputResponseBody: Equatable {
}

extension DetachElasticLoadBalancerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateElasticIpInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateElasticIpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateElasticIpInput>
    public typealias MOutput = OperationOutput<DisassociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateElasticIpOutputError>
}

extension DisassociateElasticIpInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateElasticIpInput(elasticIp: \(String(describing: elasticIp)))"}
}

extension DisassociateElasticIpInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
    }
}

public struct DisassociateElasticIpInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateElasticIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateElasticIpInput>
    public typealias MOutput = OperationOutput<DisassociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateElasticIpOutputError>
}

public struct DisassociateElasticIpInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateElasticIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateElasticIpInput>
    public typealias MOutput = OperationOutput<DisassociateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateElasticIpOutputError>
}

public struct DisassociateElasticIpInput: Equatable {
    /// <p>The Elastic IP address.</p>
    public let elasticIp: String?

    public init (
        elasticIp: String? = nil
    )
    {
        self.elasticIp = elasticIp
    }
}

struct DisassociateElasticIpInputBody: Equatable {
    public let elasticIp: String?
}

extension DisassociateElasticIpInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
    }
}

extension DisassociateElasticIpOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateElasticIpOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateElasticIpOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateElasticIpOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateElasticIpOutputResponse()"}
}

extension DisassociateElasticIpOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateElasticIpOutputResponse: Equatable {

    public init() {}
}

struct DisassociateElasticIpOutputResponseBody: Equatable {
}

extension DisassociateElasticIpOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EbsBlockDevice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteOnTermination = "DeleteOnTermination"
        case iops = "Iops"
        case snapshotId = "SnapshotId"
        case volumeSize = "VolumeSize"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteOnTermination = deleteOnTermination {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if let iops = iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let volumeSize = volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .iops)
        iops = iopsDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(VolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deleteOnTermination)
        deleteOnTermination = deleteOnTerminationDecoded
    }
}

extension EbsBlockDevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EbsBlockDevice(deleteOnTermination: \(String(describing: deleteOnTermination)), iops: \(String(describing: iops)), snapshotId: \(String(describing: snapshotId)), volumeSize: \(String(describing: volumeSize)), volumeType: \(String(describing: volumeType)))"}
}

/// <p>Describes an Amazon EBS volume. This data type maps directly to the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EbsBlockDevice.html">EbsBlockDevice</a>
///       data type.</p>
public struct EbsBlockDevice: Equatable {
    /// <p>Whether the volume is deleted on instance termination.</p>
    public let deleteOnTermination: Bool?
    /// <p>The number of I/O operations per second (IOPS) that the volume supports. For more
    ///       information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EbsBlockDevice.html">EbsBlockDevice</a>.</p>
    public let iops: Int?
    /// <p>The snapshot ID.</p>
    public let snapshotId: String?
    /// <p>The volume size, in GiB. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EbsBlockDevice.html">EbsBlockDevice</a>.</p>
    public let volumeSize: Int?
    /// <p>The volume type. <code>gp2</code> for General Purpose (SSD) volumes, <code>io1</code> for
    ///           Provisioned IOPS (SSD) volumes, <code>st1</code> for Throughput Optimized hard disk drives (HDD), <code>sc1</code> for Cold HDD,and <code>standard</code> for Magnetic volumes.</p>
    ///          <p>If you specify the <code>io1</code> volume type, you must also specify a value for the <code>Iops</code> attribute.
    ///           The maximum ratio of provisioned IOPS to requested volume size (in GiB) is 50:1. AWS uses the default volume size (in GiB)
    ///           specified in the AMI attributes to set IOPS to 50 x (volume size).</p>
    public let volumeType: VolumeType?

    public init (
        deleteOnTermination: Bool? = nil,
        iops: Int? = nil,
        snapshotId: String? = nil,
        volumeSize: Int? = nil,
        volumeType: VolumeType? = nil
    )
    {
        self.deleteOnTermination = deleteOnTermination
        self.iops = iops
        self.snapshotId = snapshotId
        self.volumeSize = volumeSize
        self.volumeType = volumeType
    }
}

extension EcsCluster: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ecsClusterArn = "EcsClusterArn"
        case ecsClusterName = "EcsClusterName"
        case registeredAt = "RegisteredAt"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecsClusterArn = ecsClusterArn {
            try encodeContainer.encode(ecsClusterArn, forKey: .ecsClusterArn)
        }
        if let ecsClusterName = ecsClusterName {
            try encodeContainer.encode(ecsClusterName, forKey: .ecsClusterName)
        }
        if let registeredAt = registeredAt {
            try encodeContainer.encode(registeredAt, forKey: .registeredAt)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
        let ecsClusterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ecsClusterName)
        ecsClusterName = ecsClusterNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let registeredAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registeredAt)
        registeredAt = registeredAtDecoded
    }
}

extension EcsCluster: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EcsCluster(ecsClusterArn: \(String(describing: ecsClusterArn)), ecsClusterName: \(String(describing: ecsClusterName)), registeredAt: \(String(describing: registeredAt)), stackId: \(String(describing: stackId)))"}
}

/// <p>Describes a registered Amazon ECS cluster.</p>
public struct EcsCluster: Equatable {
    /// <p>The cluster's ARN.</p>
    public let ecsClusterArn: String?
    /// <p>The cluster name.</p>
    public let ecsClusterName: String?
    /// <p>The time and date that the cluster was registered with the stack.</p>
    public let registeredAt: String?
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        ecsClusterArn: String? = nil,
        ecsClusterName: String? = nil,
        registeredAt: String? = nil,
        stackId: String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
        self.ecsClusterName = ecsClusterName
        self.registeredAt = registeredAt
        self.stackId = stackId
    }
}

extension ElasticIp: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
        case instanceId = "InstanceId"
        case ip = "Ip"
        case name = "Name"
        case region = "Region"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ip)
        ip = ipDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension ElasticIp: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ElasticIp(domain: \(String(describing: domain)), instanceId: \(String(describing: instanceId)), ip: \(String(describing: ip)), name: \(String(describing: name)), region: \(String(describing: region)))"}
}

/// <p>Describes an Elastic IP address.</p>
public struct ElasticIp: Equatable {
    /// <p>The domain.</p>
    public let domain: String?
    /// <p>The ID of the instance that the address is attached to.</p>
    public let instanceId: String?
    /// <p>The IP address.</p>
    public let ip: String?
    /// <p>The name.</p>
    public let name: String?
    /// <p>The AWS region. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints</a>.</p>
    public let region: String?

    public init (
        domain: String? = nil,
        instanceId: String? = nil,
        ip: String? = nil,
        name: String? = nil,
        region: String? = nil
    )
    {
        self.domain = domain
        self.instanceId = instanceId
        self.ip = ip
        self.name = name
        self.region = region
    }
}

extension ElasticLoadBalancer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case dnsName = "DnsName"
        case ec2InstanceIds = "Ec2InstanceIds"
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
        case region = "Region"
        case stackId = "StackId"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for strings0 in availabilityZones {
                try availabilityZonesContainer.encode(strings0)
            }
        }
        if let dnsName = dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let ec2InstanceIds = ec2InstanceIds {
            var ec2InstanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceIds)
            for strings0 in ec2InstanceIds {
                try ec2InstanceIdsContainer.encode(strings0)
            }
        }
        if let elasticLoadBalancerName = elasticLoadBalancerName {
            try encodeContainer.encode(elasticLoadBalancerName, forKey: .elasticLoadBalancerName)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for strings0 in subnetIds {
                try subnetIdsContainer.encode(strings0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticLoadBalancerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticLoadBalancerName)
        elasticLoadBalancerName = elasticLoadBalancerNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let dnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let ec2InstanceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ec2InstanceIds)
        var ec2InstanceIdsDecoded0:[String]? = nil
        if let ec2InstanceIdsContainer = ec2InstanceIdsContainer {
            ec2InstanceIdsDecoded0 = [String]()
            for string0 in ec2InstanceIdsContainer {
                if let string0 = string0 {
                    ec2InstanceIdsDecoded0?.append(string0)
                }
            }
        }
        ec2InstanceIds = ec2InstanceIdsDecoded0
    }
}

extension ElasticLoadBalancer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ElasticLoadBalancer(availabilityZones: \(String(describing: availabilityZones)), dnsName: \(String(describing: dnsName)), ec2InstanceIds: \(String(describing: ec2InstanceIds)), elasticLoadBalancerName: \(String(describing: elasticLoadBalancerName)), layerId: \(String(describing: layerId)), region: \(String(describing: region)), stackId: \(String(describing: stackId)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Describes an Elastic Load Balancing instance.</p>
public struct ElasticLoadBalancer: Equatable {
    /// <p>A list of Availability Zones.</p>
    public let availabilityZones: [String]?
    /// <p>The instance's public DNS name.</p>
    public let dnsName: String?
    /// <p>A list of the EC2 instances that the Elastic Load Balancing instance is managing traffic for.</p>
    public let ec2InstanceIds: [String]?
    /// <p>The Elastic Load Balancing instance's name.</p>
    public let elasticLoadBalancerName: String?
    /// <p>The ID of the layer that the instance is attached to.</p>
    public let layerId: String?
    /// <p>The instance's AWS region.</p>
    public let region: String?
    /// <p>The ID of the stack that the instance is associated with.</p>
    public let stackId: String?
    /// <p>A list of subnet IDs, if the stack is running in a VPC.</p>
    public let subnetIds: [String]?
    /// <p>The VPC ID.</p>
    public let vpcId: String?

    public init (
        availabilityZones: [String]? = nil,
        dnsName: String? = nil,
        ec2InstanceIds: [String]? = nil,
        elasticLoadBalancerName: String? = nil,
        layerId: String? = nil,
        region: String? = nil,
        stackId: String? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.dnsName = dnsName
        self.ec2InstanceIds = ec2InstanceIds
        self.elasticLoadBalancerName = elasticLoadBalancerName
        self.layerId = layerId
        self.region = region
        self.stackId = stackId
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

extension EnvironmentVariable: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case secure = "Secure"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let secure = secure {
            try encodeContainer.encode(secure, forKey: .secure)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let secureDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .secure)
        secure = secureDecoded
    }
}

extension EnvironmentVariable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentVariable(key: \(String(describing: key)), secure: \(String(describing: secure)), value: \(String(describing: value)))"}
}

/// <p>Represents an app's environment variable.</p>
public struct EnvironmentVariable: Equatable {
    /// <p>(Required) The environment variable's name, which can consist of up to 64 characters and must be specified. The name can contain upper- and lowercase letters, numbers, and underscores (_), but it must start with a letter or underscore.</p>
    public let key: String?
    /// <p>(Optional) Whether the variable's value will be returned by the <a>DescribeApps</a> action.
    ///       To conceal an environment variable's value, set <code>Secure</code> to <code>true</code>.
    ///         <code>DescribeApps</code> then returns <code>*****FILTERED*****</code> instead of the actual
    ///       value. The default value for <code>Secure</code> is <code>false</code>. </p>
    public let secure: Bool?
    /// <p>(Optional) The environment variable's value, which can be left empty. If you specify a value, it can contain up to 256 characters, which must all be printable.</p>
    public let value: String?

    public init (
        key: String? = nil,
        secure: Bool? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.secure = secure
        self.value = value
    }
}

public struct GetHostnameSuggestionInputBodyMiddleware: Middleware {
    public let id: String = "GetHostnameSuggestionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHostnameSuggestionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHostnameSuggestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHostnameSuggestionInput>
    public typealias MOutput = OperationOutput<GetHostnameSuggestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHostnameSuggestionOutputError>
}

extension GetHostnameSuggestionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetHostnameSuggestionInput(layerId: \(String(describing: layerId)))"}
}

extension GetHostnameSuggestionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerId = "LayerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
    }
}

public struct GetHostnameSuggestionInputHeadersMiddleware: Middleware {
    public let id: String = "GetHostnameSuggestionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHostnameSuggestionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHostnameSuggestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHostnameSuggestionInput>
    public typealias MOutput = OperationOutput<GetHostnameSuggestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHostnameSuggestionOutputError>
}

public struct GetHostnameSuggestionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetHostnameSuggestionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHostnameSuggestionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHostnameSuggestionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHostnameSuggestionInput>
    public typealias MOutput = OperationOutput<GetHostnameSuggestionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHostnameSuggestionOutputError>
}

public struct GetHostnameSuggestionInput: Equatable {
    /// <p>The layer ID.</p>
    public let layerId: String?

    public init (
        layerId: String? = nil
    )
    {
        self.layerId = layerId
    }
}

struct GetHostnameSuggestionInputBody: Equatable {
    public let layerId: String?
}

extension GetHostnameSuggestionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerId = "LayerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

extension GetHostnameSuggestionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHostnameSuggestionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetHostnameSuggestionOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHostnameSuggestionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetHostnameSuggestionOutputResponse(hostname: \(String(describing: hostname)), layerId: \(String(describing: layerId)))"}
}

extension GetHostnameSuggestionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetHostnameSuggestionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hostname = output.hostname
            self.layerId = output.layerId
        } else {
            self.hostname = nil
            self.layerId = nil
        }
    }
}

/// <p>Contains the response to a <code>GetHostnameSuggestion</code> request.</p>
public struct GetHostnameSuggestionOutputResponse: Equatable {
    /// <p>The generated host name.</p>
    public let hostname: String?
    /// <p>The layer ID.</p>
    public let layerId: String?

    public init (
        hostname: String? = nil,
        layerId: String? = nil
    )
    {
        self.hostname = hostname
        self.layerId = layerId
    }
}

struct GetHostnameSuggestionOutputResponseBody: Equatable {
    public let layerId: String?
    public let hostname: String?
}

extension GetHostnameSuggestionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hostname = "Hostname"
        case layerId = "LayerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostname)
        hostname = hostnameDecoded
    }
}

public struct GrantAccessInputBodyMiddleware: Middleware {
    public let id: String = "GrantAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GrantAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<GrantAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GrantAccessInput>
    public typealias MOutput = OperationOutput<GrantAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GrantAccessOutputError>
}

extension GrantAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrantAccessInput(instanceId: \(String(describing: instanceId)), validForInMinutes: \(String(describing: validForInMinutes)))"}
}

extension GrantAccessInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case validForInMinutes = "ValidForInMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let validForInMinutes = validForInMinutes {
            try encodeContainer.encode(validForInMinutes, forKey: .validForInMinutes)
        }
    }
}

public struct GrantAccessInputHeadersMiddleware: Middleware {
    public let id: String = "GrantAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GrantAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<GrantAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GrantAccessInput>
    public typealias MOutput = OperationOutput<GrantAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GrantAccessOutputError>
}

public struct GrantAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "GrantAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GrantAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<GrantAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GrantAccessInput>
    public typealias MOutput = OperationOutput<GrantAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GrantAccessOutputError>
}

public struct GrantAccessInput: Equatable {
    /// <p>The instance's AWS OpsWorks Stacks ID.</p>
    public let instanceId: String?
    /// <p>The length of time (in minutes) that the grant is valid. When the grant expires at the end of this period, the user will no longer be able to use the credentials to log in. If the user is logged in at the time, he or she automatically will be logged out.</p>
    public let validForInMinutes: Int?

    public init (
        instanceId: String? = nil,
        validForInMinutes: Int? = nil
    )
    {
        self.instanceId = instanceId
        self.validForInMinutes = validForInMinutes
    }
}

struct GrantAccessInputBody: Equatable {
    public let instanceId: String?
    public let validForInMinutes: Int?
}

extension GrantAccessInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case validForInMinutes = "ValidForInMinutes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let validForInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .validForInMinutes)
        validForInMinutes = validForInMinutesDecoded
    }
}

extension GrantAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GrantAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GrantAccessOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GrantAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrantAccessOutputResponse(temporaryCredential: \(String(describing: temporaryCredential)))"}
}

extension GrantAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GrantAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.temporaryCredential = output.temporaryCredential
        } else {
            self.temporaryCredential = nil
        }
    }
}

/// <p>Contains the response to a <code>GrantAccess</code> request.</p>
public struct GrantAccessOutputResponse: Equatable {
    /// <p>A <code>TemporaryCredential</code> object that contains the data needed to log in to the
    ///       instance by RDP clients, such as the Microsoft Remote Desktop Connection.</p>
    public let temporaryCredential: TemporaryCredential?

    public init (
        temporaryCredential: TemporaryCredential? = nil
    )
    {
        self.temporaryCredential = temporaryCredential
    }
}

struct GrantAccessOutputResponseBody: Equatable {
    public let temporaryCredential: TemporaryCredential?
}

extension GrantAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case temporaryCredential = "TemporaryCredential"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let temporaryCredentialDecoded = try containerValues.decodeIfPresent(TemporaryCredential.self, forKey: .temporaryCredential)
        temporaryCredential = temporaryCredentialDecoded
    }
}

extension Instance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case arn = "Arn"
        case autoScalingType = "AutoScalingType"
        case availabilityZone = "AvailabilityZone"
        case blockDeviceMappings = "BlockDeviceMappings"
        case createdAt = "CreatedAt"
        case ebsOptimized = "EbsOptimized"
        case ec2InstanceId = "Ec2InstanceId"
        case ecsClusterArn = "EcsClusterArn"
        case ecsContainerInstanceArn = "EcsContainerInstanceArn"
        case elasticIp = "ElasticIp"
        case hostname = "Hostname"
        case infrastructureClass = "InfrastructureClass"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceId = "InstanceId"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case lastServiceErrorId = "LastServiceErrorId"
        case layerIds = "LayerIds"
        case os = "Os"
        case platform = "Platform"
        case privateDns = "PrivateDns"
        case privateIp = "PrivateIp"
        case publicDns = "PublicDns"
        case publicIp = "PublicIp"
        case registeredBy = "RegisteredBy"
        case reportedAgentVersion = "ReportedAgentVersion"
        case reportedOs = "ReportedOs"
        case rootDeviceType = "RootDeviceType"
        case rootDeviceVolumeId = "RootDeviceVolumeId"
        case securityGroupIds = "SecurityGroupIds"
        case sshHostDsaKeyFingerprint = "SshHostDsaKeyFingerprint"
        case sshHostRsaKeyFingerprint = "SshHostRsaKeyFingerprint"
        case sshKeyName = "SshKeyName"
        case stackId = "StackId"
        case status = "Status"
        case subnetId = "SubnetId"
        case tenancy = "Tenancy"
        case virtualizationType = "VirtualizationType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let autoScalingType = autoScalingType {
            try encodeContainer.encode(autoScalingType.rawValue, forKey: .autoScalingType)
        }
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for blockdevicemappings0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(blockdevicemappings0)
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let ebsOptimized = ebsOptimized {
            try encodeContainer.encode(ebsOptimized, forKey: .ebsOptimized)
        }
        if let ec2InstanceId = ec2InstanceId {
            try encodeContainer.encode(ec2InstanceId, forKey: .ec2InstanceId)
        }
        if let ecsClusterArn = ecsClusterArn {
            try encodeContainer.encode(ecsClusterArn, forKey: .ecsClusterArn)
        }
        if let ecsContainerInstanceArn = ecsContainerInstanceArn {
            try encodeContainer.encode(ecsContainerInstanceArn, forKey: .ecsContainerInstanceArn)
        }
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let infrastructureClass = infrastructureClass {
            try encodeContainer.encode(infrastructureClass, forKey: .infrastructureClass)
        }
        if let installUpdatesOnBoot = installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceProfileArn = instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let lastServiceErrorId = lastServiceErrorId {
            try encodeContainer.encode(lastServiceErrorId, forKey: .lastServiceErrorId)
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
        if let os = os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let privateDns = privateDns {
            try encodeContainer.encode(privateDns, forKey: .privateDns)
        }
        if let privateIp = privateIp {
            try encodeContainer.encode(privateIp, forKey: .privateIp)
        }
        if let publicDns = publicDns {
            try encodeContainer.encode(publicDns, forKey: .publicDns)
        }
        if let publicIp = publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let registeredBy = registeredBy {
            try encodeContainer.encode(registeredBy, forKey: .registeredBy)
        }
        if let reportedAgentVersion = reportedAgentVersion {
            try encodeContainer.encode(reportedAgentVersion, forKey: .reportedAgentVersion)
        }
        if let reportedOs = reportedOs {
            try encodeContainer.encode(reportedOs, forKey: .reportedOs)
        }
        if let rootDeviceType = rootDeviceType {
            try encodeContainer.encode(rootDeviceType.rawValue, forKey: .rootDeviceType)
        }
        if let rootDeviceVolumeId = rootDeviceVolumeId {
            try encodeContainer.encode(rootDeviceVolumeId, forKey: .rootDeviceVolumeId)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for strings0 in securityGroupIds {
                try securityGroupIdsContainer.encode(strings0)
            }
        }
        if let sshHostDsaKeyFingerprint = sshHostDsaKeyFingerprint {
            try encodeContainer.encode(sshHostDsaKeyFingerprint, forKey: .sshHostDsaKeyFingerprint)
        }
        if let sshHostRsaKeyFingerprint = sshHostRsaKeyFingerprint {
            try encodeContainer.encode(sshHostRsaKeyFingerprint, forKey: .sshHostRsaKeyFingerprint)
        }
        if let sshKeyName = sshKeyName {
            try encodeContainer.encode(sshKeyName, forKey: .sshKeyName)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tenancy = tenancy {
            try encodeContainer.encode(tenancy, forKey: .tenancy)
        }
        if let virtualizationType = virtualizationType {
            try encodeContainer.encode(virtualizationType.rawValue, forKey: .virtualizationType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let autoScalingTypeDecoded = try containerValues.decodeIfPresent(AutoScalingType.self, forKey: .autoScalingType)
        autoScalingType = autoScalingTypeDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([BlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[BlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [BlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
        let ecsContainerInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ecsContainerInstanceArn)
        ecsContainerInstanceArn = ecsContainerInstanceArnDecoded
        let elasticIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let infrastructureClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .infrastructureClass)
        infrastructureClass = infrastructureClassDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let lastServiceErrorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastServiceErrorId)
        lastServiceErrorId = lastServiceErrorIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
        let osDecoded = try containerValues.decodeIfPresent(String.self, forKey: .os)
        os = osDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let privateDnsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateDns)
        privateDns = privateDnsDecoded
        let privateIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIp)
        privateIp = privateIpDecoded
        let publicDnsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicDns)
        publicDns = publicDnsDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let registeredByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registeredBy)
        registeredBy = registeredByDecoded
        let reportedAgentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportedAgentVersion)
        reportedAgentVersion = reportedAgentVersionDecoded
        let reportedOsDecoded = try containerValues.decodeIfPresent(ReportedOs.self, forKey: .reportedOs)
        reportedOs = reportedOsDecoded
        let rootDeviceTypeDecoded = try containerValues.decodeIfPresent(RootDeviceType.self, forKey: .rootDeviceType)
        rootDeviceType = rootDeviceTypeDecoded
        let rootDeviceVolumeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rootDeviceVolumeId)
        rootDeviceVolumeId = rootDeviceVolumeIdDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let sshHostDsaKeyFingerprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshHostDsaKeyFingerprint)
        sshHostDsaKeyFingerprint = sshHostDsaKeyFingerprintDecoded
        let sshHostRsaKeyFingerprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshHostRsaKeyFingerprint)
        sshHostRsaKeyFingerprint = sshHostRsaKeyFingerprintDecoded
        let sshKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshKeyName)
        sshKeyName = sshKeyNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let virtualizationTypeDecoded = try containerValues.decodeIfPresent(VirtualizationType.self, forKey: .virtualizationType)
        virtualizationType = virtualizationTypeDecoded
    }
}

extension Instance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Instance(agentVersion: \(String(describing: agentVersion)), amiId: \(String(describing: amiId)), architecture: \(String(describing: architecture)), arn: \(String(describing: arn)), autoScalingType: \(String(describing: autoScalingType)), availabilityZone: \(String(describing: availabilityZone)), blockDeviceMappings: \(String(describing: blockDeviceMappings)), createdAt: \(String(describing: createdAt)), ebsOptimized: \(String(describing: ebsOptimized)), ec2InstanceId: \(String(describing: ec2InstanceId)), ecsClusterArn: \(String(describing: ecsClusterArn)), ecsContainerInstanceArn: \(String(describing: ecsContainerInstanceArn)), elasticIp: \(String(describing: elasticIp)), hostname: \(String(describing: hostname)), infrastructureClass: \(String(describing: infrastructureClass)), installUpdatesOnBoot: \(String(describing: installUpdatesOnBoot)), instanceId: \(String(describing: instanceId)), instanceProfileArn: \(String(describing: instanceProfileArn)), instanceType: \(String(describing: instanceType)), lastServiceErrorId: \(String(describing: lastServiceErrorId)), layerIds: \(String(describing: layerIds)), os: \(String(describing: os)), platform: \(String(describing: platform)), privateDns: \(String(describing: privateDns)), privateIp: \(String(describing: privateIp)), publicDns: \(String(describing: publicDns)), publicIp: \(String(describing: publicIp)), registeredBy: \(String(describing: registeredBy)), reportedAgentVersion: \(String(describing: reportedAgentVersion)), reportedOs: \(String(describing: reportedOs)), rootDeviceType: \(String(describing: rootDeviceType)), rootDeviceVolumeId: \(String(describing: rootDeviceVolumeId)), securityGroupIds: \(String(describing: securityGroupIds)), sshHostDsaKeyFingerprint: \(String(describing: sshHostDsaKeyFingerprint)), sshHostRsaKeyFingerprint: \(String(describing: sshHostRsaKeyFingerprint)), sshKeyName: \(String(describing: sshKeyName)), stackId: \(String(describing: stackId)), status: \(String(describing: status)), subnetId: \(String(describing: subnetId)), tenancy: \(String(describing: tenancy)), virtualizationType: \(String(describing: virtualizationType)))"}
}

/// <p>Describes an instance.</p>
public struct Instance: Equatable {
    /// <p>The agent version. This parameter is set to <code>INHERIT</code> if
    ///       the instance inherits the default stack setting or to a
    ///       a version number for a fixed agent version.</p>
    public let agentVersion: String?
    /// <p>A custom AMI ID to be used to create the instance. For more
    ///       information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">Instances</a>
    ///          </p>
    public let amiId: String?
    /// <p>The instance architecture: "i386" or "x86_64".</p>
    public let architecture: Architecture?
    /// <p>The instance's Amazon Resource Number (ARN).</p>
    public let arn: String?
    /// <p>For load-based or time-based instances, the type.</p>
    public let autoScalingType: AutoScalingType?
    /// <p>The instance Availability Zone. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints</a>.</p>
    public let availabilityZone: String?
    /// <p>An array of <code>BlockDeviceMapping</code> objects that specify the instance's block device
    ///       mappings.</p>
    public let blockDeviceMappings: [BlockDeviceMapping]?
    /// <p>The time that the instance was created.</p>
    public let createdAt: String?
    /// <p>Whether this is an Amazon EBS-optimized instance.</p>
    public let ebsOptimized: Bool?
    /// <p>The ID of the associated Amazon EC2 instance.</p>
    public let ec2InstanceId: String?
    /// <p>For container instances, the Amazon ECS cluster's ARN.</p>
    public let ecsClusterArn: String?
    /// <p>For container instances, the instance's ARN.</p>
    public let ecsContainerInstanceArn: String?
    /// <p>The instance <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP address </a>.</p>
    public let elasticIp: String?
    /// <p>The instance host name.</p>
    public let hostname: String?
    /// <p>For registered instances, the infrastructure class: <code>ec2</code> or
    ///         <code>on-premises</code>.</p>
    public let infrastructureClass: String?
    /// <p>Whether to install operating system and package updates when the instance boots. The default
    ///       value is <code>true</code>. If this value is set to <code>false</code>, you must then update
    ///       your instances manually by using <a>CreateDeployment</a> to run the
    ///         <code>update_dependencies</code> stack command or
    ///       by manually running <code>yum</code> (Amazon
    ///       Linux) or <code>apt-get</code> (Ubuntu) on the instances. </p>
    ///          <note>
    ///             <p>We strongly recommend using the default value of <code>true</code>, to ensure that your
    ///         instances have the latest security updates.</p>
    ///          </note>
    public let installUpdatesOnBoot: Bool?
    /// <p>The instance ID.</p>
    public let instanceId: String?
    /// <p>The ARN of the instance's IAM profile. For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers</a>.</p>
    public let instanceProfileArn: String?
    /// <p>The instance type, such as <code>t2.micro</code>.</p>
    public let instanceType: String?
    /// <p>The ID of the last service error. For more information, call
    ///       <a>DescribeServiceErrors</a>.</p>
    public let lastServiceErrorId: String?
    /// <p>An array containing the instance layer IDs.</p>
    public let layerIds: [String]?
    /// <p>The instance's operating system.</p>
    public let os: String?
    /// <p>The instance's platform.</p>
    public let platform: String?
    /// <p>The instance's private DNS name.</p>
    public let privateDns: String?
    /// <p>The instance's private IP address.</p>
    public let privateIp: String?
    /// <p>The instance public DNS name.</p>
    public let publicDns: String?
    /// <p>The instance public IP address.</p>
    public let publicIp: String?
    /// <p>For registered instances, who performed the registration.</p>
    public let registeredBy: String?
    /// <p>The instance's reported AWS OpsWorks Stacks agent version.</p>
    public let reportedAgentVersion: String?
    /// <p>For registered instances, the reported operating system.</p>
    public let reportedOs: ReportedOs?
    /// <p>The instance's root device type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device">Storage for the Root Device</a>.</p>
    public let rootDeviceType: RootDeviceType?
    /// <p>The root device volume ID.</p>
    public let rootDeviceVolumeId: String?
    /// <p>An array containing the instance security group IDs.</p>
    public let securityGroupIds: [String]?
    /// <p>The SSH key's Deep Security Agent (DSA) fingerprint.</p>
    public let sshHostDsaKeyFingerprint: String?
    /// <p>The SSH key's RSA fingerprint.</p>
    public let sshHostRsaKeyFingerprint: String?
    /// <p>The instance's Amazon EC2 key-pair name.</p>
    public let sshKeyName: String?
    /// <p>The stack ID.</p>
    public let stackId: String?
    /// <p>The instance status:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>booting</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>connection_lost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>online</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>pending</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>rebooting</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>requested</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>running_setup</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>setup_failed</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>shutting_down</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>start_failed</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>stop_failed</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>stopped</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>stopping</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>terminated</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>terminating</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The instance's subnet ID; applicable only if the stack is running in a VPC.</p>
    public let subnetId: String?
    /// <p>The instance's tenancy option, such as <code>dedicated</code> or <code>host</code>.</p>
    public let tenancy: String?
    /// <p>The instance's virtualization type: <code>paravirtual</code> or <code>hvm</code>.</p>
    public let virtualizationType: VirtualizationType?

    public init (
        agentVersion: String? = nil,
        amiId: String? = nil,
        architecture: Architecture? = nil,
        arn: String? = nil,
        autoScalingType: AutoScalingType? = nil,
        availabilityZone: String? = nil,
        blockDeviceMappings: [BlockDeviceMapping]? = nil,
        createdAt: String? = nil,
        ebsOptimized: Bool? = nil,
        ec2InstanceId: String? = nil,
        ecsClusterArn: String? = nil,
        ecsContainerInstanceArn: String? = nil,
        elasticIp: String? = nil,
        hostname: String? = nil,
        infrastructureClass: String? = nil,
        installUpdatesOnBoot: Bool? = nil,
        instanceId: String? = nil,
        instanceProfileArn: String? = nil,
        instanceType: String? = nil,
        lastServiceErrorId: String? = nil,
        layerIds: [String]? = nil,
        os: String? = nil,
        platform: String? = nil,
        privateDns: String? = nil,
        privateIp: String? = nil,
        publicDns: String? = nil,
        publicIp: String? = nil,
        registeredBy: String? = nil,
        reportedAgentVersion: String? = nil,
        reportedOs: ReportedOs? = nil,
        rootDeviceType: RootDeviceType? = nil,
        rootDeviceVolumeId: String? = nil,
        securityGroupIds: [String]? = nil,
        sshHostDsaKeyFingerprint: String? = nil,
        sshHostRsaKeyFingerprint: String? = nil,
        sshKeyName: String? = nil,
        stackId: String? = nil,
        status: String? = nil,
        subnetId: String? = nil,
        tenancy: String? = nil,
        virtualizationType: VirtualizationType? = nil
    )
    {
        self.agentVersion = agentVersion
        self.amiId = amiId
        self.architecture = architecture
        self.arn = arn
        self.autoScalingType = autoScalingType
        self.availabilityZone = availabilityZone
        self.blockDeviceMappings = blockDeviceMappings
        self.createdAt = createdAt
        self.ebsOptimized = ebsOptimized
        self.ec2InstanceId = ec2InstanceId
        self.ecsClusterArn = ecsClusterArn
        self.ecsContainerInstanceArn = ecsContainerInstanceArn
        self.elasticIp = elasticIp
        self.hostname = hostname
        self.infrastructureClass = infrastructureClass
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.instanceId = instanceId
        self.instanceProfileArn = instanceProfileArn
        self.instanceType = instanceType
        self.lastServiceErrorId = lastServiceErrorId
        self.layerIds = layerIds
        self.os = os
        self.platform = platform
        self.privateDns = privateDns
        self.privateIp = privateIp
        self.publicDns = publicDns
        self.publicIp = publicIp
        self.registeredBy = registeredBy
        self.reportedAgentVersion = reportedAgentVersion
        self.reportedOs = reportedOs
        self.rootDeviceType = rootDeviceType
        self.rootDeviceVolumeId = rootDeviceVolumeId
        self.securityGroupIds = securityGroupIds
        self.sshHostDsaKeyFingerprint = sshHostDsaKeyFingerprint
        self.sshHostRsaKeyFingerprint = sshHostRsaKeyFingerprint
        self.sshKeyName = sshKeyName
        self.stackId = stackId
        self.status = status
        self.subnetId = subnetId
        self.tenancy = tenancy
        self.virtualizationType = virtualizationType
    }
}

extension InstanceIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case document = "Document"
        case signature = "Signature"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let signature = signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .document)
        document = documentDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signature)
        signature = signatureDecoded
    }
}

extension InstanceIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceIdentity(document: \(String(describing: document)), signature: \(String(describing: signature)))"}
}

/// <p>Contains a description of an Amazon EC2 instance from the Amazon EC2 metadata service. For more
///       information, see <a href="https://docs.aws.amazon.com/sdkfornet/latest/apidocs/Index.html">Instance Metadata and User Data</a>.</p>
public struct InstanceIdentity: Equatable {
    /// <p>A JSON document that contains the metadata.</p>
    public let document: String?
    /// <p>A signature that can be used to verify the document's accuracy and authenticity.</p>
    public let signature: String?

    public init (
        document: String? = nil,
        signature: String? = nil
    )
    {
        self.document = document
        self.signature = signature
    }
}

extension InstancesCount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assigning = "Assigning"
        case booting = "Booting"
        case connectionLost = "ConnectionLost"
        case deregistering = "Deregistering"
        case online = "Online"
        case pending = "Pending"
        case rebooting = "Rebooting"
        case registered = "Registered"
        case registering = "Registering"
        case requested = "Requested"
        case runningSetup = "RunningSetup"
        case setupFailed = "SetupFailed"
        case shuttingDown = "ShuttingDown"
        case startFailed = "StartFailed"
        case stopFailed = "StopFailed"
        case stopped = "Stopped"
        case stopping = "Stopping"
        case terminated = "Terminated"
        case terminating = "Terminating"
        case unassigning = "Unassigning"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assigning = assigning {
            try encodeContainer.encode(assigning, forKey: .assigning)
        }
        if let booting = booting {
            try encodeContainer.encode(booting, forKey: .booting)
        }
        if let connectionLost = connectionLost {
            try encodeContainer.encode(connectionLost, forKey: .connectionLost)
        }
        if let deregistering = deregistering {
            try encodeContainer.encode(deregistering, forKey: .deregistering)
        }
        if let online = online {
            try encodeContainer.encode(online, forKey: .online)
        }
        if let pending = pending {
            try encodeContainer.encode(pending, forKey: .pending)
        }
        if let rebooting = rebooting {
            try encodeContainer.encode(rebooting, forKey: .rebooting)
        }
        if let registered = registered {
            try encodeContainer.encode(registered, forKey: .registered)
        }
        if let registering = registering {
            try encodeContainer.encode(registering, forKey: .registering)
        }
        if let requested = requested {
            try encodeContainer.encode(requested, forKey: .requested)
        }
        if let runningSetup = runningSetup {
            try encodeContainer.encode(runningSetup, forKey: .runningSetup)
        }
        if let setupFailed = setupFailed {
            try encodeContainer.encode(setupFailed, forKey: .setupFailed)
        }
        if let shuttingDown = shuttingDown {
            try encodeContainer.encode(shuttingDown, forKey: .shuttingDown)
        }
        if let startFailed = startFailed {
            try encodeContainer.encode(startFailed, forKey: .startFailed)
        }
        if let stopFailed = stopFailed {
            try encodeContainer.encode(stopFailed, forKey: .stopFailed)
        }
        if let stopped = stopped {
            try encodeContainer.encode(stopped, forKey: .stopped)
        }
        if let stopping = stopping {
            try encodeContainer.encode(stopping, forKey: .stopping)
        }
        if let terminated = terminated {
            try encodeContainer.encode(terminated, forKey: .terminated)
        }
        if let terminating = terminating {
            try encodeContainer.encode(terminating, forKey: .terminating)
        }
        if let unassigning = unassigning {
            try encodeContainer.encode(unassigning, forKey: .unassigning)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assigningDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .assigning)
        assigning = assigningDecoded
        let bootingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .booting)
        booting = bootingDecoded
        let connectionLostDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .connectionLost)
        connectionLost = connectionLostDecoded
        let deregisteringDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .deregistering)
        deregistering = deregisteringDecoded
        let onlineDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .online)
        online = onlineDecoded
        let pendingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pending)
        pending = pendingDecoded
        let rebootingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .rebooting)
        rebooting = rebootingDecoded
        let registeredDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .registered)
        registered = registeredDecoded
        let registeringDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .registering)
        registering = registeringDecoded
        let requestedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .requested)
        requested = requestedDecoded
        let runningSetupDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .runningSetup)
        runningSetup = runningSetupDecoded
        let setupFailedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .setupFailed)
        setupFailed = setupFailedDecoded
        let shuttingDownDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .shuttingDown)
        shuttingDown = shuttingDownDecoded
        let startFailedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startFailed)
        startFailed = startFailedDecoded
        let stopFailedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stopFailed)
        stopFailed = stopFailedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stopped)
        stopped = stoppedDecoded
        let stoppingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .stopping)
        stopping = stoppingDecoded
        let terminatedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .terminated)
        terminated = terminatedDecoded
        let terminatingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .terminating)
        terminating = terminatingDecoded
        let unassigningDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .unassigning)
        unassigning = unassigningDecoded
    }
}

extension InstancesCount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstancesCount(assigning: \(String(describing: assigning)), booting: \(String(describing: booting)), connectionLost: \(String(describing: connectionLost)), deregistering: \(String(describing: deregistering)), online: \(String(describing: online)), pending: \(String(describing: pending)), rebooting: \(String(describing: rebooting)), registered: \(String(describing: registered)), registering: \(String(describing: registering)), requested: \(String(describing: requested)), runningSetup: \(String(describing: runningSetup)), setupFailed: \(String(describing: setupFailed)), shuttingDown: \(String(describing: shuttingDown)), startFailed: \(String(describing: startFailed)), stopFailed: \(String(describing: stopFailed)), stopped: \(String(describing: stopped)), stopping: \(String(describing: stopping)), terminated: \(String(describing: terminated)), terminating: \(String(describing: terminating)), unassigning: \(String(describing: unassigning)))"}
}

/// <p>Describes how many instances a stack has for each status.</p>
public struct InstancesCount: Equatable {
    /// <p>The number of instances in the Assigning state.</p>
    public let assigning: Int?
    /// <p>The number of instances with <code>booting</code> status.</p>
    public let booting: Int?
    /// <p>The number of instances with <code>connection_lost</code> status.</p>
    public let connectionLost: Int?
    /// <p>The number of instances in the Deregistering state.</p>
    public let deregistering: Int?
    /// <p>The number of instances with <code>online</code> status.</p>
    public let online: Int?
    /// <p>The number of instances with <code>pending</code> status.</p>
    public let pending: Int?
    /// <p>The number of instances with <code>rebooting</code> status.</p>
    public let rebooting: Int?
    /// <p>The number of instances in the Registered state.</p>
    public let registered: Int?
    /// <p>The number of instances in the Registering state.</p>
    public let registering: Int?
    /// <p>The number of instances with <code>requested</code> status.</p>
    public let requested: Int?
    /// <p>The number of instances with <code>running_setup</code> status.</p>
    public let runningSetup: Int?
    /// <p>The number of instances with <code>setup_failed</code> status.</p>
    public let setupFailed: Int?
    /// <p>The number of instances with <code>shutting_down</code> status.</p>
    public let shuttingDown: Int?
    /// <p>The number of instances with <code>start_failed</code> status.</p>
    public let startFailed: Int?
    /// <p>The number of instances with <code>stop_failed</code> status.</p>
    public let stopFailed: Int?
    /// <p>The number of instances with <code>stopped</code> status.</p>
    public let stopped: Int?
    /// <p>The number of instances with <code>stopping</code> status.</p>
    public let stopping: Int?
    /// <p>The number of instances with <code>terminated</code> status.</p>
    public let terminated: Int?
    /// <p>The number of instances with <code>terminating</code> status.</p>
    public let terminating: Int?
    /// <p>The number of instances in the Unassigning state.</p>
    public let unassigning: Int?

    public init (
        assigning: Int? = nil,
        booting: Int? = nil,
        connectionLost: Int? = nil,
        deregistering: Int? = nil,
        online: Int? = nil,
        pending: Int? = nil,
        rebooting: Int? = nil,
        registered: Int? = nil,
        registering: Int? = nil,
        requested: Int? = nil,
        runningSetup: Int? = nil,
        setupFailed: Int? = nil,
        shuttingDown: Int? = nil,
        startFailed: Int? = nil,
        stopFailed: Int? = nil,
        stopped: Int? = nil,
        stopping: Int? = nil,
        terminated: Int? = nil,
        terminating: Int? = nil,
        unassigning: Int? = nil
    )
    {
        self.assigning = assigning
        self.booting = booting
        self.connectionLost = connectionLost
        self.deregistering = deregistering
        self.online = online
        self.pending = pending
        self.rebooting = rebooting
        self.registered = registered
        self.registering = registering
        self.requested = requested
        self.runningSetup = runningSetup
        self.setupFailed = setupFailed
        self.shuttingDown = shuttingDown
        self.startFailed = startFailed
        self.stopFailed = stopFailed
        self.stopped = stopped
        self.stopping = stopping
        self.terminated = terminated
        self.terminating = terminating
        self.unassigning = unassigning
    }
}

extension Layer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case createdAt = "CreatedAt"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case defaultRecipes = "DefaultRecipes"
        case defaultSecurityGroupNames = "DefaultSecurityGroupNames"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case layerId = "LayerId"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case stackId = "StackId"
        case type = "Type"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, layerattributes0) in attributes {
                try attributesContainer.encode(layerattributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let autoAssignElasticIps = autoAssignElasticIps {
            try encodeContainer.encode(autoAssignElasticIps, forKey: .autoAssignElasticIps)
        }
        if let autoAssignPublicIps = autoAssignPublicIps {
            try encodeContainer.encode(autoAssignPublicIps, forKey: .autoAssignPublicIps)
        }
        if let cloudWatchLogsConfiguration = cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let customInstanceProfileArn = customInstanceProfileArn {
            try encodeContainer.encode(customInstanceProfileArn, forKey: .customInstanceProfileArn)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let customRecipes = customRecipes {
            try encodeContainer.encode(customRecipes, forKey: .customRecipes)
        }
        if let customSecurityGroupIds = customSecurityGroupIds {
            var customSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customSecurityGroupIds)
            for strings0 in customSecurityGroupIds {
                try customSecurityGroupIdsContainer.encode(strings0)
            }
        }
        if let defaultRecipes = defaultRecipes {
            try encodeContainer.encode(defaultRecipes, forKey: .defaultRecipes)
        }
        if let defaultSecurityGroupNames = defaultSecurityGroupNames {
            var defaultSecurityGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultSecurityGroupNames)
            for strings0 in defaultSecurityGroupNames {
                try defaultSecurityGroupNamesContainer.encode(strings0)
            }
        }
        if let enableAutoHealing = enableAutoHealing {
            try encodeContainer.encode(enableAutoHealing, forKey: .enableAutoHealing)
        }
        if let installUpdatesOnBoot = installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let lifecycleEventConfiguration = lifecycleEventConfiguration {
            try encodeContainer.encode(lifecycleEventConfiguration, forKey: .lifecycleEventConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packages = packages {
            var packagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .packages)
            for strings0 in packages {
                try packagesContainer.encode(strings0)
            }
        }
        if let shortname = shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let useEbsOptimizedInstances = useEbsOptimizedInstances {
            try encodeContainer.encode(useEbsOptimizedInstances, forKey: .useEbsOptimizedInstances)
        }
        if let volumeConfigurations = volumeConfigurations {
            var volumeConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeConfigurations)
            for volumeconfigurations0 in volumeConfigurations {
                try volumeConfigurationsContainer.encode(volumeconfigurations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(LayerType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(CloudWatchLogsConfiguration.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let customInstanceProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customInstanceProfileArn)
        customInstanceProfileArn = customInstanceProfileArnDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let customSecurityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .customSecurityGroupIds)
        var customSecurityGroupIdsDecoded0:[String]? = nil
        if let customSecurityGroupIdsContainer = customSecurityGroupIdsContainer {
            customSecurityGroupIdsDecoded0 = [String]()
            for string0 in customSecurityGroupIdsContainer {
                if let string0 = string0 {
                    customSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        customSecurityGroupIds = customSecurityGroupIdsDecoded0
        let defaultSecurityGroupNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .defaultSecurityGroupNames)
        var defaultSecurityGroupNamesDecoded0:[String]? = nil
        if let defaultSecurityGroupNamesContainer = defaultSecurityGroupNamesContainer {
            defaultSecurityGroupNamesDecoded0 = [String]()
            for string0 in defaultSecurityGroupNamesContainer {
                if let string0 = string0 {
                    defaultSecurityGroupNamesDecoded0?.append(string0)
                }
            }
        }
        defaultSecurityGroupNames = defaultSecurityGroupNamesDecoded0
        let packagesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .packages)
        var packagesDecoded0:[String]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [String]()
            for string0 in packagesContainer {
                if let string0 = string0 {
                    packagesDecoded0?.append(string0)
                }
            }
        }
        packages = packagesDecoded0
        let volumeConfigurationsContainer = try containerValues.decodeIfPresent([VolumeConfiguration?].self, forKey: .volumeConfigurations)
        var volumeConfigurationsDecoded0:[VolumeConfiguration]? = nil
        if let volumeConfigurationsContainer = volumeConfigurationsContainer {
            volumeConfigurationsDecoded0 = [VolumeConfiguration]()
            for structure0 in volumeConfigurationsContainer {
                if let structure0 = structure0 {
                    volumeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        volumeConfigurations = volumeConfigurationsDecoded0
        let enableAutoHealingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoHealing)
        enableAutoHealing = enableAutoHealingDecoded
        let autoAssignElasticIpsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoAssignElasticIps)
        autoAssignElasticIps = autoAssignElasticIpsDecoded
        let autoAssignPublicIpsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoAssignPublicIps)
        autoAssignPublicIps = autoAssignPublicIpsDecoded
        let defaultRecipesDecoded = try containerValues.decodeIfPresent(Recipes.self, forKey: .defaultRecipes)
        defaultRecipes = defaultRecipesDecoded
        let customRecipesDecoded = try containerValues.decodeIfPresent(Recipes.self, forKey: .customRecipes)
        customRecipes = customRecipesDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let useEbsOptimizedInstancesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useEbsOptimizedInstances)
        useEbsOptimizedInstances = useEbsOptimizedInstancesDecoded
        let lifecycleEventConfigurationDecoded = try containerValues.decodeIfPresent(LifecycleEventConfiguration.self, forKey: .lifecycleEventConfiguration)
        lifecycleEventConfiguration = lifecycleEventConfigurationDecoded
    }
}

extension Layer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Layer(arn: \(String(describing: arn)), attributes: \(String(describing: attributes)), autoAssignElasticIps: \(String(describing: autoAssignElasticIps)), autoAssignPublicIps: \(String(describing: autoAssignPublicIps)), cloudWatchLogsConfiguration: \(String(describing: cloudWatchLogsConfiguration)), createdAt: \(String(describing: createdAt)), customInstanceProfileArn: \(String(describing: customInstanceProfileArn)), customJson: \(String(describing: customJson)), customRecipes: \(String(describing: customRecipes)), customSecurityGroupIds: \(String(describing: customSecurityGroupIds)), defaultRecipes: \(String(describing: defaultRecipes)), defaultSecurityGroupNames: \(String(describing: defaultSecurityGroupNames)), enableAutoHealing: \(String(describing: enableAutoHealing)), installUpdatesOnBoot: \(String(describing: installUpdatesOnBoot)), layerId: \(String(describing: layerId)), lifecycleEventConfiguration: \(String(describing: lifecycleEventConfiguration)), name: \(String(describing: name)), packages: \(String(describing: packages)), shortname: \(String(describing: shortname)), stackId: \(String(describing: stackId)), type: \(String(describing: type)), useEbsOptimizedInstances: \(String(describing: useEbsOptimizedInstances)), volumeConfigurations: \(String(describing: volumeConfigurations)))"}
}

/// <p>Describes a layer.</p>
public struct Layer: Equatable {
    /// <p>The Amazon Resource Number (ARN) of a layer.</p>
    public let arn: String?
    /// <p>The layer attributes.</p>
    ///          <p>For the <code>HaproxyStatsPassword</code>, <code>MysqlRootPassword</code>, and
    ///         <code>GangliaPassword</code> attributes, AWS OpsWorks Stacks returns <code>*****FILTERED*****</code>
    ///       instead of the actual value</p>
    ///          <p>For an ECS Cluster layer, AWS OpsWorks Stacks the <code>EcsClusterArn</code> attribute is set to the cluster's ARN.</p>
    public let attributes: [String:String]?
    /// <p>Whether to automatically assign an <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP
    ///         address</a> to the layer's instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html">How to Edit
    ///         a Layer</a>.</p>
    public let autoAssignElasticIps: Bool?
    /// <p>For stacks that are running in a VPC, whether to automatically assign a public IP address to
    ///       the layer's instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html">How to Edit
    ///         a Layer</a>.</p>
    public let autoAssignPublicIps: Bool?
    /// <p>The Amazon CloudWatch Logs configuration settings for the layer.</p>
    public let cloudWatchLogsConfiguration: CloudWatchLogsConfiguration?
    /// <p>Date when the layer was created.</p>
    public let createdAt: String?
    /// <p>The ARN of the default IAM profile to be used for the layer's EC2 instances. For more
    ///       information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers</a>.</p>
    public let customInstanceProfileArn: String?
    /// <p>A JSON formatted string containing the layer's custom stack configuration and deployment attributes.</p>
    public let customJson: String?
    /// <p>A <code>LayerCustomRecipes</code> object that specifies the layer's custom recipes.</p>
    public let customRecipes: Recipes?
    /// <p>An array containing the layer's custom security group IDs.</p>
    public let customSecurityGroupIds: [String]?
    /// <p>AWS OpsWorks Stacks supports five lifecycle events: <b>setup</b>, <b>configuration</b>,
    ///             <b>deploy</b>, <b>undeploy</b>, and <b>shutdown</b>.
    ///             For each layer, AWS OpsWorks Stacks runs a set of standard recipes for each event. You can also provide
    ///             custom recipes for any or all layers and events. AWS OpsWorks Stacks runs custom event recipes after the standard
    ///             recipes. <code>LayerCustomRecipes</code> specifies the custom recipes for a particular layer to be run in response to each of
    ///             the five events.</p>
    ///         <p>To specify a recipe, use the cookbook's directory name in the repository followed by two colons and the recipe
    ///             name, which is the recipe's file name without the <code>.rb</code> extension. For example: <code>phpapp2::dbsetup</code> specifies the
    ///             <code>dbsetup.rb</code> recipe in the repository's <code>phpapp2</code> folder.</p>
    public let defaultRecipes: Recipes?
    /// <p>An array containing the layer's security group names.</p>
    public let defaultSecurityGroupNames: [String]?
    /// <p>Whether auto healing is disabled for the layer.</p>
    public let enableAutoHealing: Bool?
    /// <p>Whether to install operating system and package updates when the instance boots. The default
    ///       value is <code>true</code>. If this value is set to <code>false</code>, you must then update
    ///       your instances manually by using <a>CreateDeployment</a> to run the
    ///         <code>update_dependencies</code> stack command or manually running <code>yum</code> (Amazon
    ///       Linux) or <code>apt-get</code> (Ubuntu) on the instances. </p>
    ///          <note>
    ///             <p>We strongly recommend using the default value of <code>true</code>, to ensure that your
    ///         instances have the latest security updates.</p>
    ///          </note>
    public let installUpdatesOnBoot: Bool?
    /// <p>The layer ID.</p>
    public let layerId: String?
    /// <p>A <code>LifeCycleEventConfiguration</code> object that specifies the Shutdown event
    ///       configuration.</p>
    public let lifecycleEventConfiguration: LifecycleEventConfiguration?
    /// <p>The layer name.</p>
    public let name: String?
    /// <p>An array of <code>Package</code> objects that describe the layer's packages.</p>
    public let packages: [String]?
    /// <p>The layer short name.</p>
    public let shortname: String?
    /// <p>The layer stack ID.</p>
    public let stackId: String?
    /// <p>The layer type.</p>
    public let type: LayerType?
    /// <p>Whether the layer uses Amazon EBS-optimized instances.</p>
    public let useEbsOptimizedInstances: Bool?
    /// <p>A <code>VolumeConfigurations</code> object that describes the layer's Amazon EBS volumes.</p>
    public let volumeConfigurations: [VolumeConfiguration]?

    public init (
        arn: String? = nil,
        attributes: [String:String]? = nil,
        autoAssignElasticIps: Bool? = nil,
        autoAssignPublicIps: Bool? = nil,
        cloudWatchLogsConfiguration: CloudWatchLogsConfiguration? = nil,
        createdAt: String? = nil,
        customInstanceProfileArn: String? = nil,
        customJson: String? = nil,
        customRecipes: Recipes? = nil,
        customSecurityGroupIds: [String]? = nil,
        defaultRecipes: Recipes? = nil,
        defaultSecurityGroupNames: [String]? = nil,
        enableAutoHealing: Bool? = nil,
        installUpdatesOnBoot: Bool? = nil,
        layerId: String? = nil,
        lifecycleEventConfiguration: LifecycleEventConfiguration? = nil,
        name: String? = nil,
        packages: [String]? = nil,
        shortname: String? = nil,
        stackId: String? = nil,
        type: LayerType? = nil,
        useEbsOptimizedInstances: Bool? = nil,
        volumeConfigurations: [VolumeConfiguration]? = nil
    )
    {
        self.arn = arn
        self.attributes = attributes
        self.autoAssignElasticIps = autoAssignElasticIps
        self.autoAssignPublicIps = autoAssignPublicIps
        self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
        self.createdAt = createdAt
        self.customInstanceProfileArn = customInstanceProfileArn
        self.customJson = customJson
        self.customRecipes = customRecipes
        self.customSecurityGroupIds = customSecurityGroupIds
        self.defaultRecipes = defaultRecipes
        self.defaultSecurityGroupNames = defaultSecurityGroupNames
        self.enableAutoHealing = enableAutoHealing
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.layerId = layerId
        self.lifecycleEventConfiguration = lifecycleEventConfiguration
        self.name = name
        self.packages = packages
        self.shortname = shortname
        self.stackId = stackId
        self.type = type
        self.useEbsOptimizedInstances = useEbsOptimizedInstances
        self.volumeConfigurations = volumeConfigurations
    }
}

public enum LayerAttributesKeys {
    case bundlerversion
    case ecsclusterarn
    case enablehaproxystats
    case gangliapassword
    case gangliaurl
    case gangliauser
    case haproxyhealthcheckmethod
    case haproxyhealthcheckurl
    case haproxystatspassword
    case haproxystatsurl
    case haproxystatsuser
    case javaappserver
    case javaappserverversion
    case jvm
    case jvmoptions
    case jvmversion
    case managebundler
    case memcachedmemory
    case mysqlrootpassword
    case mysqlrootpasswordubiquitous
    case nodejsversion
    case passengerversion
    case railsstack
    case rubyversion
    case rubygemsversion
    case sdkUnknown(String)
}

extension LayerAttributesKeys : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LayerAttributesKeys] {
        return [
            .bundlerversion,
            .ecsclusterarn,
            .enablehaproxystats,
            .gangliapassword,
            .gangliaurl,
            .gangliauser,
            .haproxyhealthcheckmethod,
            .haproxyhealthcheckurl,
            .haproxystatspassword,
            .haproxystatsurl,
            .haproxystatsuser,
            .javaappserver,
            .javaappserverversion,
            .jvm,
            .jvmoptions,
            .jvmversion,
            .managebundler,
            .memcachedmemory,
            .mysqlrootpassword,
            .mysqlrootpasswordubiquitous,
            .nodejsversion,
            .passengerversion,
            .railsstack,
            .rubyversion,
            .rubygemsversion,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bundlerversion: return "BundlerVersion"
        case .ecsclusterarn: return "EcsClusterArn"
        case .enablehaproxystats: return "EnableHaproxyStats"
        case .gangliapassword: return "GangliaPassword"
        case .gangliaurl: return "GangliaUrl"
        case .gangliauser: return "GangliaUser"
        case .haproxyhealthcheckmethod: return "HaproxyHealthCheckMethod"
        case .haproxyhealthcheckurl: return "HaproxyHealthCheckUrl"
        case .haproxystatspassword: return "HaproxyStatsPassword"
        case .haproxystatsurl: return "HaproxyStatsUrl"
        case .haproxystatsuser: return "HaproxyStatsUser"
        case .javaappserver: return "JavaAppServer"
        case .javaappserverversion: return "JavaAppServerVersion"
        case .jvm: return "Jvm"
        case .jvmoptions: return "JvmOptions"
        case .jvmversion: return "JvmVersion"
        case .managebundler: return "ManageBundler"
        case .memcachedmemory: return "MemcachedMemory"
        case .mysqlrootpassword: return "MysqlRootPassword"
        case .mysqlrootpasswordubiquitous: return "MysqlRootPasswordUbiquitous"
        case .nodejsversion: return "NodejsVersion"
        case .passengerversion: return "PassengerVersion"
        case .railsstack: return "RailsStack"
        case .rubyversion: return "RubyVersion"
        case .rubygemsversion: return "RubygemsVersion"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LayerAttributesKeys(rawValue: rawValue) ?? LayerAttributesKeys.sdkUnknown(rawValue)
    }
}

public enum LayerType {
    case awsFlowRuby
    case custom
    case dbMaster
    case ecsCluster
    case javaApp
    case lb
    case memcached
    case monitoringMaster
    case nodejsApp
    case phpApp
    case railsApp
    case web
    case sdkUnknown(String)
}

extension LayerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LayerType] {
        return [
            .awsFlowRuby,
            .custom,
            .dbMaster,
            .ecsCluster,
            .javaApp,
            .lb,
            .memcached,
            .monitoringMaster,
            .nodejsApp,
            .phpApp,
            .railsApp,
            .web,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsFlowRuby: return "aws-flow-ruby"
        case .custom: return "custom"
        case .dbMaster: return "db-master"
        case .ecsCluster: return "ecs-cluster"
        case .javaApp: return "java-app"
        case .lb: return "lb"
        case .memcached: return "memcached"
        case .monitoringMaster: return "monitoring-master"
        case .nodejsApp: return "nodejs-app"
        case .phpApp: return "php-app"
        case .railsApp: return "rails-app"
        case .web: return "web"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LayerType(rawValue: rawValue) ?? LayerType.sdkUnknown(rawValue)
    }
}

extension LifecycleEventConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case shutdown = "Shutdown"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shutdown = shutdown {
            try encodeContainer.encode(shutdown, forKey: .shutdown)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shutdownDecoded = try containerValues.decodeIfPresent(ShutdownEventConfiguration.self, forKey: .shutdown)
        shutdown = shutdownDecoded
    }
}

extension LifecycleEventConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LifecycleEventConfiguration(shutdown: \(String(describing: shutdown)))"}
}

/// <p>Specifies the lifecycle event configuration</p>
public struct LifecycleEventConfiguration: Equatable {
    /// <p>A <code>ShutdownEventConfiguration</code> object that specifies the Shutdown event
    ///       configuration.</p>
    public let shutdown: ShutdownEventConfiguration?

    public init (
        shutdown: ShutdownEventConfiguration? = nil
    )
    {
        self.shutdown = shutdown
    }
}

public struct ListTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

extension ListTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Equatable {
    /// <p>Do not use. A validation exception occurs if you add a <code>MaxResults</code> parameter to a <code>ListTagsRequest</code> call.
    ///       </p>
    public let maxResults: Int
    /// <p>Do not use. A validation exception occurs if you add a <code>NextToken</code> parameter to a <code>ListTagsRequest</code> call.
    ///       </p>
    public let nextToken: String?
    /// <p>The stack or layer's Amazon Resource Number (ARN).</p>
    public let resourceArn: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsInputBody: Equatable {
    public let resourceArn: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

/// <p>Contains the response to a <code>ListTags</code> request.</p>
public struct ListTagsOutputResponse: Equatable {
    /// <p>If a paginated request does not return all of the remaining results, this parameter is set to a token that
    ///             you can assign to the request object's <code>NextToken</code> parameter to get the next set of results.
    ///             If the previous paginated request returned all of the remaining results,
    ///             this parameter is set to <code>null</code>.
    ///       </p>
    public let nextToken: String?
    /// <p>A set of key-value pairs that contain tag keys and tag values that are attached to a stack or layer.</p>
    public let tags: [String:String]?

    public init (
        nextToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Equatable {
    public let tags: [String:String]?
    public let nextToken: String?
}

extension ListTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LoadBasedAutoScalingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case downScaling = "DownScaling"
        case enable = "Enable"
        case layerId = "LayerId"
        case upScaling = "UpScaling"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downScaling = downScaling {
            try encodeContainer.encode(downScaling, forKey: .downScaling)
        }
        if let enable = enable {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let upScaling = upScaling {
            try encodeContainer.encode(upScaling, forKey: .upScaling)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let enableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enable)
        enable = enableDecoded
        let upScalingDecoded = try containerValues.decodeIfPresent(AutoScalingThresholds.self, forKey: .upScaling)
        upScaling = upScalingDecoded
        let downScalingDecoded = try containerValues.decodeIfPresent(AutoScalingThresholds.self, forKey: .downScaling)
        downScaling = downScalingDecoded
    }
}

extension LoadBasedAutoScalingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoadBasedAutoScalingConfiguration(downScaling: \(String(describing: downScaling)), enable: \(String(describing: enable)), layerId: \(String(describing: layerId)), upScaling: \(String(describing: upScaling)))"}
}

/// <p>Describes a layer's load-based auto scaling configuration.</p>
public struct LoadBasedAutoScalingConfiguration: Equatable {
    /// <p>An <code>AutoScalingThresholds</code> object that describes the downscaling configuration,
    ///       which defines how and when AWS OpsWorks Stacks reduces the number of instances.</p>
    public let downScaling: AutoScalingThresholds?
    /// <p>Whether load-based auto scaling is enabled for the layer.</p>
    public let enable: Bool?
    /// <p>The layer ID.</p>
    public let layerId: String?
    /// <p>An <code>AutoScalingThresholds</code> object that describes the upscaling configuration,
    ///       which defines how and when AWS OpsWorks Stacks increases the number of instances.</p>
    public let upScaling: AutoScalingThresholds?

    public init (
        downScaling: AutoScalingThresholds? = nil,
        enable: Bool? = nil,
        layerId: String? = nil,
        upScaling: AutoScalingThresholds? = nil
    )
    {
        self.downScaling = downScaling
        self.enable = enable
        self.layerId = layerId
        self.upScaling = upScaling
    }
}

extension OperatingSystem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationManagers = "ConfigurationManagers"
        case id = "Id"
        case name = "Name"
        case reportedName = "ReportedName"
        case reportedVersion = "ReportedVersion"
        case supported = "Supported"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationManagers = configurationManagers {
            var configurationManagersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationManagers)
            for operatingsystemconfigurationmanagers0 in configurationManagers {
                try configurationManagersContainer.encode(operatingsystemconfigurationmanagers0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reportedName = reportedName {
            try encodeContainer.encode(reportedName, forKey: .reportedName)
        }
        if let reportedVersion = reportedVersion {
            try encodeContainer.encode(reportedVersion, forKey: .reportedVersion)
        }
        if let supported = supported {
            try encodeContainer.encode(supported, forKey: .supported)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let configurationManagersContainer = try containerValues.decodeIfPresent([OperatingSystemConfigurationManager?].self, forKey: .configurationManagers)
        var configurationManagersDecoded0:[OperatingSystemConfigurationManager]? = nil
        if let configurationManagersContainer = configurationManagersContainer {
            configurationManagersDecoded0 = [OperatingSystemConfigurationManager]()
            for structure0 in configurationManagersContainer {
                if let structure0 = structure0 {
                    configurationManagersDecoded0?.append(structure0)
                }
            }
        }
        configurationManagers = configurationManagersDecoded0
        let reportedNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportedName)
        reportedName = reportedNameDecoded
        let reportedVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportedVersion)
        reportedVersion = reportedVersionDecoded
        let supportedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .supported)
        supported = supportedDecoded
    }
}

extension OperatingSystem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperatingSystem(configurationManagers: \(String(describing: configurationManagers)), id: \(String(describing: id)), name: \(String(describing: name)), reportedName: \(String(describing: reportedName)), reportedVersion: \(String(describing: reportedVersion)), supported: \(String(describing: supported)), type: \(String(describing: type)))"}
}

/// <p>Describes supported operating systems in AWS OpsWorks Stacks.</p>
public struct OperatingSystem: Equatable {
    /// <p>Supported configuration manager name and versions for an AWS OpsWorks Stacks operating system.</p>
    public let configurationManagers: [OperatingSystemConfigurationManager]?
    /// <p>The ID of a supported operating system, such as <code>Amazon Linux 2018.03</code>.</p>
    public let id: String?
    /// <p>The name of the operating system, such as <code>Amazon Linux 2018.03</code>.</p>
    public let name: String?
    /// <p>A short name for the operating system manufacturer.</p>
    public let reportedName: String?
    /// <p>The version of the operating system, including the release and edition, if applicable.</p>
    public let reportedVersion: String?
    /// <p>Indicates that an operating system is not supported for new instances.</p>
    public let supported: Bool?
    /// <p>The type of a supported operating system, either <code>Linux</code> or <code>Windows</code>.</p>
    public let type: String?

    public init (
        configurationManagers: [OperatingSystemConfigurationManager]? = nil,
        id: String? = nil,
        name: String? = nil,
        reportedName: String? = nil,
        reportedVersion: String? = nil,
        supported: Bool? = nil,
        type: String? = nil
    )
    {
        self.configurationManagers = configurationManagers
        self.id = id
        self.name = name
        self.reportedName = reportedName
        self.reportedVersion = reportedVersion
        self.supported = supported
        self.type = type
    }
}

extension OperatingSystemConfigurationManager: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension OperatingSystemConfigurationManager: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperatingSystemConfigurationManager(name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>A block that contains information about the configuration manager (Chef) and the versions of the configuration manager that are supported for an operating system.</p>
public struct OperatingSystemConfigurationManager: Equatable {
    /// <p>The name of the configuration manager, which is Chef.</p>
    public let name: String?
    /// <p>The versions of the configuration manager that are supported by an operating system.</p>
    public let version: String?

    public init (
        name: String? = nil,
        version: String? = nil
    )
    {
        self.name = name
        self.version = version
    }
}

extension Permission: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowSsh = "AllowSsh"
        case allowSudo = "AllowSudo"
        case iamUserArn = "IamUserArn"
        case level = "Level"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSsh = allowSsh {
            try encodeContainer.encode(allowSsh, forKey: .allowSsh)
        }
        if let allowSudo = allowSudo {
            try encodeContainer.encode(allowSudo, forKey: .allowSudo)
        }
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let level = level {
            try encodeContainer.encode(level, forKey: .level)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let iamUserArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let allowSshDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSsh)
        allowSsh = allowSshDecoded
        let allowSudoDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSudo)
        allowSudo = allowSudoDecoded
        let levelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .level)
        level = levelDecoded
    }
}

extension Permission: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Permission(allowSsh: \(String(describing: allowSsh)), allowSudo: \(String(describing: allowSudo)), iamUserArn: \(String(describing: iamUserArn)), level: \(String(describing: level)), stackId: \(String(describing: stackId)))"}
}

/// <p>Describes stack or user permissions.</p>
public struct Permission: Equatable {
    /// <p>Whether the user can use SSH.</p>
    public let allowSsh: Bool?
    /// <p>Whether the user can use <b>sudo</b>.</p>
    public let allowSudo: Bool?
    /// <p>The Amazon Resource Name (ARN) for an AWS Identity and Access Management (IAM) role. For more
    ///       information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers</a>.</p>
    public let iamUserArn: String?
    /// <p>The user's permission level, which must be the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>deny</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>show</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deploy</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>manage</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>iam_only</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information on the permissions associated with these levels, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/opsworks-security-users.html">Managing User Permissions</a>
    ///          </p>
    public let level: String?
    /// <p>A stack ID.</p>
    public let stackId: String?

    public init (
        allowSsh: Bool? = nil,
        allowSudo: Bool? = nil,
        iamUserArn: String? = nil,
        level: String? = nil,
        stackId: String? = nil
    )
    {
        self.allowSsh = allowSsh
        self.allowSudo = allowSudo
        self.iamUserArn = iamUserArn
        self.level = level
        self.stackId = stackId
    }
}

extension RaidArray: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case createdAt = "CreatedAt"
        case device = "Device"
        case instanceId = "InstanceId"
        case iops = "Iops"
        case mountPoint = "MountPoint"
        case name = "Name"
        case numberOfDisks = "NumberOfDisks"
        case raidArrayId = "RaidArrayId"
        case raidLevel = "RaidLevel"
        case size = "Size"
        case stackId = "StackId"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let iops = iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let mountPoint = mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberOfDisks = numberOfDisks {
            try encodeContainer.encode(numberOfDisks, forKey: .numberOfDisks)
        }
        if let raidArrayId = raidArrayId {
            try encodeContainer.encode(raidArrayId, forKey: .raidArrayId)
        }
        if let raidLevel = raidLevel {
            try encodeContainer.encode(raidLevel, forKey: .raidLevel)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let raidArrayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .raidArrayId)
        raidArrayId = raidArrayIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let raidLevelDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .raidLevel)
        raidLevel = raidLevelDecoded
        let numberOfDisksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfDisks)
        numberOfDisks = numberOfDisksDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .size)
        size = sizeDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .device)
        device = deviceDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .iops)
        iops = iopsDecoded
    }
}

extension RaidArray: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RaidArray(availabilityZone: \(String(describing: availabilityZone)), createdAt: \(String(describing: createdAt)), device: \(String(describing: device)), instanceId: \(String(describing: instanceId)), iops: \(String(describing: iops)), mountPoint: \(String(describing: mountPoint)), name: \(String(describing: name)), numberOfDisks: \(String(describing: numberOfDisks)), raidArrayId: \(String(describing: raidArrayId)), raidLevel: \(String(describing: raidLevel)), size: \(String(describing: size)), stackId: \(String(describing: stackId)), volumeType: \(String(describing: volumeType)))"}
}

/// <p>Describes an instance's RAID array.</p>
public struct RaidArray: Equatable {
    /// <p>The array's Availability Zone. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints</a>.</p>
    public let availabilityZone: String?
    /// <p>When the RAID array was created.</p>
    public let createdAt: String?
    /// <p>The array's Linux device. For example /dev/mdadm0.</p>
    public let device: String?
    /// <p>The instance ID.</p>
    public let instanceId: String?
    /// <p>For PIOPS volumes, the IOPS per disk.</p>
    public let iops: Int?
    /// <p>The array's mount point.</p>
    public let mountPoint: String?
    /// <p>The array name.</p>
    public let name: String?
    /// <p>The number of disks in the array.</p>
    public let numberOfDisks: Int?
    /// <p>The array ID.</p>
    public let raidArrayId: String?
    /// <p>The <a href="http://en.wikipedia.org/wiki/Standard_RAID_levels">RAID level</a>.</p>
    public let raidLevel: Int?
    /// <p>The array's size.</p>
    public let size: Int?
    /// <p>The stack ID.</p>
    public let stackId: String?
    /// <p>The volume type, standard or PIOPS.</p>
    public let volumeType: String?

    public init (
        availabilityZone: String? = nil,
        createdAt: String? = nil,
        device: String? = nil,
        instanceId: String? = nil,
        iops: Int? = nil,
        mountPoint: String? = nil,
        name: String? = nil,
        numberOfDisks: Int? = nil,
        raidArrayId: String? = nil,
        raidLevel: Int? = nil,
        size: Int? = nil,
        stackId: String? = nil,
        volumeType: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.createdAt = createdAt
        self.device = device
        self.instanceId = instanceId
        self.iops = iops
        self.mountPoint = mountPoint
        self.name = name
        self.numberOfDisks = numberOfDisks
        self.raidArrayId = raidArrayId
        self.raidLevel = raidLevel
        self.size = size
        self.stackId = stackId
        self.volumeType = volumeType
    }
}

extension RdsDbInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case dbInstanceIdentifier = "DbInstanceIdentifier"
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case engine = "Engine"
        case missingOnRds = "MissingOnRds"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
        case region = "Region"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let dbInstanceIdentifier = dbInstanceIdentifier {
            try encodeContainer.encode(dbInstanceIdentifier, forKey: .dbInstanceIdentifier)
        }
        if let dbPassword = dbPassword {
            try encodeContainer.encode(dbPassword, forKey: .dbPassword)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let engine = engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let missingOnRds = missingOnRds {
            try encodeContainer.encode(missingOnRds, forKey: .missingOnRds)
        }
        if let rdsDbInstanceArn = rdsDbInstanceArn {
            try encodeContainer.encode(rdsDbInstanceArn, forKey: .rdsDbInstanceArn)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsDbInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rdsDbInstanceArn)
        rdsDbInstanceArn = rdsDbInstanceArnDecoded
        let dbInstanceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbInstanceIdentifier)
        dbInstanceIdentifier = dbInstanceIdentifierDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let missingOnRdsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .missingOnRds)
        missingOnRds = missingOnRdsDecoded
    }
}

extension RdsDbInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RdsDbInstance(address: \(String(describing: address)), dbInstanceIdentifier: \(String(describing: dbInstanceIdentifier)), dbPassword: \(String(describing: dbPassword)), dbUser: \(String(describing: dbUser)), engine: \(String(describing: engine)), missingOnRds: \(String(describing: missingOnRds)), rdsDbInstanceArn: \(String(describing: rdsDbInstanceArn)), region: \(String(describing: region)), stackId: \(String(describing: stackId)))"}
}

/// <p>Describes an Amazon RDS instance.</p>
public struct RdsDbInstance: Equatable {
    /// <p>The instance's address.</p>
    public let address: String?
    /// <p>The DB instance identifier.</p>
    public let dbInstanceIdentifier: String?
    /// <p>AWS OpsWorks Stacks returns <code>*****FILTERED*****</code> instead of the actual value.</p>
    public let dbPassword: String?
    /// <p>The master user name.</p>
    public let dbUser: String?
    /// <p>The instance's database engine.</p>
    public let engine: String?
    /// <p>Set to <code>true</code> if AWS OpsWorks Stacks is unable to discover the Amazon RDS instance. AWS OpsWorks Stacks attempts
    ///       to discover the instance only once. If this value is set to <code>true</code>, you must
    ///       deregister the instance, and then register it again.</p>
    public let missingOnRds: Bool?
    /// <p>The instance's ARN.</p>
    public let rdsDbInstanceArn: String?
    /// <p>The instance's AWS region.</p>
    public let region: String?
    /// <p>The ID of the stack with which the instance is registered.</p>
    public let stackId: String?

    public init (
        address: String? = nil,
        dbInstanceIdentifier: String? = nil,
        dbPassword: String? = nil,
        dbUser: String? = nil,
        engine: String? = nil,
        missingOnRds: Bool? = nil,
        rdsDbInstanceArn: String? = nil,
        region: String? = nil,
        stackId: String? = nil
    )
    {
        self.address = address
        self.dbInstanceIdentifier = dbInstanceIdentifier
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.engine = engine
        self.missingOnRds = missingOnRds
        self.rdsDbInstanceArn = rdsDbInstanceArn
        self.region = region
        self.stackId = stackId
    }
}

public struct RebootInstanceInputBodyMiddleware: Middleware {
    public let id: String = "RebootInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootInstanceInput>
    public typealias MOutput = OperationOutput<RebootInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootInstanceOutputError>
}

extension RebootInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootInstanceInput(instanceId: \(String(describing: instanceId)))"}
}

extension RebootInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct RebootInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "RebootInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootInstanceInput>
    public typealias MOutput = OperationOutput<RebootInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootInstanceOutputError>
}

public struct RebootInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "RebootInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootInstanceInput>
    public typealias MOutput = OperationOutput<RebootInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootInstanceOutputError>
}

public struct RebootInstanceInput: Equatable {
    /// <p>The instance ID.</p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct RebootInstanceInputBody: Equatable {
    public let instanceId: String?
}

extension RebootInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension RebootInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootInstanceOutputResponse()"}
}

extension RebootInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RebootInstanceOutputResponse: Equatable {

    public init() {}
}

struct RebootInstanceOutputResponseBody: Equatable {
}

extension RebootInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Recipes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configure = "Configure"
        case deploy = "Deploy"
        case setup = "Setup"
        case shutdown = "Shutdown"
        case undeploy = "Undeploy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configure = configure {
            var configureContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configure)
            for strings0 in configure {
                try configureContainer.encode(strings0)
            }
        }
        if let deploy = deploy {
            var deployContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploy)
            for strings0 in deploy {
                try deployContainer.encode(strings0)
            }
        }
        if let setup = setup {
            var setupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .setup)
            for strings0 in setup {
                try setupContainer.encode(strings0)
            }
        }
        if let shutdown = shutdown {
            var shutdownContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shutdown)
            for strings0 in shutdown {
                try shutdownContainer.encode(strings0)
            }
        }
        if let undeploy = undeploy {
            var undeployContainer = encodeContainer.nestedUnkeyedContainer(forKey: .undeploy)
            for strings0 in undeploy {
                try undeployContainer.encode(strings0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let setupContainer = try containerValues.decodeIfPresent([String?].self, forKey: .setup)
        var setupDecoded0:[String]? = nil
        if let setupContainer = setupContainer {
            setupDecoded0 = [String]()
            for string0 in setupContainer {
                if let string0 = string0 {
                    setupDecoded0?.append(string0)
                }
            }
        }
        setup = setupDecoded0
        let configureContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configure)
        var configureDecoded0:[String]? = nil
        if let configureContainer = configureContainer {
            configureDecoded0 = [String]()
            for string0 in configureContainer {
                if let string0 = string0 {
                    configureDecoded0?.append(string0)
                }
            }
        }
        configure = configureDecoded0
        let deployContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deploy)
        var deployDecoded0:[String]? = nil
        if let deployContainer = deployContainer {
            deployDecoded0 = [String]()
            for string0 in deployContainer {
                if let string0 = string0 {
                    deployDecoded0?.append(string0)
                }
            }
        }
        deploy = deployDecoded0
        let undeployContainer = try containerValues.decodeIfPresent([String?].self, forKey: .undeploy)
        var undeployDecoded0:[String]? = nil
        if let undeployContainer = undeployContainer {
            undeployDecoded0 = [String]()
            for string0 in undeployContainer {
                if let string0 = string0 {
                    undeployDecoded0?.append(string0)
                }
            }
        }
        undeploy = undeployDecoded0
        let shutdownContainer = try containerValues.decodeIfPresent([String?].self, forKey: .shutdown)
        var shutdownDecoded0:[String]? = nil
        if let shutdownContainer = shutdownContainer {
            shutdownDecoded0 = [String]()
            for string0 in shutdownContainer {
                if let string0 = string0 {
                    shutdownDecoded0?.append(string0)
                }
            }
        }
        shutdown = shutdownDecoded0
    }
}

extension Recipes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Recipes(configure: \(String(describing: configure)), deploy: \(String(describing: deploy)), setup: \(String(describing: setup)), shutdown: \(String(describing: shutdown)), undeploy: \(String(describing: undeploy)))"}
}

/// <p>AWS OpsWorks Stacks supports five
///       lifecycle events:
///         <b>setup</b>, <b>configuration</b>, <b>deploy</b>, <b>undeploy</b>, and <b>shutdown</b>. For
///       each layer, AWS OpsWorks Stacks runs a set of standard recipes for each event. In addition, you can provide
///       custom recipes for any or all layers and events. AWS OpsWorks Stacks runs custom event recipes after the
///       standard recipes. <code>LayerCustomRecipes</code> specifies the custom recipes for a
///       particular layer to be run in response to each of the five events. </p>
///
///          <p>To specify a recipe, use the cookbook's directory name in the repository followed by two colons and the recipe name, which is the recipe's file name without the .rb extension. For example: phpapp2::dbsetup specifies the dbsetup.rb recipe in the repository's phpapp2 folder.</p>
public struct Recipes: Equatable {
    /// <p>An array of custom recipe names to be run following a <code>configure</code> event.</p>
    public let configure: [String]?
    /// <p>An array of custom recipe names to be run following a <code>deploy</code> event.</p>
    public let deploy: [String]?
    /// <p>An array of custom recipe names to be run following a <code>setup</code> event.</p>
    public let setup: [String]?
    /// <p>An array of custom recipe names to be run following a <code>shutdown</code> event.</p>
    public let shutdown: [String]?
    /// <p>An array of custom recipe names to be run following a <code>undeploy</code> event.</p>
    public let undeploy: [String]?

    public init (
        configure: [String]? = nil,
        deploy: [String]? = nil,
        setup: [String]? = nil,
        shutdown: [String]? = nil,
        undeploy: [String]? = nil
    )
    {
        self.configure = configure
        self.deploy = deploy
        self.setup = setup
        self.shutdown = shutdown
        self.undeploy = undeploy
    }
}

public struct RegisterEcsClusterInputBodyMiddleware: Middleware {
    public let id: String = "RegisterEcsClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterEcsClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterEcsClusterInput>
    public typealias MOutput = OperationOutput<RegisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterEcsClusterOutputError>
}

extension RegisterEcsClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterEcsClusterInput(ecsClusterArn: \(String(describing: ecsClusterArn)), stackId: \(String(describing: stackId)))"}
}

extension RegisterEcsClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ecsClusterArn = "EcsClusterArn"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecsClusterArn = ecsClusterArn {
            try encodeContainer.encode(ecsClusterArn, forKey: .ecsClusterArn)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct RegisterEcsClusterInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterEcsClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterEcsClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterEcsClusterInput>
    public typealias MOutput = OperationOutput<RegisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterEcsClusterOutputError>
}

public struct RegisterEcsClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterEcsClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterEcsClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterEcsClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterEcsClusterInput>
    public typealias MOutput = OperationOutput<RegisterEcsClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterEcsClusterOutputError>
}

public struct RegisterEcsClusterInput: Equatable {
    /// <p>The cluster's ARN.</p>
    public let ecsClusterArn: String?
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        ecsClusterArn: String? = nil,
        stackId: String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
        self.stackId = stackId
    }
}

struct RegisterEcsClusterInputBody: Equatable {
    public let ecsClusterArn: String?
    public let stackId: String?
}

extension RegisterEcsClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ecsClusterArn = "EcsClusterArn"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension RegisterEcsClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterEcsClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterEcsClusterOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterEcsClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterEcsClusterOutputResponse(ecsClusterArn: \(String(describing: ecsClusterArn)))"}
}

extension RegisterEcsClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterEcsClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ecsClusterArn = output.ecsClusterArn
        } else {
            self.ecsClusterArn = nil
        }
    }
}

/// <p>Contains the response to a <code>RegisterEcsCluster</code> request.</p>
public struct RegisterEcsClusterOutputResponse: Equatable {
    /// <p>The cluster's ARN.</p>
    public let ecsClusterArn: String?

    public init (
        ecsClusterArn: String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
    }
}

struct RegisterEcsClusterOutputResponseBody: Equatable {
    public let ecsClusterArn: String?
}

extension RegisterEcsClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ecsClusterArn = "EcsClusterArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
    }
}

public struct RegisterElasticIpInputBodyMiddleware: Middleware {
    public let id: String = "RegisterElasticIpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterElasticIpInput>
    public typealias MOutput = OperationOutput<RegisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterElasticIpOutputError>
}

extension RegisterElasticIpInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterElasticIpInput(elasticIp: \(String(describing: elasticIp)), stackId: \(String(describing: stackId)))"}
}

extension RegisterElasticIpInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct RegisterElasticIpInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterElasticIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterElasticIpInput>
    public typealias MOutput = OperationOutput<RegisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterElasticIpOutputError>
}

public struct RegisterElasticIpInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterElasticIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterElasticIpInput>
    public typealias MOutput = OperationOutput<RegisterElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterElasticIpOutputError>
}

public struct RegisterElasticIpInput: Equatable {
    /// <p>The Elastic IP address.</p>
    public let elasticIp: String?
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        elasticIp: String? = nil,
        stackId: String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.stackId = stackId
    }
}

struct RegisterElasticIpInputBody: Equatable {
    public let elasticIp: String?
    public let stackId: String?
}

extension RegisterElasticIpInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension RegisterElasticIpOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterElasticIpOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterElasticIpOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterElasticIpOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterElasticIpOutputResponse(elasticIp: \(String(describing: elasticIp)))"}
}

extension RegisterElasticIpOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterElasticIpOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.elasticIp = output.elasticIp
        } else {
            self.elasticIp = nil
        }
    }
}

/// <p>Contains the response to a <code>RegisterElasticIp</code> request.</p>
public struct RegisterElasticIpOutputResponse: Equatable {
    /// <p>The Elastic IP address.</p>
    public let elasticIp: String?

    public init (
        elasticIp: String? = nil
    )
    {
        self.elasticIp = elasticIp
    }
}

struct RegisterElasticIpOutputResponseBody: Equatable {
    public let elasticIp: String?
}

extension RegisterElasticIpOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
    }
}

public struct RegisterInstanceInputBodyMiddleware: Middleware {
    public let id: String = "RegisterInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterInstanceOutputError>
}

extension RegisterInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterInstanceInput(hostname: \(String(describing: hostname)), instanceIdentity: \(String(describing: instanceIdentity)), privateIp: \(String(describing: privateIp)), publicIp: \(String(describing: publicIp)), rsaPublicKey: \(String(describing: rsaPublicKey)), rsaPublicKeyFingerprint: \(String(describing: rsaPublicKeyFingerprint)), stackId: \(String(describing: stackId)))"}
}

extension RegisterInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostname = "Hostname"
        case instanceIdentity = "InstanceIdentity"
        case privateIp = "PrivateIp"
        case publicIp = "PublicIp"
        case rsaPublicKey = "RsaPublicKey"
        case rsaPublicKeyFingerprint = "RsaPublicKeyFingerprint"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let instanceIdentity = instanceIdentity {
            try encodeContainer.encode(instanceIdentity, forKey: .instanceIdentity)
        }
        if let privateIp = privateIp {
            try encodeContainer.encode(privateIp, forKey: .privateIp)
        }
        if let publicIp = publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let rsaPublicKey = rsaPublicKey {
            try encodeContainer.encode(rsaPublicKey, forKey: .rsaPublicKey)
        }
        if let rsaPublicKeyFingerprint = rsaPublicKeyFingerprint {
            try encodeContainer.encode(rsaPublicKeyFingerprint, forKey: .rsaPublicKeyFingerprint)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct RegisterInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterInstanceOutputError>
}

public struct RegisterInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterInstanceInput>
    public typealias MOutput = OperationOutput<RegisterInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterInstanceOutputError>
}

public struct RegisterInstanceInput: Equatable {
    /// <p>The instance's hostname.</p>
    public let hostname: String?
    /// <p>An InstanceIdentity object that contains the instance's identity.</p>
    public let instanceIdentity: InstanceIdentity?
    /// <p>The instance's private IP address.</p>
    public let privateIp: String?
    /// <p>The instance's public IP address.</p>
    public let publicIp: String?
    /// <p>The instances public RSA key. This key is used to encrypt communication between the instance and the service.</p>
    public let rsaPublicKey: String?
    /// <p>The instances public RSA key fingerprint.</p>
    public let rsaPublicKeyFingerprint: String?
    /// <p>The ID of the stack that the instance is to be registered with.</p>
    public let stackId: String?

    public init (
        hostname: String? = nil,
        instanceIdentity: InstanceIdentity? = nil,
        privateIp: String? = nil,
        publicIp: String? = nil,
        rsaPublicKey: String? = nil,
        rsaPublicKeyFingerprint: String? = nil,
        stackId: String? = nil
    )
    {
        self.hostname = hostname
        self.instanceIdentity = instanceIdentity
        self.privateIp = privateIp
        self.publicIp = publicIp
        self.rsaPublicKey = rsaPublicKey
        self.rsaPublicKeyFingerprint = rsaPublicKeyFingerprint
        self.stackId = stackId
    }
}

struct RegisterInstanceInputBody: Equatable {
    public let stackId: String?
    public let hostname: String?
    public let publicIp: String?
    public let privateIp: String?
    public let rsaPublicKey: String?
    public let rsaPublicKeyFingerprint: String?
    public let instanceIdentity: InstanceIdentity?
}

extension RegisterInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hostname = "Hostname"
        case instanceIdentity = "InstanceIdentity"
        case privateIp = "PrivateIp"
        case publicIp = "PublicIp"
        case rsaPublicKey = "RsaPublicKey"
        case rsaPublicKeyFingerprint = "RsaPublicKeyFingerprint"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let privateIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIp)
        privateIp = privateIpDecoded
        let rsaPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rsaPublicKey)
        rsaPublicKey = rsaPublicKeyDecoded
        let rsaPublicKeyFingerprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rsaPublicKeyFingerprint)
        rsaPublicKeyFingerprint = rsaPublicKeyFingerprintDecoded
        let instanceIdentityDecoded = try containerValues.decodeIfPresent(InstanceIdentity.self, forKey: .instanceIdentity)
        instanceIdentity = instanceIdentityDecoded
    }
}

extension RegisterInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterInstanceOutputResponse(instanceId: \(String(describing: instanceId)))"}
}

extension RegisterInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceId = output.instanceId
        } else {
            self.instanceId = nil
        }
    }
}

/// <p>Contains the response to a <code>RegisterInstanceResult</code> request.</p>
public struct RegisterInstanceOutputResponse: Equatable {
    /// <p>The registered instance's AWS OpsWorks Stacks ID.</p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct RegisterInstanceOutputResponseBody: Equatable {
    public let instanceId: String?
}

extension RegisterInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

public struct RegisterRdsDbInstanceInputBodyMiddleware: Middleware {
    public let id: String = "RegisterRdsDbInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterRdsDbInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterRdsDbInstanceInput>
    public typealias MOutput = OperationOutput<RegisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterRdsDbInstanceOutputError>
}

extension RegisterRdsDbInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterRdsDbInstanceInput(dbPassword: \(String(describing: dbPassword)), dbUser: \(String(describing: dbUser)), rdsDbInstanceArn: \(String(describing: rdsDbInstanceArn)), stackId: \(String(describing: stackId)))"}
}

extension RegisterRdsDbInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbPassword = dbPassword {
            try encodeContainer.encode(dbPassword, forKey: .dbPassword)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let rdsDbInstanceArn = rdsDbInstanceArn {
            try encodeContainer.encode(rdsDbInstanceArn, forKey: .rdsDbInstanceArn)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct RegisterRdsDbInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterRdsDbInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterRdsDbInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterRdsDbInstanceInput>
    public typealias MOutput = OperationOutput<RegisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterRdsDbInstanceOutputError>
}

public struct RegisterRdsDbInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterRdsDbInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterRdsDbInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterRdsDbInstanceInput>
    public typealias MOutput = OperationOutput<RegisterRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterRdsDbInstanceOutputError>
}

public struct RegisterRdsDbInstanceInput: Equatable {
    /// <p>The database password.</p>
    public let dbPassword: String?
    /// <p>The database's master user name.</p>
    public let dbUser: String?
    /// <p>The Amazon RDS instance's ARN.</p>
    public let rdsDbInstanceArn: String?
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        dbPassword: String? = nil,
        dbUser: String? = nil,
        rdsDbInstanceArn: String? = nil,
        stackId: String? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.rdsDbInstanceArn = rdsDbInstanceArn
        self.stackId = stackId
    }
}

struct RegisterRdsDbInstanceInputBody: Equatable {
    public let stackId: String?
    public let rdsDbInstanceArn: String?
    public let dbUser: String?
    public let dbPassword: String?
}

extension RegisterRdsDbInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let rdsDbInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rdsDbInstanceArn)
        rdsDbInstanceArn = rdsDbInstanceArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
    }
}

extension RegisterRdsDbInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterRdsDbInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterRdsDbInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterRdsDbInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterRdsDbInstanceOutputResponse()"}
}

extension RegisterRdsDbInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RegisterRdsDbInstanceOutputResponse: Equatable {

    public init() {}
}

struct RegisterRdsDbInstanceOutputResponseBody: Equatable {
}

extension RegisterRdsDbInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RegisterVolumeInputBodyMiddleware: Middleware {
    public let id: String = "RegisterVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterVolumeInput>
    public typealias MOutput = OperationOutput<RegisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterVolumeOutputError>
}

extension RegisterVolumeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterVolumeInput(ec2VolumeId: \(String(describing: ec2VolumeId)), stackId: \(String(describing: stackId)))"}
}

extension RegisterVolumeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ec2VolumeId = "Ec2VolumeId"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2VolumeId = ec2VolumeId {
            try encodeContainer.encode(ec2VolumeId, forKey: .ec2VolumeId)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct RegisterVolumeInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterVolumeInput>
    public typealias MOutput = OperationOutput<RegisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterVolumeOutputError>
}

public struct RegisterVolumeInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterVolumeInput>
    public typealias MOutput = OperationOutput<RegisterVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterVolumeOutputError>
}

public struct RegisterVolumeInput: Equatable {
    /// <p>The Amazon EBS volume ID.</p>
    public let ec2VolumeId: String?
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        ec2VolumeId: String? = nil,
        stackId: String? = nil
    )
    {
        self.ec2VolumeId = ec2VolumeId
        self.stackId = stackId
    }
}

struct RegisterVolumeInputBody: Equatable {
    public let ec2VolumeId: String?
    public let stackId: String?
}

extension RegisterVolumeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ec2VolumeId = "Ec2VolumeId"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2VolumeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2VolumeId)
        ec2VolumeId = ec2VolumeIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension RegisterVolumeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterVolumeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterVolumeOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterVolumeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterVolumeOutputResponse(volumeId: \(String(describing: volumeId)))"}
}

extension RegisterVolumeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterVolumeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.volumeId = output.volumeId
        } else {
            self.volumeId = nil
        }
    }
}

/// <p>Contains the response to a <code>RegisterVolume</code> request.</p>
public struct RegisterVolumeOutputResponse: Equatable {
    /// <p>The volume ID.</p>
    public let volumeId: String?

    public init (
        volumeId: String? = nil
    )
    {
        self.volumeId = volumeId
    }
}

struct RegisterVolumeOutputResponseBody: Equatable {
    public let volumeId: String?
}

extension RegisterVolumeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeId = "VolumeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
    }
}

extension ReportedOs: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case family = "Family"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .family)
        family = familyDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension ReportedOs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportedOs(family: \(String(describing: family)), name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>A registered instance's reported operating system.</p>
public struct ReportedOs: Equatable {
    /// <p>The operating system family.</p>
    public let family: String?
    /// <p>The operating system name.</p>
    public let name: String?
    /// <p>The operating system version.</p>
    public let version: String?

    public init (
        family: String? = nil,
        name: String? = nil,
        version: String? = nil
    )
    {
        self.family = family
        self.name = name
        self.version = version
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum RootDeviceType {
    case ebs
    case instanceStore
    case sdkUnknown(String)
}

extension RootDeviceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RootDeviceType] {
        return [
            .ebs,
            .instanceStore,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ebs: return "ebs"
        case .instanceStore: return "instance-store"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RootDeviceType(rawValue: rawValue) ?? RootDeviceType.sdkUnknown(rawValue)
    }
}

extension SelfUserProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iamUserArn = "IamUserArn"
        case name = "Name"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let sshUsername = sshUsername {
            try encodeContainer.encode(sshUsername, forKey: .sshUsername)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sshUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshUsername)
        sshUsername = sshUsernameDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension SelfUserProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelfUserProfile(iamUserArn: \(String(describing: iamUserArn)), name: \(String(describing: name)), sshPublicKey: \(String(describing: sshPublicKey)), sshUsername: \(String(describing: sshUsername)))"}
}

/// <p>Describes a user's SSH information.</p>
public struct SelfUserProfile: Equatable {
    /// <p>The user's IAM ARN.</p>
    public let iamUserArn: String?
    /// <p>The user's name.</p>
    public let name: String?
    /// <p>The user's SSH public key.</p>
    public let sshPublicKey: String?
    /// <p>The user's SSH user name.</p>
    public let sshUsername: String?

    public init (
        iamUserArn: String? = nil,
        name: String? = nil,
        sshPublicKey: String? = nil,
        sshUsername: String? = nil
    )
    {
        self.iamUserArn = iamUserArn
        self.name = name
        self.sshPublicKey = sshPublicKey
        self.sshUsername = sshUsername
    }
}

extension ServiceError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case instanceId = "InstanceId"
        case message = "Message"
        case serviceErrorId = "ServiceErrorId"
        case stackId = "StackId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let serviceErrorId = serviceErrorId {
            try encodeContainer.encode(serviceErrorId, forKey: .serviceErrorId)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceErrorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceErrorId)
        serviceErrorId = serviceErrorIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension ServiceError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceError(createdAt: \(String(describing: createdAt)), instanceId: \(String(describing: instanceId)), message: \(String(describing: message)), serviceErrorId: \(String(describing: serviceErrorId)), stackId: \(String(describing: stackId)), type: \(String(describing: type)))"}
}

/// <p>Describes an AWS OpsWorks Stacks service error.</p>
public struct ServiceError: Equatable {
    /// <p>When the error occurred.</p>
    public let createdAt: String?
    /// <p>The instance ID.</p>
    public let instanceId: String?
    /// <p>A message that describes the error.</p>
    public let message: String?
    /// <p>The error ID.</p>
    public let serviceErrorId: String?
    /// <p>The stack ID.</p>
    public let stackId: String?
    /// <p>The error type.</p>
    public let type: String?

    public init (
        createdAt: String? = nil,
        instanceId: String? = nil,
        message: String? = nil,
        serviceErrorId: String? = nil,
        stackId: String? = nil,
        type: String? = nil
    )
    {
        self.createdAt = createdAt
        self.instanceId = instanceId
        self.message = message
        self.serviceErrorId = serviceErrorId
        self.stackId = stackId
        self.type = type
    }
}

public struct SetLoadBasedAutoScalingInputBodyMiddleware: Middleware {
    public let id: String = "SetLoadBasedAutoScalingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoadBasedAutoScalingInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoadBasedAutoScalingInput>
    public typealias MOutput = OperationOutput<SetLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoadBasedAutoScalingOutputError>
}

extension SetLoadBasedAutoScalingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetLoadBasedAutoScalingInput(downScaling: \(String(describing: downScaling)), enable: \(String(describing: enable)), layerId: \(String(describing: layerId)), upScaling: \(String(describing: upScaling)))"}
}

extension SetLoadBasedAutoScalingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case downScaling = "DownScaling"
        case enable = "Enable"
        case layerId = "LayerId"
        case upScaling = "UpScaling"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downScaling = downScaling {
            try encodeContainer.encode(downScaling, forKey: .downScaling)
        }
        if let enable = enable {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let upScaling = upScaling {
            try encodeContainer.encode(upScaling, forKey: .upScaling)
        }
    }
}

public struct SetLoadBasedAutoScalingInputHeadersMiddleware: Middleware {
    public let id: String = "SetLoadBasedAutoScalingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoadBasedAutoScalingInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoadBasedAutoScalingInput>
    public typealias MOutput = OperationOutput<SetLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoadBasedAutoScalingOutputError>
}

public struct SetLoadBasedAutoScalingInputQueryItemMiddleware: Middleware {
    public let id: String = "SetLoadBasedAutoScalingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetLoadBasedAutoScalingInput>,
                  next: H) -> Swift.Result<OperationOutput<SetLoadBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetLoadBasedAutoScalingInput>
    public typealias MOutput = OperationOutput<SetLoadBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetLoadBasedAutoScalingOutputError>
}

public struct SetLoadBasedAutoScalingInput: Equatable {
    /// <p>An <code>AutoScalingThresholds</code> object with the downscaling threshold configuration. If
    ///       the load falls below these thresholds for a specified amount of time, AWS OpsWorks Stacks stops a specified
    ///       number of instances.</p>
    public let downScaling: AutoScalingThresholds?
    /// <p>Enables load-based auto scaling for the layer.</p>
    public let enable: Bool?
    /// <p>The layer ID.</p>
    public let layerId: String?
    /// <p>An <code>AutoScalingThresholds</code> object with the upscaling threshold configuration. If
    ///       the load exceeds these thresholds for a specified amount of time, AWS OpsWorks Stacks starts a specified
    ///       number of instances.</p>
    public let upScaling: AutoScalingThresholds?

    public init (
        downScaling: AutoScalingThresholds? = nil,
        enable: Bool? = nil,
        layerId: String? = nil,
        upScaling: AutoScalingThresholds? = nil
    )
    {
        self.downScaling = downScaling
        self.enable = enable
        self.layerId = layerId
        self.upScaling = upScaling
    }
}

struct SetLoadBasedAutoScalingInputBody: Equatable {
    public let layerId: String?
    public let enable: Bool?
    public let upScaling: AutoScalingThresholds?
    public let downScaling: AutoScalingThresholds?
}

extension SetLoadBasedAutoScalingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case downScaling = "DownScaling"
        case enable = "Enable"
        case layerId = "LayerId"
        case upScaling = "UpScaling"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let enableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enable)
        enable = enableDecoded
        let upScalingDecoded = try containerValues.decodeIfPresent(AutoScalingThresholds.self, forKey: .upScaling)
        upScaling = upScalingDecoded
        let downScalingDecoded = try containerValues.decodeIfPresent(AutoScalingThresholds.self, forKey: .downScaling)
        downScaling = downScalingDecoded
    }
}

extension SetLoadBasedAutoScalingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetLoadBasedAutoScalingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetLoadBasedAutoScalingOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetLoadBasedAutoScalingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetLoadBasedAutoScalingOutputResponse()"}
}

extension SetLoadBasedAutoScalingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetLoadBasedAutoScalingOutputResponse: Equatable {

    public init() {}
}

struct SetLoadBasedAutoScalingOutputResponseBody: Equatable {
}

extension SetLoadBasedAutoScalingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetPermissionInputBodyMiddleware: Middleware {
    public let id: String = "SetPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetPermissionInput>
    public typealias MOutput = OperationOutput<SetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetPermissionOutputError>
}

extension SetPermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetPermissionInput(allowSsh: \(String(describing: allowSsh)), allowSudo: \(String(describing: allowSudo)), iamUserArn: \(String(describing: iamUserArn)), level: \(String(describing: level)), stackId: \(String(describing: stackId)))"}
}

extension SetPermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowSsh = "AllowSsh"
        case allowSudo = "AllowSudo"
        case iamUserArn = "IamUserArn"
        case level = "Level"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSsh = allowSsh {
            try encodeContainer.encode(allowSsh, forKey: .allowSsh)
        }
        if let allowSudo = allowSudo {
            try encodeContainer.encode(allowSudo, forKey: .allowSudo)
        }
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let level = level {
            try encodeContainer.encode(level, forKey: .level)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct SetPermissionInputHeadersMiddleware: Middleware {
    public let id: String = "SetPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetPermissionInput>
    public typealias MOutput = OperationOutput<SetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetPermissionOutputError>
}

public struct SetPermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "SetPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetPermissionInput>
    public typealias MOutput = OperationOutput<SetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetPermissionOutputError>
}

public struct SetPermissionInput: Equatable {
    /// <p>The user is allowed to use SSH to communicate with the instance.</p>
    public let allowSsh: Bool?
    /// <p>The user is allowed to use <b>sudo</b> to elevate privileges.</p>
    public let allowSudo: Bool?
    /// <p>The user's IAM ARN. This can also be a federated user's ARN.</p>
    public let iamUserArn: String?
    /// <p>The user's permission level, which must be set to one of the following strings. You cannot set your own permissions level.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>deny</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>show</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>deploy</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>manage</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>iam_only</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about the permissions associated with these levels, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/opsworks-security-users.html">Managing User Permissions</a>.</p>
    public let level: String?
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        allowSsh: Bool? = nil,
        allowSudo: Bool? = nil,
        iamUserArn: String? = nil,
        level: String? = nil,
        stackId: String? = nil
    )
    {
        self.allowSsh = allowSsh
        self.allowSudo = allowSudo
        self.iamUserArn = iamUserArn
        self.level = level
        self.stackId = stackId
    }
}

struct SetPermissionInputBody: Equatable {
    public let stackId: String?
    public let iamUserArn: String?
    public let allowSsh: Bool?
    public let allowSudo: Bool?
    public let level: String?
}

extension SetPermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowSsh = "AllowSsh"
        case allowSudo = "AllowSudo"
        case iamUserArn = "IamUserArn"
        case level = "Level"
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let iamUserArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let allowSshDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSsh)
        allowSsh = allowSshDecoded
        let allowSudoDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSudo)
        allowSudo = allowSudoDecoded
        let levelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .level)
        level = levelDecoded
    }
}

extension SetPermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetPermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetPermissionOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetPermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetPermissionOutputResponse()"}
}

extension SetPermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetPermissionOutputResponse: Equatable {

    public init() {}
}

struct SetPermissionOutputResponseBody: Equatable {
}

extension SetPermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetTimeBasedAutoScalingInputBodyMiddleware: Middleware {
    public let id: String = "SetTimeBasedAutoScalingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTimeBasedAutoScalingInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTimeBasedAutoScalingInput>
    public typealias MOutput = OperationOutput<SetTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTimeBasedAutoScalingOutputError>
}

extension SetTimeBasedAutoScalingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetTimeBasedAutoScalingInput(autoScalingSchedule: \(String(describing: autoScalingSchedule)), instanceId: \(String(describing: instanceId)))"}
}

extension SetTimeBasedAutoScalingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingSchedule = "AutoScalingSchedule"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingSchedule = autoScalingSchedule {
            try encodeContainer.encode(autoScalingSchedule, forKey: .autoScalingSchedule)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct SetTimeBasedAutoScalingInputHeadersMiddleware: Middleware {
    public let id: String = "SetTimeBasedAutoScalingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTimeBasedAutoScalingInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTimeBasedAutoScalingInput>
    public typealias MOutput = OperationOutput<SetTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTimeBasedAutoScalingOutputError>
}

public struct SetTimeBasedAutoScalingInputQueryItemMiddleware: Middleware {
    public let id: String = "SetTimeBasedAutoScalingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTimeBasedAutoScalingInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTimeBasedAutoScalingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTimeBasedAutoScalingInput>
    public typealias MOutput = OperationOutput<SetTimeBasedAutoScalingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTimeBasedAutoScalingOutputError>
}

public struct SetTimeBasedAutoScalingInput: Equatable {
    /// <p>An <code>AutoScalingSchedule</code> with the instance schedule.</p>
    public let autoScalingSchedule: WeeklyAutoScalingSchedule?
    /// <p>The instance ID.</p>
    public let instanceId: String?

    public init (
        autoScalingSchedule: WeeklyAutoScalingSchedule? = nil,
        instanceId: String? = nil
    )
    {
        self.autoScalingSchedule = autoScalingSchedule
        self.instanceId = instanceId
    }
}

struct SetTimeBasedAutoScalingInputBody: Equatable {
    public let instanceId: String?
    public let autoScalingSchedule: WeeklyAutoScalingSchedule?
}

extension SetTimeBasedAutoScalingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoScalingSchedule = "AutoScalingSchedule"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let autoScalingScheduleDecoded = try containerValues.decodeIfPresent(WeeklyAutoScalingSchedule.self, forKey: .autoScalingSchedule)
        autoScalingSchedule = autoScalingScheduleDecoded
    }
}

extension SetTimeBasedAutoScalingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetTimeBasedAutoScalingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetTimeBasedAutoScalingOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetTimeBasedAutoScalingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetTimeBasedAutoScalingOutputResponse()"}
}

extension SetTimeBasedAutoScalingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetTimeBasedAutoScalingOutputResponse: Equatable {

    public init() {}
}

struct SetTimeBasedAutoScalingOutputResponseBody: Equatable {
}

extension SetTimeBasedAutoScalingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ShutdownEventConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case delayUntilElbConnectionsDrained = "DelayUntilElbConnectionsDrained"
        case executionTimeout = "ExecutionTimeout"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delayUntilElbConnectionsDrained = delayUntilElbConnectionsDrained {
            try encodeContainer.encode(delayUntilElbConnectionsDrained, forKey: .delayUntilElbConnectionsDrained)
        }
        if let executionTimeout = executionTimeout {
            try encodeContainer.encode(executionTimeout, forKey: .executionTimeout)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .executionTimeout)
        executionTimeout = executionTimeoutDecoded
        let delayUntilElbConnectionsDrainedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .delayUntilElbConnectionsDrained)
        delayUntilElbConnectionsDrained = delayUntilElbConnectionsDrainedDecoded
    }
}

extension ShutdownEventConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShutdownEventConfiguration(delayUntilElbConnectionsDrained: \(String(describing: delayUntilElbConnectionsDrained)), executionTimeout: \(String(describing: executionTimeout)))"}
}

/// <p>The Shutdown event configuration.</p>
public struct ShutdownEventConfiguration: Equatable {
    /// <p>Whether to enable Elastic Load Balancing connection draining. For more information, see <a href="https://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/TerminologyandKeyConcepts.html#conn-drain">Connection Draining</a>
    ///          </p>
    public let delayUntilElbConnectionsDrained: Bool?
    /// <p>The time, in seconds, that AWS OpsWorks Stacks will wait after triggering a Shutdown event before shutting down an instance.</p>
    public let executionTimeout: Int?

    public init (
        delayUntilElbConnectionsDrained: Bool? = nil,
        executionTimeout: Int? = nil
    )
    {
        self.delayUntilElbConnectionsDrained = delayUntilElbConnectionsDrained
        self.executionTimeout = executionTimeout
    }
}

extension Source: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case password = "Password"
        case revision = "Revision"
        case sshKey = "SshKey"
        case type = "Type"
        case url = "Url"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let sshKey = sshKey {
            try encodeContainer.encode(sshKey, forKey: .sshKey)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .type)
        type = typeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let sshKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshKey)
        sshKey = sshKeyDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension Source: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Source(password: \(String(describing: password)), revision: \(String(describing: revision)), sshKey: \(String(describing: sshKey)), type: \(String(describing: type)), url: \(String(describing: url)), username: \(String(describing: username)))"}
}

/// <p>Contains the information required to retrieve an app or cookbook from a repository. For more
///       information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html">Creating Apps</a> or <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html">Custom Recipes and
///         Cookbooks</a>.</p>
public struct Source: Equatable {
    /// <p>When included in a request, the parameter depends on the repository type.</p>
    ///          <ul>
    ///             <li>
    ///                <p>For Amazon S3 bundles, set <code>Password</code> to the appropriate IAM secret access
    ///         key.</p>
    ///             </li>
    ///             <li>
    ///                <p>For HTTP bundles and Subversion repositories, set <code>Password</code> to the
    ///         password.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information on how to safely handle IAM credentials, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html">https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html</a>.</p>
    ///          <p>In responses, AWS OpsWorks Stacks returns <code>*****FILTERED*****</code> instead of the actual value.</p>
    public let password: String?
    /// <p>The application's version. AWS OpsWorks Stacks enables you to easily deploy new versions of an application. One of the simplest approaches is to have branches or revisions in your repository that represent different versions that can potentially be deployed.</p>
    public let revision: String?
    /// <p>In requests, the repository's SSH key.</p>
    ///          <p>In responses, AWS OpsWorks Stacks returns <code>*****FILTERED*****</code> instead of the actual value.</p>
    public let sshKey: String?
    /// <p>The repository type.</p>
    public let type: SourceType?
    /// <p>The source URL. The following is an example of an Amazon S3 source URL:  <code>https://s3.amazonaws.com/opsworks-demo-bucket/opsworks_cookbook_demo.tar.gz</code>.</p>
    public let url: String?
    /// <p>This parameter depends on the repository type.</p>
    ///          <ul>
    ///             <li>
    ///                <p>For Amazon S3 bundles, set <code>Username</code> to the appropriate IAM access key
    ///         ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>For HTTP bundles, Git repositories, and Subversion repositories, set <code>Username</code>
    ///         to the user name.</p>
    ///             </li>
    ///          </ul>
    public let username: String?

    public init (
        password: String? = nil,
        revision: String? = nil,
        sshKey: String? = nil,
        type: SourceType? = nil,
        url: String? = nil,
        username: String? = nil
    )
    {
        self.password = password
        self.revision = revision
        self.sshKey = sshKey
        self.type = type
        self.url = url
        self.username = username
    }
}

public enum SourceType {
    case archive
    case git
    case s3
    case svn
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .archive,
            .git,
            .s3,
            .svn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .archive: return "archive"
        case .git: return "git"
        case .s3: return "s3"
        case .svn: return "svn"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

extension SslConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case chain = "Chain"
        case privateKey = "PrivateKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let chain = chain {
            try encodeContainer.encode(chain, forKey: .chain)
        }
        if let privateKey = privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let chainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .chain)
        chain = chainDecoded
    }
}

extension SslConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SslConfiguration(certificate: \(String(describing: certificate)), chain: \(String(describing: chain)), privateKey: \(String(describing: privateKey)))"}
}

/// <p>Describes an app's SSL configuration.</p>
public struct SslConfiguration: Equatable {
    /// <p>The contents of the certificate's domain.crt file.</p>
    public let certificate: String?
    /// <p>Optional. Can be used to specify an intermediate certificate authority key or client authentication.</p>
    public let chain: String?
    /// <p>The private key; the contents of the certificate's domain.kex file.</p>
    public let privateKey: String?

    public init (
        certificate: String? = nil,
        chain: String? = nil,
        privateKey: String? = nil
    )
    {
        self.certificate = certificate
        self.chain = chain
        self.privateKey = privateKey
    }
}

extension Stack: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentVersion = "AgentVersion"
        case arn = "Arn"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case createdAt = "CreatedAt"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case stackId = "StackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, stackattributes0) in attributes {
                try attributesContainer.encode(stackattributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let chefConfiguration = chefConfiguration {
            try encodeContainer.encode(chefConfiguration, forKey: .chefConfiguration)
        }
        if let configurationManager = configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let customCookbooksSource = customCookbooksSource {
            try encodeContainer.encode(customCookbooksSource, forKey: .customCookbooksSource)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let defaultAvailabilityZone = defaultAvailabilityZone {
            try encodeContainer.encode(defaultAvailabilityZone, forKey: .defaultAvailabilityZone)
        }
        if let defaultInstanceProfileArn = defaultInstanceProfileArn {
            try encodeContainer.encode(defaultInstanceProfileArn, forKey: .defaultInstanceProfileArn)
        }
        if let defaultOs = defaultOs {
            try encodeContainer.encode(defaultOs, forKey: .defaultOs)
        }
        if let defaultRootDeviceType = defaultRootDeviceType {
            try encodeContainer.encode(defaultRootDeviceType.rawValue, forKey: .defaultRootDeviceType)
        }
        if let defaultSshKeyName = defaultSshKeyName {
            try encodeContainer.encode(defaultSshKeyName, forKey: .defaultSshKeyName)
        }
        if let defaultSubnetId = defaultSubnetId {
            try encodeContainer.encode(defaultSubnetId, forKey: .defaultSubnetId)
        }
        if let hostnameTheme = hostnameTheme {
            try encodeContainer.encode(hostnameTheme, forKey: .hostnameTheme)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let useCustomCookbooks = useCustomCookbooks {
            try encodeContainer.encode(useCustomCookbooks, forKey: .useCustomCookbooks)
        }
        if let useOpsworksSecurityGroups = useOpsworksSecurityGroups {
            try encodeContainer.encode(useOpsworksSecurityGroups, forKey: .useOpsworksSecurityGroups)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let defaultInstanceProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultInstanceProfileArn)
        defaultInstanceProfileArn = defaultInstanceProfileArnDecoded
        let defaultOsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultOs)
        defaultOs = defaultOsDecoded
        let hostnameThemeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostnameTheme)
        hostnameTheme = hostnameThemeDecoded
        let defaultAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAvailabilityZone)
        defaultAvailabilityZone = defaultAvailabilityZoneDecoded
        let defaultSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubnetId)
        defaultSubnetId = defaultSubnetIdDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
        let chefConfigurationDecoded = try containerValues.decodeIfPresent(ChefConfiguration.self, forKey: .chefConfiguration)
        chefConfiguration = chefConfigurationDecoded
        let useCustomCookbooksDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useCustomCookbooks)
        useCustomCookbooks = useCustomCookbooksDecoded
        let useOpsworksSecurityGroupsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useOpsworksSecurityGroups)
        useOpsworksSecurityGroups = useOpsworksSecurityGroupsDecoded
        let customCookbooksSourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .customCookbooksSource)
        customCookbooksSource = customCookbooksSourceDecoded
        let defaultSshKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSshKeyName)
        defaultSshKeyName = defaultSshKeyNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let defaultRootDeviceTypeDecoded = try containerValues.decodeIfPresent(RootDeviceType.self, forKey: .defaultRootDeviceType)
        defaultRootDeviceType = defaultRootDeviceTypeDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension Stack: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Stack(agentVersion: \(String(describing: agentVersion)), arn: \(String(describing: arn)), attributes: \(String(describing: attributes)), chefConfiguration: \(String(describing: chefConfiguration)), configurationManager: \(String(describing: configurationManager)), createdAt: \(String(describing: createdAt)), customCookbooksSource: \(String(describing: customCookbooksSource)), customJson: \(String(describing: customJson)), defaultAvailabilityZone: \(String(describing: defaultAvailabilityZone)), defaultInstanceProfileArn: \(String(describing: defaultInstanceProfileArn)), defaultOs: \(String(describing: defaultOs)), defaultRootDeviceType: \(String(describing: defaultRootDeviceType)), defaultSshKeyName: \(String(describing: defaultSshKeyName)), defaultSubnetId: \(String(describing: defaultSubnetId)), hostnameTheme: \(String(describing: hostnameTheme)), name: \(String(describing: name)), region: \(String(describing: region)), serviceRoleArn: \(String(describing: serviceRoleArn)), stackId: \(String(describing: stackId)), useCustomCookbooks: \(String(describing: useCustomCookbooks)), useOpsworksSecurityGroups: \(String(describing: useOpsworksSecurityGroups)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Describes a stack.</p>
public struct Stack: Equatable {
    /// <p>The agent version. This parameter is set to <code>LATEST</code> for auto-update.
    ///       or a version number for a fixed agent version.</p>
    public let agentVersion: String?
    /// <p>The stack's ARN.</p>
    public let arn: String?
    /// <p>The stack's attributes.</p>
    public let attributes: [String:String]?
    /// <p>A <code>ChefConfiguration</code> object that specifies whether to enable Berkshelf and the
    ///       Berkshelf version. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New Stack</a>.</p>
    public let chefConfiguration: ChefConfiguration?
    /// <p>The configuration manager.</p>
    public let configurationManager: StackConfigurationManager?
    /// <p>The date when the stack was created.</p>
    public let createdAt: String?
    /// <p>Contains the information required to retrieve an app or cookbook from a repository. For more information,
    ///             see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html">Adding Apps</a> or
    ///             <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html">Cookbooks and Recipes</a>.</p>
    public let customCookbooksSource: Source?
    /// <p>A JSON object that contains user-defined attributes to be added to the stack configuration and deployment attributes. You can use custom JSON to override the corresponding default stack configuration attribute values or to pass data to recipes. The string should be in the following format:</p>
    ///          <p>
    ///             <code>"{\"key1\": \"value1\", \"key2\": \"value2\",...}"</code>
    ///          </p>
    ///          <p>For more information on custom JSON, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html">Use Custom JSON to
    ///         Modify the Stack Configuration Attributes</a>.</p>
    public let customJson: String?
    /// <p>The stack's default Availability Zone. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints</a>.</p>
    public let defaultAvailabilityZone: String?
    /// <p>The ARN of an IAM profile that is the default profile for all of the stack's EC2 instances.
    ///       For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers</a>.</p>
    public let defaultInstanceProfileArn: String?
    /// <p>The stack's default operating system.</p>
    public let defaultOs: String?
    /// <p>The default root device type. This value is used by default for all instances in the stack,
    ///       but you can override it when you create an instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device">Storage for the Root Device</a>.</p>
    public let defaultRootDeviceType: RootDeviceType?
    /// <p>A default Amazon EC2 key pair for the stack's instances. You can override this value when you create or update an instance.</p>
    public let defaultSshKeyName: String?
    /// <p>The default subnet ID; applicable only if the stack is running in a VPC.</p>
    public let defaultSubnetId: String?
    /// <p>The stack host name theme, with spaces replaced by underscores.</p>
    public let hostnameTheme: String?
    /// <p>The stack name.</p>
    public let name: String?
    /// <p>The stack AWS region, such as "ap-northeast-2". For more information about AWS regions, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints</a>.</p>
    public let region: String?
    /// <p>The stack AWS Identity and Access Management (IAM) role.</p>
    public let serviceRoleArn: String?
    /// <p>The stack ID.</p>
    public let stackId: String?
    /// <p>Whether the stack uses custom cookbooks.</p>
    public let useCustomCookbooks: Bool?
    /// <p>Whether the stack automatically associates the AWS OpsWorks Stacks built-in security groups with the stack's layers.</p>
    public let useOpsworksSecurityGroups: Bool?
    /// <p>The VPC ID; applicable only if the stack is running in a VPC.</p>
    public let vpcId: String?

    public init (
        agentVersion: String? = nil,
        arn: String? = nil,
        attributes: [String:String]? = nil,
        chefConfiguration: ChefConfiguration? = nil,
        configurationManager: StackConfigurationManager? = nil,
        createdAt: String? = nil,
        customCookbooksSource: Source? = nil,
        customJson: String? = nil,
        defaultAvailabilityZone: String? = nil,
        defaultInstanceProfileArn: String? = nil,
        defaultOs: String? = nil,
        defaultRootDeviceType: RootDeviceType? = nil,
        defaultSshKeyName: String? = nil,
        defaultSubnetId: String? = nil,
        hostnameTheme: String? = nil,
        name: String? = nil,
        region: String? = nil,
        serviceRoleArn: String? = nil,
        stackId: String? = nil,
        useCustomCookbooks: Bool? = nil,
        useOpsworksSecurityGroups: Bool? = nil,
        vpcId: String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.arn = arn
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.configurationManager = configurationManager
        self.createdAt = createdAt
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.region = region
        self.serviceRoleArn = serviceRoleArn
        self.stackId = stackId
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
        self.vpcId = vpcId
    }
}

public enum StackAttributesKeys {
    case color
    case sdkUnknown(String)
}

extension StackAttributesKeys : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StackAttributesKeys] {
        return [
            .color,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .color: return "Color"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StackAttributesKeys(rawValue: rawValue) ?? StackAttributesKeys.sdkUnknown(rawValue)
    }
}

extension StackConfigurationManager: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension StackConfigurationManager: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackConfigurationManager(name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>Describes the configuration manager.</p>
public struct StackConfigurationManager: Equatable {
    /// <p>The name. This parameter must be set to "Chef".</p>
    public let name: String?
    /// <p>The Chef version. This parameter must be set to 12, 11.10, or 11.4 for Linux stacks, and to 12.2 for Windows stacks. The default value for Linux stacks is 11.4.</p>
    public let version: String?

    public init (
        name: String? = nil,
        version: String? = nil
    )
    {
        self.name = name
        self.version = version
    }
}

extension StackSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appsCount = "AppsCount"
        case arn = "Arn"
        case instancesCount = "InstancesCount"
        case layersCount = "LayersCount"
        case name = "Name"
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsCount = appsCount {
            try encodeContainer.encode(appsCount, forKey: .appsCount)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let instancesCount = instancesCount {
            try encodeContainer.encode(instancesCount, forKey: .instancesCount)
        }
        if let layersCount = layersCount {
            try encodeContainer.encode(layersCount, forKey: .layersCount)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let layersCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .layersCount)
        layersCount = layersCountDecoded
        let appsCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .appsCount)
        appsCount = appsCountDecoded
        let instancesCountDecoded = try containerValues.decodeIfPresent(InstancesCount.self, forKey: .instancesCount)
        instancesCount = instancesCountDecoded
    }
}

extension StackSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StackSummary(appsCount: \(String(describing: appsCount)), arn: \(String(describing: arn)), instancesCount: \(String(describing: instancesCount)), layersCount: \(String(describing: layersCount)), name: \(String(describing: name)), stackId: \(String(describing: stackId)))"}
}

/// <p>Summarizes the number of layers, instances, and apps in a stack.</p>
public struct StackSummary: Equatable {
    /// <p>The number of apps.</p>
    public let appsCount: Int?
    /// <p>The stack's ARN.</p>
    public let arn: String?
    /// <p>An <code>InstancesCount</code> object with the number of instances in each status.</p>
    public let instancesCount: InstancesCount?
    /// <p>The number of layers.</p>
    public let layersCount: Int?
    /// <p>The stack name.</p>
    public let name: String?
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        appsCount: Int? = nil,
        arn: String? = nil,
        instancesCount: InstancesCount? = nil,
        layersCount: Int? = nil,
        name: String? = nil,
        stackId: String? = nil
    )
    {
        self.appsCount = appsCount
        self.arn = arn
        self.instancesCount = instancesCount
        self.layersCount = layersCount
        self.name = name
        self.stackId = stackId
    }
}

public struct StartInstanceInputBodyMiddleware: Middleware {
    public let id: String = "StartInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StartInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartInstanceInput>
    public typealias MOutput = OperationOutput<StartInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartInstanceOutputError>
}

extension StartInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartInstanceInput(instanceId: \(String(describing: instanceId)))"}
}

extension StartInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct StartInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "StartInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StartInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartInstanceInput>
    public typealias MOutput = OperationOutput<StartInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartInstanceOutputError>
}

public struct StartInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "StartInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StartInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartInstanceInput>
    public typealias MOutput = OperationOutput<StartInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartInstanceOutputError>
}

public struct StartInstanceInput: Equatable {
    /// <p>The instance ID.</p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct StartInstanceInputBody: Equatable {
    public let instanceId: String?
}

extension StartInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension StartInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartInstanceOutputResponse()"}
}

extension StartInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartInstanceOutputResponse: Equatable {

    public init() {}
}

struct StartInstanceOutputResponseBody: Equatable {
}

extension StartInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartStackInputBodyMiddleware: Middleware {
    public let id: String = "StartStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartStackInput>,
                  next: H) -> Swift.Result<OperationOutput<StartStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartStackInput>
    public typealias MOutput = OperationOutput<StartStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartStackOutputError>
}

extension StartStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartStackInput(stackId: \(String(describing: stackId)))"}
}

extension StartStackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct StartStackInputHeadersMiddleware: Middleware {
    public let id: String = "StartStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartStackInput>,
                  next: H) -> Swift.Result<OperationOutput<StartStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartStackInput>
    public typealias MOutput = OperationOutput<StartStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartStackOutputError>
}

public struct StartStackInputQueryItemMiddleware: Middleware {
    public let id: String = "StartStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartStackInput>,
                  next: H) -> Swift.Result<OperationOutput<StartStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartStackInput>
    public typealias MOutput = OperationOutput<StartStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartStackOutputError>
}

public struct StartStackInput: Equatable {
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        stackId: String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct StartStackInputBody: Equatable {
    public let stackId: String?
}

extension StartStackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension StartStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartStackOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartStackOutputResponse()"}
}

extension StartStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartStackOutputResponse: Equatable {

    public init() {}
}

struct StartStackOutputResponseBody: Equatable {
}

extension StartStackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StopInstanceInputBodyMiddleware: Middleware {
    public let id: String = "StopInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StopInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopInstanceInput>
    public typealias MOutput = OperationOutput<StopInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopInstanceOutputError>
}

extension StopInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopInstanceInput(force: \(String(describing: force)), instanceId: \(String(describing: instanceId)))"}
}

extension StopInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case force = "Force"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let force = force {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct StopInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "StopInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StopInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopInstanceInput>
    public typealias MOutput = OperationOutput<StopInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopInstanceOutputError>
}

public struct StopInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "StopInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StopInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopInstanceInput>
    public typealias MOutput = OperationOutput<StopInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopInstanceOutputError>
}

public struct StopInstanceInput: Equatable {
    /// <p>Specifies whether to force an instance to stop. If the instance's root device type is <code>ebs</code>, or EBS-backed,
    ///             adding the <code>Force</code> parameter to the <code>StopInstances</code> API call disassociates the AWS OpsWorks Stacks instance from EC2, and forces deletion of <i>only</i> the OpsWorks Stacks instance.
    ///             You must also delete the formerly-associated instance in EC2 after troubleshooting and replacing the AWS OpsWorks Stacks instance with a new one.</p>
    public let force: Bool?
    /// <p>The instance ID.</p>
    public let instanceId: String?

    public init (
        force: Bool? = nil,
        instanceId: String? = nil
    )
    {
        self.force = force
        self.instanceId = instanceId
    }
}

struct StopInstanceInputBody: Equatable {
    public let instanceId: String?
    public let force: Bool?
}

extension StopInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case force = "Force"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let forceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension StopInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopInstanceOutputResponse()"}
}

extension StopInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopInstanceOutputResponse: Equatable {

    public init() {}
}

struct StopInstanceOutputResponseBody: Equatable {
}

extension StopInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StopStackInputBodyMiddleware: Middleware {
    public let id: String = "StopStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopStackInput>,
                  next: H) -> Swift.Result<OperationOutput<StopStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopStackInput>
    public typealias MOutput = OperationOutput<StopStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopStackOutputError>
}

extension StopStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopStackInput(stackId: \(String(describing: stackId)))"}
}

extension StopStackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

public struct StopStackInputHeadersMiddleware: Middleware {
    public let id: String = "StopStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopStackInput>,
                  next: H) -> Swift.Result<OperationOutput<StopStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopStackInput>
    public typealias MOutput = OperationOutput<StopStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopStackOutputError>
}

public struct StopStackInputQueryItemMiddleware: Middleware {
    public let id: String = "StopStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopStackInput>,
                  next: H) -> Swift.Result<OperationOutput<StopStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopStackInput>
    public typealias MOutput = OperationOutput<StopStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopStackOutputError>
}

public struct StopStackInput: Equatable {
    /// <p>The stack ID.</p>
    public let stackId: String?

    public init (
        stackId: String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct StopStackInputBody: Equatable {
    public let stackId: String?
}

extension StopStackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stackId = "StackId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension StopStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopStackOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopStackOutputResponse()"}
}

extension StopStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopStackOutputResponse: Equatable {

    public init() {}
}

struct StopStackOutputResponseBody: Equatable {
}

extension StopStackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The stack or layer's Amazon Resource Number (ARN).</p>
    public let resourceArn: String?
    /// <p>A map that contains tag keys and tag values that are attached to a stack or layer.</p>
    ///          <ul>
    ///             <li>
    ///                <p>The key cannot be empty.</p>
    ///             </li>
    ///             <li>
    ///                <p>The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Leading and trailing white spaces are trimmed from both the key and value.</p>
    ///             </li>
    ///             <li>
    ///                <p>A maximum of 40 tags is allowed for any resource.</p>
    ///             </li>
    ///          </ul>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TemporaryCredential: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case password = "Password"
        case username = "Username"
        case validForInMinutes = "ValidForInMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
        if let validForInMinutes = validForInMinutes {
            try encodeContainer.encode(validForInMinutes, forKey: .validForInMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let validForInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .validForInMinutes)
        validForInMinutes = validForInMinutesDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension TemporaryCredential: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemporaryCredential(instanceId: \(String(describing: instanceId)), password: \(String(describing: password)), username: \(String(describing: username)), validForInMinutes: \(String(describing: validForInMinutes)))"}
}

/// <p>Contains the data needed by RDP clients such as the Microsoft Remote Desktop Connection to log in to the instance.</p>
public struct TemporaryCredential: Equatable {
    /// <p>The instance's AWS OpsWorks Stacks ID.</p>
    public let instanceId: String?
    /// <p>The password.</p>
    public let password: String?
    /// <p>The user name.</p>
    public let username: String?
    /// <p>The length of time (in minutes) that the grant is valid. When the grant expires, at the end of this period, the user will no longer be able to use the credentials to log in. If they are logged in at the time, they will be automatically logged out.</p>
    public let validForInMinutes: Int?

    public init (
        instanceId: String? = nil,
        password: String? = nil,
        username: String? = nil,
        validForInMinutes: Int? = nil
    )
    {
        self.instanceId = instanceId
        self.password = password
        self.username = username
        self.validForInMinutes = validForInMinutes
    }
}

extension TimeBasedAutoScalingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoScalingSchedule = "AutoScalingSchedule"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingSchedule = autoScalingSchedule {
            try encodeContainer.encode(autoScalingSchedule, forKey: .autoScalingSchedule)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let autoScalingScheduleDecoded = try containerValues.decodeIfPresent(WeeklyAutoScalingSchedule.self, forKey: .autoScalingSchedule)
        autoScalingSchedule = autoScalingScheduleDecoded
    }
}

extension TimeBasedAutoScalingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeBasedAutoScalingConfiguration(autoScalingSchedule: \(String(describing: autoScalingSchedule)), instanceId: \(String(describing: instanceId)))"}
}

/// <p>Describes an instance's time-based auto scaling configuration.</p>
public struct TimeBasedAutoScalingConfiguration: Equatable {
    /// <p>A <code>WeeklyAutoScalingSchedule</code> object with the instance schedule.</p>
    public let autoScalingSchedule: WeeklyAutoScalingSchedule?
    /// <p>The instance ID.</p>
    public let instanceId: String?

    public init (
        autoScalingSchedule: WeeklyAutoScalingSchedule? = nil,
        instanceId: String? = nil
    )
    {
        self.autoScalingSchedule = autoScalingSchedule
        self.instanceId = instanceId
    }
}

public struct UnassignInstanceInputBodyMiddleware: Middleware {
    public let id: String = "UnassignInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnassignInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UnassignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnassignInstanceInput>
    public typealias MOutput = OperationOutput<UnassignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnassignInstanceOutputError>
}

extension UnassignInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnassignInstanceInput(instanceId: \(String(describing: instanceId)))"}
}

extension UnassignInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct UnassignInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "UnassignInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnassignInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UnassignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnassignInstanceInput>
    public typealias MOutput = OperationOutput<UnassignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnassignInstanceOutputError>
}

public struct UnassignInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "UnassignInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnassignInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UnassignInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnassignInstanceInput>
    public typealias MOutput = OperationOutput<UnassignInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnassignInstanceOutputError>
}

public struct UnassignInstanceInput: Equatable {
    /// <p>The instance ID.</p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct UnassignInstanceInputBody: Equatable {
    public let instanceId: String?
}

extension UnassignInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension UnassignInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnassignInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnassignInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnassignInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnassignInstanceOutputResponse()"}
}

extension UnassignInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UnassignInstanceOutputResponse: Equatable {

    public init() {}
}

struct UnassignInstanceOutputResponseBody: Equatable {
}

extension UnassignInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UnassignVolumeInputBodyMiddleware: Middleware {
    public let id: String = "UnassignVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnassignVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<UnassignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnassignVolumeInput>
    public typealias MOutput = OperationOutput<UnassignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnassignVolumeOutputError>
}

extension UnassignVolumeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnassignVolumeInput(volumeId: \(String(describing: volumeId)))"}
}

extension UnassignVolumeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case volumeId = "VolumeId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }
}

public struct UnassignVolumeInputHeadersMiddleware: Middleware {
    public let id: String = "UnassignVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnassignVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<UnassignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnassignVolumeInput>
    public typealias MOutput = OperationOutput<UnassignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnassignVolumeOutputError>
}

public struct UnassignVolumeInputQueryItemMiddleware: Middleware {
    public let id: String = "UnassignVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnassignVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<UnassignVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnassignVolumeInput>
    public typealias MOutput = OperationOutput<UnassignVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnassignVolumeOutputError>
}

public struct UnassignVolumeInput: Equatable {
    /// <p>The volume ID.</p>
    public let volumeId: String?

    public init (
        volumeId: String? = nil
    )
    {
        self.volumeId = volumeId
    }
}

struct UnassignVolumeInputBody: Equatable {
    public let volumeId: String?
}

extension UnassignVolumeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case volumeId = "VolumeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
    }
}

extension UnassignVolumeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnassignVolumeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnassignVolumeOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnassignVolumeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnassignVolumeOutputResponse()"}
}

extension UnassignVolumeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UnassignVolumeOutputResponse: Equatable {

    public init() {}
}

struct UnassignVolumeOutputResponseBody: Equatable {
}

extension UnassignVolumeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The stack or layer's Amazon Resource Number (ARN).</p>
    public let resourceArn: String?
    /// <p>A list of the keys of tags to be removed from a stack or layer.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAppInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAppInput>
    public typealias MOutput = OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAppOutputError>
}

extension UpdateAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAppInput(appId: \(String(describing: appId)), appSource: \(String(describing: appSource)), attributes: \(String(describing: attributes)), dataSources: \(String(describing: dataSources)), description: \(String(describing: description)), domains: \(String(describing: domains)), enableSsl: \(String(describing: enableSsl)), environment: \(String(describing: environment)), name: \(String(describing: name)), sslConfiguration: \(String(describing: sslConfiguration)), type: \(String(describing: type)))"}
}

extension UpdateAppInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId = "AppId"
        case appSource = "AppSource"
        case attributes = "Attributes"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case sslConfiguration = "SslConfiguration"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appSource = appSource {
            try encodeContainer.encode(appSource, forKey: .appSource)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, appattributes0) in attributes {
                try attributesContainer.encode(appattributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasources0 in dataSources {
                try dataSourcesContainer.encode(datasources0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for strings0 in domains {
                try domainsContainer.encode(strings0)
            }
        }
        if let enableSsl = enableSsl {
            try encodeContainer.encode(enableSsl, forKey: .enableSsl)
        }
        if let environment = environment {
            var environmentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environment)
            for environmentvariables0 in environment {
                try environmentContainer.encode(environmentvariables0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sslConfiguration = sslConfiguration {
            try encodeContainer.encode(sslConfiguration, forKey: .sslConfiguration)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateAppInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAppInput>
    public typealias MOutput = OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAppOutputError>
}

public struct UpdateAppInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAppInput>
    public typealias MOutput = OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAppOutputError>
}

public struct UpdateAppInput: Equatable {
    /// <p>The app ID.</p>
    public let appId: String?
    /// <p>A <code>Source</code> object that specifies the app repository.</p>
    public let appSource: Source?
    /// <p>One or more user-defined key/value pairs to be added to the stack attributes.</p>
    public let attributes: [String:String]?
    /// <p>The app's data sources.</p>
    public let dataSources: [DataSource]?
    /// <p>A description of the app.</p>
    public let description: String?
    /// <p>The app's virtual host settings, with multiple domains separated by commas. For example:
    ///         <code>'www.example.com, example.com'</code>
    ///          </p>
    public let domains: [String]?
    /// <p>Whether SSL is enabled for the app.</p>
    public let enableSsl: Bool?
    /// <p>An array of <code>EnvironmentVariable</code> objects that specify environment variables to be
    ///       associated with the app. After you deploy the app, these variables are defined on the
    ///       associated app server instances.For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-environment"> Environment Variables</a>.</p>
    ///          <p>There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variables' names, values, and protected flag values - cannot exceed 20 KB. This limit should accommodate most if not all use cases. Exceeding it will cause an exception with the message, "Environment: is too large (maximum is 20 KB)."</p>
    ///          <note>
    ///             <p>If you have specified one or more environment variables, you cannot modify the stack's Chef version.</p>
    ///          </note>
    public let environment: [EnvironmentVariable]?
    /// <p>The app name.</p>
    public let name: String?
    /// <p>An <code>SslConfiguration</code> object with the SSL configuration.</p>
    public let sslConfiguration: SslConfiguration?
    /// <p>The app type.</p>
    public let type: AppType?

    public init (
        appId: String? = nil,
        appSource: Source? = nil,
        attributes: [String:String]? = nil,
        dataSources: [DataSource]? = nil,
        description: String? = nil,
        domains: [String]? = nil,
        enableSsl: Bool? = nil,
        environment: [EnvironmentVariable]? = nil,
        name: String? = nil,
        sslConfiguration: SslConfiguration? = nil,
        type: AppType? = nil
    )
    {
        self.appId = appId
        self.appSource = appSource
        self.attributes = attributes
        self.dataSources = dataSources
        self.description = description
        self.domains = domains
        self.enableSsl = enableSsl
        self.environment = environment
        self.name = name
        self.sslConfiguration = sslConfiguration
        self.type = type
    }
}

struct UpdateAppInputBody: Equatable {
    public let appId: String?
    public let name: String?
    public let description: String?
    public let dataSources: [DataSource]?
    public let type: AppType?
    public let appSource: Source?
    public let domains: [String]?
    public let enableSsl: Bool?
    public let sslConfiguration: SslConfiguration?
    public let attributes: [String:String]?
    public let environment: [EnvironmentVariable]?
}

extension UpdateAppInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId = "AppId"
        case appSource = "AppSource"
        case attributes = "Attributes"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case sslConfiguration = "SslConfiguration"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourcesContainer = try containerValues.decodeIfPresent([DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(AppType.self, forKey: .type)
        type = typeDecoded
        let appSourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .appSource)
        appSource = appSourceDecoded
        let domainsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .domains)
        var domainsDecoded0:[String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
        let enableSslDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableSsl)
        enableSsl = enableSslDecoded
        let sslConfigurationDecoded = try containerValues.decodeIfPresent(SslConfiguration.self, forKey: .sslConfiguration)
        sslConfiguration = sslConfigurationDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let environmentContainer = try containerValues.decodeIfPresent([EnvironmentVariable?].self, forKey: .environment)
        var environmentDecoded0:[EnvironmentVariable]? = nil
        if let environmentContainer = environmentContainer {
            environmentDecoded0 = [EnvironmentVariable]()
            for structure0 in environmentContainer {
                if let structure0 = structure0 {
                    environmentDecoded0?.append(structure0)
                }
            }
        }
        environment = environmentDecoded0
    }
}

extension UpdateAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAppOutputResponse()"}
}

extension UpdateAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAppOutputResponse: Equatable {

    public init() {}
}

struct UpdateAppOutputResponseBody: Equatable {
}

extension UpdateAppOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateElasticIpInputBodyMiddleware: Middleware {
    public let id: String = "UpdateElasticIpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateElasticIpInput>
    public typealias MOutput = OperationOutput<UpdateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateElasticIpOutputError>
}

extension UpdateElasticIpInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateElasticIpInput(elasticIp: \(String(describing: elasticIp)), name: \(String(describing: name)))"}
}

extension UpdateElasticIpInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateElasticIpInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateElasticIpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateElasticIpInput>
    public typealias MOutput = OperationOutput<UpdateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateElasticIpOutputError>
}

public struct UpdateElasticIpInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateElasticIpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateElasticIpInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateElasticIpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateElasticIpInput>
    public typealias MOutput = OperationOutput<UpdateElasticIpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateElasticIpOutputError>
}

public struct UpdateElasticIpInput: Equatable {
    /// <p>The IP address for which you want to update the name.</p>
    public let elasticIp: String?
    /// <p>The new name.</p>
    public let name: String?

    public init (
        elasticIp: String? = nil,
        name: String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.name = name
    }
}

struct UpdateElasticIpInputBody: Equatable {
    public let elasticIp: String?
    public let name: String?
}

extension UpdateElasticIpInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case elasticIp = "ElasticIp"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateElasticIpOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateElasticIpOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateElasticIpOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateElasticIpOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateElasticIpOutputResponse()"}
}

extension UpdateElasticIpOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateElasticIpOutputResponse: Equatable {

    public init() {}
}

struct UpdateElasticIpOutputResponseBody: Equatable {
}

extension UpdateElasticIpOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateInstanceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceInput>
    public typealias MOutput = OperationOutput<UpdateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceOutputError>
}

extension UpdateInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstanceInput(agentVersion: \(String(describing: agentVersion)), amiId: \(String(describing: amiId)), architecture: \(String(describing: architecture)), autoScalingType: \(String(describing: autoScalingType)), ebsOptimized: \(String(describing: ebsOptimized)), hostname: \(String(describing: hostname)), installUpdatesOnBoot: \(String(describing: installUpdatesOnBoot)), instanceId: \(String(describing: instanceId)), instanceType: \(String(describing: instanceType)), layerIds: \(String(describing: layerIds)), os: \(String(describing: os)), sshKeyName: \(String(describing: sshKeyName)))"}
}

extension UpdateInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case autoScalingType = "AutoScalingType"
        case ebsOptimized = "EbsOptimized"
        case hostname = "Hostname"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceId = "InstanceId"
        case instanceType = "InstanceType"
        case layerIds = "LayerIds"
        case os = "Os"
        case sshKeyName = "SshKeyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let architecture = architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let autoScalingType = autoScalingType {
            try encodeContainer.encode(autoScalingType.rawValue, forKey: .autoScalingType)
        }
        if let ebsOptimized = ebsOptimized {
            try encodeContainer.encode(ebsOptimized, forKey: .ebsOptimized)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let installUpdatesOnBoot = installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for strings0 in layerIds {
                try layerIdsContainer.encode(strings0)
            }
        }
        if let os = os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if let sshKeyName = sshKeyName {
            try encodeContainer.encode(sshKeyName, forKey: .sshKeyName)
        }
    }
}

public struct UpdateInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceInput>
    public typealias MOutput = OperationOutput<UpdateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceOutputError>
}

public struct UpdateInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInstanceInput>
    public typealias MOutput = OperationOutput<UpdateInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInstanceOutputError>
}

public struct UpdateInstanceInput: Equatable {
    /// <p>The default AWS OpsWorks Stacks agent version. You have the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>INHERIT</code> - Use the stack's default agent version setting.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>version_number</i> - Use the specified agent version.
    ///         This value overrides the stack's default setting.
    ///         To update the agent version, you must edit the instance configuration and specify a
    ///         new version.
    ///         AWS OpsWorks Stacks then automatically installs that version on the instance.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The default setting is <code>INHERIT</code>. To specify an agent version,
    ///       you must use the complete version number, not the abbreviated number shown on the console.
    ///       For a list of available agent version numbers, call <a>DescribeAgentVersions</a>.</p>
    ///          <p>AgentVersion cannot be set to Chef 12.2.</p>
    public let agentVersion: String?
    /// <p>The ID of the AMI that was used to create the instance. The value of this parameter must be the same AMI ID that the instance is already using.
    ///           You cannot apply a new AMI to an instance by running UpdateInstance. UpdateInstance does not work on instances that are using custom AMIs.
    ///       </p>
    public let amiId: String?
    /// <p>The instance architecture. Instance types do not necessarily support both architectures. For
    ///       a list of the architectures that are supported by the different instance types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance
    ///         Families and Types</a>.</p>
    public let architecture: Architecture?
    /// <p>For load-based or time-based instances, the type. Windows stacks can use only time-based instances.</p>
    public let autoScalingType: AutoScalingType?
    /// <p>This property cannot be updated.</p>
    public let ebsOptimized: Bool?
    /// <p>The instance host name.</p>
    public let hostname: String?
    /// <p>Whether to install operating system and package updates when the instance boots. The default
    ///       value is <code>true</code>. To control when updates are installed, set this value to
    ///         <code>false</code>. You must then update your instances manually by using
    ///         <a>CreateDeployment</a> to run the <code>update_dependencies</code> stack command or
    ///       by manually running <code>yum</code> (Amazon Linux) or <code>apt-get</code> (Ubuntu) on the
    ///       instances. </p>
    ///          <note>
    ///             <p>We strongly recommend using the default value of <code>true</code>, to ensure that your
    ///         instances have the latest security updates.</p>
    ///          </note>
    public let installUpdatesOnBoot: Bool?
    /// <p>The instance ID.</p>
    public let instanceId: String?
    /// <p>The instance type, such as <code>t2.micro</code>. For a list of supported instance types,
    ///       open the stack in the console, choose <b>Instances</b>, and choose <b>+ Instance</b>.
    ///       The <b>Size</b> list contains the currently supported types. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance
    ///         Families and Types</a>. The parameter values that you use to specify the various types are
    ///       in the <b>API Name</b> column of the <b>Available Instance Types</b> table.</p>
    public let instanceType: String?
    /// <p>The instance's layer IDs.</p>
    public let layerIds: [String]?
    /// <p>The instance's operating system, which must be set to one of the following. You cannot update an instance that is using a custom AMI.</p>
    ///          <ul>
    ///             <li>
    ///                <p>A supported Linux operating system: An Amazon Linux version, such as <code>Amazon Linux 2018.03</code>, <code>Amazon Linux 2017.09</code>, <code>Amazon Linux 2017.03</code>, <code>Amazon Linux 2016.09</code>, <code>Amazon Linux 2016.03</code>, <code>Amazon Linux 2015.09</code>, or <code>Amazon Linux
    ///         2015.03</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>A supported Ubuntu operating system, such as <code>Ubuntu 16.04 LTS</code>, <code>Ubuntu 14.04 LTS</code>, or <code>Ubuntu 12.04 LTS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CentOS Linux 7</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Red Hat Enterprise Linux 7</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>A supported Windows operating system, such as <code>Microsoft Windows Server 2012 R2 Base</code>, <code>Microsoft Windows Server 2012 R2 with SQL Server Express</code>,
    ///               <code>Microsoft Windows Server 2012 R2 with SQL Server Standard</code>, or <code>Microsoft Windows Server 2012 R2 with SQL Server Web</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about supported operating systems,
    ///       see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">AWS OpsWorks Stacks Operating Systems</a>.</p>
    ///          <p>The default option is the current Amazon Linux version. If you set this parameter to
    ///         <code>Custom</code>, you must use the AmiId parameter to
    ///       specify the custom AMI that you want to use. For more information about supported operating
    ///       systems, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">Operating Systems</a>. For more information about how to use custom AMIs with OpsWorks, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">Using
    ///         Custom AMIs</a>.</p>
    ///          <note>
    ///             <p>You can specify a different Linux operating system for the updated stack, but you cannot change from Linux to Windows or Windows to Linux.</p>
    ///          </note>
    public let os: String?
    /// <p>The instance's Amazon EC2 key name.</p>
    public let sshKeyName: String?

    public init (
        agentVersion: String? = nil,
        amiId: String? = nil,
        architecture: Architecture? = nil,
        autoScalingType: AutoScalingType? = nil,
        ebsOptimized: Bool? = nil,
        hostname: String? = nil,
        installUpdatesOnBoot: Bool? = nil,
        instanceId: String? = nil,
        instanceType: String? = nil,
        layerIds: [String]? = nil,
        os: String? = nil,
        sshKeyName: String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.amiId = amiId
        self.architecture = architecture
        self.autoScalingType = autoScalingType
        self.ebsOptimized = ebsOptimized
        self.hostname = hostname
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.instanceId = instanceId
        self.instanceType = instanceType
        self.layerIds = layerIds
        self.os = os
        self.sshKeyName = sshKeyName
    }
}

struct UpdateInstanceInputBody: Equatable {
    public let instanceId: String?
    public let layerIds: [String]?
    public let instanceType: String?
    public let autoScalingType: AutoScalingType?
    public let hostname: String?
    public let os: String?
    public let amiId: String?
    public let sshKeyName: String?
    public let architecture: Architecture?
    public let installUpdatesOnBoot: Bool?
    public let ebsOptimized: Bool?
    public let agentVersion: String?
}

extension UpdateInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case autoScalingType = "AutoScalingType"
        case ebsOptimized = "EbsOptimized"
        case hostname = "Hostname"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceId = "InstanceId"
        case instanceType = "InstanceType"
        case layerIds = "LayerIds"
        case os = "Os"
        case sshKeyName = "SshKeyName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let autoScalingTypeDecoded = try containerValues.decodeIfPresent(AutoScalingType.self, forKey: .autoScalingType)
        autoScalingType = autoScalingTypeDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let osDecoded = try containerValues.decodeIfPresent(String.self, forKey: .os)
        os = osDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let sshKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshKeyName)
        sshKeyName = sshKeyNameDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension UpdateInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInstanceOutputResponse()"}
}

extension UpdateInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInstanceOutputResponse: Equatable {

    public init() {}
}

struct UpdateInstanceOutputResponseBody: Equatable {
}

extension UpdateInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLayerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLayerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLayerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLayerInput>
    public typealias MOutput = OperationOutput<UpdateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLayerOutputError>
}

extension UpdateLayerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLayerInput(attributes: \(String(describing: attributes)), autoAssignElasticIps: \(String(describing: autoAssignElasticIps)), autoAssignPublicIps: \(String(describing: autoAssignPublicIps)), cloudWatchLogsConfiguration: \(String(describing: cloudWatchLogsConfiguration)), customInstanceProfileArn: \(String(describing: customInstanceProfileArn)), customJson: \(String(describing: customJson)), customRecipes: \(String(describing: customRecipes)), customSecurityGroupIds: \(String(describing: customSecurityGroupIds)), enableAutoHealing: \(String(describing: enableAutoHealing)), installUpdatesOnBoot: \(String(describing: installUpdatesOnBoot)), layerId: \(String(describing: layerId)), lifecycleEventConfiguration: \(String(describing: lifecycleEventConfiguration)), name: \(String(describing: name)), packages: \(String(describing: packages)), shortname: \(String(describing: shortname)), useEbsOptimizedInstances: \(String(describing: useEbsOptimizedInstances)), volumeConfigurations: \(String(describing: volumeConfigurations)))"}
}

extension UpdateLayerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case layerId = "LayerId"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, layerattributes0) in attributes {
                try attributesContainer.encode(layerattributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let autoAssignElasticIps = autoAssignElasticIps {
            try encodeContainer.encode(autoAssignElasticIps, forKey: .autoAssignElasticIps)
        }
        if let autoAssignPublicIps = autoAssignPublicIps {
            try encodeContainer.encode(autoAssignPublicIps, forKey: .autoAssignPublicIps)
        }
        if let cloudWatchLogsConfiguration = cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let customInstanceProfileArn = customInstanceProfileArn {
            try encodeContainer.encode(customInstanceProfileArn, forKey: .customInstanceProfileArn)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let customRecipes = customRecipes {
            try encodeContainer.encode(customRecipes, forKey: .customRecipes)
        }
        if let customSecurityGroupIds = customSecurityGroupIds {
            var customSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customSecurityGroupIds)
            for strings0 in customSecurityGroupIds {
                try customSecurityGroupIdsContainer.encode(strings0)
            }
        }
        if let enableAutoHealing = enableAutoHealing {
            try encodeContainer.encode(enableAutoHealing, forKey: .enableAutoHealing)
        }
        if let installUpdatesOnBoot = installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let layerId = layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let lifecycleEventConfiguration = lifecycleEventConfiguration {
            try encodeContainer.encode(lifecycleEventConfiguration, forKey: .lifecycleEventConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packages = packages {
            var packagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .packages)
            for strings0 in packages {
                try packagesContainer.encode(strings0)
            }
        }
        if let shortname = shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let useEbsOptimizedInstances = useEbsOptimizedInstances {
            try encodeContainer.encode(useEbsOptimizedInstances, forKey: .useEbsOptimizedInstances)
        }
        if let volumeConfigurations = volumeConfigurations {
            var volumeConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeConfigurations)
            for volumeconfigurations0 in volumeConfigurations {
                try volumeConfigurationsContainer.encode(volumeconfigurations0)
            }
        }
    }
}

public struct UpdateLayerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLayerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLayerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLayerInput>
    public typealias MOutput = OperationOutput<UpdateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLayerOutputError>
}

public struct UpdateLayerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLayerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLayerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLayerInput>
    public typealias MOutput = OperationOutput<UpdateLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLayerOutputError>
}

public struct UpdateLayerInput: Equatable {
    /// <p>One or more user-defined key/value pairs to be added to the stack attributes.</p>
    public let attributes: [String:String]?
    /// <p>Whether to automatically assign an <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP
    ///         address</a> to the layer's instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html">How to Edit
    ///         a Layer</a>.</p>
    public let autoAssignElasticIps: Bool?
    /// <p>For stacks that are running in a VPC, whether to automatically assign a public IP address to
    ///       the layer's instances. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html">How to Edit
    ///         a Layer</a>.</p>
    public let autoAssignPublicIps: Bool?
    /// <p>Specifies CloudWatch Logs configuration options for the layer. For more information, see <a>CloudWatchLogsLogStream</a>.</p>
    public let cloudWatchLogsConfiguration: CloudWatchLogsConfiguration?
    /// <p>The ARN of an IAM profile to be used for all of the layer's EC2 instances. For more
    ///       information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers</a>.</p>
    public let customInstanceProfileArn: String?
    /// <p>A JSON-formatted string containing custom stack configuration and deployment attributes
    ///       to be installed on the layer's instances. For more information, see
    ///       <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook-json-override.html">
    ///         Using Custom JSON</a>.
    ///     </p>
    public let customJson: String?
    /// <p>A <code>LayerCustomRecipes</code> object that specifies the layer's custom recipes.</p>
    public let customRecipes: Recipes?
    /// <p>An array containing the layer's custom security group IDs.</p>
    public let customSecurityGroupIds: [String]?
    /// <p>Whether to disable auto healing for the layer.</p>
    public let enableAutoHealing: Bool?
    /// <p>Whether to install operating system and package updates when the instance boots. The default
    ///       value is <code>true</code>. To control when updates are installed, set this value to
    ///         <code>false</code>. You must then update your instances manually by using
    ///         <a>CreateDeployment</a> to run the <code>update_dependencies</code> stack command or
    ///       manually running <code>yum</code> (Amazon Linux) or <code>apt-get</code> (Ubuntu) on the
    ///       instances. </p>
    ///          <note>
    ///             <p>We strongly recommend using the default value of <code>true</code>, to ensure that your
    ///         instances have the latest security updates.</p>
    ///          </note>
    public let installUpdatesOnBoot: Bool?
    /// <p>The layer ID.</p>
    public let layerId: String?
    /// <p></p>
    public let lifecycleEventConfiguration: LifecycleEventConfiguration?
    /// <p>The layer name, which is used by the console.</p>
    public let name: String?
    /// <p>An array of <code>Package</code> objects that describe the layer's packages.</p>
    public let packages: [String]?
    /// <p>For custom layers only, use this parameter to specify the layer's short name, which is used internally by AWS OpsWorks Stacks and by Chef. The short name is also used as the name for the directory where your app files are installed. It can have a maximum of 200 characters and must be in the following format: /\A[a-z0-9\-\_\.]+\Z/.</p>
    ///          <p>The built-in layers' short names are defined by AWS OpsWorks Stacks. For more information, see the <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/layers.html">Layer Reference</a>
    ///          </p>
    public let shortname: String?
    /// <p>Whether to use Amazon EBS-optimized instances.</p>
    public let useEbsOptimizedInstances: Bool?
    /// <p>A <code>VolumeConfigurations</code> object that describes the layer's Amazon EBS volumes.</p>
    public let volumeConfigurations: [VolumeConfiguration]?

    public init (
        attributes: [String:String]? = nil,
        autoAssignElasticIps: Bool? = nil,
        autoAssignPublicIps: Bool? = nil,
        cloudWatchLogsConfiguration: CloudWatchLogsConfiguration? = nil,
        customInstanceProfileArn: String? = nil,
        customJson: String? = nil,
        customRecipes: Recipes? = nil,
        customSecurityGroupIds: [String]? = nil,
        enableAutoHealing: Bool? = nil,
        installUpdatesOnBoot: Bool? = nil,
        layerId: String? = nil,
        lifecycleEventConfiguration: LifecycleEventConfiguration? = nil,
        name: String? = nil,
        packages: [String]? = nil,
        shortname: String? = nil,
        useEbsOptimizedInstances: Bool? = nil,
        volumeConfigurations: [VolumeConfiguration]? = nil
    )
    {
        self.attributes = attributes
        self.autoAssignElasticIps = autoAssignElasticIps
        self.autoAssignPublicIps = autoAssignPublicIps
        self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
        self.customInstanceProfileArn = customInstanceProfileArn
        self.customJson = customJson
        self.customRecipes = customRecipes
        self.customSecurityGroupIds = customSecurityGroupIds
        self.enableAutoHealing = enableAutoHealing
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.layerId = layerId
        self.lifecycleEventConfiguration = lifecycleEventConfiguration
        self.name = name
        self.packages = packages
        self.shortname = shortname
        self.useEbsOptimizedInstances = useEbsOptimizedInstances
        self.volumeConfigurations = volumeConfigurations
    }
}

struct UpdateLayerInputBody: Equatable {
    public let layerId: String?
    public let name: String?
    public let shortname: String?
    public let attributes: [String:String]?
    public let cloudWatchLogsConfiguration: CloudWatchLogsConfiguration?
    public let customInstanceProfileArn: String?
    public let customJson: String?
    public let customSecurityGroupIds: [String]?
    public let packages: [String]?
    public let volumeConfigurations: [VolumeConfiguration]?
    public let enableAutoHealing: Bool?
    public let autoAssignElasticIps: Bool?
    public let autoAssignPublicIps: Bool?
    public let customRecipes: Recipes?
    public let installUpdatesOnBoot: Bool?
    public let useEbsOptimizedInstances: Bool?
    public let lifecycleEventConfiguration: LifecycleEventConfiguration?
}

extension UpdateLayerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case layerId = "LayerId"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(CloudWatchLogsConfiguration.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let customInstanceProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customInstanceProfileArn)
        customInstanceProfileArn = customInstanceProfileArnDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let customSecurityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .customSecurityGroupIds)
        var customSecurityGroupIdsDecoded0:[String]? = nil
        if let customSecurityGroupIdsContainer = customSecurityGroupIdsContainer {
            customSecurityGroupIdsDecoded0 = [String]()
            for string0 in customSecurityGroupIdsContainer {
                if let string0 = string0 {
                    customSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        customSecurityGroupIds = customSecurityGroupIdsDecoded0
        let packagesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .packages)
        var packagesDecoded0:[String]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [String]()
            for string0 in packagesContainer {
                if let string0 = string0 {
                    packagesDecoded0?.append(string0)
                }
            }
        }
        packages = packagesDecoded0
        let volumeConfigurationsContainer = try containerValues.decodeIfPresent([VolumeConfiguration?].self, forKey: .volumeConfigurations)
        var volumeConfigurationsDecoded0:[VolumeConfiguration]? = nil
        if let volumeConfigurationsContainer = volumeConfigurationsContainer {
            volumeConfigurationsDecoded0 = [VolumeConfiguration]()
            for structure0 in volumeConfigurationsContainer {
                if let structure0 = structure0 {
                    volumeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        volumeConfigurations = volumeConfigurationsDecoded0
        let enableAutoHealingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoHealing)
        enableAutoHealing = enableAutoHealingDecoded
        let autoAssignElasticIpsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoAssignElasticIps)
        autoAssignElasticIps = autoAssignElasticIpsDecoded
        let autoAssignPublicIpsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoAssignPublicIps)
        autoAssignPublicIps = autoAssignPublicIpsDecoded
        let customRecipesDecoded = try containerValues.decodeIfPresent(Recipes.self, forKey: .customRecipes)
        customRecipes = customRecipesDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let useEbsOptimizedInstancesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useEbsOptimizedInstances)
        useEbsOptimizedInstances = useEbsOptimizedInstancesDecoded
        let lifecycleEventConfigurationDecoded = try containerValues.decodeIfPresent(LifecycleEventConfiguration.self, forKey: .lifecycleEventConfiguration)
        lifecycleEventConfiguration = lifecycleEventConfigurationDecoded
    }
}

extension UpdateLayerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLayerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLayerOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLayerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLayerOutputResponse()"}
}

extension UpdateLayerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLayerOutputResponse: Equatable {

    public init() {}
}

struct UpdateLayerOutputResponseBody: Equatable {
}

extension UpdateLayerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateMyUserProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMyUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMyUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMyUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMyUserProfileInput>
    public typealias MOutput = OperationOutput<UpdateMyUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMyUserProfileOutputError>
}

extension UpdateMyUserProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMyUserProfileInput(sshPublicKey: \(String(describing: sshPublicKey)))"}
}

extension UpdateMyUserProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sshPublicKey = "SshPublicKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
    }
}

public struct UpdateMyUserProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMyUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMyUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMyUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMyUserProfileInput>
    public typealias MOutput = OperationOutput<UpdateMyUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMyUserProfileOutputError>
}

public struct UpdateMyUserProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMyUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMyUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMyUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMyUserProfileInput>
    public typealias MOutput = OperationOutput<UpdateMyUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMyUserProfileOutputError>
}

public struct UpdateMyUserProfileInput: Equatable {
    /// <p>The user's SSH public key.</p>
    public let sshPublicKey: String?

    public init (
        sshPublicKey: String? = nil
    )
    {
        self.sshPublicKey = sshPublicKey
    }
}

struct UpdateMyUserProfileInputBody: Equatable {
    public let sshPublicKey: String?
}

extension UpdateMyUserProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sshPublicKey = "SshPublicKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension UpdateMyUserProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMyUserProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMyUserProfileOutputError: Swift.Error, Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMyUserProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMyUserProfileOutputResponse()"}
}

extension UpdateMyUserProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMyUserProfileOutputResponse: Equatable {

    public init() {}
}

struct UpdateMyUserProfileOutputResponseBody: Equatable {
}

extension UpdateMyUserProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRdsDbInstanceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRdsDbInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRdsDbInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRdsDbInstanceInput>
    public typealias MOutput = OperationOutput<UpdateRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRdsDbInstanceOutputError>
}

extension UpdateRdsDbInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRdsDbInstanceInput(dbPassword: \(String(describing: dbPassword)), dbUser: \(String(describing: dbUser)), rdsDbInstanceArn: \(String(describing: rdsDbInstanceArn)))"}
}

extension UpdateRdsDbInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbPassword = dbPassword {
            try encodeContainer.encode(dbPassword, forKey: .dbPassword)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let rdsDbInstanceArn = rdsDbInstanceArn {
            try encodeContainer.encode(rdsDbInstanceArn, forKey: .rdsDbInstanceArn)
        }
    }
}

public struct UpdateRdsDbInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRdsDbInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRdsDbInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRdsDbInstanceInput>
    public typealias MOutput = OperationOutput<UpdateRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRdsDbInstanceOutputError>
}

public struct UpdateRdsDbInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRdsDbInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRdsDbInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRdsDbInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRdsDbInstanceInput>
    public typealias MOutput = OperationOutput<UpdateRdsDbInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRdsDbInstanceOutputError>
}

public struct UpdateRdsDbInstanceInput: Equatable {
    /// <p>The database password.</p>
    public let dbPassword: String?
    /// <p>The master user name.</p>
    public let dbUser: String?
    /// <p>The Amazon RDS instance's ARN.</p>
    public let rdsDbInstanceArn: String?

    public init (
        dbPassword: String? = nil,
        dbUser: String? = nil,
        rdsDbInstanceArn: String? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.rdsDbInstanceArn = rdsDbInstanceArn
    }
}

struct UpdateRdsDbInstanceInputBody: Equatable {
    public let rdsDbInstanceArn: String?
    public let dbUser: String?
    public let dbPassword: String?
}

extension UpdateRdsDbInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsDbInstanceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rdsDbInstanceArn)
        rdsDbInstanceArn = rdsDbInstanceArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
    }
}

extension UpdateRdsDbInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRdsDbInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRdsDbInstanceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRdsDbInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRdsDbInstanceOutputResponse()"}
}

extension UpdateRdsDbInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRdsDbInstanceOutputResponse: Equatable {

    public init() {}
}

struct UpdateRdsDbInstanceOutputResponseBody: Equatable {
}

extension UpdateRdsDbInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateStackInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackInput>
    public typealias MOutput = OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackOutputError>
}

extension UpdateStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStackInput(agentVersion: \(String(describing: agentVersion)), attributes: \(String(describing: attributes)), chefConfiguration: \(String(describing: chefConfiguration)), configurationManager: \(String(describing: configurationManager)), customCookbooksSource: \(String(describing: customCookbooksSource)), customJson: \(String(describing: customJson)), defaultAvailabilityZone: \(String(describing: defaultAvailabilityZone)), defaultInstanceProfileArn: \(String(describing: defaultInstanceProfileArn)), defaultOs: \(String(describing: defaultOs)), defaultRootDeviceType: \(String(describing: defaultRootDeviceType)), defaultSshKeyName: \(String(describing: defaultSshKeyName)), defaultSubnetId: \(String(describing: defaultSubnetId)), hostnameTheme: \(String(describing: hostnameTheme)), name: \(String(describing: name)), serviceRoleArn: \(String(describing: serviceRoleArn)), stackId: \(String(describing: stackId)), useCustomCookbooks: \(String(describing: useCustomCookbooks)), useOpsworksSecurityGroups: \(String(describing: useOpsworksSecurityGroups)))"}
}

extension UpdateStackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case serviceRoleArn = "ServiceRoleArn"
        case stackId = "StackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, stackattributes0) in attributes {
                try attributesContainer.encode(stackattributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let chefConfiguration = chefConfiguration {
            try encodeContainer.encode(chefConfiguration, forKey: .chefConfiguration)
        }
        if let configurationManager = configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let customCookbooksSource = customCookbooksSource {
            try encodeContainer.encode(customCookbooksSource, forKey: .customCookbooksSource)
        }
        if let customJson = customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let defaultAvailabilityZone = defaultAvailabilityZone {
            try encodeContainer.encode(defaultAvailabilityZone, forKey: .defaultAvailabilityZone)
        }
        if let defaultInstanceProfileArn = defaultInstanceProfileArn {
            try encodeContainer.encode(defaultInstanceProfileArn, forKey: .defaultInstanceProfileArn)
        }
        if let defaultOs = defaultOs {
            try encodeContainer.encode(defaultOs, forKey: .defaultOs)
        }
        if let defaultRootDeviceType = defaultRootDeviceType {
            try encodeContainer.encode(defaultRootDeviceType.rawValue, forKey: .defaultRootDeviceType)
        }
        if let defaultSshKeyName = defaultSshKeyName {
            try encodeContainer.encode(defaultSshKeyName, forKey: .defaultSshKeyName)
        }
        if let defaultSubnetId = defaultSubnetId {
            try encodeContainer.encode(defaultSubnetId, forKey: .defaultSubnetId)
        }
        if let hostnameTheme = hostnameTheme {
            try encodeContainer.encode(hostnameTheme, forKey: .hostnameTheme)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let useCustomCookbooks = useCustomCookbooks {
            try encodeContainer.encode(useCustomCookbooks, forKey: .useCustomCookbooks)
        }
        if let useOpsworksSecurityGroups = useOpsworksSecurityGroups {
            try encodeContainer.encode(useOpsworksSecurityGroups, forKey: .useOpsworksSecurityGroups)
        }
    }
}

public struct UpdateStackInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackInput>
    public typealias MOutput = OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackOutputError>
}

public struct UpdateStackInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStackInput>
    public typealias MOutput = OperationOutput<UpdateStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStackOutputError>
}

public struct UpdateStackInput: Equatable {
    /// <p>The default AWS OpsWorks Stacks agent version. You have the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Auto-update - Set this parameter to <code>LATEST</code>. AWS OpsWorks Stacks
    ///         automatically installs new agent versions on the stack's instances as soon as
    ///         they are available.</p>
    ///             </li>
    ///             <li>
    ///                <p>Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. AWS OpsWorks Stacks then automatically installs that version on the stack's instances.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The default setting is <code>LATEST</code>. To specify an agent version,
    ///       you must use the complete version number, not the abbreviated number shown on the console.
    ///       For a list of available agent version numbers, call <a>DescribeAgentVersions</a>.
    ///           AgentVersion cannot be set to Chef 12.2.</p>
    ///          <note>
    ///             <p>You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.</p>
    ///          </note>
    public let agentVersion: String?
    /// <p>One or more user-defined key-value pairs to be added to the stack attributes.</p>
    public let attributes: [String:String]?
    /// <p>A <code>ChefConfiguration</code> object that specifies whether to enable Berkshelf and the
    ///       Berkshelf version on Chef 11.10 stacks. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New Stack</a>.</p>
    public let chefConfiguration: ChefConfiguration?
    /// <p>The configuration manager. When you update a stack, we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.</p>
    public let configurationManager: StackConfigurationManager?
    /// <p>Contains the information required to retrieve an app or cookbook from a repository. For more information,
    ///             see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html">Adding Apps</a> or <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html">Cookbooks and Recipes</a>.</p>
    public let customCookbooksSource: Source?
    /// <p>A string that contains user-defined, custom JSON. It can be used to override the corresponding default stack configuration JSON values or to pass data to recipes. The string should be in the following format:</p>
    ///          <p>
    ///             <code>"{\"key1\": \"value1\", \"key2\": \"value2\",...}"</code>
    ///          </p>
    ///          <p>For more information about custom JSON, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html">Use Custom JSON to
    ///         Modify the Stack Configuration Attributes</a>.</p>
    public let customJson: String?
    /// <p>The stack's default Availability Zone, which must be in the
    ///       stack's region. For more
    ///       information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and
    ///         Endpoints</a>. If you also specify a value for <code>DefaultSubnetId</code>, the subnet must
    ///       be in the same zone. For more information, see <a>CreateStack</a>. </p>
    public let defaultAvailabilityZone: String?
    /// <p>The ARN of an IAM profile that is the default profile for all of the stack's EC2 instances.
    ///       For more information about IAM ARNs, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html">Using
    ///       Identifiers</a>.</p>
    public let defaultInstanceProfileArn: String?
    /// <p>The stack's operating system, which must be set to one of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>A supported Linux operating system: An Amazon Linux version, such as <code>Amazon Linux 2018.03</code>, <code>Amazon Linux 2017.09</code>, <code>Amazon Linux 2017.03</code>, <code>Amazon Linux 2016.09</code>,
    ///               <code>Amazon Linux 2016.03</code>, <code>Amazon Linux 2015.09</code>, or <code>Amazon Linux 2015.03</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>A supported Ubuntu operating system, such as <code>Ubuntu 16.04 LTS</code>, <code>Ubuntu 14.04 LTS</code>, or <code>Ubuntu 12.04 LTS</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CentOS Linux 7</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Red Hat Enterprise Linux 7</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>A supported Windows operating system, such as <code>Microsoft Windows Server 2012 R2 Base</code>, <code>Microsoft Windows Server 2012 R2 with SQL Server Express</code>,
    ///               <code>Microsoft Windows Server 2012 R2 with SQL Server Standard</code>, or <code>Microsoft Windows Server 2012 R2 with SQL Server Web</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>A custom AMI: <code>Custom</code>. You specify the custom AMI you want to use when
    ///         you create instances. For more information about how to use custom AMIs with OpsWorks, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html">Using
    ///           Custom AMIs</a>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The default option is the stack's current operating system.
    ///       For more information about supported operating systems,
    ///       see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html">AWS OpsWorks Stacks Operating Systems</a>.</p>
    public let defaultOs: String?
    /// <p>The default root device type. This value is used by default for all instances in the stack,
    ///       but you can override it when you create an instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device">Storage for the Root Device</a>.</p>
    public let defaultRootDeviceType: RootDeviceType?
    /// <p>A default Amazon EC2 key-pair name. The default value is
    ///       <code>none</code>. If you specify a key-pair name,
    ///       AWS OpsWorks Stacks installs the public key on the instance and you can use the private key with an SSH
    ///       client to log in to the instance. For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-ssh.html"> Using SSH to
    ///         Communicate with an Instance</a> and <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/security-ssh-access.html"> Managing SSH
    ///         Access</a>. You can override this setting by specifying a different key pair, or no key
    ///       pair, when you <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-add.html">
    ///         create an instance</a>. </p>
    public let defaultSshKeyName: String?
    /// <p>The stack's default VPC subnet ID. This parameter is required if you specify a value for the
    ///         <code>VpcId</code> parameter. All instances are launched into this subnet unless you specify
    ///       otherwise when you create the instance. If you also specify a value for
    ///         <code>DefaultAvailabilityZone</code>, the subnet must be in that zone. For information on
    ///       default values and when this parameter is required, see the <code>VpcId</code> parameter
    ///       description. </p>
    public let defaultSubnetId: String?
    /// <p>The stack's new host name theme, with spaces replaced by underscores.
    ///       The theme is used to generate host names for the stack's instances.
    ///       By default, <code>HostnameTheme</code> is set to <code>Layer_Dependent</code>, which creates host names by appending integers to the
    ///       layer's short name. The other themes are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Baked_Goods</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Clouds</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Europe_Cities</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fruits</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Greek_Deities_and_Titans</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Legendary_creatures_from_Japan</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Planets_and_Moons</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Roman_Deities</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Scottish_Islands</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>US_Cities</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Wild_Cats</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To obtain a generated host name, call <code>GetHostNameSuggestion</code>, which returns a
    ///       host name based on the current theme.</p>
    public let hostnameTheme: String?
    /// <p>The stack's new name.</p>
    public let name: String?
    /// <p>Do not use this parameter. You cannot update a stack's service role.</p>
    public let serviceRoleArn: String?
    /// <p>The stack ID.</p>
    public let stackId: String?
    /// <p>Whether the stack uses custom cookbooks.</p>
    public let useCustomCookbooks: Bool?
    /// <p>Whether to associate the AWS OpsWorks Stacks built-in security groups with the stack's layers.</p>
    ///          <p>AWS OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are
    ///       associated with layers by default. <code>UseOpsworksSecurityGroups</code> allows you to
    ///       provide your own custom security groups
    ///       instead of using the built-in groups. <code>UseOpsworksSecurityGroups</code> has
    ///       the following settings: </p>
    ///          <ul>
    ///             <li>
    ///                <p>True - AWS OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it, but you cannot delete the built-in security group.</p>
    ///             </li>
    ///             <li>
    ///                <p>False - AWS OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on. Custom security groups are required only for those layers that need custom settings.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html">Create a New
    ///         Stack</a>.</p>
    public let useOpsworksSecurityGroups: Bool?

    public init (
        agentVersion: String? = nil,
        attributes: [String:String]? = nil,
        chefConfiguration: ChefConfiguration? = nil,
        configurationManager: StackConfigurationManager? = nil,
        customCookbooksSource: Source? = nil,
        customJson: String? = nil,
        defaultAvailabilityZone: String? = nil,
        defaultInstanceProfileArn: String? = nil,
        defaultOs: String? = nil,
        defaultRootDeviceType: RootDeviceType? = nil,
        defaultSshKeyName: String? = nil,
        defaultSubnetId: String? = nil,
        hostnameTheme: String? = nil,
        name: String? = nil,
        serviceRoleArn: String? = nil,
        stackId: String? = nil,
        useCustomCookbooks: Bool? = nil,
        useOpsworksSecurityGroups: Bool? = nil
    )
    {
        self.agentVersion = agentVersion
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.configurationManager = configurationManager
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.serviceRoleArn = serviceRoleArn
        self.stackId = stackId
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
    }
}

struct UpdateStackInputBody: Equatable {
    public let stackId: String?
    public let name: String?
    public let attributes: [String:String]?
    public let serviceRoleArn: String?
    public let defaultInstanceProfileArn: String?
    public let defaultOs: String?
    public let hostnameTheme: String?
    public let defaultAvailabilityZone: String?
    public let defaultSubnetId: String?
    public let customJson: String?
    public let configurationManager: StackConfigurationManager?
    public let chefConfiguration: ChefConfiguration?
    public let useCustomCookbooks: Bool?
    public let customCookbooksSource: Source?
    public let defaultSshKeyName: String?
    public let defaultRootDeviceType: RootDeviceType?
    public let useOpsworksSecurityGroups: Bool?
    public let agentVersion: String?
}

extension UpdateStackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case serviceRoleArn = "ServiceRoleArn"
        case stackId = "StackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let defaultInstanceProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultInstanceProfileArn)
        defaultInstanceProfileArn = defaultInstanceProfileArnDecoded
        let defaultOsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultOs)
        defaultOs = defaultOsDecoded
        let hostnameThemeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostnameTheme)
        hostnameTheme = hostnameThemeDecoded
        let defaultAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAvailabilityZone)
        defaultAvailabilityZone = defaultAvailabilityZoneDecoded
        let defaultSubnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubnetId)
        defaultSubnetId = defaultSubnetIdDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
        let chefConfigurationDecoded = try containerValues.decodeIfPresent(ChefConfiguration.self, forKey: .chefConfiguration)
        chefConfiguration = chefConfigurationDecoded
        let useCustomCookbooksDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useCustomCookbooks)
        useCustomCookbooks = useCustomCookbooksDecoded
        let customCookbooksSourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .customCookbooksSource)
        customCookbooksSource = customCookbooksSourceDecoded
        let defaultSshKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSshKeyName)
        defaultSshKeyName = defaultSshKeyNameDecoded
        let defaultRootDeviceTypeDecoded = try containerValues.decodeIfPresent(RootDeviceType.self, forKey: .defaultRootDeviceType)
        defaultRootDeviceType = defaultRootDeviceTypeDecoded
        let useOpsworksSecurityGroupsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useOpsworksSecurityGroups)
        useOpsworksSecurityGroups = useOpsworksSecurityGroupsDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension UpdateStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStackOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStackOutputResponse()"}
}

extension UpdateStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateStackOutputResponse: Equatable {

    public init() {}
}

struct UpdateStackOutputResponseBody: Equatable {
}

extension UpdateStackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateUserProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserProfileInput>
    public typealias MOutput = OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserProfileOutputError>
}

extension UpdateUserProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserProfileInput(allowSelfManagement: \(String(describing: allowSelfManagement)), iamUserArn: \(String(describing: iamUserArn)), sshPublicKey: \(String(describing: sshPublicKey)), sshUsername: \(String(describing: sshUsername)))"}
}

extension UpdateUserProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSelfManagement = allowSelfManagement {
            try encodeContainer.encode(allowSelfManagement, forKey: .allowSelfManagement)
        }
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let sshUsername = sshUsername {
            try encodeContainer.encode(sshUsername, forKey: .sshUsername)
        }
    }
}

public struct UpdateUserProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserProfileInput>
    public typealias MOutput = OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserProfileOutputError>
}

public struct UpdateUserProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserProfileInput>
    public typealias MOutput = OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserProfileOutputError>
}

public struct UpdateUserProfileInput: Equatable {
    /// <p>Whether users can specify their own SSH public key through the My Settings page. For more
    ///       information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/security-settingsshkey.html">Managing User
    ///         Permissions</a>.</p>
    public let allowSelfManagement: Bool?
    /// <p>The user IAM ARN. This can also be a federated user's ARN.</p>
    public let iamUserArn: String?
    /// <p>The user's new SSH public key.</p>
    public let sshPublicKey: String?
    /// <p>The user's SSH user name. The allowable characters are [a-z], [A-Z], [0-9], '-', and '_'. If
    ///       the specified name includes other punctuation marks, AWS OpsWorks Stacks removes them. For example,
    ///         <code>my.name</code> will be changed to <code>myname</code>. If you do not specify an SSH
    ///       user name, AWS OpsWorks Stacks generates one from the IAM user name. </p>
    public let sshUsername: String?

    public init (
        allowSelfManagement: Bool? = nil,
        iamUserArn: String? = nil,
        sshPublicKey: String? = nil,
        sshUsername: String? = nil
    )
    {
        self.allowSelfManagement = allowSelfManagement
        self.iamUserArn = iamUserArn
        self.sshPublicKey = sshPublicKey
        self.sshUsername = sshUsername
    }
}

struct UpdateUserProfileInputBody: Equatable {
    public let iamUserArn: String?
    public let sshUsername: String?
    public let sshPublicKey: String?
    public let allowSelfManagement: Bool?
}

extension UpdateUserProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let sshUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshUsername)
        sshUsername = sshUsernameDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let allowSelfManagementDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSelfManagement)
        allowSelfManagement = allowSelfManagementDecoded
    }
}

extension UpdateUserProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserProfileOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserProfileOutputResponse()"}
}

extension UpdateUserProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserProfileOutputResponse: Equatable {

    public init() {}
}

struct UpdateUserProfileOutputResponseBody: Equatable {
}

extension UpdateUserProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateVolumeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVolumeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVolumeInput>
    public typealias MOutput = OperationOutput<UpdateVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVolumeOutputError>
}

extension UpdateVolumeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVolumeInput(mountPoint: \(String(describing: mountPoint)), name: \(String(describing: name)), volumeId: \(String(describing: volumeId)))"}
}

extension UpdateVolumeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mountPoint = "MountPoint"
        case name = "Name"
        case volumeId = "VolumeId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mountPoint = mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }
}

public struct UpdateVolumeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVolumeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVolumeInput>
    public typealias MOutput = OperationOutput<UpdateVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVolumeOutputError>
}

public struct UpdateVolumeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVolumeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVolumeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVolumeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVolumeInput>
    public typealias MOutput = OperationOutput<UpdateVolumeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVolumeOutputError>
}

public struct UpdateVolumeInput: Equatable {
    /// <p>The new mount point.</p>
    public let mountPoint: String?
    /// <p>The new name.</p>
    public let name: String?
    /// <p>The volume ID.</p>
    public let volumeId: String?

    public init (
        mountPoint: String? = nil,
        name: String? = nil,
        volumeId: String? = nil
    )
    {
        self.mountPoint = mountPoint
        self.name = name
        self.volumeId = volumeId
    }
}

struct UpdateVolumeInputBody: Equatable {
    public let volumeId: String?
    public let name: String?
    public let mountPoint: String?
}

extension UpdateVolumeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mountPoint = "MountPoint"
        case name = "Name"
        case volumeId = "VolumeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
    }
}

extension UpdateVolumeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVolumeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVolumeOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVolumeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVolumeOutputResponse()"}
}

extension UpdateVolumeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateVolumeOutputResponse: Equatable {

    public init() {}
}

struct UpdateVolumeOutputResponseBody: Equatable {
}

extension UpdateVolumeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UserProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case name = "Name"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSelfManagement = allowSelfManagement {
            try encodeContainer.encode(allowSelfManagement, forKey: .allowSelfManagement)
        }
        if let iamUserArn = iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let sshUsername = sshUsername {
            try encodeContainer.encode(sshUsername, forKey: .sshUsername)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sshUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshUsername)
        sshUsername = sshUsernameDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let allowSelfManagementDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowSelfManagement)
        allowSelfManagement = allowSelfManagementDecoded
    }
}

extension UserProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserProfile(allowSelfManagement: \(String(describing: allowSelfManagement)), iamUserArn: \(String(describing: iamUserArn)), name: \(String(describing: name)), sshPublicKey: \(String(describing: sshPublicKey)), sshUsername: \(String(describing: sshUsername)))"}
}

/// <p>Describes a user's SSH information.</p>
public struct UserProfile: Equatable {
    /// <p>Whether users can specify their own SSH public key through the My Settings page. For more
    ///       information, see <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/security-settingsshkey.html">Managing User
    ///         Permissions</a>.</p>
    public let allowSelfManagement: Bool?
    /// <p>The user's IAM ARN.</p>
    public let iamUserArn: String?
    /// <p>The user's name.</p>
    public let name: String?
    /// <p>The user's SSH public key.</p>
    public let sshPublicKey: String?
    /// <p>The user's SSH user name.</p>
    public let sshUsername: String?

    public init (
        allowSelfManagement: Bool? = nil,
        iamUserArn: String? = nil,
        name: String? = nil,
        sshPublicKey: String? = nil,
        sshUsername: String? = nil
    )
    {
        self.allowSelfManagement = allowSelfManagement
        self.iamUserArn = iamUserArn
        self.name = name
        self.sshPublicKey = sshPublicKey
        self.sshUsername = sshUsername
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a request was not valid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum VirtualizationType {
    case hvm
    case paravirtual
    case sdkUnknown(String)
}

extension VirtualizationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VirtualizationType] {
        return [
            .hvm,
            .paravirtual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hvm: return "hvm"
        case .paravirtual: return "paravirtual"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VirtualizationType(rawValue: rawValue) ?? VirtualizationType.sdkUnknown(rawValue)
    }
}

extension Volume: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case device = "Device"
        case ec2VolumeId = "Ec2VolumeId"
        case encrypted = "Encrypted"
        case instanceId = "InstanceId"
        case iops = "Iops"
        case mountPoint = "MountPoint"
        case name = "Name"
        case raidArrayId = "RaidArrayId"
        case region = "Region"
        case size = "Size"
        case status = "Status"
        case volumeId = "VolumeId"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let ec2VolumeId = ec2VolumeId {
            try encodeContainer.encode(ec2VolumeId, forKey: .ec2VolumeId)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let iops = iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let mountPoint = mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let raidArrayId = raidArrayId {
            try encodeContainer.encode(raidArrayId, forKey: .raidArrayId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let volumeId = volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let ec2VolumeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2VolumeId)
        ec2VolumeId = ec2VolumeIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let raidArrayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .raidArrayId)
        raidArrayId = raidArrayIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .size)
        size = sizeDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .device)
        device = deviceDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .iops)
        iops = iopsDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
    }
}

extension Volume: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Volume(availabilityZone: \(String(describing: availabilityZone)), device: \(String(describing: device)), ec2VolumeId: \(String(describing: ec2VolumeId)), encrypted: \(String(describing: encrypted)), instanceId: \(String(describing: instanceId)), iops: \(String(describing: iops)), mountPoint: \(String(describing: mountPoint)), name: \(String(describing: name)), raidArrayId: \(String(describing: raidArrayId)), region: \(String(describing: region)), size: \(String(describing: size)), status: \(String(describing: status)), volumeId: \(String(describing: volumeId)), volumeType: \(String(describing: volumeType)))"}
}

/// <p>Describes an instance's Amazon EBS volume.</p>
public struct Volume: Equatable {
    /// <p>The volume Availability Zone. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints</a>.</p>
    public let availabilityZone: String?
    /// <p>The device name.</p>
    public let device: String?
    /// <p>The Amazon EC2 volume ID.</p>
    public let ec2VolumeId: String?
    /// <p>Specifies whether an Amazon EBS volume is encrypted. For more information,
    ///             see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a>.</p>
    public let encrypted: Bool?
    /// <p>The instance ID.</p>
    public let instanceId: String?
    /// <p>For PIOPS volumes, the IOPS per disk.</p>
    public let iops: Int?
    /// <p>The volume mount point. For example, "/mnt/disk1".</p>
    public let mountPoint: String?
    /// <p>The volume name.</p>
    public let name: String?
    /// <p>The RAID array ID.</p>
    public let raidArrayId: String?
    /// <p>The AWS region. For more information about AWS regions, see <a href="https://docs.aws.amazon.com/general/latest/gr/rande.html">Regions and Endpoints</a>.</p>
    public let region: String?
    /// <p>The volume size.</p>
    public let size: Int?
    /// <p>The value returned by <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeVolumes.html">DescribeVolumes</a>.</p>
    public let status: String?
    /// <p>The volume ID.</p>
    public let volumeId: String?
    /// <p>The volume type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">
    ///           Amazon EBS Volume Types</a>.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>standard</code> - Magnetic. Magnetic volumes must have a minimum size of 1 GiB and a maximum size of 1024 GiB.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>io1</code> - Provisioned IOPS (SSD). PIOPS volumes must have a minimum size of 4 GiB and a maximum size of 16384 GiB.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>gp2</code> - General Purpose (SSD). General purpose volumes must have a minimum size of 1 GiB and a maximum size of 16384 GiB.</p>
    ///             </li>
    ///             <li>
    ///               <p>
    ///                   <code>st1</code> - Throughput Optimized hard disk drive (HDD). Throughput optimized HDD volumes must have a minimum size of 500 GiB and a maximum size of 16384 GiB.</p>
    ///             </li>
    ///             <li>
    ///               <p>
    ///                   <code>sc1</code> - Cold HDD. Cold HDD volumes must have a minimum size of 500 GiB and a maximum size of 16384 GiB.</p>
    ///             </li>
    ///          </ul>
    public let volumeType: String?

    public init (
        availabilityZone: String? = nil,
        device: String? = nil,
        ec2VolumeId: String? = nil,
        encrypted: Bool? = nil,
        instanceId: String? = nil,
        iops: Int? = nil,
        mountPoint: String? = nil,
        name: String? = nil,
        raidArrayId: String? = nil,
        region: String? = nil,
        size: Int? = nil,
        status: String? = nil,
        volumeId: String? = nil,
        volumeType: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.device = device
        self.ec2VolumeId = ec2VolumeId
        self.encrypted = encrypted
        self.instanceId = instanceId
        self.iops = iops
        self.mountPoint = mountPoint
        self.name = name
        self.raidArrayId = raidArrayId
        self.region = region
        self.size = size
        self.status = status
        self.volumeId = volumeId
        self.volumeType = volumeType
    }
}

extension VolumeConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encrypted = "Encrypted"
        case iops = "Iops"
        case mountPoint = "MountPoint"
        case numberOfDisks = "NumberOfDisks"
        case raidLevel = "RaidLevel"
        case size = "Size"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let iops = iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let mountPoint = mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let numberOfDisks = numberOfDisks {
            try encodeContainer.encode(numberOfDisks, forKey: .numberOfDisks)
        }
        if let raidLevel = raidLevel {
            try encodeContainer.encode(raidLevel, forKey: .raidLevel)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mountPointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
        let raidLevelDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .raidLevel)
        raidLevel = raidLevelDecoded
        let numberOfDisksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfDisks)
        numberOfDisks = numberOfDisksDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .size)
        size = sizeDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .iops)
        iops = iopsDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
    }
}

extension VolumeConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VolumeConfiguration(encrypted: \(String(describing: encrypted)), iops: \(String(describing: iops)), mountPoint: \(String(describing: mountPoint)), numberOfDisks: \(String(describing: numberOfDisks)), raidLevel: \(String(describing: raidLevel)), size: \(String(describing: size)), volumeType: \(String(describing: volumeType)))"}
}

/// <p>Describes an Amazon EBS volume configuration.</p>
public struct VolumeConfiguration: Equatable {
    /// <p>Specifies whether an Amazon EBS volume is encrypted. For more information,
    ///             see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a>.</p>
    public let encrypted: Bool?
    /// <p>For PIOPS volumes, the IOPS per disk.</p>
    public let iops: Int?
    /// <p>The volume mount point. For example "/dev/sdh".</p>
    public let mountPoint: String?
    /// <p>The number of disks in the volume.</p>
    public let numberOfDisks: Int?
    /// <p>The volume <a href="http://en.wikipedia.org/wiki/Standard_RAID_levels">RAID level</a>.</p>
    public let raidLevel: Int?
    /// <p>The volume size.</p>
    public let size: Int?
    /// <p>The volume type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">
    ///           Amazon EBS Volume Types</a>.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>standard</code> - Magnetic. Magnetic volumes must have a minimum size of 1 GiB and a maximum size of 1024 GiB.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>io1</code> - Provisioned IOPS (SSD). PIOPS volumes must have a minimum size of 4 GiB and a maximum size of 16384 GiB.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>gp2</code> - General Purpose (SSD). General purpose volumes must have a minimum size of 1 GiB and a maximum size of 16384 GiB.</p>
    ///             </li>
    ///             <li>
    ///               <p>
    ///                   <code>st1</code> - Throughput Optimized hard disk drive (HDD). Throughput optimized HDD volumes must have a minimum size of 500 GiB and a maximum size of 16384 GiB.</p>
    ///             </li>
    ///             <li>
    ///               <p>
    ///                   <code>sc1</code> - Cold HDD. Cold HDD volumes must have a minimum size of 500 GiB and a maximum size of 16384 GiB.</p>
    ///             </li>
    ///          </ul>
    public let volumeType: String?

    public init (
        encrypted: Bool? = nil,
        iops: Int? = nil,
        mountPoint: String? = nil,
        numberOfDisks: Int? = nil,
        raidLevel: Int? = nil,
        size: Int? = nil,
        volumeType: String? = nil
    )
    {
        self.encrypted = encrypted
        self.iops = iops
        self.mountPoint = mountPoint
        self.numberOfDisks = numberOfDisks
        self.raidLevel = raidLevel
        self.size = size
        self.volumeType = volumeType
    }
}

public enum VolumeType {
    case gp2
    case io1
    case standard
    case sdkUnknown(String)
}

extension VolumeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VolumeType] {
        return [
            .gp2,
            .io1,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .gp2: return "gp2"
        case .io1: return "io1"
        case .standard: return "standard"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VolumeType(rawValue: rawValue) ?? VolumeType.sdkUnknown(rawValue)
    }
}

extension WeeklyAutoScalingSchedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case friday = "Friday"
        case monday = "Monday"
        case saturday = "Saturday"
        case sunday = "Sunday"
        case thursday = "Thursday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let friday = friday {
            var fridayContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .friday)
            for (dictKey0, dailyautoscalingschedule0) in friday {
                try fridayContainer.encode(dailyautoscalingschedule0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let monday = monday {
            var mondayContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .monday)
            for (dictKey0, dailyautoscalingschedule0) in monday {
                try mondayContainer.encode(dailyautoscalingschedule0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let saturday = saturday {
            var saturdayContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .saturday)
            for (dictKey0, dailyautoscalingschedule0) in saturday {
                try saturdayContainer.encode(dailyautoscalingschedule0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let sunday = sunday {
            var sundayContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .sunday)
            for (dictKey0, dailyautoscalingschedule0) in sunday {
                try sundayContainer.encode(dailyautoscalingschedule0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let thursday = thursday {
            var thursdayContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .thursday)
            for (dictKey0, dailyautoscalingschedule0) in thursday {
                try thursdayContainer.encode(dailyautoscalingschedule0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tuesday = tuesday {
            var tuesdayContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tuesday)
            for (dictKey0, dailyautoscalingschedule0) in tuesday {
                try tuesdayContainer.encode(dailyautoscalingschedule0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let wednesday = wednesday {
            var wednesdayContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .wednesday)
            for (dictKey0, dailyautoscalingschedule0) in wednesday {
                try wednesdayContainer.encode(dailyautoscalingschedule0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mondayContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .monday)
        var mondayDecoded0: [String:String]? = nil
        if let mondayContainer = mondayContainer {
            mondayDecoded0 = [String:String]()
            for (key0, switch0) in mondayContainer {
                if let switch0 = switch0 {
                    mondayDecoded0?[key0] = switch0
                }
            }
        }
        monday = mondayDecoded0
        let tuesdayContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tuesday)
        var tuesdayDecoded0: [String:String]? = nil
        if let tuesdayContainer = tuesdayContainer {
            tuesdayDecoded0 = [String:String]()
            for (key0, switch0) in tuesdayContainer {
                if let switch0 = switch0 {
                    tuesdayDecoded0?[key0] = switch0
                }
            }
        }
        tuesday = tuesdayDecoded0
        let wednesdayContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .wednesday)
        var wednesdayDecoded0: [String:String]? = nil
        if let wednesdayContainer = wednesdayContainer {
            wednesdayDecoded0 = [String:String]()
            for (key0, switch0) in wednesdayContainer {
                if let switch0 = switch0 {
                    wednesdayDecoded0?[key0] = switch0
                }
            }
        }
        wednesday = wednesdayDecoded0
        let thursdayContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .thursday)
        var thursdayDecoded0: [String:String]? = nil
        if let thursdayContainer = thursdayContainer {
            thursdayDecoded0 = [String:String]()
            for (key0, switch0) in thursdayContainer {
                if let switch0 = switch0 {
                    thursdayDecoded0?[key0] = switch0
                }
            }
        }
        thursday = thursdayDecoded0
        let fridayContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .friday)
        var fridayDecoded0: [String:String]? = nil
        if let fridayContainer = fridayContainer {
            fridayDecoded0 = [String:String]()
            for (key0, switch0) in fridayContainer {
                if let switch0 = switch0 {
                    fridayDecoded0?[key0] = switch0
                }
            }
        }
        friday = fridayDecoded0
        let saturdayContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .saturday)
        var saturdayDecoded0: [String:String]? = nil
        if let saturdayContainer = saturdayContainer {
            saturdayDecoded0 = [String:String]()
            for (key0, switch0) in saturdayContainer {
                if let switch0 = switch0 {
                    saturdayDecoded0?[key0] = switch0
                }
            }
        }
        saturday = saturdayDecoded0
        let sundayContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .sunday)
        var sundayDecoded0: [String:String]? = nil
        if let sundayContainer = sundayContainer {
            sundayDecoded0 = [String:String]()
            for (key0, switch0) in sundayContainer {
                if let switch0 = switch0 {
                    sundayDecoded0?[key0] = switch0
                }
            }
        }
        sunday = sundayDecoded0
    }
}

extension WeeklyAutoScalingSchedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WeeklyAutoScalingSchedule(friday: \(String(describing: friday)), monday: \(String(describing: monday)), saturday: \(String(describing: saturday)), sunday: \(String(describing: sunday)), thursday: \(String(describing: thursday)), tuesday: \(String(describing: tuesday)), wednesday: \(String(describing: wednesday)))"}
}

/// <p>Describes a time-based instance's auto scaling schedule. The schedule consists of a set of key-value pairs.</p>
///          <ul>
///             <li>
///                <p>The key is the time period (a UTC hour) and must be an integer from 0 - 23.</p>
///             </li>
///             <li>
///                <p>The value indicates whether the instance should be online or offline for the specified period, and must be set to "on" or "off"</p>
///             </li>
///          </ul>
///          <p>The default setting for all time periods is off, so you use the following parameters primarily to specify the online periods. You don't have to explicitly specify offline periods unless you want to change an online period to an offline period.</p>
///          <p>The following example specifies that the instance should be online for four hours, from UTC 1200 - 1600. It will be off for the remainder of the day.</p>
///          <p>
///             <code> { "12":"on", "13":"on", "14":"on", "15":"on" } </code>
///          </p>
public struct WeeklyAutoScalingSchedule: Equatable {
    /// <p>The schedule for Friday.</p>
    public let friday: [String:String]?
    /// <p>The schedule for Monday.</p>
    public let monday: [String:String]?
    /// <p>The schedule for Saturday.</p>
    public let saturday: [String:String]?
    /// <p>The schedule for Sunday.</p>
    public let sunday: [String:String]?
    /// <p>The schedule for Thursday.</p>
    public let thursday: [String:String]?
    /// <p>The schedule for Tuesday.</p>
    public let tuesday: [String:String]?
    /// <p>The schedule for Wednesday.</p>
    public let wednesday: [String:String]?

    public init (
        friday: [String:String]? = nil,
        monday: [String:String]? = nil,
        saturday: [String:String]? = nil,
        sunday: [String:String]? = nil,
        thursday: [String:String]? = nil,
        tuesday: [String:String]? = nil,
        wednesday: [String:String]? = nil
    )
    {
        self.friday = friday
        self.monday = monday
        self.saturday = saturday
        self.sunday = sunday
        self.thursday = thursday
        self.tuesday = tuesday
        self.wednesday = wednesday
    }
}
