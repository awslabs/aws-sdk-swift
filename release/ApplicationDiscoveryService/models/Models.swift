// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AgentConfigurationStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentId
        case description
        case operationSucceeded
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if operationSucceeded != false {
            try encodeContainer.encode(operationSucceeded, forKey: .operationSucceeded)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let operationSucceededDecoded = try containerValues.decode(Bool.self, forKey: .operationSucceeded)
        operationSucceeded = operationSucceededDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AgentConfigurationStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AgentConfigurationStatus(agentId: \(String(describing: agentId)), description: \(String(describing: description)), operationSucceeded: \(String(describing: operationSucceeded)))"}
}

/// <p>Information about agents or connectors that were instructed to start collecting data.
///       Information includes the agent/connector ID, a description of the operation, and whether the
///       agent/connector configuration was updated.</p>
public struct AgentConfigurationStatus: Equatable {
    /// <p>The agent/connector ID.</p>
    public let agentId: String?
    /// <p>A description of the operation performed.</p>
    public let description: String?
    /// <p>Information about the status of the <code>StartDataCollection</code> and
    ///         <code>StopDataCollection</code> operations. The system has recorded the data collection
    ///       operation. The agent/connector receives this command the next time it polls for a new command.
    ///     </p>
    public let operationSucceeded: Bool

    public init (
        agentId: String? = nil,
        description: String? = nil,
        operationSucceeded: Bool = false
    )
    {
        self.agentId = agentId
        self.description = description
        self.operationSucceeded = operationSucceeded
    }
}

extension AgentInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentId
        case agentNetworkInfoList
        case agentType
        case collectionStatus
        case connectorId
        case health
        case hostName
        case lastHealthPingTime
        case registeredTime
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentNetworkInfoList = agentNetworkInfoList {
            var agentNetworkInfoListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentNetworkInfoList)
            for agentnetworkinfolist0 in agentNetworkInfoList {
                try agentNetworkInfoListContainer.encode(agentnetworkinfolist0)
            }
        }
        if let agentType = agentType {
            try encodeContainer.encode(agentType, forKey: .agentType)
        }
        if let collectionStatus = collectionStatus {
            try encodeContainer.encode(collectionStatus, forKey: .collectionStatus)
        }
        if let connectorId = connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let health = health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let hostName = hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let lastHealthPingTime = lastHealthPingTime {
            try encodeContainer.encode(lastHealthPingTime, forKey: .lastHealthPingTime)
        }
        if let registeredTime = registeredTime {
            try encodeContainer.encode(registeredTime, forKey: .registeredTime)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let hostNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let agentNetworkInfoListContainer = try containerValues.decodeIfPresent([AgentNetworkInfo?].self, forKey: .agentNetworkInfoList)
        var agentNetworkInfoListDecoded0:[AgentNetworkInfo]? = nil
        if let agentNetworkInfoListContainer = agentNetworkInfoListContainer {
            agentNetworkInfoListDecoded0 = [AgentNetworkInfo]()
            for structure0 in agentNetworkInfoListContainer {
                if let structure0 = structure0 {
                    agentNetworkInfoListDecoded0?.append(structure0)
                }
            }
        }
        agentNetworkInfoList = agentNetworkInfoListDecoded0
        let connectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let healthDecoded = try containerValues.decodeIfPresent(AgentStatus.self, forKey: .health)
        health = healthDecoded
        let lastHealthPingTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastHealthPingTime)
        lastHealthPingTime = lastHealthPingTimeDecoded
        let collectionStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .collectionStatus)
        collectionStatus = collectionStatusDecoded
        let agentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentType)
        agentType = agentTypeDecoded
        let registeredTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registeredTime)
        registeredTime = registeredTimeDecoded
    }
}

extension AgentInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AgentInfo(agentId: \(String(describing: agentId)), agentNetworkInfoList: \(String(describing: agentNetworkInfoList)), agentType: \(String(describing: agentType)), collectionStatus: \(String(describing: collectionStatus)), connectorId: \(String(describing: connectorId)), health: \(String(describing: health)), hostName: \(String(describing: hostName)), lastHealthPingTime: \(String(describing: lastHealthPingTime)), registeredTime: \(String(describing: registeredTime)), version: \(String(describing: version)))"}
}

/// <p>Information about agents or connectors associated with the userâ€™s AWS account.
///       Information includes agent or connector IDs, IP addresses, media access control (MAC)
///       addresses, agent or connector health, hostname where the agent or connector resides, and agent
///       version for each agent.</p>
public struct AgentInfo: Equatable {
    /// <p>The agent or connector ID.</p>
    public let agentId: String?
    /// <p>Network details about the host where the agent or connector resides.</p>
    public let agentNetworkInfoList: [AgentNetworkInfo]?
    /// <p>Type of agent.</p>
    public let agentType: String?
    /// <p>Status of the collection process for an agent or connector.</p>
    public let collectionStatus: String?
    /// <p>The ID of the connector.</p>
    public let connectorId: String?
    /// <p>The health of the agent or connector.</p>
    public let health: AgentStatus?
    /// <p>The name of the host where the agent or connector resides. The host can be a server or
    ///       virtual machine.</p>
    public let hostName: String?
    /// <p>Time since agent or connector health was reported.</p>
    public let lastHealthPingTime: String?
    /// <p>Agent's first registration timestamp in UTC.</p>
    public let registeredTime: String?
    /// <p>The agent or connector version.</p>
    public let version: String?

    public init (
        agentId: String? = nil,
        agentNetworkInfoList: [AgentNetworkInfo]? = nil,
        agentType: String? = nil,
        collectionStatus: String? = nil,
        connectorId: String? = nil,
        health: AgentStatus? = nil,
        hostName: String? = nil,
        lastHealthPingTime: String? = nil,
        registeredTime: String? = nil,
        version: String? = nil
    )
    {
        self.agentId = agentId
        self.agentNetworkInfoList = agentNetworkInfoList
        self.agentType = agentType
        self.collectionStatus = collectionStatus
        self.connectorId = connectorId
        self.health = health
        self.hostName = hostName
        self.lastHealthPingTime = lastHealthPingTime
        self.registeredTime = registeredTime
        self.version = version
    }
}

extension AgentNetworkInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipAddress
        case macAddress
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let macAddress = macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
    }
}

extension AgentNetworkInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AgentNetworkInfo(ipAddress: \(String(describing: ipAddress)), macAddress: \(String(describing: macAddress)))"}
}

/// <p>Network details about the host where the agent/connector resides.</p>
public struct AgentNetworkInfo: Equatable {
    /// <p>The IP address for the host where the agent/connector resides.</p>
    public let ipAddress: String?
    /// <p>The MAC address for the host where the agent/connector resides.</p>
    public let macAddress: String?

    public init (
        ipAddress: String? = nil,
        macAddress: String? = nil
    )
    {
        self.ipAddress = ipAddress
        self.macAddress = macAddress
    }
}

public enum AgentStatus {
    case blacklisted
    case healthy
    case running
    case shutdown
    case unhealthy
    case unknown
    case sdkUnknown(String)
}

extension AgentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AgentStatus] {
        return [
            .blacklisted,
            .healthy,
            .running,
            .shutdown,
            .unhealthy,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .blacklisted: return "BLACKLISTED"
        case .healthy: return "HEALTHY"
        case .running: return "RUNNING"
        case .shutdown: return "SHUTDOWN"
        case .unhealthy: return "UNHEALTHY"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AgentStatus(rawValue: rawValue) ?? AgentStatus.sdkUnknown(rawValue)
    }
}

public struct AssociateConfigurationItemsToApplicationInputBodyMiddleware: Middleware {
    public let id: String = "AssociateConfigurationItemsToApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateConfigurationItemsToApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateConfigurationItemsToApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateConfigurationItemsToApplicationInput>
    public typealias MOutput = OperationOutput<AssociateConfigurationItemsToApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateConfigurationItemsToApplicationOutputError>
}

extension AssociateConfigurationItemsToApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateConfigurationItemsToApplicationInput(applicationConfigurationId: \(String(describing: applicationConfigurationId)), configurationIds: \(String(describing: configurationIds)))"}
}

extension AssociateConfigurationItemsToApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationConfigurationId
        case configurationIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfigurationId = applicationConfigurationId {
            try encodeContainer.encode(applicationConfigurationId, forKey: .applicationConfigurationId)
        }
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationidlist0 in configurationIds {
                try configurationIdsContainer.encode(configurationidlist0)
            }
        }
    }
}

public struct AssociateConfigurationItemsToApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateConfigurationItemsToApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateConfigurationItemsToApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateConfigurationItemsToApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateConfigurationItemsToApplicationInput>
    public typealias MOutput = OperationOutput<AssociateConfigurationItemsToApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateConfigurationItemsToApplicationOutputError>
}

public struct AssociateConfigurationItemsToApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateConfigurationItemsToApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateConfigurationItemsToApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateConfigurationItemsToApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateConfigurationItemsToApplicationInput>
    public typealias MOutput = OperationOutput<AssociateConfigurationItemsToApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateConfigurationItemsToApplicationOutputError>
}

public struct AssociateConfigurationItemsToApplicationInput: Equatable {
    /// <p>The configuration ID of an application with which items are to be associated.</p>
    public let applicationConfigurationId: String?
    /// <p>The ID of each configuration item to be associated with an application.</p>
    public let configurationIds: [String]?

    public init (
        applicationConfigurationId: String? = nil,
        configurationIds: [String]? = nil
    )
    {
        self.applicationConfigurationId = applicationConfigurationId
        self.configurationIds = configurationIds
    }
}

struct AssociateConfigurationItemsToApplicationInputBody: Equatable {
    public let applicationConfigurationId: String?
    public let configurationIds: [String]?
}

extension AssociateConfigurationItemsToApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationConfigurationId
        case configurationIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationConfigurationId)
        applicationConfigurationId = applicationConfigurationIdDecoded
        let configurationIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
    }
}

extension AssociateConfigurationItemsToApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateConfigurationItemsToApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateConfigurationItemsToApplicationOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateConfigurationItemsToApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateConfigurationItemsToApplicationOutputResponse()"}
}

extension AssociateConfigurationItemsToApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateConfigurationItemsToApplicationOutputResponse: Equatable {

    public init() {}
}

struct AssociateConfigurationItemsToApplicationOutputResponseBody: Equatable {
}

extension AssociateConfigurationItemsToApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AuthorizationErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationErrorException(message: \(String(describing: message)))"}
}

extension AuthorizationErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AuthorizationErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS user account does not have permission to perform the action. Check the IAM
///       policy associated with this account.</p>
public struct AuthorizationErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationErrorExceptionBody: Equatable {
    public let message: String?
}

extension AuthorizationErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchDeleteImportDataError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorDescription
        case importTaskId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorDescription = errorDescription {
            try encodeContainer.encode(errorDescription, forKey: .errorDescription)
        }
        if let importTaskId = importTaskId {
            try encodeContainer.encode(importTaskId, forKey: .importTaskId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importTaskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importTaskId)
        importTaskId = importTaskIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(BatchDeleteImportDataErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorDescription)
        errorDescription = errorDescriptionDecoded
    }
}

extension BatchDeleteImportDataError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteImportDataError(errorCode: \(String(describing: errorCode)), errorDescription: \(String(describing: errorDescription)), importTaskId: \(String(describing: importTaskId)))"}
}

/// <p>Error messages returned for each import task that you deleted as a response for this
///       command.</p>
public struct BatchDeleteImportDataError: Equatable {
    /// <p>The type of error that occurred for a specific import task.</p>
    public let errorCode: BatchDeleteImportDataErrorCode?
    /// <p>The description of the error that occurred for a specific import task.</p>
    public let errorDescription: String?
    /// <p>The unique import ID associated with the error that occurred.</p>
    public let importTaskId: String?

    public init (
        errorCode: BatchDeleteImportDataErrorCode? = nil,
        errorDescription: String? = nil,
        importTaskId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorDescription = errorDescription
        self.importTaskId = importTaskId
    }
}

public enum BatchDeleteImportDataErrorCode {
    case internalServerError
    case notFound
    case overLimit
    case sdkUnknown(String)
}

extension BatchDeleteImportDataErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BatchDeleteImportDataErrorCode] {
        return [
            .internalServerError,
            .notFound,
            .overLimit,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalServerError: return "INTERNAL_SERVER_ERROR"
        case .notFound: return "NOT_FOUND"
        case .overLimit: return "OVER_LIMIT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BatchDeleteImportDataErrorCode(rawValue: rawValue) ?? BatchDeleteImportDataErrorCode.sdkUnknown(rawValue)
    }
}

public struct BatchDeleteImportDataInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteImportDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteImportDataInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteImportDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteImportDataInput>
    public typealias MOutput = OperationOutput<BatchDeleteImportDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteImportDataOutputError>
}

extension BatchDeleteImportDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteImportDataInput(importTaskIds: \(String(describing: importTaskIds)))"}
}

extension BatchDeleteImportDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case importTaskIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importTaskIds = importTaskIds {
            var importTaskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .importTaskIds)
            for todeleteidentifierlist0 in importTaskIds {
                try importTaskIdsContainer.encode(todeleteidentifierlist0)
            }
        }
    }
}

public struct BatchDeleteImportDataInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteImportDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteImportDataInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteImportDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteImportDataInput>
    public typealias MOutput = OperationOutput<BatchDeleteImportDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteImportDataOutputError>
}

public struct BatchDeleteImportDataInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteImportDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteImportDataInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteImportDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteImportDataInput>
    public typealias MOutput = OperationOutput<BatchDeleteImportDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteImportDataOutputError>
}

public struct BatchDeleteImportDataInput: Equatable {
    /// <p>The IDs for the import tasks that you want to delete.</p>
    public let importTaskIds: [String]?

    public init (
        importTaskIds: [String]? = nil
    )
    {
        self.importTaskIds = importTaskIds
    }
}

struct BatchDeleteImportDataInputBody: Equatable {
    public let importTaskIds: [String]?
}

extension BatchDeleteImportDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importTaskIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importTaskIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .importTaskIds)
        var importTaskIdsDecoded0:[String]? = nil
        if let importTaskIdsContainer = importTaskIdsContainer {
            importTaskIdsDecoded0 = [String]()
            for string0 in importTaskIdsContainer {
                if let string0 = string0 {
                    importTaskIdsDecoded0?.append(string0)
                }
            }
        }
        importTaskIds = importTaskIdsDecoded0
    }
}

extension BatchDeleteImportDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteImportDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteImportDataOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteImportDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteImportDataOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchDeleteImportDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteImportDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteImportDataOutputResponse: Equatable {
    /// <p>Error messages returned for each import task that you deleted as a response for this
    ///       command.</p>
    public let errors: [BatchDeleteImportDataError]?

    public init (
        errors: [BatchDeleteImportDataError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteImportDataOutputResponseBody: Equatable {
    public let errors: [BatchDeleteImportDataError]?
}

extension BatchDeleteImportDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([BatchDeleteImportDataError?].self, forKey: .errors)
        var errorsDecoded0:[BatchDeleteImportDataError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchDeleteImportDataError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public enum ConfigurationItemType {
    case application
    case connections
    case process
    case server
    case sdkUnknown(String)
}

extension ConfigurationItemType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationItemType] {
        return [
            .application,
            .connections,
            .process,
            .server,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .application: return "APPLICATION"
        case .connections: return "CONNECTION"
        case .process: return "PROCESS"
        case .server: return "SERVER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationItemType(rawValue: rawValue) ?? ConfigurationItemType.sdkUnknown(rawValue)
    }
}

extension ConfigurationTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationId
        case configurationType
        case key
        case timeOfCreation
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if let configurationType = configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let timeOfCreation = timeOfCreation {
            try encodeContainer.encode(timeOfCreation.timeIntervalSince1970, forKey: .timeOfCreation)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(ConfigurationItemType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let configurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let timeOfCreationDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timeOfCreation)
        timeOfCreation = timeOfCreationDecoded
    }
}

extension ConfigurationTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationTag(configurationId: \(String(describing: configurationId)), configurationType: \(String(describing: configurationType)), key: \(String(describing: key)), timeOfCreation: \(String(describing: timeOfCreation)), value: \(String(describing: value)))"}
}

/// <p>Tags for a configuration item. Tags are metadata that help you categorize IT
///       assets.</p>
public struct ConfigurationTag: Equatable {
    /// <p>The configuration ID for the item to tag. You can specify a list of keys and
    ///       values.</p>
    public let configurationId: String?
    /// <p>A type of IT asset to tag.</p>
    public let configurationType: ConfigurationItemType?
    /// <p>A type of tag on which to filter. For example,
    ///       <i>serverType</i>.</p>
    public let key: String?
    /// <p>The time the configuration tag was created in Coordinated Universal Time
    ///       (UTC).</p>
    public let timeOfCreation: Date?
    /// <p>A value on which to filter. For example <i>key = serverType</i> and
    ///         <i>value = web server</i>.</p>
    public let value: String?

    public init (
        configurationId: String? = nil,
        configurationType: ConfigurationItemType? = nil,
        key: String? = nil,
        timeOfCreation: Date? = nil,
        value: String? = nil
    )
    {
        self.configurationId = configurationId
        self.configurationType = configurationType
        self.key = key
        self.timeOfCreation = timeOfCreation
        self.value = value
    }
}

extension ConflictErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictErrorException(message: \(String(describing: message)))"}
}

extension ConflictErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ConflictErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictErrorExceptionBody: Equatable {
    public let message: String?
}

extension ConflictErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ContinuousExportDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSource
        case exportId
        case s3Bucket
        case schemaStorageConfig
        case startTime
        case status
        case statusDetail
        case stopTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let exportId = exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let schemaStorageConfig = schemaStorageConfig {
            var schemaStorageConfigContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .schemaStorageConfig)
            for (dictKey0, schemastorageconfig0) in schemaStorageConfig {
                try schemaStorageConfigContainer.encode(schemastorageconfig0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetail = statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
        if let stopTime = stopTime {
            try encodeContainer.encode(stopTime.timeIntervalSince1970, forKey: .stopTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ContinuousExportStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopTime)
        stopTime = stopTimeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaStorageConfigContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .schemaStorageConfig)
        var schemaStorageConfigDecoded0: [String:String]? = nil
        if let schemaStorageConfigContainer = schemaStorageConfigContainer {
            schemaStorageConfigDecoded0 = [String:String]()
            for (key0, string0) in schemaStorageConfigContainer {
                if let string0 = string0 {
                    schemaStorageConfigDecoded0?[key0] = string0
                }
            }
        }
        schemaStorageConfig = schemaStorageConfigDecoded0
    }
}

extension ContinuousExportDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContinuousExportDescription(dataSource: \(String(describing: dataSource)), exportId: \(String(describing: exportId)), s3Bucket: \(String(describing: s3Bucket)), schemaStorageConfig: \(String(describing: schemaStorageConfig)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), statusDetail: \(String(describing: statusDetail)), stopTime: \(String(describing: stopTime)))"}
}

/// <p>A list of continuous export descriptions.</p>
public struct ContinuousExportDescription: Equatable {
    /// <p>The type of data collector used to gather this data (currently only offered for
    ///       AGENT).</p>
    public let dataSource: DataSource?
    /// <p>The unique ID assigned to this export.</p>
    public let exportId: String?
    /// <p>The name of the s3 bucket where the export data parquet files are stored.</p>
    public let s3Bucket: String?
    /// <p>An object which describes how the data is stored.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>databaseName</code> - the name of the Glue database used to store the
    ///           schema.</p>
    ///             </li>
    ///          </ul>
    public let schemaStorageConfig: [String:String]?
    /// <p>The timestamp representing when the continuous export was started.</p>
    public let startTime: Date?
    /// <p>Describes the status of the export. Can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>START_IN_PROGRESS - setting up resources to start continuous export.</p>
    ///             </li>
    ///             <li>
    ///                <p>START_FAILED - an error occurred setting up continuous export. To recover, call
    ///           start-continuous-export again.</p>
    ///             </li>
    ///             <li>
    ///                <p>ACTIVE - data is being exported to the customer bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>ERROR - an error occurred during export. To fix the issue, call
    ///           stop-continuous-export and start-continuous-export.</p>
    ///             </li>
    ///             <li>
    ///                <p>STOP_IN_PROGRESS - stopping the export.</p>
    ///             </li>
    ///             <li>
    ///                <p>STOP_FAILED - an error occurred stopping the export. To recover, call
    ///           stop-continuous-export again.</p>
    ///             </li>
    ///             <li>
    ///                <p>INACTIVE - the continuous export has been stopped. Data is no longer being exported
    ///           to the customer bucket.</p>
    ///             </li>
    ///          </ul>
    public let status: ContinuousExportStatus?
    /// <p>Contains information about any errors that have occurred. This data type can have the
    ///       following values:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>ACCESS_DENIED - You donâ€™t have permission to start Data Exploration in Amazon
    ///           Athena. Contact your AWS administrator for help. For more information, see <a href="http://docs.aws.amazon.com/application-discovery/latest/userguide/setting-up.html">Setting Up AWS Application Discovery Service</a> in the Application Discovery
    ///           Service User Guide.</p>
    ///             </li>
    ///             <li>
    ///                <p>DELIVERY_STREAM_LIMIT_FAILURE - You reached the limit for Amazon Kinesis Data
    ///           Firehose delivery streams. Reduce the number of streams or request a limit increase and
    ///           try again. For more information, see <a href="http://docs.aws.amazon.com/streams/latest/dev/service-sizes-and-limits.html">Kinesis Data Streams Limits</a> in the Amazon Kinesis Data Streams Developer
    ///           Guide.</p>
    ///             </li>
    ///             <li>
    ///                <p>FIREHOSE_ROLE_MISSING - The Data Exploration feature is in an error state because
    ///           your IAM User is missing the AWSApplicationDiscoveryServiceFirehose role. Turn on Data
    ///           Exploration in Amazon Athena and try again. For more information, see <a href="http://docs.aws.amazon.com/application-discovery/latest/userguide/setting-up.html#setting-up-user-policy">Step 3: Provide Application Discovery Service Access to Non-Administrator Users by
    ///             Attaching Policies</a> in the Application Discovery Service User Guide.</p>
    ///             </li>
    ///             <li>
    ///                <p>FIREHOSE_STREAM_DOES_NOT_EXIST - The Data Exploration feature is in an error state
    ///           because your IAM User is missing one or more of the Kinesis data delivery
    ///           streams.</p>
    ///             </li>
    ///             <li>
    ///                <p>INTERNAL_FAILURE - The Data Exploration feature is in an error state because of an
    ///           internal failure. Try again later. If this problem persists, contact AWS
    ///           Support.</p>
    ///             </li>
    ///             <li>
    ///                <p>S3_BUCKET_LIMIT_FAILURE - You reached the limit for Amazon S3 buckets. Reduce the
    ///           number of Amazon S3 buckets or request a limit increase and try again. For more
    ///           information, see <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html">Bucket
    ///             Restrictions and Limitations</a> in the Amazon Simple Storage Service Developer
    ///           Guide.</p>
    ///             </li>
    ///             <li>
    ///                <p>S3_NOT_SIGNED_UP - Your account is not signed up for the Amazon S3 service. You
    ///           must sign up before you can use Amazon S3. You can sign up at the following URL: <a href="https://aws.amazon.com/s3">https://aws.amazon.com/s3</a>.</p>
    ///             </li>
    ///          </ul>
    public let statusDetail: String?
    /// <p>The timestamp that represents when this continuous export was stopped.</p>
    public let stopTime: Date?

    public init (
        dataSource: DataSource? = nil,
        exportId: String? = nil,
        s3Bucket: String? = nil,
        schemaStorageConfig: [String:String]? = nil,
        startTime: Date? = nil,
        status: ContinuousExportStatus? = nil,
        statusDetail: String? = nil,
        stopTime: Date? = nil
    )
    {
        self.dataSource = dataSource
        self.exportId = exportId
        self.s3Bucket = s3Bucket
        self.schemaStorageConfig = schemaStorageConfig
        self.startTime = startTime
        self.status = status
        self.statusDetail = statusDetail
        self.stopTime = stopTime
    }
}

public enum ContinuousExportStatus {
    case active
    case error
    case inactive
    case startFailed
    case startInProgress
    case stopFailed
    case stopInProgress
    case sdkUnknown(String)
}

extension ContinuousExportStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContinuousExportStatus] {
        return [
            .active,
            .error,
            .inactive,
            .startFailed,
            .startInProgress,
            .stopFailed,
            .stopInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .error: return "ERROR"
        case .inactive: return "INACTIVE"
        case .startFailed: return "START_FAILED"
        case .startInProgress: return "START_IN_PROGRESS"
        case .stopFailed: return "STOP_FAILED"
        case .stopInProgress: return "STOP_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContinuousExportStatus(rawValue: rawValue) ?? ContinuousExportStatus.sdkUnknown(rawValue)
    }
}

public struct CreateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

extension CreateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationInput(description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension CreateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInput: Equatable {
    /// <p>Description of the application to be created.</p>
    public let description: String?
    /// <p>Name of the application to be created.</p>
    public let name: String?

    public init (
        description: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

struct CreateApplicationInputBody: Equatable {
    public let name: String?
    public let description: String?
}

extension CreateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationOutputResponse(configurationId: \(String(describing: configurationId)))"}
}

extension CreateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationId = output.configurationId
        } else {
            self.configurationId = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Equatable {
    /// <p>Configuration ID of an application to be created.</p>
    public let configurationId: String?

    public init (
        configurationId: String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

struct CreateApplicationOutputResponseBody: Equatable {
    public let configurationId: String?
}

extension CreateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
    }
}

public struct CreateTagsInputBodyMiddleware: Middleware {
    public let id: String = "CreateTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

extension CreateTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTagsInput(configurationIds: \(String(describing: configurationIds)), tags: \(String(describing: tags)))"}
}

extension CreateTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationIds
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationidlist0 in configurationIds {
                try configurationIdsContainer.encode(configurationidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagset0 in tags {
                try tagsContainer.encode(tagset0)
            }
        }
    }
}

public struct CreateTagsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

public struct CreateTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

public struct CreateTagsInput: Equatable {
    /// <p>A list of configuration items that you want to tag.</p>
    public let configurationIds: [String]?
    /// <p>Tags that you want to associate with one or more configuration items. Specify the tags
    ///       that you want to create in a <i>key</i>-<i>value</i> format. For
    ///       example:</p>
    ///          <p>
    ///             <code>{"key": "serverType", "value": "webServer"}</code>
    ///          </p>
    public let tags: [Tag]?

    public init (
        configurationIds: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.configurationIds = configurationIds
        self.tags = tags
    }
}

struct CreateTagsInputBody: Equatable {
    public let configurationIds: [String]?
    public let tags: [Tag]?
}

extension CreateTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationIds
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTagsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTagsOutputResponse()"}
}

extension CreateTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateTagsOutputResponse: Equatable {

    public init() {}
}

struct CreateTagsOutputResponseBody: Equatable {
}

extension CreateTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CustomerAgentInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeAgents
        case blackListedAgents
        case healthyAgents
        case shutdownAgents
        case totalAgents
        case unhealthyAgents
        case unknownAgents
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeAgents != 0 {
            try encodeContainer.encode(activeAgents, forKey: .activeAgents)
        }
        if blackListedAgents != 0 {
            try encodeContainer.encode(blackListedAgents, forKey: .blackListedAgents)
        }
        if healthyAgents != 0 {
            try encodeContainer.encode(healthyAgents, forKey: .healthyAgents)
        }
        if shutdownAgents != 0 {
            try encodeContainer.encode(shutdownAgents, forKey: .shutdownAgents)
        }
        if totalAgents != 0 {
            try encodeContainer.encode(totalAgents, forKey: .totalAgents)
        }
        if unhealthyAgents != 0 {
            try encodeContainer.encode(unhealthyAgents, forKey: .unhealthyAgents)
        }
        if unknownAgents != 0 {
            try encodeContainer.encode(unknownAgents, forKey: .unknownAgents)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeAgentsDecoded = try containerValues.decode(Int.self, forKey: .activeAgents)
        activeAgents = activeAgentsDecoded
        let healthyAgentsDecoded = try containerValues.decode(Int.self, forKey: .healthyAgents)
        healthyAgents = healthyAgentsDecoded
        let blackListedAgentsDecoded = try containerValues.decode(Int.self, forKey: .blackListedAgents)
        blackListedAgents = blackListedAgentsDecoded
        let shutdownAgentsDecoded = try containerValues.decode(Int.self, forKey: .shutdownAgents)
        shutdownAgents = shutdownAgentsDecoded
        let unhealthyAgentsDecoded = try containerValues.decode(Int.self, forKey: .unhealthyAgents)
        unhealthyAgents = unhealthyAgentsDecoded
        let totalAgentsDecoded = try containerValues.decode(Int.self, forKey: .totalAgents)
        totalAgents = totalAgentsDecoded
        let unknownAgentsDecoded = try containerValues.decode(Int.self, forKey: .unknownAgents)
        unknownAgents = unknownAgentsDecoded
    }
}

extension CustomerAgentInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomerAgentInfo(activeAgents: \(String(describing: activeAgents)), blackListedAgents: \(String(describing: blackListedAgents)), healthyAgents: \(String(describing: healthyAgents)), shutdownAgents: \(String(describing: shutdownAgents)), totalAgents: \(String(describing: totalAgents)), unhealthyAgents: \(String(describing: unhealthyAgents)), unknownAgents: \(String(describing: unknownAgents)))"}
}

/// <p>Inventory data for installed discovery agents.</p>
public struct CustomerAgentInfo: Equatable {
    /// <p>Number of active discovery agents.</p>
    public let activeAgents: Int
    /// <p>Number of blacklisted discovery agents.</p>
    public let blackListedAgents: Int
    /// <p>Number of healthy discovery agents</p>
    public let healthyAgents: Int
    /// <p>Number of discovery agents with status SHUTDOWN.</p>
    public let shutdownAgents: Int
    /// <p>Total number of discovery agents.</p>
    public let totalAgents: Int
    /// <p>Number of unhealthy discovery agents.</p>
    public let unhealthyAgents: Int
    /// <p>Number of unknown discovery agents.</p>
    public let unknownAgents: Int

    public init (
        activeAgents: Int = 0,
        blackListedAgents: Int = 0,
        healthyAgents: Int = 0,
        shutdownAgents: Int = 0,
        totalAgents: Int = 0,
        unhealthyAgents: Int = 0,
        unknownAgents: Int = 0
    )
    {
        self.activeAgents = activeAgents
        self.blackListedAgents = blackListedAgents
        self.healthyAgents = healthyAgents
        self.shutdownAgents = shutdownAgents
        self.totalAgents = totalAgents
        self.unhealthyAgents = unhealthyAgents
        self.unknownAgents = unknownAgents
    }
}

extension CustomerConnectorInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeConnectors
        case blackListedConnectors
        case healthyConnectors
        case shutdownConnectors
        case totalConnectors
        case unhealthyConnectors
        case unknownConnectors
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeConnectors != 0 {
            try encodeContainer.encode(activeConnectors, forKey: .activeConnectors)
        }
        if blackListedConnectors != 0 {
            try encodeContainer.encode(blackListedConnectors, forKey: .blackListedConnectors)
        }
        if healthyConnectors != 0 {
            try encodeContainer.encode(healthyConnectors, forKey: .healthyConnectors)
        }
        if shutdownConnectors != 0 {
            try encodeContainer.encode(shutdownConnectors, forKey: .shutdownConnectors)
        }
        if totalConnectors != 0 {
            try encodeContainer.encode(totalConnectors, forKey: .totalConnectors)
        }
        if unhealthyConnectors != 0 {
            try encodeContainer.encode(unhealthyConnectors, forKey: .unhealthyConnectors)
        }
        if unknownConnectors != 0 {
            try encodeContainer.encode(unknownConnectors, forKey: .unknownConnectors)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeConnectorsDecoded = try containerValues.decode(Int.self, forKey: .activeConnectors)
        activeConnectors = activeConnectorsDecoded
        let healthyConnectorsDecoded = try containerValues.decode(Int.self, forKey: .healthyConnectors)
        healthyConnectors = healthyConnectorsDecoded
        let blackListedConnectorsDecoded = try containerValues.decode(Int.self, forKey: .blackListedConnectors)
        blackListedConnectors = blackListedConnectorsDecoded
        let shutdownConnectorsDecoded = try containerValues.decode(Int.self, forKey: .shutdownConnectors)
        shutdownConnectors = shutdownConnectorsDecoded
        let unhealthyConnectorsDecoded = try containerValues.decode(Int.self, forKey: .unhealthyConnectors)
        unhealthyConnectors = unhealthyConnectorsDecoded
        let totalConnectorsDecoded = try containerValues.decode(Int.self, forKey: .totalConnectors)
        totalConnectors = totalConnectorsDecoded
        let unknownConnectorsDecoded = try containerValues.decode(Int.self, forKey: .unknownConnectors)
        unknownConnectors = unknownConnectorsDecoded
    }
}

extension CustomerConnectorInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomerConnectorInfo(activeConnectors: \(String(describing: activeConnectors)), blackListedConnectors: \(String(describing: blackListedConnectors)), healthyConnectors: \(String(describing: healthyConnectors)), shutdownConnectors: \(String(describing: shutdownConnectors)), totalConnectors: \(String(describing: totalConnectors)), unhealthyConnectors: \(String(describing: unhealthyConnectors)), unknownConnectors: \(String(describing: unknownConnectors)))"}
}

/// <p>Inventory data for installed discovery connectors.</p>
public struct CustomerConnectorInfo: Equatable {
    /// <p>Number of active discovery connectors.</p>
    public let activeConnectors: Int
    /// <p>Number of blacklisted discovery connectors.</p>
    public let blackListedConnectors: Int
    /// <p>Number of healthy discovery connectors.</p>
    public let healthyConnectors: Int
    /// <p>Number of discovery connectors with status SHUTDOWN,</p>
    public let shutdownConnectors: Int
    /// <p>Total number of discovery connectors.</p>
    public let totalConnectors: Int
    /// <p>Number of unhealthy discovery connectors.</p>
    public let unhealthyConnectors: Int
    /// <p>Number of unknown discovery connectors.</p>
    public let unknownConnectors: Int

    public init (
        activeConnectors: Int = 0,
        blackListedConnectors: Int = 0,
        healthyConnectors: Int = 0,
        shutdownConnectors: Int = 0,
        totalConnectors: Int = 0,
        unhealthyConnectors: Int = 0,
        unknownConnectors: Int = 0
    )
    {
        self.activeConnectors = activeConnectors
        self.blackListedConnectors = blackListedConnectors
        self.healthyConnectors = healthyConnectors
        self.shutdownConnectors = shutdownConnectors
        self.totalConnectors = totalConnectors
        self.unhealthyConnectors = unhealthyConnectors
        self.unknownConnectors = unknownConnectors
    }
}

public enum DataSource {
    case agent
    case sdkUnknown(String)
}

extension DataSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataSource] {
        return [
            .agent,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .agent: return "AGENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataSource(rawValue: rawValue) ?? DataSource.sdkUnknown(rawValue)
    }
}

public struct DeleteApplicationsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationsInput>
    public typealias MOutput = OperationOutput<DeleteApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationsOutputError>
}

extension DeleteApplicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationsInput(configurationIds: \(String(describing: configurationIds)))"}
}

extension DeleteApplicationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for applicationidslist0 in configurationIds {
                try configurationIdsContainer.encode(applicationidslist0)
            }
        }
    }
}

public struct DeleteApplicationsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationsInput>
    public typealias MOutput = OperationOutput<DeleteApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationsOutputError>
}

public struct DeleteApplicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationsInput>
    public typealias MOutput = OperationOutput<DeleteApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationsOutputError>
}

public struct DeleteApplicationsInput: Equatable {
    /// <p>Configuration ID of an application to be deleted.</p>
    public let configurationIds: [String]?

    public init (
        configurationIds: [String]? = nil
    )
    {
        self.configurationIds = configurationIds
    }
}

struct DeleteApplicationsInputBody: Equatable {
    public let configurationIds: [String]?
}

extension DeleteApplicationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
    }
}

extension DeleteApplicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationsOutputResponse()"}
}

extension DeleteApplicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationsOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationsOutputResponseBody: Equatable {
}

extension DeleteApplicationsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTagsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

extension DeleteTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagsInput(configurationIds: \(String(describing: configurationIds)), tags: \(String(describing: tags)))"}
}

extension DeleteTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationIds
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationidlist0 in configurationIds {
                try configurationIdsContainer.encode(configurationidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagset0 in tags {
                try tagsContainer.encode(tagset0)
            }
        }
    }
}

public struct DeleteTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInput: Equatable {
    /// <p>A list of configuration items with tags that you want to delete.</p>
    public let configurationIds: [String]?
    /// <p>Tags that you want to delete from one or more configuration items. Specify the tags
    ///       that you want to delete in a <i>key</i>-<i>value</i> format. For
    ///       example:</p>
    ///          <p>
    ///             <code>{"key": "serverType", "value": "webServer"}</code>
    ///          </p>
    public let tags: [Tag]?

    public init (
        configurationIds: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.configurationIds = configurationIds
        self.tags = tags
    }
}

struct DeleteTagsInputBody: Equatable {
    public let configurationIds: [String]?
    public let tags: [Tag]?
}

extension DeleteTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationIds
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DeleteTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagsOutputResponse()"}
}

extension DeleteTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsOutputResponse: Equatable {

    public init() {}
}

struct DeleteTagsOutputResponseBody: Equatable {
}

extension DeleteTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAgentsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAgentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAgentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAgentsInput>
    public typealias MOutput = OperationOutput<DescribeAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAgentsOutputError>
}

extension DescribeAgentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAgentsInput(agentIds: \(String(describing: agentIds)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAgentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentIds
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentIds = agentIds {
            var agentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentIds)
            for agentids0 in agentIds {
                try agentIdsContainer.encode(agentids0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAgentsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAgentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAgentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAgentsInput>
    public typealias MOutput = OperationOutput<DescribeAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAgentsOutputError>
}

public struct DescribeAgentsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAgentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAgentsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAgentsInput>
    public typealias MOutput = OperationOutput<DescribeAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAgentsOutputError>
}

public struct DescribeAgentsInput: Equatable {
    /// <p>The agent or the Connector IDs for which you want information. If you specify no IDs,
    ///       the system returns information about all agents/Connectors associated with your AWS user
    ///       account.</p>
    public let agentIds: [String]?
    /// <p>You can filter the request using various logical operators and a
    ///         <i>key</i>-<i>value</i> format. For example: </p>
    ///          <p>
    ///             <code>{"key": "collectionStatus", "value": "STARTED"}</code>
    ///          </p>
    public let filters: [Filter]?
    /// <p>The total number of agents/Connectors to return in a single page of output. The maximum
    ///       value is 100.</p>
    public let maxResults: Int
    /// <p>Token to retrieve the next set of results. For example, if you previously specified 100
    ///       IDs for <code>DescribeAgentsRequest$agentIds</code> but set
    ///         <code>DescribeAgentsRequest$maxResults</code> to 10, you received a set of 10 results along
    ///       with a token. Use that token in this query to get the next set of 10.</p>
    public let nextToken: String?

    public init (
        agentIds: [String]? = nil,
        filters: [Filter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.agentIds = agentIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAgentsInputBody: Equatable {
    public let agentIds: [String]?
    public let filters: [Filter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeAgentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentIds
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentIds)
        var agentIdsDecoded0:[String]? = nil
        if let agentIdsContainer = agentIdsContainer {
            agentIdsDecoded0 = [String]()
            for string0 in agentIdsContainer {
                if let string0 = string0 {
                    agentIdsDecoded0?.append(string0)
                }
            }
        }
        agentIds = agentIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAgentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAgentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAgentsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAgentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAgentsOutputResponse(agentsInfo: \(String(describing: agentsInfo)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAgentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAgentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.agentsInfo = output.agentsInfo
            self.nextToken = output.nextToken
        } else {
            self.agentsInfo = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAgentsOutputResponse: Equatable {
    /// <p>Lists agents or the Connector by ID or lists all agents/Connectors associated with your
    ///       user account if you did not specify an agent/Connector ID. The output includes agent/Connector
    ///       IDs, IP addresses, media access control (MAC) addresses, agent/Connector health, host name
    ///       where the agent/Connector resides, and the version number of each agent/Connector.</p>
    public let agentsInfo: [AgentInfo]?
    /// <p>Token to retrieve the next set of results. For example, if you specified 100 IDs for
    ///         <code>DescribeAgentsRequest$agentIds</code> but set
    ///         <code>DescribeAgentsRequest$maxResults</code> to 10, you received a set of 10 results along
    ///       with this token. Use this token in the next query to retrieve the next set of 10.</p>
    public let nextToken: String?

    public init (
        agentsInfo: [AgentInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.agentsInfo = agentsInfo
        self.nextToken = nextToken
    }
}

struct DescribeAgentsOutputResponseBody: Equatable {
    public let agentsInfo: [AgentInfo]?
    public let nextToken: String?
}

extension DescribeAgentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentsInfo
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentsInfoContainer = try containerValues.decodeIfPresent([AgentInfo?].self, forKey: .agentsInfo)
        var agentsInfoDecoded0:[AgentInfo]? = nil
        if let agentsInfoContainer = agentsInfoContainer {
            agentsInfoDecoded0 = [AgentInfo]()
            for structure0 in agentsInfoContainer {
                if let structure0 = structure0 {
                    agentsInfoDecoded0?.append(structure0)
                }
            }
        }
        agentsInfo = agentsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationsOutputError>
}

extension DescribeConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationsInput(configurationIds: \(String(describing: configurationIds)))"}
}

extension DescribeConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationidlist0 in configurationIds {
                try configurationIdsContainer.encode(configurationidlist0)
            }
        }
    }
}

public struct DescribeConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationsOutputError>
}

public struct DescribeConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationsOutputError>
}

public struct DescribeConfigurationsInput: Equatable {
    /// <p>One or more configuration IDs.</p>
    public let configurationIds: [String]?

    public init (
        configurationIds: [String]? = nil
    )
    {
        self.configurationIds = configurationIds
    }
}

struct DescribeConfigurationsInputBody: Equatable {
    public let configurationIds: [String]?
}

extension DescribeConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
    }
}

extension DescribeConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationsOutputResponse(configurations: \(String(describing: configurations)))"}
}

extension DescribeConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurations = output.configurations
        } else {
            self.configurations = nil
        }
    }
}

public struct DescribeConfigurationsOutputResponse: Equatable {
    /// <p>A key in the response map. The value is an array of data.</p>
    public let configurations: [[String:String]]?

    public init (
        configurations: [[String:String]]? = nil
    )
    {
        self.configurations = configurations
    }
}

struct DescribeConfigurationsOutputResponseBody: Equatable {
    public let configurations: [[String:String]]?
}

extension DescribeConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([[String: String?]?].self, forKey: .configurations)
        var configurationsDecoded0:[[String:String]]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [[String:String]]()
            for map0 in configurationsContainer {
                var configurationsContainerDecoded0: [String: String]? = nil
                if let map0 = map0 {
                    configurationsContainerDecoded0 = [String: String]()
                    for (key1, string1) in map0 {
                        if let string1 = string1 {
                            configurationsContainerDecoded0?[key1] = string1
                        }
                    }
                }
                if let configurationsContainerDecoded0 = configurationsContainerDecoded0 {
                    configurationsDecoded0?.append(configurationsContainerDecoded0)
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

public struct DescribeContinuousExportsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeContinuousExportsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeContinuousExportsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeContinuousExportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeContinuousExportsInput>
    public typealias MOutput = OperationOutput<DescribeContinuousExportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeContinuousExportsOutputError>
}

extension DescribeContinuousExportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeContinuousExportsInput(exportIds: \(String(describing: exportIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeContinuousExportsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportIds
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportIds = exportIds {
            var exportIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportIds)
            for continuousexportids0 in exportIds {
                try exportIdsContainer.encode(continuousexportids0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeContinuousExportsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeContinuousExportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeContinuousExportsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeContinuousExportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeContinuousExportsInput>
    public typealias MOutput = OperationOutput<DescribeContinuousExportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeContinuousExportsOutputError>
}

public struct DescribeContinuousExportsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeContinuousExportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeContinuousExportsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeContinuousExportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeContinuousExportsInput>
    public typealias MOutput = OperationOutput<DescribeContinuousExportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeContinuousExportsOutputError>
}

public struct DescribeContinuousExportsInput: Equatable {
    /// <p>The unique IDs assigned to the exports.</p>
    public let exportIds: [String]?
    /// <p>A number between 1 and 100 specifying the maximum number of continuous export
    ///       descriptions returned.</p>
    public let maxResults: Int?
    /// <p>The token from the previous call to <code>DescribeExportTasks</code>.</p>
    public let nextToken: String?

    public init (
        exportIds: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.exportIds = exportIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeContinuousExportsInputBody: Equatable {
    public let exportIds: [String]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeContinuousExportsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportIds
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exportIds)
        var exportIdsDecoded0:[String]? = nil
        if let exportIdsContainer = exportIdsContainer {
            exportIdsDecoded0 = [String]()
            for string0 in exportIdsContainer {
                if let string0 = string0 {
                    exportIdsDecoded0?.append(string0)
                }
            }
        }
        exportIds = exportIdsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeContinuousExportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeContinuousExportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeContinuousExportsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeContinuousExportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeContinuousExportsOutputResponse(descriptions: \(String(describing: descriptions)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeContinuousExportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeContinuousExportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.descriptions = output.descriptions
            self.nextToken = output.nextToken
        } else {
            self.descriptions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeContinuousExportsOutputResponse: Equatable {
    /// <p>A list of continuous export descriptions.</p>
    public let descriptions: [ContinuousExportDescription]?
    /// <p>The token from the previous call to <code>DescribeExportTasks</code>.</p>
    public let nextToken: String?

    public init (
        descriptions: [ContinuousExportDescription]? = nil,
        nextToken: String? = nil
    )
    {
        self.descriptions = descriptions
        self.nextToken = nextToken
    }
}

struct DescribeContinuousExportsOutputResponseBody: Equatable {
    public let descriptions: [ContinuousExportDescription]?
    public let nextToken: String?
}

extension DescribeContinuousExportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case descriptions
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionsContainer = try containerValues.decodeIfPresent([ContinuousExportDescription?].self, forKey: .descriptions)
        var descriptionsDecoded0:[ContinuousExportDescription]? = nil
        if let descriptionsContainer = descriptionsContainer {
            descriptionsDecoded0 = [ContinuousExportDescription]()
            for structure0 in descriptionsContainer {
                if let structure0 = structure0 {
                    descriptionsDecoded0?.append(structure0)
                }
            }
        }
        descriptions = descriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeExportConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeExportConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExportConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExportConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExportConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeExportConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExportConfigurationsOutputError>
}

extension DescribeExportConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExportConfigurationsInput(exportIds: \(String(describing: exportIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeExportConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportIds
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportIds = exportIds {
            var exportIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportIds)
            for exportids0 in exportIds {
                try exportIdsContainer.encode(exportids0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeExportConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeExportConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExportConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExportConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExportConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeExportConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExportConfigurationsOutputError>
}

public struct DescribeExportConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeExportConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExportConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExportConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExportConfigurationsInput>
    public typealias MOutput = OperationOutput<DescribeExportConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExportConfigurationsOutputError>
}

public struct DescribeExportConfigurationsInput: Equatable {
    /// <p>A list of continuous export IDs to search for.</p>
    public let exportIds: [String]?
    /// <p>A number between 1 and 100 specifying the maximum number of continuous export
    ///       descriptions returned.</p>
    public let maxResults: Int
    /// <p>The token from the previous call to describe-export-tasks.</p>
    public let nextToken: String?

    public init (
        exportIds: [String]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.exportIds = exportIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeExportConfigurationsInputBody: Equatable {
    public let exportIds: [String]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeExportConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportIds
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exportIds)
        var exportIdsDecoded0:[String]? = nil
        if let exportIdsContainer = exportIdsContainer {
            exportIdsDecoded0 = [String]()
            for string0 in exportIdsContainer {
                if let string0 = string0 {
                    exportIdsDecoded0?.append(string0)
                }
            }
        }
        exportIds = exportIdsDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeExportConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExportConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExportConfigurationsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExportConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExportConfigurationsOutputResponse(exportsInfo: \(String(describing: exportsInfo)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeExportConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeExportConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exportsInfo = output.exportsInfo
            self.nextToken = output.nextToken
        } else {
            self.exportsInfo = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeExportConfigurationsOutputResponse: Equatable {
    /// <p></p>
    public let exportsInfo: [ExportInfo]?
    /// <p>The token from the previous call to describe-export-tasks.</p>
    public let nextToken: String?

    public init (
        exportsInfo: [ExportInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.exportsInfo = exportsInfo
        self.nextToken = nextToken
    }
}

struct DescribeExportConfigurationsOutputResponseBody: Equatable {
    public let exportsInfo: [ExportInfo]?
    public let nextToken: String?
}

extension DescribeExportConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportsInfo
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportsInfoContainer = try containerValues.decodeIfPresent([ExportInfo?].self, forKey: .exportsInfo)
        var exportsInfoDecoded0:[ExportInfo]? = nil
        if let exportsInfoContainer = exportsInfoContainer {
            exportsInfoDecoded0 = [ExportInfo]()
            for structure0 in exportsInfoContainer {
                if let structure0 = structure0 {
                    exportsInfoDecoded0?.append(structure0)
                }
            }
        }
        exportsInfo = exportsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeExportTasksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeExportTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExportTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExportTasksInput>
    public typealias MOutput = OperationOutput<DescribeExportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExportTasksOutputError>
}

extension DescribeExportTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExportTasksInput(exportIds: \(String(describing: exportIds)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeExportTasksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportIds
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportIds = exportIds {
            var exportIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportIds)
            for exportids0 in exportIds {
                try exportIdsContainer.encode(exportids0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for exportfilters0 in filters {
                try filtersContainer.encode(exportfilters0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeExportTasksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeExportTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExportTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExportTasksInput>
    public typealias MOutput = OperationOutput<DescribeExportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExportTasksOutputError>
}

public struct DescribeExportTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeExportTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExportTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExportTasksInput>
    public typealias MOutput = OperationOutput<DescribeExportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExportTasksOutputError>
}

public struct DescribeExportTasksInput: Equatable {
    /// <p>One or more unique identifiers used to query the status of an export request.</p>
    public let exportIds: [String]?
    /// <p>One or more filters.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AgentId</code> - ID of the agent whose collected data will be
    ///           exported</p>
    ///             </li>
    ///          </ul>
    public let filters: [ExportFilter]?
    /// <p>The maximum number of volume results returned by <code>DescribeExportTasks</code> in
    ///       paginated output. When this parameter is used, <code>DescribeExportTasks</code> only returns
    ///         <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///       response element.</p>
    public let maxResults: Int
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///         <code>DescribeExportTasks</code> request where <code>maxResults</code> was used and the
    ///       results exceeded the value of that parameter. Pagination continues from the end of the
    ///       previous results that returned the <code>nextToken</code> value. This value is null when there
    ///       are no more results to return.</p>
    public let nextToken: String?

    public init (
        exportIds: [String]? = nil,
        filters: [ExportFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.exportIds = exportIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeExportTasksInputBody: Equatable {
    public let exportIds: [String]?
    public let filters: [ExportFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeExportTasksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportIds
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exportIds)
        var exportIdsDecoded0:[String]? = nil
        if let exportIdsContainer = exportIdsContainer {
            exportIdsDecoded0 = [String]()
            for string0 in exportIdsContainer {
                if let string0 = string0 {
                    exportIdsDecoded0?.append(string0)
                }
            }
        }
        exportIds = exportIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ExportFilter?].self, forKey: .filters)
        var filtersDecoded0:[ExportFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ExportFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeExportTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExportTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExportTasksOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExportTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExportTasksOutputResponse(exportsInfo: \(String(describing: exportsInfo)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeExportTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeExportTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exportsInfo = output.exportsInfo
            self.nextToken = output.nextToken
        } else {
            self.exportsInfo = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeExportTasksOutputResponse: Equatable {
    /// <p>Contains one or more sets of export request details. When the status of a request is
    ///         <code>SUCCEEDED</code>, the response includes a URL for an Amazon S3 bucket where you can
    ///       view the data in a CSV file.</p>
    public let exportsInfo: [ExportInfo]?
    /// <p>The <code>nextToken</code> value to include in a future
    ///         <code>DescribeExportTasks</code> request. When the results of a
    ///         <code>DescribeExportTasks</code> request exceed <code>maxResults</code>, this value can be
    ///       used to retrieve the next page of results. This value is null when there are no more results
    ///       to return.</p>
    public let nextToken: String?

    public init (
        exportsInfo: [ExportInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.exportsInfo = exportsInfo
        self.nextToken = nextToken
    }
}

struct DescribeExportTasksOutputResponseBody: Equatable {
    public let exportsInfo: [ExportInfo]?
    public let nextToken: String?
}

extension DescribeExportTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportsInfo
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportsInfoContainer = try containerValues.decodeIfPresent([ExportInfo?].self, forKey: .exportsInfo)
        var exportsInfoDecoded0:[ExportInfo]? = nil
        if let exportsInfoContainer = exportsInfoContainer {
            exportsInfoDecoded0 = [ExportInfo]()
            for structure0 in exportsInfoContainer {
                if let structure0 = structure0 {
                    exportsInfoDecoded0?.append(structure0)
                }
            }
        }
        exportsInfo = exportsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeImportTasksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeImportTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImportTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImportTasksInput>
    public typealias MOutput = OperationOutput<DescribeImportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImportTasksOutputError>
}

extension DescribeImportTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImportTasksInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeImportTasksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for describeimporttasksfilterlist0 in filters {
                try filtersContainer.encode(describeimporttasksfilterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeImportTasksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeImportTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImportTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImportTasksInput>
    public typealias MOutput = OperationOutput<DescribeImportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImportTasksOutputError>
}

public struct DescribeImportTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeImportTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImportTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImportTasksInput>
    public typealias MOutput = OperationOutput<DescribeImportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImportTasksOutputError>
}

public struct DescribeImportTasksInput: Equatable {
    /// <p>An array of name-value pairs that you provide to filter the results for the
    ///         <code>DescribeImportTask</code> request to a specific subset of results. Currently, wildcard
    ///       values aren't supported for filters.</p>
    public let filters: [ImportTaskFilter]?
    /// <p>The maximum number of results that you want this request to return, up to 100.</p>
    public let maxResults: Int?
    /// <p>The token to request a specific page of results.</p>
    public let nextToken: String?

    public init (
        filters: [ImportTaskFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeImportTasksInputBody: Equatable {
    public let filters: [ImportTaskFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeImportTasksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ImportTaskFilter?].self, forKey: .filters)
        var filtersDecoded0:[ImportTaskFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImportTaskFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImportTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImportTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImportTasksOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImportTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImportTasksOutputResponse(nextToken: \(String(describing: nextToken)), tasks: \(String(describing: tasks)))"}
}

extension DescribeImportTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeImportTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct DescribeImportTasksOutputResponse: Equatable {
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?
    /// <p>A returned array of import tasks that match any applied filters, up to the specified
    ///       number of maximum results.</p>
    public let tasks: [ImportTask]?

    public init (
        nextToken: String? = nil,
        tasks: [ImportTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct DescribeImportTasksOutputResponseBody: Equatable {
    public let nextToken: String?
    public let tasks: [ImportTask]?
}

extension DescribeImportTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tasks
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tasksContainer = try containerValues.decodeIfPresent([ImportTask?].self, forKey: .tasks)
        var tasksDecoded0:[ImportTask]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [ImportTask]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
    }
}

public struct DescribeTagsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

extension DescribeTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for tagfilters0 in filters {
                try filtersContainer.encode(tagfilters0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInput: Equatable {
    /// <p>You can filter the list using a <i>key</i>-<i>value</i>
    ///       format. You can separate these items by using logical operators. Allowed filters include
    ///         <code>tagKey</code>, <code>tagValue</code>, and <code>configurationId</code>. </p>
    public let filters: [TagFilter]?
    /// <p>The total number of items to return in a single page of output. The maximum value is
    ///       100.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results.</p>
    public let nextToken: String?

    public init (
        filters: [TagFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeTagsInputBody: Equatable {
    public let filters: [TagFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([TagFilter?].self, forKey: .filters)
        var filtersDecoded0:[TagFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [TagFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension DescribeTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct DescribeTagsOutputResponse: Equatable {
    /// <p>The call returns a token. Use this token to get the next set of results.</p>
    public let nextToken: String?
    /// <p>Depending on the input, this is a list of configuration items tagged with a specific
    ///       tag, or a list of tags for a specific configuration item.</p>
    public let tags: [ConfigurationTag]?

    public init (
        nextToken: String? = nil,
        tags: [ConfigurationTag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct DescribeTagsOutputResponseBody: Equatable {
    public let tags: [ConfigurationTag]?
    public let nextToken: String?
}

extension DescribeTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ConfigurationTag?].self, forKey: .tags)
        var tagsDecoded0:[ConfigurationTag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ConfigurationTag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DisassociateConfigurationItemsFromApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateConfigurationItemsFromApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateConfigurationItemsFromApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateConfigurationItemsFromApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateConfigurationItemsFromApplicationInput>
    public typealias MOutput = OperationOutput<DisassociateConfigurationItemsFromApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateConfigurationItemsFromApplicationOutputError>
}

extension DisassociateConfigurationItemsFromApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateConfigurationItemsFromApplicationInput(applicationConfigurationId: \(String(describing: applicationConfigurationId)), configurationIds: \(String(describing: configurationIds)))"}
}

extension DisassociateConfigurationItemsFromApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationConfigurationId
        case configurationIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfigurationId = applicationConfigurationId {
            try encodeContainer.encode(applicationConfigurationId, forKey: .applicationConfigurationId)
        }
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationidlist0 in configurationIds {
                try configurationIdsContainer.encode(configurationidlist0)
            }
        }
    }
}

public struct DisassociateConfigurationItemsFromApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateConfigurationItemsFromApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateConfigurationItemsFromApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateConfigurationItemsFromApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateConfigurationItemsFromApplicationInput>
    public typealias MOutput = OperationOutput<DisassociateConfigurationItemsFromApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateConfigurationItemsFromApplicationOutputError>
}

public struct DisassociateConfigurationItemsFromApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateConfigurationItemsFromApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateConfigurationItemsFromApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateConfigurationItemsFromApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateConfigurationItemsFromApplicationInput>
    public typealias MOutput = OperationOutput<DisassociateConfigurationItemsFromApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateConfigurationItemsFromApplicationOutputError>
}

public struct DisassociateConfigurationItemsFromApplicationInput: Equatable {
    /// <p>Configuration ID of an application from which each item is disassociated.</p>
    public let applicationConfigurationId: String?
    /// <p>Configuration ID of each item to be disassociated from an application.</p>
    public let configurationIds: [String]?

    public init (
        applicationConfigurationId: String? = nil,
        configurationIds: [String]? = nil
    )
    {
        self.applicationConfigurationId = applicationConfigurationId
        self.configurationIds = configurationIds
    }
}

struct DisassociateConfigurationItemsFromApplicationInputBody: Equatable {
    public let applicationConfigurationId: String?
    public let configurationIds: [String]?
}

extension DisassociateConfigurationItemsFromApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationConfigurationId
        case configurationIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationConfigurationId)
        applicationConfigurationId = applicationConfigurationIdDecoded
        let configurationIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
    }
}

extension DisassociateConfigurationItemsFromApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateConfigurationItemsFromApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateConfigurationItemsFromApplicationOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateConfigurationItemsFromApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateConfigurationItemsFromApplicationOutputResponse()"}
}

extension DisassociateConfigurationItemsFromApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateConfigurationItemsFromApplicationOutputResponse: Equatable {

    public init() {}
}

struct DisassociateConfigurationItemsFromApplicationOutputResponseBody: Equatable {
}

extension DisassociateConfigurationItemsFromApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ExportConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportConfigurationsInput()"}
}

extension ExportConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ExportConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ExportConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportConfigurationsInput>
    public typealias MOutput = OperationOutput<ExportConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportConfigurationsOutputError>
}

public struct ExportConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ExportConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportConfigurationsInput>
    public typealias MOutput = OperationOutput<ExportConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportConfigurationsOutputError>
}

public struct ExportConfigurationsInput: Equatable {

    public init() {}
}

struct ExportConfigurationsInputBody: Equatable {
}

extension ExportConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ExportConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportConfigurationsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportConfigurationsOutputResponse(exportId: \(String(describing: exportId)))"}
}

extension ExportConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExportConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exportId = output.exportId
        } else {
            self.exportId = nil
        }
    }
}

public struct ExportConfigurationsOutputResponse: Equatable {
    /// <p>A unique identifier that you can use to query the export status.</p>
    public let exportId: String?

    public init (
        exportId: String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct ExportConfigurationsOutputResponseBody: Equatable {
    public let exportId: String?
}

extension ExportConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
    }
}

public enum ExportDataFormat {
    case csv
    case graphml
    case sdkUnknown(String)
}

extension ExportDataFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExportDataFormat] {
        return [
            .csv,
            .graphml,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .graphml: return "GRAPHML"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExportDataFormat(rawValue: rawValue) ?? ExportDataFormat.sdkUnknown(rawValue)
    }
}

extension ExportFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ExportFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportFilter(condition: \(String(describing: condition)), name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Used to select which agent's data is to be exported. A single agent ID may be selected
///       for export using the <a href="http://docs.aws.amazon.com/application-discovery/latest/APIReference/API_StartExportTask.html">StartExportTask</a> action.</p>
public struct ExportFilter: Equatable {
    /// <p>Supported condition: <code>EQUALS</code>
    ///          </p>
    public let condition: String?
    /// <p>A single <code>ExportFilter</code> name. Supported filters:
    ///       <code>agentId</code>.</p>
    public let name: String?
    /// <p>A single <code>agentId</code> for a Discovery Agent. An <code>agentId</code> can be
    ///       found using the <a href="http://docs.aws.amazon.com/application-discovery/latest/APIReference/API_DescribeExportTasks.html">DescribeAgents</a> action. Typically an ADS <code>agentId</code> is in the form
    ///         <code>o-0123456789abcdef0</code>.</p>
    public let values: [String]?

    public init (
        condition: String? = nil,
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.condition = condition
        self.name = name
        self.values = values
    }
}

extension ExportInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationsDownloadUrl
        case exportId
        case exportRequestTime
        case exportStatus
        case isTruncated
        case requestedEndTime
        case requestedStartTime
        case statusMessage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationsDownloadUrl = configurationsDownloadUrl {
            try encodeContainer.encode(configurationsDownloadUrl, forKey: .configurationsDownloadUrl)
        }
        if let exportId = exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
        if let exportRequestTime = exportRequestTime {
            try encodeContainer.encode(exportRequestTime.timeIntervalSince1970, forKey: .exportRequestTime)
        }
        if let exportStatus = exportStatus {
            try encodeContainer.encode(exportStatus.rawValue, forKey: .exportStatus)
        }
        if isTruncated != false {
            try encodeContainer.encode(isTruncated, forKey: .isTruncated)
        }
        if let requestedEndTime = requestedEndTime {
            try encodeContainer.encode(requestedEndTime.timeIntervalSince1970, forKey: .requestedEndTime)
        }
        if let requestedStartTime = requestedStartTime {
            try encodeContainer.encode(requestedStartTime.timeIntervalSince1970, forKey: .requestedStartTime)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let configurationsDownloadUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationsDownloadUrl)
        configurationsDownloadUrl = configurationsDownloadUrlDecoded
        let exportRequestTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .exportRequestTime)
        exportRequestTime = exportRequestTimeDecoded
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let requestedStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .requestedStartTime)
        requestedStartTime = requestedStartTimeDecoded
        let requestedEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .requestedEndTime)
        requestedEndTime = requestedEndTimeDecoded
    }
}

extension ExportInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportInfo(configurationsDownloadUrl: \(String(describing: configurationsDownloadUrl)), exportId: \(String(describing: exportId)), exportRequestTime: \(String(describing: exportRequestTime)), exportStatus: \(String(describing: exportStatus)), isTruncated: \(String(describing: isTruncated)), requestedEndTime: \(String(describing: requestedEndTime)), requestedStartTime: \(String(describing: requestedStartTime)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>Information regarding the export status of discovered data. The value is an array of
///       objects.</p>
public struct ExportInfo: Equatable {
    /// <p>A URL for an Amazon S3 bucket where you can review the exported data. The URL is
    ///       displayed only if the export succeeded.</p>
    public let configurationsDownloadUrl: String?
    /// <p>A unique identifier used to query an export.</p>
    public let exportId: String?
    /// <p>The time that the data export was initiated.</p>
    public let exportRequestTime: Date?
    /// <p>The status of the data export job.</p>
    public let exportStatus: ExportStatus?
    /// <p>If true, the export of agent information exceeded the size limit for a single export
    ///       and the exported data is incomplete for the requested time range. To address this, select a
    ///       smaller time range for the export by using <code>startDate</code> and
    ///       <code>endDate</code>.</p>
    public let isTruncated: Bool
    /// <p>The <code>endTime</code> used in the <code>StartExportTask</code> request. If no
    ///         <code>endTime</code> was requested, this result does not appear in
    ///       <code>ExportInfo</code>.</p>
    public let requestedEndTime: Date?
    /// <p>The value of <code>startTime</code> parameter in the <code>StartExportTask</code>
    ///       request. If no <code>startTime</code> was requested, this result does not appear in
    ///         <code>ExportInfo</code>.</p>
    public let requestedStartTime: Date?
    /// <p>A status message provided for API callers.</p>
    public let statusMessage: String?

    public init (
        configurationsDownloadUrl: String? = nil,
        exportId: String? = nil,
        exportRequestTime: Date? = nil,
        exportStatus: ExportStatus? = nil,
        isTruncated: Bool = false,
        requestedEndTime: Date? = nil,
        requestedStartTime: Date? = nil,
        statusMessage: String? = nil
    )
    {
        self.configurationsDownloadUrl = configurationsDownloadUrl
        self.exportId = exportId
        self.exportRequestTime = exportRequestTime
        self.exportStatus = exportStatus
        self.isTruncated = isTruncated
        self.requestedEndTime = requestedEndTime
        self.requestedStartTime = requestedStartTime
        self.statusMessage = statusMessage
    }
}

public enum ExportStatus {
    case failed
    case inProgress
    case succeeded
    case sdkUnknown(String)
}

extension ExportStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExportStatus] {
        return [
            .failed,
            .inProgress,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExportStatus(rawValue: rawValue) ?? ExportStatus.sdkUnknown(rawValue)
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(condition: \(String(describing: condition)), name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A filter that can use conditional operators.</p>
///          <p>For more information about filters, see <a href="https://docs.aws.amazon.com/application-discovery/latest/userguide/discovery-api-queries.html">Querying Discovered
///         Configuration Items</a> in the <i>AWS Application Discovery Service User
///         Guide</i>. </p>
public struct Filter: Equatable {
    /// <p>A conditional operator. The following operators are valid: EQUALS, NOT_EQUALS,
    ///       CONTAINS, NOT_CONTAINS. If you specify multiple filters, the system utilizes all filters as
    ///       though concatenated by <i>AND</i>. If you specify multiple values for a
    ///       particular filter, the system differentiates the values using <i>OR</i>. Calling
    ///       either <i>DescribeConfigurations</i> or <i>ListConfigurations</i>
    ///       returns attributes of matching configuration items.</p>
    public let condition: String?
    /// <p>The name of the filter.</p>
    public let name: String?
    /// <p>A string value on which to filter. For example, if you choose the
    ///         <code>destinationServer.osVersion</code> filter name, you could specify <code>Ubuntu</code>
    ///       for the value.</p>
    public let values: [String]?

    public init (
        condition: String? = nil,
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.condition = condition
        self.name = name
        self.values = values
    }
}

extension GetDiscoverySummaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDiscoverySummaryInput()"}
}

extension GetDiscoverySummaryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDiscoverySummaryInputHeadersMiddleware: Middleware {
    public let id: String = "GetDiscoverySummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDiscoverySummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDiscoverySummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDiscoverySummaryInput>
    public typealias MOutput = OperationOutput<GetDiscoverySummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDiscoverySummaryOutputError>
}

public struct GetDiscoverySummaryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDiscoverySummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDiscoverySummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDiscoverySummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDiscoverySummaryInput>
    public typealias MOutput = OperationOutput<GetDiscoverySummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDiscoverySummaryOutputError>
}

public struct GetDiscoverySummaryInput: Equatable {

    public init() {}
}

struct GetDiscoverySummaryInputBody: Equatable {
}

extension GetDiscoverySummaryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDiscoverySummaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDiscoverySummaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDiscoverySummaryOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDiscoverySummaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDiscoverySummaryOutputResponse(agentSummary: \(String(describing: agentSummary)), applications: \(String(describing: applications)), connectorSummary: \(String(describing: connectorSummary)), servers: \(String(describing: servers)), serversMappedToApplications: \(String(describing: serversMappedToApplications)), serversMappedtoTags: \(String(describing: serversMappedtoTags)))"}
}

extension GetDiscoverySummaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDiscoverySummaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.agentSummary = output.agentSummary
            self.applications = output.applications
            self.connectorSummary = output.connectorSummary
            self.servers = output.servers
            self.serversMappedToApplications = output.serversMappedToApplications
            self.serversMappedtoTags = output.serversMappedtoTags
        } else {
            self.agentSummary = nil
            self.applications = 0
            self.connectorSummary = nil
            self.servers = 0
            self.serversMappedToApplications = 0
            self.serversMappedtoTags = 0
        }
    }
}

public struct GetDiscoverySummaryOutputResponse: Equatable {
    /// <p>Details about discovered agents, including agent status and health.</p>
    public let agentSummary: CustomerAgentInfo?
    /// <p>The number of applications discovered.</p>
    public let applications: Int
    /// <p>Details about discovered connectors, including connector status and health.</p>
    public let connectorSummary: CustomerConnectorInfo?
    /// <p>The number of servers discovered.</p>
    public let servers: Int
    /// <p>The number of servers mapped to applications.</p>
    public let serversMappedToApplications: Int
    /// <p>The number of servers mapped to tags.</p>
    public let serversMappedtoTags: Int

    public init (
        agentSummary: CustomerAgentInfo? = nil,
        applications: Int = 0,
        connectorSummary: CustomerConnectorInfo? = nil,
        servers: Int = 0,
        serversMappedToApplications: Int = 0,
        serversMappedtoTags: Int = 0
    )
    {
        self.agentSummary = agentSummary
        self.applications = applications
        self.connectorSummary = connectorSummary
        self.servers = servers
        self.serversMappedToApplications = serversMappedToApplications
        self.serversMappedtoTags = serversMappedtoTags
    }
}

struct GetDiscoverySummaryOutputResponseBody: Equatable {
    public let servers: Int
    public let applications: Int
    public let serversMappedToApplications: Int
    public let serversMappedtoTags: Int
    public let agentSummary: CustomerAgentInfo?
    public let connectorSummary: CustomerConnectorInfo?
}

extension GetDiscoverySummaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentSummary
        case applications
        case connectorSummary
        case servers
        case serversMappedToApplications
        case serversMappedtoTags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serversDecoded = try containerValues.decode(Int.self, forKey: .servers)
        servers = serversDecoded
        let applicationsDecoded = try containerValues.decode(Int.self, forKey: .applications)
        applications = applicationsDecoded
        let serversMappedToApplicationsDecoded = try containerValues.decode(Int.self, forKey: .serversMappedToApplications)
        serversMappedToApplications = serversMappedToApplicationsDecoded
        let serversMappedtoTagsDecoded = try containerValues.decode(Int.self, forKey: .serversMappedtoTags)
        serversMappedtoTags = serversMappedtoTagsDecoded
        let agentSummaryDecoded = try containerValues.decodeIfPresent(CustomerAgentInfo.self, forKey: .agentSummary)
        agentSummary = agentSummaryDecoded
        let connectorSummaryDecoded = try containerValues.decodeIfPresent(CustomerConnectorInfo.self, forKey: .connectorSummary)
        connectorSummary = connectorSummaryDecoded
    }
}

extension HomeRegionNotSetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HomeRegionNotSetException(message: \(String(describing: message)))"}
}

extension HomeRegionNotSetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: HomeRegionNotSetExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The home region is not set. Set the home region to continue.</p>
public struct HomeRegionNotSetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct HomeRegionNotSetExceptionBody: Equatable {
    public let message: String?
}

extension HomeRegionNotSetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ImportStatus {
    case deleteComplete
    case deleteFailed
    case deleteFailedLimitExceeded
    case deleteInProgress
    case importComplete
    case importCompleteWithErrors
    case importFailed
    case importFailedRecordLimitExceeded
    case importFailedServerLimitExceeded
    case importInProgress
    case internalError
    case sdkUnknown(String)
}

extension ImportStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImportStatus] {
        return [
            .deleteComplete,
            .deleteFailed,
            .deleteFailedLimitExceeded,
            .deleteInProgress,
            .importComplete,
            .importCompleteWithErrors,
            .importFailed,
            .importFailedRecordLimitExceeded,
            .importFailedServerLimitExceeded,
            .importInProgress,
            .internalError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleteComplete: return "DELETE_COMPLETE"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteFailedLimitExceeded: return "DELETE_FAILED_LIMIT_EXCEEDED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .importComplete: return "IMPORT_COMPLETE"
        case .importCompleteWithErrors: return "IMPORT_COMPLETE_WITH_ERRORS"
        case .importFailed: return "IMPORT_FAILED"
        case .importFailedRecordLimitExceeded: return "IMPORT_FAILED_RECORD_LIMIT_EXCEEDED"
        case .importFailedServerLimitExceeded: return "IMPORT_FAILED_SERVER_LIMIT_EXCEEDED"
        case .importInProgress: return "IMPORT_IN_PROGRESS"
        case .internalError: return "INTERNAL_ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImportStatus(rawValue: rawValue) ?? ImportStatus.sdkUnknown(rawValue)
    }
}

extension ImportTask: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationImportFailure
        case applicationImportSuccess
        case clientRequestToken
        case errorsAndFailedEntriesZip
        case importCompletionTime
        case importDeletedTime
        case importRequestTime
        case importTaskId
        case importUrl
        case name
        case serverImportFailure
        case serverImportSuccess
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applicationImportFailure != 0 {
            try encodeContainer.encode(applicationImportFailure, forKey: .applicationImportFailure)
        }
        if applicationImportSuccess != 0 {
            try encodeContainer.encode(applicationImportSuccess, forKey: .applicationImportSuccess)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let errorsAndFailedEntriesZip = errorsAndFailedEntriesZip {
            try encodeContainer.encode(errorsAndFailedEntriesZip, forKey: .errorsAndFailedEntriesZip)
        }
        if let importCompletionTime = importCompletionTime {
            try encodeContainer.encode(importCompletionTime.timeIntervalSince1970, forKey: .importCompletionTime)
        }
        if let importDeletedTime = importDeletedTime {
            try encodeContainer.encode(importDeletedTime.timeIntervalSince1970, forKey: .importDeletedTime)
        }
        if let importRequestTime = importRequestTime {
            try encodeContainer.encode(importRequestTime.timeIntervalSince1970, forKey: .importRequestTime)
        }
        if let importTaskId = importTaskId {
            try encodeContainer.encode(importTaskId, forKey: .importTaskId)
        }
        if let importUrl = importUrl {
            try encodeContainer.encode(importUrl, forKey: .importUrl)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if serverImportFailure != 0 {
            try encodeContainer.encode(serverImportFailure, forKey: .serverImportFailure)
        }
        if serverImportSuccess != 0 {
            try encodeContainer.encode(serverImportSuccess, forKey: .serverImportSuccess)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importTaskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importTaskId)
        importTaskId = importTaskIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let importUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importUrl)
        importUrl = importUrlDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImportStatus.self, forKey: .status)
        status = statusDecoded
        let importRequestTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .importRequestTime)
        importRequestTime = importRequestTimeDecoded
        let importCompletionTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .importCompletionTime)
        importCompletionTime = importCompletionTimeDecoded
        let importDeletedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .importDeletedTime)
        importDeletedTime = importDeletedTimeDecoded
        let serverImportSuccessDecoded = try containerValues.decode(Int.self, forKey: .serverImportSuccess)
        serverImportSuccess = serverImportSuccessDecoded
        let serverImportFailureDecoded = try containerValues.decode(Int.self, forKey: .serverImportFailure)
        serverImportFailure = serverImportFailureDecoded
        let applicationImportSuccessDecoded = try containerValues.decode(Int.self, forKey: .applicationImportSuccess)
        applicationImportSuccess = applicationImportSuccessDecoded
        let applicationImportFailureDecoded = try containerValues.decode(Int.self, forKey: .applicationImportFailure)
        applicationImportFailure = applicationImportFailureDecoded
        let errorsAndFailedEntriesZipDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorsAndFailedEntriesZip)
        errorsAndFailedEntriesZip = errorsAndFailedEntriesZipDecoded
    }
}

extension ImportTask: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportTask(applicationImportFailure: \(String(describing: applicationImportFailure)), applicationImportSuccess: \(String(describing: applicationImportSuccess)), clientRequestToken: \(String(describing: clientRequestToken)), errorsAndFailedEntriesZip: \(String(describing: errorsAndFailedEntriesZip)), importCompletionTime: \(String(describing: importCompletionTime)), importDeletedTime: \(String(describing: importDeletedTime)), importRequestTime: \(String(describing: importRequestTime)), importTaskId: \(String(describing: importTaskId)), importUrl: \(String(describing: importUrl)), name: \(String(describing: name)), serverImportFailure: \(String(describing: serverImportFailure)), serverImportSuccess: \(String(describing: serverImportSuccess)), status: \(String(describing: status)))"}
}

/// <p>An array of information related to the import task request that includes status
///       information, times, IDs, the Amazon S3 Object URL for the import file, and more.</p>
public struct ImportTask: Equatable {
    /// <p>The total number of application records in the import file that failed to be
    ///       imported.</p>
    public let applicationImportFailure: Int
    /// <p>The total number of application records in the import file that were successfully
    ///       imported.</p>
    public let applicationImportSuccess: Int
    /// <p>A unique token used to prevent the same import request from occurring more than once. If
    ///       you didn't provide a token, a token was automatically generated when the import task request
    ///       was sent.</p>
    public let clientRequestToken: String?
    /// <p>A link to a compressed archive folder (in the ZIP format) that contains an error log and a
    ///       file of failed records. You can use these two files to quickly identify records that failed,
    ///       why they failed, and correct those records. Afterward, you can upload the corrected file to
    ///       your Amazon S3 bucket and create another import task request.</p>
    ///
    ///          <p>This field also includes authorization information so you can confirm the authenticity of
    ///       the compressed archive before you download it.</p>
    ///
    ///          <p>If some records failed to be imported we recommend that you correct the records in the
    ///       failed entries file and then imports that failed entries file. This prevents you from having
    ///       to correct and update the larger original file and attempt importing it again.</p>
    public let errorsAndFailedEntriesZip: String?
    /// <p>The time that the import task request finished, presented in the Unix time stamp
    ///       format.</p>
    public let importCompletionTime: Date?
    /// <p>The time that the import task request was deleted, presented in the Unix time stamp
    ///       format.</p>
    public let importDeletedTime: Date?
    /// <p>The time that the import task request was made, presented in the Unix time stamp
    ///       format.</p>
    public let importRequestTime: Date?
    /// <p>The unique ID for a specific import task. These IDs aren't globally unique, but they are
    ///       unique within an AWS account.</p>
    public let importTaskId: String?
    /// <p>The URL for your import file that you've uploaded to Amazon S3.</p>
    public let importUrl: String?
    /// <p>A descriptive name for an import task. You can use this name to filter future requests
    ///       related to this import task, such as identifying applications and servers that were included
    ///       in this import task. We recommend that you use a meaningful name for each import task.</p>
    public let name: String?
    /// <p>The total number of server records in the import file that failed to be imported.</p>
    public let serverImportFailure: Int
    /// <p>The total number of server records in the import file that were successfully
    ///       imported.</p>
    public let serverImportSuccess: Int
    /// <p>The status of the import task. An import can have the status of
    ///         <code>IMPORT_COMPLETE</code> and still have some records fail to import from the overall
    ///       request. More information can be found in the downloadable archive defined in the
    ///         <code>errorsAndFailedEntriesZip</code> field, or in the Migration Hub management
    ///       console.</p>
    public let status: ImportStatus?

    public init (
        applicationImportFailure: Int = 0,
        applicationImportSuccess: Int = 0,
        clientRequestToken: String? = nil,
        errorsAndFailedEntriesZip: String? = nil,
        importCompletionTime: Date? = nil,
        importDeletedTime: Date? = nil,
        importRequestTime: Date? = nil,
        importTaskId: String? = nil,
        importUrl: String? = nil,
        name: String? = nil,
        serverImportFailure: Int = 0,
        serverImportSuccess: Int = 0,
        status: ImportStatus? = nil
    )
    {
        self.applicationImportFailure = applicationImportFailure
        self.applicationImportSuccess = applicationImportSuccess
        self.clientRequestToken = clientRequestToken
        self.errorsAndFailedEntriesZip = errorsAndFailedEntriesZip
        self.importCompletionTime = importCompletionTime
        self.importDeletedTime = importDeletedTime
        self.importRequestTime = importRequestTime
        self.importTaskId = importTaskId
        self.importUrl = importUrl
        self.name = name
        self.serverImportFailure = serverImportFailure
        self.serverImportSuccess = serverImportSuccess
        self.status = status
    }
}

extension ImportTaskFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for importtaskfiltervaluelist0 in values {
                try valuesContainer.encode(importtaskfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ImportTaskFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ImportTaskFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportTaskFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A name-values pair of elements you can use to filter the results when querying your import
///       tasks. Currently, wildcards are not supported for filters.</p>
///
///          <note>
///             <p>When filtering by import status, all other filter values are ignored.</p>
///          </note>
public struct ImportTaskFilter: Equatable {
    /// <p>The name, status, or import task ID for a specific import task.</p>
    public let name: ImportTaskFilterName?
    /// <p>An array of strings that you can provide to match against a specific name, status, or
    ///       import task ID to filter the results for your import task queries.</p>
    public let values: [String]?

    public init (
        name: ImportTaskFilterName? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public enum ImportTaskFilterName {
    case importTaskId
    case name
    case status
    case sdkUnknown(String)
}

extension ImportTaskFilterName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImportTaskFilterName] {
        return [
            .importTaskId,
            .name,
            .status,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .importTaskId: return "IMPORT_TASK_ID"
        case .name: return "NAME"
        case .status: return "STATUS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImportTaskFilterName(rawValue: rawValue) ?? ImportTaskFilterName.sdkUnknown(rawValue)
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters are not valid. Verify the parameters and try again.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValueException(message: \(String(describing: message)))"}
}

extension InvalidParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value of one or more parameters are either invalid or out of range. Verify the
///       parameter values and try again.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "ListConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationsInput>
    public typealias MOutput = OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationsOutputError>
}

extension ListConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationsInput(configurationType: \(String(describing: configurationType)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), orderBy: \(String(describing: orderBy)))"}
}

extension ListConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationType
        case filters
        case maxResults
        case nextToken
        case orderBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationType = configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let orderBy = orderBy {
            var orderByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderBy)
            for orderbylist0 in orderBy {
                try orderByContainer.encode(orderbylist0)
            }
        }
    }
}

public struct ListConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationsInput>
    public typealias MOutput = OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationsInput>
    public typealias MOutput = OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInput: Equatable {
    /// <p>A valid configuration identified by Application Discovery Service. </p>
    public let configurationType: ConfigurationItemType?
    /// <p>You can filter the request using various logical operators and a
    ///         <i>key</i>-<i>value</i> format. For example: </p>
    ///          <p>
    ///             <code>{"key": "serverType", "value": "webServer"}</code>
    ///          </p>
    ///          <p>For a complete list of filter options and guidance about using them with this action,
    ///       see <a href="https://docs.aws.amazon.com/application-discovery/latest/userguide/discovery-api-queries.html#ListConfigurations">Using the ListConfigurations Action</a> in the <i>AWS Application Discovery
    ///         Service User Guide</i>.</p>
    public let filters: [Filter]?
    /// <p>The total number of items to return. The maximum value is 100.</p>
    public let maxResults: Int
    /// <p>Token to retrieve the next set of results. For example, if a previous call to
    ///       ListConfigurations returned 100 items, but you set
    ///         <code>ListConfigurationsRequest$maxResults</code> to 10, you received a set of 10 results
    ///       along with a token. Use that token in this query to get the next set of 10.</p>
    public let nextToken: String?
    /// <p>Certain filter criteria return output that can be sorted in ascending or descending
    ///       order. For a list of output characteristics for each filter, see <a href="https://docs.aws.amazon.com/application-discovery/latest/userguide/discovery-api-queries.html#ListConfigurations">Using the ListConfigurations Action</a> in the <i>AWS Application Discovery
    ///         Service User Guide</i>.</p>
    public let orderBy: [OrderByElement]?

    public init (
        configurationType: ConfigurationItemType? = nil,
        filters: [Filter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        orderBy: [OrderByElement]? = nil
    )
    {
        self.configurationType = configurationType
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderBy = orderBy
    }
}

struct ListConfigurationsInputBody: Equatable {
    public let configurationType: ConfigurationItemType?
    public let filters: [Filter]?
    public let maxResults: Int
    public let nextToken: String?
    public let orderBy: [OrderByElement]?
}

extension ListConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationType
        case filters
        case maxResults
        case nextToken
        case orderBy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(ConfigurationItemType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let orderByContainer = try containerValues.decodeIfPresent([OrderByElement?].self, forKey: .orderBy)
        var orderByDecoded0:[OrderByElement]? = nil
        if let orderByContainer = orderByContainer {
            orderByDecoded0 = [OrderByElement]()
            for structure0 in orderByContainer {
                if let structure0 = structure0 {
                    orderByDecoded0?.append(structure0)
                }
            }
        }
        orderBy = orderByDecoded0
    }
}

extension ListConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationsOutputResponse(configurations: \(String(describing: configurations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurations = output.configurations
            self.nextToken = output.nextToken
        } else {
            self.configurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationsOutputResponse: Equatable {
    /// <p>Returns configuration details, including the configuration ID, attribute names, and
    ///       attribute values.</p>
    public let configurations: [[String:String]]?
    /// <p>Token to retrieve the next set of results. For example, if your call to
    ///       ListConfigurations returned 100 items, but you set
    ///         <code>ListConfigurationsRequest$maxResults</code> to 10, you received a set of 10 results
    ///       along with this token. Use this token in the next query to retrieve the next set of
    ///       10.</p>
    public let nextToken: String?

    public init (
        configurations: [[String:String]]? = nil,
        nextToken: String? = nil
    )
    {
        self.configurations = configurations
        self.nextToken = nextToken
    }
}

struct ListConfigurationsOutputResponseBody: Equatable {
    public let configurations: [[String:String]]?
    public let nextToken: String?
}

extension ListConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurations
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([[String: String?]?].self, forKey: .configurations)
        var configurationsDecoded0:[[String:String]]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [[String:String]]()
            for map0 in configurationsContainer {
                var configurationsContainerDecoded0: [String: String]? = nil
                if let map0 = map0 {
                    configurationsContainerDecoded0 = [String: String]()
                    for (key1, string1) in map0 {
                        if let string1 = string1 {
                            configurationsContainerDecoded0?[key1] = string1
                        }
                    }
                }
                if let configurationsContainerDecoded0 = configurationsContainerDecoded0 {
                    configurationsDecoded0?.append(configurationsContainerDecoded0)
                }
            }
        }
        configurations = configurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListServerNeighborsInputBodyMiddleware: Middleware {
    public let id: String = "ListServerNeighborsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServerNeighborsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServerNeighborsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServerNeighborsInput>
    public typealias MOutput = OperationOutput<ListServerNeighborsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServerNeighborsOutputError>
}

extension ListServerNeighborsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServerNeighborsInput(configurationId: \(String(describing: configurationId)), maxResults: \(String(describing: maxResults)), neighborConfigurationIds: \(String(describing: neighborConfigurationIds)), nextToken: \(String(describing: nextToken)), portInformationNeeded: \(String(describing: portInformationNeeded)))"}
}

extension ListServerNeighborsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationId
        case maxResults
        case neighborConfigurationIds
        case nextToken
        case portInformationNeeded
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let neighborConfigurationIds = neighborConfigurationIds {
            var neighborConfigurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neighborConfigurationIds)
            for configurationidlist0 in neighborConfigurationIds {
                try neighborConfigurationIdsContainer.encode(configurationidlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if portInformationNeeded != false {
            try encodeContainer.encode(portInformationNeeded, forKey: .portInformationNeeded)
        }
    }
}

public struct ListServerNeighborsInputHeadersMiddleware: Middleware {
    public let id: String = "ListServerNeighborsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServerNeighborsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServerNeighborsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServerNeighborsInput>
    public typealias MOutput = OperationOutput<ListServerNeighborsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServerNeighborsOutputError>
}

public struct ListServerNeighborsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServerNeighborsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServerNeighborsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServerNeighborsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServerNeighborsInput>
    public typealias MOutput = OperationOutput<ListServerNeighborsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServerNeighborsOutputError>
}

public struct ListServerNeighborsInput: Equatable {
    /// <p>Configuration ID of the server for which neighbors are being listed.</p>
    public let configurationId: String?
    /// <p>Maximum number of results to return in a single page of output.</p>
    public let maxResults: Int
    /// <p>List of configuration IDs to test for one-hop-away.</p>
    public let neighborConfigurationIds: [String]?
    /// <p>Token to retrieve the next set of results. For example, if you previously specified 100
    ///       IDs for <code>ListServerNeighborsRequest$neighborConfigurationIds</code> but set
    ///         <code>ListServerNeighborsRequest$maxResults</code> to 10, you received a set of 10 results
    ///       along with a token. Use that token in this query to get the next set of 10.</p>
    public let nextToken: String?
    /// <p>Flag to indicate if port and protocol information is needed as part of the
    ///       response.</p>
    public let portInformationNeeded: Bool

    public init (
        configurationId: String? = nil,
        maxResults: Int = 0,
        neighborConfigurationIds: [String]? = nil,
        nextToken: String? = nil,
        portInformationNeeded: Bool = false
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.neighborConfigurationIds = neighborConfigurationIds
        self.nextToken = nextToken
        self.portInformationNeeded = portInformationNeeded
    }
}

struct ListServerNeighborsInputBody: Equatable {
    public let configurationId: String?
    public let portInformationNeeded: Bool
    public let neighborConfigurationIds: [String]?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListServerNeighborsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationId
        case maxResults
        case neighborConfigurationIds
        case nextToken
        case portInformationNeeded
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let portInformationNeededDecoded = try containerValues.decode(Bool.self, forKey: .portInformationNeeded)
        portInformationNeeded = portInformationNeededDecoded
        let neighborConfigurationIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .neighborConfigurationIds)
        var neighborConfigurationIdsDecoded0:[String]? = nil
        if let neighborConfigurationIdsContainer = neighborConfigurationIdsContainer {
            neighborConfigurationIdsDecoded0 = [String]()
            for string0 in neighborConfigurationIdsContainer {
                if let string0 = string0 {
                    neighborConfigurationIdsDecoded0?.append(string0)
                }
            }
        }
        neighborConfigurationIds = neighborConfigurationIdsDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServerNeighborsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServerNeighborsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServerNeighborsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServerNeighborsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServerNeighborsOutputResponse(knownDependencyCount: \(String(describing: knownDependencyCount)), neighbors: \(String(describing: neighbors)), nextToken: \(String(describing: nextToken)))"}
}

extension ListServerNeighborsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServerNeighborsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.knownDependencyCount = output.knownDependencyCount
            self.neighbors = output.neighbors
            self.nextToken = output.nextToken
        } else {
            self.knownDependencyCount = 0
            self.neighbors = nil
            self.nextToken = nil
        }
    }
}

public struct ListServerNeighborsOutputResponse: Equatable {
    /// <p>Count of distinct servers that are one hop away from the given server.</p>
    public let knownDependencyCount: Int
    /// <p>List of distinct servers that are one hop away from the given server.</p>
    public let neighbors: [NeighborConnectionDetail]?
    /// <p>Token to retrieve the next set of results. For example, if you specified 100 IDs for
    ///         <code>ListServerNeighborsRequest$neighborConfigurationIds</code> but set
    ///         <code>ListServerNeighborsRequest$maxResults</code> to 10, you received a set of 10 results
    ///       along with this token. Use this token in the next query to retrieve the next set of
    ///       10.</p>
    public let nextToken: String?

    public init (
        knownDependencyCount: Int = 0,
        neighbors: [NeighborConnectionDetail]? = nil,
        nextToken: String? = nil
    )
    {
        self.knownDependencyCount = knownDependencyCount
        self.neighbors = neighbors
        self.nextToken = nextToken
    }
}

struct ListServerNeighborsOutputResponseBody: Equatable {
    public let neighbors: [NeighborConnectionDetail]?
    public let nextToken: String?
    public let knownDependencyCount: Int
}

extension ListServerNeighborsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case knownDependencyCount
        case neighbors
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let neighborsContainer = try containerValues.decodeIfPresent([NeighborConnectionDetail?].self, forKey: .neighbors)
        var neighborsDecoded0:[NeighborConnectionDetail]? = nil
        if let neighborsContainer = neighborsContainer {
            neighborsDecoded0 = [NeighborConnectionDetail]()
            for structure0 in neighborsContainer {
                if let structure0 = structure0 {
                    neighborsDecoded0?.append(structure0)
                }
            }
        }
        neighbors = neighborsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let knownDependencyCountDecoded = try containerValues.decode(Int.self, forKey: .knownDependencyCount)
        knownDependencyCount = knownDependencyCountDecoded
    }
}

extension NeighborConnectionDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionsCount
        case destinationPort
        case destinationServerId
        case sourceServerId
        case transportProtocol
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if connectionsCount != 0 {
            try encodeContainer.encode(connectionsCount, forKey: .connectionsCount)
        }
        if let destinationPort = destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let destinationServerId = destinationServerId {
            try encodeContainer.encode(destinationServerId, forKey: .destinationServerId)
        }
        if let sourceServerId = sourceServerId {
            try encodeContainer.encode(sourceServerId, forKey: .sourceServerId)
        }
        if let transportProtocol = transportProtocol {
            try encodeContainer.encode(transportProtocol, forKey: .transportProtocol)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceServerId)
        sourceServerId = sourceServerIdDecoded
        let destinationServerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationServerId)
        destinationServerId = destinationServerIdDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let transportProtocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transportProtocol)
        transportProtocol = transportProtocolDecoded
        let connectionsCountDecoded = try containerValues.decode(Int.self, forKey: .connectionsCount)
        connectionsCount = connectionsCountDecoded
    }
}

extension NeighborConnectionDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NeighborConnectionDetail(connectionsCount: \(String(describing: connectionsCount)), destinationPort: \(String(describing: destinationPort)), destinationServerId: \(String(describing: destinationServerId)), sourceServerId: \(String(describing: sourceServerId)), transportProtocol: \(String(describing: transportProtocol)))"}
}

/// <p>Details about neighboring servers.</p>
public struct NeighborConnectionDetail: Equatable {
    /// <p>The number of open network connections with the neighboring server.</p>
    public let connectionsCount: Int
    /// <p>The destination network port for the connection.</p>
    public let destinationPort: Int?
    /// <p>The ID of the server that accepted the network connection.</p>
    public let destinationServerId: String?
    /// <p>The ID of the server that opened the network connection.</p>
    public let sourceServerId: String?
    /// <p>The network protocol used for the connection.</p>
    public let transportProtocol: String?

    public init (
        connectionsCount: Int = 0,
        destinationPort: Int? = nil,
        destinationServerId: String? = nil,
        sourceServerId: String? = nil,
        transportProtocol: String? = nil
    )
    {
        self.connectionsCount = connectionsCount
        self.destinationPort = destinationPort
        self.destinationServerId = destinationServerId
        self.sourceServerId = sourceServerId
        self.transportProtocol = transportProtocol
    }
}

extension OperationNotPermittedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationNotPermittedException(message: \(String(describing: message)))"}
}

extension OperationNotPermittedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This operation is not permitted.</p>
public struct OperationNotPermittedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Equatable {
    public let message: String?
}

extension OperationNotPermittedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrderByElement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldName
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldName = fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(OrderString.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension OrderByElement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrderByElement(fieldName: \(String(describing: fieldName)), sortOrder: \(String(describing: sortOrder)))"}
}

/// <p>A field and direction for ordered output.</p>
public struct OrderByElement: Equatable {
    /// <p>The field on which to order.</p>
    public let fieldName: String?
    /// <p>Ordering direction.</p>
    public let sortOrder: OrderString?

    public init (
        fieldName: String? = nil,
        sortOrder: OrderString? = nil
    )
    {
        self.fieldName = fieldName
        self.sortOrder = sortOrder
    }
}

public enum OrderString {
    case asc
    case desc
    case sdkUnknown(String)
}

extension OrderString : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrderString] {
        return [
            .asc,
            .desc,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .asc: return "ASC"
        case .desc: return "DESC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrderString(rawValue: rawValue) ?? OrderString.sdkUnknown(rawValue)
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This issue occurs when the same <code>clientRequestToken</code> is used with the
///         <code>StartImportTask</code> action, but with different parameters. For example, you use the
///       same request token but have two different import URLs, you can encounter this issue. If the
///       import tasks are meant to be different, use a different <code>clientRequestToken</code>, and
///       try again.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified configuration ID was not located. Verify the configuration ID and try
///       again.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServerInternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerInternalErrorException(message: \(String(describing: message)))"}
}

extension ServerInternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServerInternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The server experienced an internal error. Try again.</p>
public struct ServerInternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServerInternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension ServerInternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartContinuousExportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartContinuousExportInput()"}
}

extension StartContinuousExportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StartContinuousExportInputHeadersMiddleware: Middleware {
    public let id: String = "StartContinuousExportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartContinuousExportInput>,
                  next: H) -> Swift.Result<OperationOutput<StartContinuousExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartContinuousExportInput>
    public typealias MOutput = OperationOutput<StartContinuousExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartContinuousExportOutputError>
}

public struct StartContinuousExportInputQueryItemMiddleware: Middleware {
    public let id: String = "StartContinuousExportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartContinuousExportInput>,
                  next: H) -> Swift.Result<OperationOutput<StartContinuousExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartContinuousExportInput>
    public typealias MOutput = OperationOutput<StartContinuousExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartContinuousExportOutputError>
}

public struct StartContinuousExportInput: Equatable {

    public init() {}
}

struct StartContinuousExportInputBody: Equatable {
}

extension StartContinuousExportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StartContinuousExportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartContinuousExportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictErrorException" : self = .conflictErrorException(try ConflictErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartContinuousExportOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case conflictErrorException(ConflictErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartContinuousExportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartContinuousExportOutputResponse(dataSource: \(String(describing: dataSource)), exportId: \(String(describing: exportId)), s3Bucket: \(String(describing: s3Bucket)), schemaStorageConfig: \(String(describing: schemaStorageConfig)), startTime: \(String(describing: startTime)))"}
}

extension StartContinuousExportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartContinuousExportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSource = output.dataSource
            self.exportId = output.exportId
            self.s3Bucket = output.s3Bucket
            self.schemaStorageConfig = output.schemaStorageConfig
            self.startTime = output.startTime
        } else {
            self.dataSource = nil
            self.exportId = nil
            self.s3Bucket = nil
            self.schemaStorageConfig = nil
            self.startTime = nil
        }
    }
}

public struct StartContinuousExportOutputResponse: Equatable {
    /// <p>The type of data collector used to gather this data (currently only offered for
    ///       AGENT).</p>
    public let dataSource: DataSource?
    /// <p>The unique ID assigned to this export.</p>
    public let exportId: String?
    /// <p>The name of the s3 bucket where the export data parquet files are stored.</p>
    public let s3Bucket: String?
    /// <p>A dictionary which describes how the data is stored.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>databaseName</code> - the name of the Glue database used to store the
    ///           schema.</p>
    ///             </li>
    ///          </ul>
    public let schemaStorageConfig: [String:String]?
    /// <p>The timestamp representing when the continuous export was started.</p>
    public let startTime: Date?

    public init (
        dataSource: DataSource? = nil,
        exportId: String? = nil,
        s3Bucket: String? = nil,
        schemaStorageConfig: [String:String]? = nil,
        startTime: Date? = nil
    )
    {
        self.dataSource = dataSource
        self.exportId = exportId
        self.s3Bucket = s3Bucket
        self.schemaStorageConfig = schemaStorageConfig
        self.startTime = startTime
    }
}

struct StartContinuousExportOutputResponseBody: Equatable {
    public let exportId: String?
    public let s3Bucket: String?
    public let startTime: Date?
    public let dataSource: DataSource?
    public let schemaStorageConfig: [String:String]?
}

extension StartContinuousExportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSource
        case exportId
        case s3Bucket
        case schemaStorageConfig
        case startTime
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaStorageConfigContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .schemaStorageConfig)
        var schemaStorageConfigDecoded0: [String:String]? = nil
        if let schemaStorageConfigContainer = schemaStorageConfigContainer {
            schemaStorageConfigDecoded0 = [String:String]()
            for (key0, string0) in schemaStorageConfigContainer {
                if let string0 = string0 {
                    schemaStorageConfigDecoded0?[key0] = string0
                }
            }
        }
        schemaStorageConfig = schemaStorageConfigDecoded0
    }
}

public struct StartDataCollectionByAgentIdsInputBodyMiddleware: Middleware {
    public let id: String = "StartDataCollectionByAgentIdsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDataCollectionByAgentIdsInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDataCollectionByAgentIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDataCollectionByAgentIdsInput>
    public typealias MOutput = OperationOutput<StartDataCollectionByAgentIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDataCollectionByAgentIdsOutputError>
}

extension StartDataCollectionByAgentIdsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDataCollectionByAgentIdsInput(agentIds: \(String(describing: agentIds)))"}
}

extension StartDataCollectionByAgentIdsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentIds = agentIds {
            var agentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentIds)
            for agentids0 in agentIds {
                try agentIdsContainer.encode(agentids0)
            }
        }
    }
}

public struct StartDataCollectionByAgentIdsInputHeadersMiddleware: Middleware {
    public let id: String = "StartDataCollectionByAgentIdsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDataCollectionByAgentIdsInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDataCollectionByAgentIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDataCollectionByAgentIdsInput>
    public typealias MOutput = OperationOutput<StartDataCollectionByAgentIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDataCollectionByAgentIdsOutputError>
}

public struct StartDataCollectionByAgentIdsInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDataCollectionByAgentIdsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDataCollectionByAgentIdsInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDataCollectionByAgentIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDataCollectionByAgentIdsInput>
    public typealias MOutput = OperationOutput<StartDataCollectionByAgentIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDataCollectionByAgentIdsOutputError>
}

public struct StartDataCollectionByAgentIdsInput: Equatable {
    /// <p>The IDs of the agents or connectors from which to start collecting data. If you send a
    ///       request to an agent/connector ID that you do not have permission to contact, according to your
    ///       AWS account, the service does not throw an exception. Instead, it returns the error in the
    ///         <i>Description</i> field. If you send a request to multiple agents/connectors
    ///       and you do not have permission to contact some of those agents/connectors, the system does not
    ///       throw an exception. Instead, the system shows <code>Failed</code> in the
    ///         <i>Description</i> field.</p>
    public let agentIds: [String]?

    public init (
        agentIds: [String]? = nil
    )
    {
        self.agentIds = agentIds
    }
}

struct StartDataCollectionByAgentIdsInputBody: Equatable {
    public let agentIds: [String]?
}

extension StartDataCollectionByAgentIdsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentIds)
        var agentIdsDecoded0:[String]? = nil
        if let agentIdsContainer = agentIdsContainer {
            agentIdsDecoded0 = [String]()
            for string0 in agentIdsContainer {
                if let string0 = string0 {
                    agentIdsDecoded0?.append(string0)
                }
            }
        }
        agentIds = agentIdsDecoded0
    }
}

extension StartDataCollectionByAgentIdsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDataCollectionByAgentIdsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDataCollectionByAgentIdsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDataCollectionByAgentIdsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDataCollectionByAgentIdsOutputResponse(agentsConfigurationStatus: \(String(describing: agentsConfigurationStatus)))"}
}

extension StartDataCollectionByAgentIdsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDataCollectionByAgentIdsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.agentsConfigurationStatus = output.agentsConfigurationStatus
        } else {
            self.agentsConfigurationStatus = nil
        }
    }
}

public struct StartDataCollectionByAgentIdsOutputResponse: Equatable {
    /// <p>Information about agents or the connector that were instructed to start collecting
    ///       data. Information includes the agent/connector ID, a description of the operation performed,
    ///       and whether the agent/connector configuration was updated.</p>
    public let agentsConfigurationStatus: [AgentConfigurationStatus]?

    public init (
        agentsConfigurationStatus: [AgentConfigurationStatus]? = nil
    )
    {
        self.agentsConfigurationStatus = agentsConfigurationStatus
    }
}

struct StartDataCollectionByAgentIdsOutputResponseBody: Equatable {
    public let agentsConfigurationStatus: [AgentConfigurationStatus]?
}

extension StartDataCollectionByAgentIdsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentsConfigurationStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentsConfigurationStatusContainer = try containerValues.decodeIfPresent([AgentConfigurationStatus?].self, forKey: .agentsConfigurationStatus)
        var agentsConfigurationStatusDecoded0:[AgentConfigurationStatus]? = nil
        if let agentsConfigurationStatusContainer = agentsConfigurationStatusContainer {
            agentsConfigurationStatusDecoded0 = [AgentConfigurationStatus]()
            for structure0 in agentsConfigurationStatusContainer {
                if let structure0 = structure0 {
                    agentsConfigurationStatusDecoded0?.append(structure0)
                }
            }
        }
        agentsConfigurationStatus = agentsConfigurationStatusDecoded0
    }
}

public struct StartExportTaskInputBodyMiddleware: Middleware {
    public let id: String = "StartExportTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExportTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExportTaskInput>
    public typealias MOutput = OperationOutput<StartExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExportTaskOutputError>
}

extension StartExportTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartExportTaskInput(endTime: \(String(describing: endTime)), exportDataFormat: \(String(describing: exportDataFormat)), filters: \(String(describing: filters)), startTime: \(String(describing: startTime)))"}
}

extension StartExportTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime
        case exportDataFormat
        case filters
        case startTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let exportDataFormat = exportDataFormat {
            var exportDataFormatContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportDataFormat)
            for exportdataformats0 in exportDataFormat {
                try exportDataFormatContainer.encode(exportdataformats0.rawValue)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for exportfilters0 in filters {
                try filtersContainer.encode(exportfilters0)
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct StartExportTaskInputHeadersMiddleware: Middleware {
    public let id: String = "StartExportTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExportTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExportTaskInput>
    public typealias MOutput = OperationOutput<StartExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExportTaskOutputError>
}

public struct StartExportTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "StartExportTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartExportTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartExportTaskInput>
    public typealias MOutput = OperationOutput<StartExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartExportTaskOutputError>
}

public struct StartExportTaskInput: Equatable {
    /// <p>The end timestamp for exported data from the single Application Discovery Agent
    ///       selected in the filters. If no value is specified, exported data includes the most recent data
    ///       collected by the agent.</p>
    public let endTime: Date?
    /// <p>The file format for the returned export data. Default value is <code>CSV</code>.
    ///         <b>Note:</b>
    ///             <i>The</i>
    ///             <code>GRAPHML</code>
    ///             <i>option has been deprecated.</i>
    ///          </p>
    public let exportDataFormat: [ExportDataFormat]?
    /// <p>If a filter is present, it selects the single <code>agentId</code> of the Application
    ///       Discovery Agent for which data is exported. The <code>agentId</code> can be found in the
    ///       results of the <code>DescribeAgents</code> API or CLI. If no filter is present,
    ///         <code>startTime</code> and <code>endTime</code> are ignored and exported data includes both
    ///       Agentless Discovery Connector data and summary data from Application Discovery agents.
    ///     </p>
    public let filters: [ExportFilter]?
    /// <p>The start timestamp for exported data from the single Application Discovery Agent
    ///       selected in the filters. If no value is specified, data is exported starting from the first
    ///       data collected by the agent.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        exportDataFormat: [ExportDataFormat]? = nil,
        filters: [ExportFilter]? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.exportDataFormat = exportDataFormat
        self.filters = filters
        self.startTime = startTime
    }
}

struct StartExportTaskInputBody: Equatable {
    public let exportDataFormat: [ExportDataFormat]?
    public let filters: [ExportFilter]?
    public let startTime: Date?
    public let endTime: Date?
}

extension StartExportTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime
        case exportDataFormat
        case filters
        case startTime
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportDataFormatContainer = try containerValues.decodeIfPresent([ExportDataFormat?].self, forKey: .exportDataFormat)
        var exportDataFormatDecoded0:[ExportDataFormat]? = nil
        if let exportDataFormatContainer = exportDataFormatContainer {
            exportDataFormatDecoded0 = [ExportDataFormat]()
            for string0 in exportDataFormatContainer {
                if let string0 = string0 {
                    exportDataFormatDecoded0?.append(string0)
                }
            }
        }
        exportDataFormat = exportDataFormatDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ExportFilter?].self, forKey: .filters)
        var filtersDecoded0:[ExportFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ExportFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension StartExportTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartExportTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartExportTaskOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartExportTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartExportTaskOutputResponse(exportId: \(String(describing: exportId)))"}
}

extension StartExportTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartExportTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exportId = output.exportId
        } else {
            self.exportId = nil
        }
    }
}

public struct StartExportTaskOutputResponse: Equatable {
    /// <p>A unique identifier used to query the status of an export request.</p>
    public let exportId: String?

    public init (
        exportId: String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct StartExportTaskOutputResponseBody: Equatable {
    public let exportId: String?
}

extension StartExportTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
    }
}

public struct StartImportTaskInputBodyMiddleware: Middleware {
    public let id: String = "StartImportTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImportTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImportTaskInput>
    public typealias MOutput = OperationOutput<StartImportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImportTaskOutputError>
}

extension StartImportTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartImportTaskInput(clientRequestToken: \(String(describing: clientRequestToken)), importUrl: \(String(describing: importUrl)), name: \(String(describing: name)))"}
}

extension StartImportTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case importUrl
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let importUrl = importUrl {
            try encodeContainer.encode(importUrl, forKey: .importUrl)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StartImportTaskInputHeadersMiddleware: Middleware {
    public let id: String = "StartImportTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImportTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImportTaskInput>
    public typealias MOutput = OperationOutput<StartImportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImportTaskOutputError>
}

public struct StartImportTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "StartImportTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImportTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImportTaskInput>
    public typealias MOutput = OperationOutput<StartImportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImportTaskOutputError>
}

public struct StartImportTaskInput: Equatable {
    /// <p>Optional. A unique token that you can provide to prevent the same import request from
    ///       occurring more than once. If you don't provide a token, a token is automatically
    ///       generated.</p>
    ///
    ///          <p>Sending more than one <code>StartImportTask</code> request with the same client request
    ///       token will return information about the original import task with that client request
    ///       token.</p>
    public var clientRequestToken: String?
    /// <p>The URL for your import file that you've uploaded to Amazon S3.</p>
    ///
    ///          <note>
    ///             <p>If you're using the AWS CLI, this URL is structured as follows:
    ///           <code>s3://BucketName/ImportFileName.CSV</code>
    ///             </p>
    ///          </note>
    public let importUrl: String?
    /// <p>A descriptive name for this request. You can use this name to filter future requests
    ///       related to this import task, such as identifying applications and servers that were included
    ///       in this import task. We recommend that you use a meaningful name for each import task.</p>
    public let name: String?

    public init (
        clientRequestToken: String? = nil,
        importUrl: String? = nil,
        name: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.importUrl = importUrl
        self.name = name
    }
}

struct StartImportTaskInputBody: Equatable {
    public let clientRequestToken: String?
    public let name: String?
    public let importUrl: String?
}

extension StartImportTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case importUrl
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let importUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importUrl)
        importUrl = importUrlDecoded
    }
}

extension StartImportTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImportTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartImportTaskOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceInUseException(ResourceInUseException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImportTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartImportTaskOutputResponse(task: \(String(describing: task)))"}
}

extension StartImportTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartImportTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.task = output.task
        } else {
            self.task = nil
        }
    }
}

public struct StartImportTaskOutputResponse: Equatable {
    /// <p>An array of information related to the import task request including status information,
    ///       times, IDs, the Amazon S3 Object URL for the import file, and more. </p>
    public let task: ImportTask?

    public init (
        task: ImportTask? = nil
    )
    {
        self.task = task
    }
}

struct StartImportTaskOutputResponseBody: Equatable {
    public let task: ImportTask?
}

extension StartImportTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case task
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskDecoded = try containerValues.decodeIfPresent(ImportTask.self, forKey: .task)
        task = taskDecoded
    }
}

public struct StopContinuousExportInputBodyMiddleware: Middleware {
    public let id: String = "StopContinuousExportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopContinuousExportInput>,
                  next: H) -> Swift.Result<OperationOutput<StopContinuousExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopContinuousExportInput>
    public typealias MOutput = OperationOutput<StopContinuousExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopContinuousExportOutputError>
}

extension StopContinuousExportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopContinuousExportInput(exportId: \(String(describing: exportId)))"}
}

extension StopContinuousExportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportId = exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
    }
}

public struct StopContinuousExportInputHeadersMiddleware: Middleware {
    public let id: String = "StopContinuousExportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopContinuousExportInput>,
                  next: H) -> Swift.Result<OperationOutput<StopContinuousExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopContinuousExportInput>
    public typealias MOutput = OperationOutput<StopContinuousExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopContinuousExportOutputError>
}

public struct StopContinuousExportInputQueryItemMiddleware: Middleware {
    public let id: String = "StopContinuousExportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopContinuousExportInput>,
                  next: H) -> Swift.Result<OperationOutput<StopContinuousExportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopContinuousExportInput>
    public typealias MOutput = OperationOutput<StopContinuousExportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopContinuousExportOutputError>
}

public struct StopContinuousExportInput: Equatable {
    /// <p>The unique ID assigned to this export.</p>
    public let exportId: String?

    public init (
        exportId: String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct StopContinuousExportInputBody: Equatable {
    public let exportId: String?
}

extension StopContinuousExportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportId)
        exportId = exportIdDecoded
    }
}

extension StopContinuousExportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopContinuousExportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopContinuousExportOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopContinuousExportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopContinuousExportOutputResponse(startTime: \(String(describing: startTime)), stopTime: \(String(describing: stopTime)))"}
}

extension StopContinuousExportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopContinuousExportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.startTime = output.startTime
            self.stopTime = output.stopTime
        } else {
            self.startTime = nil
            self.stopTime = nil
        }
    }
}

public struct StopContinuousExportOutputResponse: Equatable {
    /// <p>Timestamp that represents when this continuous export started collecting
    ///       data.</p>
    public let startTime: Date?
    /// <p>Timestamp that represents when this continuous export was stopped.</p>
    public let stopTime: Date?

    public init (
        startTime: Date? = nil,
        stopTime: Date? = nil
    )
    {
        self.startTime = startTime
        self.stopTime = stopTime
    }
}

struct StopContinuousExportOutputResponseBody: Equatable {
    public let startTime: Date?
    public let stopTime: Date?
}

extension StopContinuousExportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case startTime
        case stopTime
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

public struct StopDataCollectionByAgentIdsInputBodyMiddleware: Middleware {
    public let id: String = "StopDataCollectionByAgentIdsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDataCollectionByAgentIdsInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDataCollectionByAgentIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDataCollectionByAgentIdsInput>
    public typealias MOutput = OperationOutput<StopDataCollectionByAgentIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDataCollectionByAgentIdsOutputError>
}

extension StopDataCollectionByAgentIdsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDataCollectionByAgentIdsInput(agentIds: \(String(describing: agentIds)))"}
}

extension StopDataCollectionByAgentIdsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentIds = agentIds {
            var agentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentIds)
            for agentids0 in agentIds {
                try agentIdsContainer.encode(agentids0)
            }
        }
    }
}

public struct StopDataCollectionByAgentIdsInputHeadersMiddleware: Middleware {
    public let id: String = "StopDataCollectionByAgentIdsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDataCollectionByAgentIdsInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDataCollectionByAgentIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDataCollectionByAgentIdsInput>
    public typealias MOutput = OperationOutput<StopDataCollectionByAgentIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDataCollectionByAgentIdsOutputError>
}

public struct StopDataCollectionByAgentIdsInputQueryItemMiddleware: Middleware {
    public let id: String = "StopDataCollectionByAgentIdsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDataCollectionByAgentIdsInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDataCollectionByAgentIdsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDataCollectionByAgentIdsInput>
    public typealias MOutput = OperationOutput<StopDataCollectionByAgentIdsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDataCollectionByAgentIdsOutputError>
}

public struct StopDataCollectionByAgentIdsInput: Equatable {
    /// <p>The IDs of the agents or connectors from which to stop collecting data.</p>
    public let agentIds: [String]?

    public init (
        agentIds: [String]? = nil
    )
    {
        self.agentIds = agentIds
    }
}

struct StopDataCollectionByAgentIdsInputBody: Equatable {
    public let agentIds: [String]?
}

extension StopDataCollectionByAgentIdsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentIds)
        var agentIdsDecoded0:[String]? = nil
        if let agentIdsContainer = agentIdsContainer {
            agentIdsDecoded0 = [String]()
            for string0 in agentIdsContainer {
                if let string0 = string0 {
                    agentIdsDecoded0?.append(string0)
                }
            }
        }
        agentIds = agentIdsDecoded0
    }
}

extension StopDataCollectionByAgentIdsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopDataCollectionByAgentIdsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDataCollectionByAgentIdsOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDataCollectionByAgentIdsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDataCollectionByAgentIdsOutputResponse(agentsConfigurationStatus: \(String(describing: agentsConfigurationStatus)))"}
}

extension StopDataCollectionByAgentIdsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopDataCollectionByAgentIdsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.agentsConfigurationStatus = output.agentsConfigurationStatus
        } else {
            self.agentsConfigurationStatus = nil
        }
    }
}

public struct StopDataCollectionByAgentIdsOutputResponse: Equatable {
    /// <p>Information about the agents or connector that were instructed to stop collecting data.
    ///       Information includes the agent/connector ID, a description of the operation performed, and
    ///       whether the agent/connector configuration was updated.</p>
    public let agentsConfigurationStatus: [AgentConfigurationStatus]?

    public init (
        agentsConfigurationStatus: [AgentConfigurationStatus]? = nil
    )
    {
        self.agentsConfigurationStatus = agentsConfigurationStatus
    }
}

struct StopDataCollectionByAgentIdsOutputResponseBody: Equatable {
    public let agentsConfigurationStatus: [AgentConfigurationStatus]?
}

extension StopDataCollectionByAgentIdsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentsConfigurationStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentsConfigurationStatusContainer = try containerValues.decodeIfPresent([AgentConfigurationStatus?].self, forKey: .agentsConfigurationStatus)
        var agentsConfigurationStatusDecoded0:[AgentConfigurationStatus]? = nil
        if let agentsConfigurationStatusContainer = agentsConfigurationStatusContainer {
            agentsConfigurationStatusDecoded0 = [AgentConfigurationStatus]()
            for structure0 in agentsConfigurationStatusContainer {
                if let structure0 = structure0 {
                    agentsConfigurationStatusDecoded0?.append(structure0)
                }
            }
        }
        agentsConfigurationStatus = agentsConfigurationStatusDecoded0
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Metadata that help you categorize IT assets.</p>
public struct Tag: Equatable {
    /// <p>The type of tag on which to filter.</p>
    public let key: String?
    /// <p>A value for a tag key on which to filter.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension TagFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagFilter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>The tag filter. Valid names are: <code>tagKey</code>, <code>tagValue</code>,
///         <code>configurationId</code>.</p>
public struct TagFilter: Equatable {
    /// <p>A name of the tag filter.</p>
    public let name: String?
    /// <p>Values for the tag filter.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

public struct UpdateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

extension UpdateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationInput(configurationId: \(String(describing: configurationId)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension UpdateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationId
        case description
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInput: Equatable {
    /// <p>Configuration ID of the application to be updated.</p>
    public let configurationId: String?
    /// <p>New description of the application to be updated.</p>
    public let description: String?
    /// <p>New name of the application to be updated.</p>
    public let name: String?

    public init (
        configurationId: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.configurationId = configurationId
        self.description = description
        self.name = name
    }
}

struct UpdateApplicationInputBody: Equatable {
    public let configurationId: String?
    public let name: String?
    public let description: String?
}

extension UpdateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationId
        case description
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationOutputResponse()"}
}

extension UpdateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateApplicationOutputResponse: Equatable {

    public init() {}
}

struct UpdateApplicationOutputResponseBody: Equatable {
}

extension UpdateApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
