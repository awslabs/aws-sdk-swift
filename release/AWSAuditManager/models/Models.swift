// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AuditManagerClientTypes.AWSAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailAddress
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AuditManagerClientTypes {
    /// The wrapper of Amazon Web Services account details, such as account ID or email address.
    public struct AWSAccount: Swift.Equatable {
        /// The email address that's associated with the Amazon Web Services account.
        public var emailAddress: Swift.String?
        /// The identifier for the Amazon Web Services account.
        public var id: Swift.String?
        /// The name of the Amazon Web Services account.
        public var name: Swift.String?

        public init (
            emailAddress: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.emailAddress = emailAddress
            self.id = id
            self.name = name
        }
    }

}

extension AuditManagerClientTypes.AWSService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension AuditManagerClientTypes {
    /// An Amazon Web Service such as Amazon S3 or CloudTrail.
    public struct AWSService: Swift.Equatable {
        /// The name of the Amazon Web Service.
        public var serviceName: Swift.String?

        public init (
            serviceName: Swift.String? = nil
        )
        {
            self.serviceName = serviceName
        }
    }

}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your account isn't registered with Audit Manager. Check the delegated administrator setup on the Audit Manager settings page, and try again.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuditManagerClientTypes {
    public enum AccountStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case pendingActivation
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountStatus] {
            return [
                .active,
                .inactive,
                .pendingActivation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .pendingActivation: return "PENDING_ACTIVATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountStatus(rawValue: rawValue) ?? AccountStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum ActionEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case create
        case delete
        case importEvidence
        case inactive
        case reviewed
        case underReview
        case updateMetadata
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionEnum] {
            return [
                .active,
                .create,
                .delete,
                .importEvidence,
                .inactive,
                .reviewed,
                .underReview,
                .updateMetadata,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .importEvidence: return "IMPORT_EVIDENCE"
            case .inactive: return "INACTIVE"
            case .reviewed: return "REVIEWED"
            case .underReview: return "UNDER_REVIEW"
            case .updateMetadata: return "UPDATE_METADATA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionEnum(rawValue: rawValue) ?? ActionEnum.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.Assessment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case awsAccount
        case framework
        case metadata
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let awsAccount = self.awsAccount {
            try encodeContainer.encode(awsAccount, forKey: .awsAccount)
        }
        if let framework = self.framework {
            try encodeContainer.encode(framework, forKey: .framework)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let awsAccountDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AWSAccount.self, forKey: .awsAccount)
        awsAccount = awsAccountDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let frameworkDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentFramework.self, forKey: .framework)
        framework = frameworkDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AuditManagerClientTypes {
    /// An entity that defines the scope of audit evidence collected by Audit Manager. An Audit Manager assessment is an implementation of an Audit Manager framework.
    public struct Assessment: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the assessment.
        public var arn: Swift.String?
        /// The Amazon Web Services account that's associated with the assessment.
        public var awsAccount: AuditManagerClientTypes.AWSAccount?
        /// The framework that the assessment was created from.
        public var framework: AuditManagerClientTypes.AssessmentFramework?
        /// The metadata for the assessment.
        public var metadata: AuditManagerClientTypes.AssessmentMetadata?
        /// The tags that are associated with the assessment.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            awsAccount: AuditManagerClientTypes.AWSAccount? = nil,
            framework: AuditManagerClientTypes.AssessmentFramework? = nil,
            metadata: AuditManagerClientTypes.AssessmentMetadata? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.awsAccount = awsAccount
            self.framework = framework
            self.metadata = metadata
            self.tags = tags
        }
    }

}

extension AuditManagerClientTypes.AssessmentControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReportEvidenceCount
        case comments
        case description
        case evidenceCount
        case evidenceSources
        case id
        case name
        case response
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assessmentReportEvidenceCount != 0 {
            try encodeContainer.encode(assessmentReportEvidenceCount, forKey: .assessmentReportEvidenceCount)
        }
        if let comments = comments {
            var commentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comments)
            for controlcomment0 in comments {
                try commentsContainer.encode(controlcomment0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if evidenceCount != 0 {
            try encodeContainer.encode(evidenceCount, forKey: .evidenceCount)
        }
        if let evidenceSources = evidenceSources {
            var evidenceSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evidenceSources)
            for nonemptystring0 in evidenceSources {
                try evidenceSourcesContainer.encode(nonemptystring0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let response = self.response {
            try encodeContainer.encode(response.rawValue, forKey: .response)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ControlStatus.self, forKey: .status)
        status = statusDecoded
        let responseDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ControlResponse.self, forKey: .response)
        response = responseDecoded
        let commentsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlComment?].self, forKey: .comments)
        var commentsDecoded0:[AuditManagerClientTypes.ControlComment]? = nil
        if let commentsContainer = commentsContainer {
            commentsDecoded0 = [AuditManagerClientTypes.ControlComment]()
            for structure0 in commentsContainer {
                if let structure0 = structure0 {
                    commentsDecoded0?.append(structure0)
                }
            }
        }
        comments = commentsDecoded0
        let evidenceSourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .evidenceSources)
        var evidenceSourcesDecoded0:[Swift.String]? = nil
        if let evidenceSourcesContainer = evidenceSourcesContainer {
            evidenceSourcesDecoded0 = [Swift.String]()
            for string0 in evidenceSourcesContainer {
                if let string0 = string0 {
                    evidenceSourcesDecoded0?.append(string0)
                }
            }
        }
        evidenceSources = evidenceSourcesDecoded0
        let evidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceCount) ?? 0
        evidenceCount = evidenceCountDecoded
        let assessmentReportEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assessmentReportEvidenceCount) ?? 0
        assessmentReportEvidenceCount = assessmentReportEvidenceCountDecoded
    }
}

extension AuditManagerClientTypes {
    /// The control entity that represents a standard control or a custom control in an Audit Manager assessment.
    public struct AssessmentControl: Swift.Equatable {
        /// The amount of evidence in the assessment report.
        public var assessmentReportEvidenceCount: Swift.Int
        /// The list of comments that's attached to the control.
        public var comments: [AuditManagerClientTypes.ControlComment]?
        /// The description of the control.
        public var description: Swift.String?
        /// The amount of evidence that's generated for the control.
        public var evidenceCount: Swift.Int
        /// The list of data sources for the evidence.
        public var evidenceSources: [Swift.String]?
        /// The identifier for the control.
        public var id: Swift.String?
        /// The name of the control.
        public var name: Swift.String?
        /// The response of the control.
        public var response: AuditManagerClientTypes.ControlResponse?
        /// The status of the control.
        public var status: AuditManagerClientTypes.ControlStatus?

        public init (
            assessmentReportEvidenceCount: Swift.Int = 0,
            comments: [AuditManagerClientTypes.ControlComment]? = nil,
            description: Swift.String? = nil,
            evidenceCount: Swift.Int = 0,
            evidenceSources: [Swift.String]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            response: AuditManagerClientTypes.ControlResponse? = nil,
            status: AuditManagerClientTypes.ControlStatus? = nil
        )
        {
            self.assessmentReportEvidenceCount = assessmentReportEvidenceCount
            self.comments = comments
            self.description = description
            self.evidenceCount = evidenceCount
            self.evidenceSources = evidenceSources
            self.id = id
            self.name = name
            self.response = response
            self.status = status
        }
    }

}

extension AuditManagerClientTypes.AssessmentControlSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controls
        case delegations
        case description
        case id
        case manualEvidenceCount
        case roles
        case status
        case systemEvidenceCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for assessmentcontrol0 in controls {
                try controlsContainer.encode(assessmentcontrol0)
            }
        }
        if let delegations = delegations {
            var delegationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .delegations)
            for delegation0 in delegations {
                try delegationsContainer.encode(delegation0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if manualEvidenceCount != 0 {
            try encodeContainer.encode(manualEvidenceCount, forKey: .manualEvidenceCount)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for role0 in roles {
                try rolesContainer.encode(role0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if systemEvidenceCount != 0 {
            try encodeContainer.encode(systemEvidenceCount, forKey: .systemEvidenceCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ControlSetStatus.self, forKey: .status)
        status = statusDecoded
        let rolesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .roles)
        var rolesDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let controlsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentControl?].self, forKey: .controls)
        var controlsDecoded0:[AuditManagerClientTypes.AssessmentControl]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [AuditManagerClientTypes.AssessmentControl]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
        let delegationsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Delegation?].self, forKey: .delegations)
        var delegationsDecoded0:[AuditManagerClientTypes.Delegation]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [AuditManagerClientTypes.Delegation]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let systemEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .systemEvidenceCount) ?? 0
        systemEvidenceCount = systemEvidenceCountDecoded
        let manualEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manualEvidenceCount) ?? 0
        manualEvidenceCount = manualEvidenceCountDecoded
    }
}

extension AuditManagerClientTypes {
    /// Represents a set of controls in an Audit Manager assessment.
    public struct AssessmentControlSet: Swift.Equatable {
        /// The list of controls that's contained with the control set.
        public var controls: [AuditManagerClientTypes.AssessmentControl]?
        /// The delegations that are associated with the control set.
        public var delegations: [AuditManagerClientTypes.Delegation]?
        /// The description for the control set.
        public var description: Swift.String?
        /// The identifier of the control set in the assessment. This is the control set name in a plain string format.
        public var id: Swift.String?
        /// The total number of evidence objects that are uploaded manually to the control set.
        public var manualEvidenceCount: Swift.Int
        /// The roles that are associated with the control set.
        public var roles: [AuditManagerClientTypes.Role]?
        /// Specifies the current status of the control set.
        public var status: AuditManagerClientTypes.ControlSetStatus?
        /// The total number of evidence objects that are retrieved automatically for the control set.
        public var systemEvidenceCount: Swift.Int

        public init (
            controls: [AuditManagerClientTypes.AssessmentControl]? = nil,
            delegations: [AuditManagerClientTypes.Delegation]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            manualEvidenceCount: Swift.Int = 0,
            roles: [AuditManagerClientTypes.Role]? = nil,
            status: AuditManagerClientTypes.ControlSetStatus? = nil,
            systemEvidenceCount: Swift.Int = 0
        )
        {
            self.controls = controls
            self.delegations = delegations
            self.description = description
            self.id = id
            self.manualEvidenceCount = manualEvidenceCount
            self.roles = roles
            self.status = status
            self.systemEvidenceCount = systemEvidenceCount
        }
    }

}

extension AuditManagerClientTypes.AssessmentEvidenceFolder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
        case assessmentReportSelectionCount
        case author
        case controlId
        case controlName
        case controlSetId
        case dataSource
        case date
        case evidenceAwsServiceSourceCount
        case evidenceByTypeComplianceCheckCount
        case evidenceByTypeComplianceCheckIssuesCount
        case evidenceByTypeConfigurationDataCount
        case evidenceByTypeManualCount
        case evidenceByTypeUserActivityCount
        case evidenceResourcesIncludedCount
        case id
        case name
        case totalEvidence
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if assessmentReportSelectionCount != 0 {
            try encodeContainer.encode(assessmentReportSelectionCount, forKey: .assessmentReportSelectionCount)
        }
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let controlId = self.controlId {
            try encodeContainer.encode(controlId, forKey: .controlId)
        }
        if let controlName = self.controlName {
            try encodeContainer.encode(controlName, forKey: .controlName)
        }
        if let controlSetId = self.controlSetId {
            try encodeContainer.encode(controlSetId, forKey: .controlSetId)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let date = self.date {
            try encodeContainer.encodeTimestamp(date, format: .epochSeconds, forKey: .date)
        }
        if evidenceAwsServiceSourceCount != 0 {
            try encodeContainer.encode(evidenceAwsServiceSourceCount, forKey: .evidenceAwsServiceSourceCount)
        }
        if evidenceByTypeComplianceCheckCount != 0 {
            try encodeContainer.encode(evidenceByTypeComplianceCheckCount, forKey: .evidenceByTypeComplianceCheckCount)
        }
        if evidenceByTypeComplianceCheckIssuesCount != 0 {
            try encodeContainer.encode(evidenceByTypeComplianceCheckIssuesCount, forKey: .evidenceByTypeComplianceCheckIssuesCount)
        }
        if evidenceByTypeConfigurationDataCount != 0 {
            try encodeContainer.encode(evidenceByTypeConfigurationDataCount, forKey: .evidenceByTypeConfigurationDataCount)
        }
        if evidenceByTypeManualCount != 0 {
            try encodeContainer.encode(evidenceByTypeManualCount, forKey: .evidenceByTypeManualCount)
        }
        if evidenceByTypeUserActivityCount != 0 {
            try encodeContainer.encode(evidenceByTypeUserActivityCount, forKey: .evidenceByTypeUserActivityCount)
        }
        if evidenceResourcesIncludedCount != 0 {
            try encodeContainer.encode(evidenceResourcesIncludedCount, forKey: .evidenceResourcesIncludedCount)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if totalEvidence != 0 {
            try encodeContainer.encode(totalEvidence, forKey: .totalEvidence)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .date)
        date = dateDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let controlSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetId)
        controlSetId = controlSetIdDecoded
        let controlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlId)
        controlId = controlIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let totalEvidenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalEvidence) ?? 0
        totalEvidence = totalEvidenceDecoded
        let assessmentReportSelectionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assessmentReportSelectionCount) ?? 0
        assessmentReportSelectionCount = assessmentReportSelectionCountDecoded
        let controlNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlName)
        controlName = controlNameDecoded
        let evidenceResourcesIncludedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceResourcesIncludedCount) ?? 0
        evidenceResourcesIncludedCount = evidenceResourcesIncludedCountDecoded
        let evidenceByTypeConfigurationDataCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceByTypeConfigurationDataCount) ?? 0
        evidenceByTypeConfigurationDataCount = evidenceByTypeConfigurationDataCountDecoded
        let evidenceByTypeManualCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceByTypeManualCount) ?? 0
        evidenceByTypeManualCount = evidenceByTypeManualCountDecoded
        let evidenceByTypeComplianceCheckCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceByTypeComplianceCheckCount) ?? 0
        evidenceByTypeComplianceCheckCount = evidenceByTypeComplianceCheckCountDecoded
        let evidenceByTypeComplianceCheckIssuesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceByTypeComplianceCheckIssuesCount) ?? 0
        evidenceByTypeComplianceCheckIssuesCount = evidenceByTypeComplianceCheckIssuesCountDecoded
        let evidenceByTypeUserActivityCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceByTypeUserActivityCount) ?? 0
        evidenceByTypeUserActivityCount = evidenceByTypeUserActivityCountDecoded
        let evidenceAwsServiceSourceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evidenceAwsServiceSourceCount) ?? 0
        evidenceAwsServiceSourceCount = evidenceAwsServiceSourceCountDecoded
    }
}

extension AuditManagerClientTypes {
    /// The folder where Audit Manager stores evidence for an assessment.
    public struct AssessmentEvidenceFolder: Swift.Equatable {
        /// The identifier for the assessment.
        public var assessmentId: Swift.String?
        /// The total count of evidence that's included in the assessment report.
        public var assessmentReportSelectionCount: Swift.Int
        /// The name of the user who created the evidence folder.
        public var author: Swift.String?
        /// The unique identifier for the control.
        public var controlId: Swift.String?
        /// The name of the control.
        public var controlName: Swift.String?
        /// The identifier for the control set.
        public var controlSetId: Swift.String?
        /// The Amazon Web Service that the evidence was collected from.
        public var dataSource: Swift.String?
        /// The date when the first evidence was added to the evidence folder.
        public var date: ClientRuntime.Date?
        /// The total number of Amazon Web Services resources that were assessed to generate the evidence.
        public var evidenceAwsServiceSourceCount: Swift.Int
        /// The number of evidence that falls under the compliance check category. This evidence is collected from Config or Security Hub.
        public var evidenceByTypeComplianceCheckCount: Swift.Int
        /// The total number of issues that were reported directly from Security Hub, Config, or both.
        public var evidenceByTypeComplianceCheckIssuesCount: Swift.Int
        /// The number of evidence that falls under the configuration data category. This evidence is collected from configuration snapshots of other Amazon Web Services such as Amazon EC2, Amazon S3, or IAM.
        public var evidenceByTypeConfigurationDataCount: Swift.Int
        /// The number of evidence that falls under the manual category. This evidence is imported manually.
        public var evidenceByTypeManualCount: Swift.Int
        /// The number of evidence that falls under the user activity category. This evidence is collected from CloudTrail logs.
        public var evidenceByTypeUserActivityCount: Swift.Int
        /// The amount of evidence that's included in the evidence folder.
        public var evidenceResourcesIncludedCount: Swift.Int
        /// The identifier for the folder that the evidence is stored in.
        public var id: Swift.String?
        /// The name of the evidence folder.
        public var name: Swift.String?
        /// The total amount of evidence in the evidence folder.
        public var totalEvidence: Swift.Int

        public init (
            assessmentId: Swift.String? = nil,
            assessmentReportSelectionCount: Swift.Int = 0,
            author: Swift.String? = nil,
            controlId: Swift.String? = nil,
            controlName: Swift.String? = nil,
            controlSetId: Swift.String? = nil,
            dataSource: Swift.String? = nil,
            date: ClientRuntime.Date? = nil,
            evidenceAwsServiceSourceCount: Swift.Int = 0,
            evidenceByTypeComplianceCheckCount: Swift.Int = 0,
            evidenceByTypeComplianceCheckIssuesCount: Swift.Int = 0,
            evidenceByTypeConfigurationDataCount: Swift.Int = 0,
            evidenceByTypeManualCount: Swift.Int = 0,
            evidenceByTypeUserActivityCount: Swift.Int = 0,
            evidenceResourcesIncludedCount: Swift.Int = 0,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            totalEvidence: Swift.Int = 0
        )
        {
            self.assessmentId = assessmentId
            self.assessmentReportSelectionCount = assessmentReportSelectionCount
            self.author = author
            self.controlId = controlId
            self.controlName = controlName
            self.controlSetId = controlSetId
            self.dataSource = dataSource
            self.date = date
            self.evidenceAwsServiceSourceCount = evidenceAwsServiceSourceCount
            self.evidenceByTypeComplianceCheckCount = evidenceByTypeComplianceCheckCount
            self.evidenceByTypeComplianceCheckIssuesCount = evidenceByTypeComplianceCheckIssuesCount
            self.evidenceByTypeConfigurationDataCount = evidenceByTypeConfigurationDataCount
            self.evidenceByTypeManualCount = evidenceByTypeManualCount
            self.evidenceByTypeUserActivityCount = evidenceByTypeUserActivityCount
            self.evidenceResourcesIncludedCount = evidenceResourcesIncludedCount
            self.id = id
            self.name = name
            self.totalEvidence = totalEvidence
        }
    }

}

extension AuditManagerClientTypes.AssessmentFramework: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case controlSets
        case id
        case metadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlSets = controlSets {
            var controlSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlSets)
            for assessmentcontrolset0 in controlSets {
                try controlSetsContainer.encode(assessmentcontrolset0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.FrameworkMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let controlSetsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentControlSet?].self, forKey: .controlSets)
        var controlSetsDecoded0:[AuditManagerClientTypes.AssessmentControlSet]? = nil
        if let controlSetsContainer = controlSetsContainer {
            controlSetsDecoded0 = [AuditManagerClientTypes.AssessmentControlSet]()
            for structure0 in controlSetsContainer {
                if let structure0 = structure0 {
                    controlSetsDecoded0?.append(structure0)
                }
            }
        }
        controlSets = controlSetsDecoded0
    }
}

extension AuditManagerClientTypes {
    /// The file used to structure and automate Audit Manager assessments for a given compliance standard.
    public struct AssessmentFramework: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the framework.
        public var arn: Swift.String?
        /// The control sets that are associated with the framework.
        public var controlSets: [AuditManagerClientTypes.AssessmentControlSet]?
        /// The unique identifier for the framework.
        public var id: Swift.String?
        /// The metadata of a framework, such as the name, ID, or description.
        public var metadata: AuditManagerClientTypes.FrameworkMetadata?

        public init (
            arn: Swift.String? = nil,
            controlSets: [AuditManagerClientTypes.AssessmentControlSet]? = nil,
            id: Swift.String? = nil,
            metadata: AuditManagerClientTypes.FrameworkMetadata? = nil
        )
        {
            self.arn = arn
            self.controlSets = controlSets
            self.id = id
            self.metadata = metadata
        }
    }

}

extension AuditManagerClientTypes.AssessmentFrameworkMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case complianceType
        case controlSetsCount
        case controlsCount
        case createdAt
        case description
        case id
        case lastUpdatedAt
        case logo
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if controlSetsCount != 0 {
            try encodeContainer.encode(controlSetsCount, forKey: .controlSetsCount)
        }
        if controlsCount != 0 {
            try encodeContainer.encode(controlsCount, forKey: .controlsCount)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let logo = self.logo {
            try encodeContainer.encode(logo, forKey: .logo)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.FrameworkType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let logoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logo)
        logo = logoDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let controlsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .controlsCount) ?? 0
        controlsCount = controlsCountDecoded
        let controlSetsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .controlSetsCount) ?? 0
        controlSetsCount = controlSetsCountDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AuditManagerClientTypes {
    /// The metadata that's associated with a standard framework or a custom framework.
    public struct AssessmentFrameworkMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the framework.
        public var arn: Swift.String?
        /// The compliance type that the new custom framework supports, such as CIS or HIPAA.
        public var complianceType: Swift.String?
        /// The number of control sets that are associated with the framework.
        public var controlSetsCount: Swift.Int
        /// The number of controls that are associated with the framework.
        public var controlsCount: Swift.Int
        /// Specifies when the framework was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the framework.
        public var description: Swift.String?
        /// The unique identifier for the framework.
        public var id: Swift.String?
        /// Specifies when the framework was most recently updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The logo that's associated with the framework.
        public var logo: Swift.String?
        /// The name of the framework.
        public var name: Swift.String?
        /// The framework type, such as a standard framework or a custom framework.
        public var type: AuditManagerClientTypes.FrameworkType?

        public init (
            arn: Swift.String? = nil,
            complianceType: Swift.String? = nil,
            controlSetsCount: Swift.Int = 0,
            controlsCount: Swift.Int = 0,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            logo: Swift.String? = nil,
            name: Swift.String? = nil,
            type: AuditManagerClientTypes.FrameworkType? = nil
        )
        {
            self.arn = arn
            self.complianceType = complianceType
            self.controlSetsCount = controlSetsCount
            self.controlsCount = controlsCount
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.logo = logo
            self.name = name
            self.type = type
        }
    }

}

extension AuditManagerClientTypes.AssessmentFrameworkShareRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case complianceType
        case creationTime
        case customControlsCount
        case destinationAccount
        case destinationRegion
        case expirationTime
        case frameworkDescription
        case frameworkId
        case frameworkName
        case id
        case lastUpdated
        case sourceAccount
        case standardControlsCount
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let customControlsCount = self.customControlsCount {
            try encodeContainer.encode(customControlsCount, forKey: .customControlsCount)
        }
        if let destinationAccount = self.destinationAccount {
            try encodeContainer.encode(destinationAccount, forKey: .destinationAccount)
        }
        if let destinationRegion = self.destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .epochSeconds, forKey: .expirationTime)
        }
        if let frameworkDescription = self.frameworkDescription {
            try encodeContainer.encode(frameworkDescription, forKey: .frameworkDescription)
        }
        if let frameworkId = self.frameworkId {
            try encodeContainer.encode(frameworkId, forKey: .frameworkId)
        }
        if let frameworkName = self.frameworkName {
            try encodeContainer.encode(frameworkName, forKey: .frameworkName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let sourceAccount = self.sourceAccount {
            try encodeContainer.encode(sourceAccount, forKey: .sourceAccount)
        }
        if let standardControlsCount = self.standardControlsCount {
            try encodeContainer.encode(standardControlsCount, forKey: .standardControlsCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let frameworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkId)
        frameworkId = frameworkIdDecoded
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ShareRequestStatus.self, forKey: .status)
        status = statusDecoded
        let sourceAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccount)
        sourceAccount = sourceAccountDecoded
        let destinationAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationAccount)
        destinationAccount = destinationAccountDecoded
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let standardControlsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .standardControlsCount)
        standardControlsCount = standardControlsCountDecoded
        let customControlsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .customControlsCount)
        customControlsCount = customControlsCountDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
    }
}

extension AuditManagerClientTypes {
    /// Represents a share request for a custom framework in Audit Manager.
    public struct AssessmentFrameworkShareRequest: Swift.Equatable {
        /// An optional comment from the sender about the share request.
        public var comment: Swift.String?
        /// The compliance type that the shared custom framework supports, such as CIS or HIPAA.
        public var complianceType: Swift.String?
        /// The time when the share request was created.
        public var creationTime: ClientRuntime.Date?
        /// The number of custom controls that are part of the shared custom framework.
        public var customControlsCount: Swift.Int?
        /// The Amazon Web Services account of the recipient.
        public var destinationAccount: Swift.String?
        /// The Amazon Web Services Region of the recipient.
        public var destinationRegion: Swift.String?
        /// The time when the share request expires.
        public var expirationTime: ClientRuntime.Date?
        /// The description of the shared custom framework.
        public var frameworkDescription: Swift.String?
        /// The unique identifier for the shared custom framework.
        public var frameworkId: Swift.String?
        /// The name of the custom framework that the share request is for.
        public var frameworkName: Swift.String?
        /// The unique identifier for the share request.
        public var id: Swift.String?
        /// Specifies when the share request was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The Amazon Web Services account of the sender.
        public var sourceAccount: Swift.String?
        /// The number of standard controls that are part of the shared custom framework.
        public var standardControlsCount: Swift.Int?
        /// The status of the share request.
        public var status: AuditManagerClientTypes.ShareRequestStatus?

        public init (
            comment: Swift.String? = nil,
            complianceType: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            customControlsCount: Swift.Int? = nil,
            destinationAccount: Swift.String? = nil,
            destinationRegion: Swift.String? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            frameworkDescription: Swift.String? = nil,
            frameworkId: Swift.String? = nil,
            frameworkName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            sourceAccount: Swift.String? = nil,
            standardControlsCount: Swift.Int? = nil,
            status: AuditManagerClientTypes.ShareRequestStatus? = nil
        )
        {
            self.comment = comment
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.customControlsCount = customControlsCount
            self.destinationAccount = destinationAccount
            self.destinationRegion = destinationRegion
            self.expirationTime = expirationTime
            self.frameworkDescription = frameworkDescription
            self.frameworkId = frameworkId
            self.frameworkName = frameworkName
            self.id = id
            self.lastUpdated = lastUpdated
            self.sourceAccount = sourceAccount
            self.standardControlsCount = standardControlsCount
            self.status = status
        }
    }

}

extension AuditManagerClientTypes.AssessmentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReportsDestination
        case complianceType
        case creationTime
        case delegations
        case description
        case id
        case lastUpdated
        case name
        case roles
        case scope
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentReportsDestination = self.assessmentReportsDestination {
            try encodeContainer.encode(assessmentReportsDestination, forKey: .assessmentReportsDestination)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let delegations = delegations {
            var delegationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .delegations)
            for delegation0 in delegations {
                try delegationsContainer.encode(delegation0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for role0 in roles {
                try rolesContainer.encode(role0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentStatus.self, forKey: .status)
        status = statusDecoded
        let assessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportsDestination.self, forKey: .assessmentReportsDestination)
        assessmentReportsDestination = assessmentReportsDestinationDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let rolesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .roles)
        var rolesDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let delegationsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Delegation?].self, forKey: .delegations)
        var delegationsDecoded0:[AuditManagerClientTypes.Delegation]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [AuditManagerClientTypes.Delegation]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes {
    /// The metadata that's associated with the specified assessment.
    public struct AssessmentMetadata: Swift.Equatable {
        /// The destination that evidence reports are stored in for the assessment.
        public var assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
        /// The name of the compliance standard that's related to the assessment, such as PCI-DSS.
        public var complianceType: Swift.String?
        /// Specifies when the assessment was created.
        public var creationTime: ClientRuntime.Date?
        /// The delegations that are associated with the assessment.
        public var delegations: [AuditManagerClientTypes.Delegation]?
        /// The description of the assessment.
        public var description: Swift.String?
        /// The unique identifier for the assessment.
        public var id: Swift.String?
        /// The time of the most recent update.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the assessment.
        public var name: Swift.String?
        /// The roles that are associated with the assessment.
        public var roles: [AuditManagerClientTypes.Role]?
        /// The wrapper of Amazon Web Services accounts and services that are in scope for the assessment.
        public var scope: AuditManagerClientTypes.Scope?
        /// The overall status of the assessment.
        public var status: AuditManagerClientTypes.AssessmentStatus?

        public init (
            assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
            complianceType: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            delegations: [AuditManagerClientTypes.Delegation]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roles: [AuditManagerClientTypes.Role]? = nil,
            scope: AuditManagerClientTypes.Scope? = nil,
            status: AuditManagerClientTypes.AssessmentStatus? = nil
        )
        {
            self.assessmentReportsDestination = assessmentReportsDestination
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.delegations = delegations
            self.description = description
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.roles = roles
            self.scope = scope
            self.status = status
        }
    }

}

extension AuditManagerClientTypes.AssessmentMetadataItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType
        case creationTime
        case delegations
        case id
        case lastUpdated
        case name
        case roles
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let delegations = delegations {
            var delegationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .delegations)
            for delegation0 in delegations {
                try delegationsContainer.encode(delegation0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for role0 in roles {
                try rolesContainer.encode(role0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentStatus.self, forKey: .status)
        status = statusDecoded
        let rolesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .roles)
        var rolesDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let delegationsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Delegation?].self, forKey: .delegations)
        var delegationsDecoded0:[AuditManagerClientTypes.Delegation]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [AuditManagerClientTypes.Delegation]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes {
    /// A metadata object that's associated with an assessment in Audit Manager.
    public struct AssessmentMetadataItem: Swift.Equatable {
        /// The name of the compliance standard that's related to the assessment, such as PCI-DSS.
        public var complianceType: Swift.String?
        /// Specifies when the assessment was created.
        public var creationTime: ClientRuntime.Date?
        /// The delegations that are associated with the assessment.
        public var delegations: [AuditManagerClientTypes.Delegation]?
        /// The unique identifier for the assessment.
        public var id: Swift.String?
        /// The time of the most recent update.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the assessment.
        public var name: Swift.String?
        /// The roles that are associated with the assessment.
        public var roles: [AuditManagerClientTypes.Role]?
        /// The current status of the assessment.
        public var status: AuditManagerClientTypes.AssessmentStatus?

        public init (
            complianceType: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            delegations: [AuditManagerClientTypes.Delegation]? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roles: [AuditManagerClientTypes.Role]? = nil,
            status: AuditManagerClientTypes.AssessmentStatus? = nil
        )
        {
            self.complianceType = complianceType
            self.creationTime = creationTime
            self.delegations = delegations
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.roles = roles
            self.status = status
        }
    }

}

extension AuditManagerClientTypes.AssessmentReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
        case assessmentName
        case author
        case awsAccountId
        case creationTime
        case description
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AuditManagerClientTypes {
    /// A finalized document that's generated from an Audit Manager assessment. These reports summarize the relevant evidence that was collected for your audit, and link to the relevant evidence folders. These evidence folders are named and organized according to the controls that are specified in your assessment.
    public struct AssessmentReport: Swift.Equatable {
        /// The identifier for the specified assessment.
        public var assessmentId: Swift.String?
        /// The name of the associated assessment.
        public var assessmentName: Swift.String?
        /// The name of the user who created the assessment report.
        public var author: Swift.String?
        /// The identifier for the specified Amazon Web Services account.
        public var awsAccountId: Swift.String?
        /// Specifies when the assessment report was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the specified assessment report.
        public var description: Swift.String?
        /// The unique identifier for the assessment report.
        public var id: Swift.String?
        /// The name that's given to the assessment report.
        public var name: Swift.String?
        /// The current status of the specified assessment report.
        public var status: AuditManagerClientTypes.AssessmentReportStatus?

        public init (
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            author: Swift.String? = nil,
            awsAccountId: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: AuditManagerClientTypes.AssessmentReportStatus? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.author = author
            self.awsAccountId = awsAccountId
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension AuditManagerClientTypes {
    public enum AssessmentReportDestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentReportDestinationType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentReportDestinationType(rawValue: rawValue) ?? AssessmentReportDestinationType.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.AssessmentReportEvidenceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case evidenceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let evidenceId = self.evidenceId {
            try encodeContainer.encode(evidenceId, forKey: .evidenceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceId)
        evidenceId = evidenceIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AuditManagerClientTypes {
    /// An error entity for assessment report evidence errors. This is used to provide more meaningful errors than a simple string message.
    public struct AssessmentReportEvidenceError: Swift.Equatable {
        /// The error code that was returned.
        public var errorCode: Swift.String?
        /// The error message that was returned.
        public var errorMessage: Swift.String?
        /// The identifier for the evidence.
        public var evidenceId: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            evidenceId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.evidenceId = evidenceId
        }
    }

}

extension AuditManagerClientTypes.AssessmentReportMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
        case assessmentName
        case author
        case creationTime
        case description
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AuditManagerClientTypes {
    /// The metadata objects that are associated with the specified assessment report.
    public struct AssessmentReportMetadata: Swift.Equatable {
        /// The unique identifier for the associated assessment.
        public var assessmentId: Swift.String?
        /// The name of the associated assessment.
        public var assessmentName: Swift.String?
        /// The name of the user who created the assessment report.
        public var author: Swift.String?
        /// Specifies when the assessment report was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the assessment report.
        public var description: Swift.String?
        /// The unique identifier for the assessment report.
        public var id: Swift.String?
        /// The name of the assessment report.
        public var name: Swift.String?
        /// The current status of the assessment report.
        public var status: AuditManagerClientTypes.AssessmentReportStatus?

        public init (
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            author: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: AuditManagerClientTypes.AssessmentReportStatus? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension AuditManagerClientTypes {
    public enum AssessmentReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentReportStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentReportStatus(rawValue: rawValue) ?? AssessmentReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.AssessmentReportsDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case destinationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationType = self.destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportDestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension AuditManagerClientTypes {
    /// The location where Audit Manager saves assessment reports for the given assessment.
    public struct AssessmentReportsDestination: Swift.Equatable {
        /// The destination of the assessment report.
        public var destination: Swift.String?
        /// The destination type, such as Amazon S3.
        public var destinationType: AuditManagerClientTypes.AssessmentReportDestinationType?

        public init (
            destination: Swift.String? = nil,
            destinationType: AuditManagerClientTypes.AssessmentReportDestinationType? = nil
        )
        {
            self.destination = destination
            self.destinationType = destinationType
        }
    }

}

extension AuditManagerClientTypes {
    public enum AssessmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentStatus(rawValue: rawValue) ?? AssessmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssociateAssessmentReportEvidenceFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFolderId = self.evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
    }
}

extension AssociateAssessmentReportEvidenceFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/associateToAssessmentReport"
    }
}

public struct AssociateAssessmentReportEvidenceFolderInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
    }
}

struct AssociateAssessmentReportEvidenceFolderInputBody: Swift.Equatable {
    let evidenceFolderId: Swift.String?
}

extension AssociateAssessmentReportEvidenceFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
    }
}

extension AssociateAssessmentReportEvidenceFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAssessmentReportEvidenceFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateAssessmentReportEvidenceFolderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAssessmentReportEvidenceFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateAssessmentReportEvidenceFolderOutputResponse: Swift.Equatable {

    public init () { }
}

extension BatchAssociateAssessmentReportEvidenceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
        case evidenceIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFolderId = self.evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
        if let evidenceIds = evidenceIds {
            var evidenceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evidenceIds)
            for uuid0 in evidenceIds {
                try evidenceIdsContainer.encode(uuid0)
            }
        }
    }
}

extension BatchAssociateAssessmentReportEvidenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/batchAssociateToAssessmentReport"
    }
}

public struct BatchAssociateAssessmentReportEvidenceInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?
    /// The list of evidence identifiers.
    /// This member is required.
    public var evidenceIds: [Swift.String]?

    public init (
        assessmentId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil,
        evidenceIds: [Swift.String]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
        self.evidenceIds = evidenceIds
    }
}

struct BatchAssociateAssessmentReportEvidenceInputBody: Swift.Equatable {
    let evidenceFolderId: Swift.String?
    let evidenceIds: [Swift.String]?
}

extension BatchAssociateAssessmentReportEvidenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
        case evidenceIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
        let evidenceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .evidenceIds)
        var evidenceIdsDecoded0:[Swift.String]? = nil
        if let evidenceIdsContainer = evidenceIdsContainer {
            evidenceIdsDecoded0 = [Swift.String]()
            for string0 in evidenceIdsContainer {
                if let string0 = string0 {
                    evidenceIdsDecoded0?.append(string0)
                }
            }
        }
        evidenceIds = evidenceIdsDecoded0
    }
}

extension BatchAssociateAssessmentReportEvidenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateAssessmentReportEvidenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchAssociateAssessmentReportEvidenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateAssessmentReportEvidenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchAssociateAssessmentReportEvidenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.evidenceIds = output.evidenceIds
        } else {
            self.errors = nil
            self.evidenceIds = nil
        }
    }
}

public struct BatchAssociateAssessmentReportEvidenceOutputResponse: Swift.Equatable {
    /// A list of errors that the BatchAssociateAssessmentReportEvidence API returned.
    public var errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]?
    /// The list of evidence identifiers.
    public var evidenceIds: [Swift.String]?

    public init (
        errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]? = nil,
        evidenceIds: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.evidenceIds = evidenceIds
    }
}

struct BatchAssociateAssessmentReportEvidenceOutputResponseBody: Swift.Equatable {
    let evidenceIds: [Swift.String]?
    let errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]?
}

extension BatchAssociateAssessmentReportEvidenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case evidenceIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .evidenceIds)
        var evidenceIdsDecoded0:[Swift.String]? = nil
        if let evidenceIdsContainer = evidenceIdsContainer {
            evidenceIdsDecoded0 = [Swift.String]()
            for string0 in evidenceIdsContainer {
                if let string0 = string0 {
                    evidenceIdsDecoded0?.append(string0)
                }
            }
        }
        evidenceIds = evidenceIdsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentReportEvidenceError?].self, forKey: .errors)
        var errorsDecoded0:[AuditManagerClientTypes.AssessmentReportEvidenceError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AuditManagerClientTypes.AssessmentReportEvidenceError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension AuditManagerClientTypes.BatchCreateDelegationByAssessmentError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDelegationRequest
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDelegationRequest = self.createDelegationRequest {
            try encodeContainer.encode(createDelegationRequest, forKey: .createDelegationRequest)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDelegationRequestDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.CreateDelegationRequest.self, forKey: .createDelegationRequest)
        createDelegationRequest = createDelegationRequestDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AuditManagerClientTypes {
    /// An error entity for the BatchCreateDelegationByAssessment API. This is used to provide more meaningful errors than a simple string message.
    public struct BatchCreateDelegationByAssessmentError: Swift.Equatable {
        /// The API request to batch create delegations in Audit Manager.
        public var createDelegationRequest: AuditManagerClientTypes.CreateDelegationRequest?
        /// The error code that the BatchCreateDelegationByAssessment API returned.
        public var errorCode: Swift.String?
        /// The error message that the BatchCreateDelegationByAssessment API returned.
        public var errorMessage: Swift.String?

        public init (
            createDelegationRequest: AuditManagerClientTypes.CreateDelegationRequest? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.createDelegationRequest = createDelegationRequest
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension BatchCreateDelegationByAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDelegationRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDelegationRequests = createDelegationRequests {
            var createDelegationRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createDelegationRequests)
            for createdelegationrequest0 in createDelegationRequests {
                try createDelegationRequestsContainer.encode(createdelegationrequest0)
            }
        }
    }
}

extension BatchCreateDelegationByAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/delegations"
    }
}

public struct BatchCreateDelegationByAssessmentInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The API request to batch create delegations in Audit Manager.
    /// This member is required.
    public var createDelegationRequests: [AuditManagerClientTypes.CreateDelegationRequest]?

    public init (
        assessmentId: Swift.String? = nil,
        createDelegationRequests: [AuditManagerClientTypes.CreateDelegationRequest]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.createDelegationRequests = createDelegationRequests
    }
}

struct BatchCreateDelegationByAssessmentInputBody: Swift.Equatable {
    let createDelegationRequests: [AuditManagerClientTypes.CreateDelegationRequest]?
}

extension BatchCreateDelegationByAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDelegationRequests
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDelegationRequestsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.CreateDelegationRequest?].self, forKey: .createDelegationRequests)
        var createDelegationRequestsDecoded0:[AuditManagerClientTypes.CreateDelegationRequest]? = nil
        if let createDelegationRequestsContainer = createDelegationRequestsContainer {
            createDelegationRequestsDecoded0 = [AuditManagerClientTypes.CreateDelegationRequest]()
            for structure0 in createDelegationRequestsContainer {
                if let structure0 = structure0 {
                    createDelegationRequestsDecoded0?.append(structure0)
                }
            }
        }
        createDelegationRequests = createDelegationRequestsDecoded0
    }
}

extension BatchCreateDelegationByAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateDelegationByAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchCreateDelegationByAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateDelegationByAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchCreateDelegationByAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.delegations = output.delegations
            self.errors = output.errors
        } else {
            self.delegations = nil
            self.errors = nil
        }
    }
}

public struct BatchCreateDelegationByAssessmentOutputResponse: Swift.Equatable {
    /// The delegations that are associated with the assessment.
    public var delegations: [AuditManagerClientTypes.Delegation]?
    /// A list of errors that the BatchCreateDelegationByAssessment API returned.
    public var errors: [AuditManagerClientTypes.BatchCreateDelegationByAssessmentError]?

    public init (
        delegations: [AuditManagerClientTypes.Delegation]? = nil,
        errors: [AuditManagerClientTypes.BatchCreateDelegationByAssessmentError]? = nil
    )
    {
        self.delegations = delegations
        self.errors = errors
    }
}

struct BatchCreateDelegationByAssessmentOutputResponseBody: Swift.Equatable {
    let delegations: [AuditManagerClientTypes.Delegation]?
    let errors: [AuditManagerClientTypes.BatchCreateDelegationByAssessmentError]?
}

extension BatchCreateDelegationByAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegations
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegationsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Delegation?].self, forKey: .delegations)
        var delegationsDecoded0:[AuditManagerClientTypes.Delegation]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [AuditManagerClientTypes.Delegation]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.BatchCreateDelegationByAssessmentError?].self, forKey: .errors)
        var errorsDecoded0:[AuditManagerClientTypes.BatchCreateDelegationByAssessmentError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AuditManagerClientTypes.BatchCreateDelegationByAssessmentError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegationId
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegationId = self.delegationId {
            try encodeContainer.encode(delegationId, forKey: .delegationId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegationId)
        delegationId = delegationIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AuditManagerClientTypes {
    /// An error entity for the BatchDeleteDelegationByAssessment API. This is used to provide more meaningful errors than a simple string message.
    public struct BatchDeleteDelegationByAssessmentError: Swift.Equatable {
        /// The identifier for the delegation.
        public var delegationId: Swift.String?
        /// The error code that the BatchDeleteDelegationByAssessment API returned.
        public var errorCode: Swift.String?
        /// The error message that the BatchDeleteDelegationByAssessment API returned.
        public var errorMessage: Swift.String?

        public init (
            delegationId: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.delegationId = delegationId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension BatchDeleteDelegationByAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegationIds = delegationIds {
            var delegationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .delegationIds)
            for uuid0 in delegationIds {
                try delegationIdsContainer.encode(uuid0)
            }
        }
    }
}

extension BatchDeleteDelegationByAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/delegations"
    }
}

public struct BatchDeleteDelegationByAssessmentInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifiers for the delegations.
    /// This member is required.
    public var delegationIds: [Swift.String]?

    public init (
        assessmentId: Swift.String? = nil,
        delegationIds: [Swift.String]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.delegationIds = delegationIds
    }
}

struct BatchDeleteDelegationByAssessmentInputBody: Swift.Equatable {
    let delegationIds: [Swift.String]?
}

extension BatchDeleteDelegationByAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegationIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .delegationIds)
        var delegationIdsDecoded0:[Swift.String]? = nil
        if let delegationIdsContainer = delegationIdsContainer {
            delegationIdsDecoded0 = [Swift.String]()
            for string0 in delegationIdsContainer {
                if let string0 = string0 {
                    delegationIdsDecoded0?.append(string0)
                }
            }
        }
        delegationIds = delegationIdsDecoded0
    }
}

extension BatchDeleteDelegationByAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteDelegationByAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDeleteDelegationByAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteDelegationByAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDeleteDelegationByAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteDelegationByAssessmentOutputResponse: Swift.Equatable {
    /// A list of errors that the BatchDeleteDelegationByAssessment API returned.
    public var errors: [AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError]?

    public init (
        errors: [AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteDelegationByAssessmentOutputResponseBody: Swift.Equatable {
    let errors: [AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError]?
}

extension BatchDeleteDelegationByAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError?].self, forKey: .errors)
        var errorsDecoded0:[AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AuditManagerClientTypes.BatchDeleteDelegationByAssessmentError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchDisassociateAssessmentReportEvidenceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
        case evidenceIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFolderId = self.evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
        if let evidenceIds = evidenceIds {
            var evidenceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evidenceIds)
            for uuid0 in evidenceIds {
                try evidenceIdsContainer.encode(uuid0)
            }
        }
    }
}

extension BatchDisassociateAssessmentReportEvidenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/batchDisassociateFromAssessmentReport"
    }
}

public struct BatchDisassociateAssessmentReportEvidenceInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?
    /// The list of evidence identifiers.
    /// This member is required.
    public var evidenceIds: [Swift.String]?

    public init (
        assessmentId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil,
        evidenceIds: [Swift.String]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
        self.evidenceIds = evidenceIds
    }
}

struct BatchDisassociateAssessmentReportEvidenceInputBody: Swift.Equatable {
    let evidenceFolderId: Swift.String?
    let evidenceIds: [Swift.String]?
}

extension BatchDisassociateAssessmentReportEvidenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
        case evidenceIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
        let evidenceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .evidenceIds)
        var evidenceIdsDecoded0:[Swift.String]? = nil
        if let evidenceIdsContainer = evidenceIdsContainer {
            evidenceIdsDecoded0 = [Swift.String]()
            for string0 in evidenceIdsContainer {
                if let string0 = string0 {
                    evidenceIdsDecoded0?.append(string0)
                }
            }
        }
        evidenceIds = evidenceIdsDecoded0
    }
}

extension BatchDisassociateAssessmentReportEvidenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateAssessmentReportEvidenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDisassociateAssessmentReportEvidenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateAssessmentReportEvidenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDisassociateAssessmentReportEvidenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.evidenceIds = output.evidenceIds
        } else {
            self.errors = nil
            self.evidenceIds = nil
        }
    }
}

public struct BatchDisassociateAssessmentReportEvidenceOutputResponse: Swift.Equatable {
    /// A list of errors that the BatchDisassociateAssessmentReportEvidence API returned.
    public var errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]?
    /// The identifier for the evidence.
    public var evidenceIds: [Swift.String]?

    public init (
        errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]? = nil,
        evidenceIds: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.evidenceIds = evidenceIds
    }
}

struct BatchDisassociateAssessmentReportEvidenceOutputResponseBody: Swift.Equatable {
    let evidenceIds: [Swift.String]?
    let errors: [AuditManagerClientTypes.AssessmentReportEvidenceError]?
}

extension BatchDisassociateAssessmentReportEvidenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case evidenceIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .evidenceIds)
        var evidenceIdsDecoded0:[Swift.String]? = nil
        if let evidenceIdsContainer = evidenceIdsContainer {
            evidenceIdsDecoded0 = [Swift.String]()
            for string0 in evidenceIdsContainer {
                if let string0 = string0 {
                    evidenceIdsDecoded0?.append(string0)
                }
            }
        }
        evidenceIds = evidenceIdsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentReportEvidenceError?].self, forKey: .errors)
        var errorsDecoded0:[AuditManagerClientTypes.AssessmentReportEvidenceError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AuditManagerClientTypes.AssessmentReportEvidenceError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case manualEvidence
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let manualEvidence = self.manualEvidence {
            try encodeContainer.encode(manualEvidence, forKey: .manualEvidence)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manualEvidenceDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ManualEvidence.self, forKey: .manualEvidence)
        manualEvidence = manualEvidenceDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AuditManagerClientTypes {
    /// An error entity for the BatchImportEvidenceToAssessmentControl API. This is used to provide more meaningful errors than a simple string message.
    public struct BatchImportEvidenceToAssessmentControlError: Swift.Equatable {
        /// The error code that the BatchImportEvidenceToAssessmentControl API returned.
        public var errorCode: Swift.String?
        /// The error message that the BatchImportEvidenceToAssessmentControl API returned.
        public var errorMessage: Swift.String?
        /// Manual evidence that can't be collected automatically by Audit Manager.
        public var manualEvidence: AuditManagerClientTypes.ManualEvidence?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            manualEvidence: AuditManagerClientTypes.ManualEvidence? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.manualEvidence = manualEvidence
        }
    }

}

extension BatchImportEvidenceToAssessmentControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manualEvidence
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manualEvidence = manualEvidence {
            var manualEvidenceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .manualEvidence)
            for manualevidence0 in manualEvidence {
                try manualEvidenceContainer.encode(manualevidence0)
            }
        }
    }
}

extension BatchImportEvidenceToAssessmentControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        guard let controlId = controlId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/controls/\(controlId.urlPercentEncoding())/evidence"
    }
}

public struct BatchImportEvidenceToAssessmentControlInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?
    /// The identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The list of manual evidence objects.
    /// This member is required.
    public var manualEvidence: [AuditManagerClientTypes.ManualEvidence]?

    public init (
        assessmentId: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        manualEvidence: [AuditManagerClientTypes.ManualEvidence]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.manualEvidence = manualEvidence
    }
}

struct BatchImportEvidenceToAssessmentControlInputBody: Swift.Equatable {
    let manualEvidence: [AuditManagerClientTypes.ManualEvidence]?
}

extension BatchImportEvidenceToAssessmentControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manualEvidence
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manualEvidenceContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ManualEvidence?].self, forKey: .manualEvidence)
        var manualEvidenceDecoded0:[AuditManagerClientTypes.ManualEvidence]? = nil
        if let manualEvidenceContainer = manualEvidenceContainer {
            manualEvidenceDecoded0 = [AuditManagerClientTypes.ManualEvidence]()
            for structure0 in manualEvidenceContainer {
                if let structure0 = structure0 {
                    manualEvidenceDecoded0?.append(structure0)
                }
            }
        }
        manualEvidence = manualEvidenceDecoded0
    }
}

extension BatchImportEvidenceToAssessmentControlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchImportEvidenceToAssessmentControlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchImportEvidenceToAssessmentControlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchImportEvidenceToAssessmentControlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchImportEvidenceToAssessmentControlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchImportEvidenceToAssessmentControlOutputResponse: Swift.Equatable {
    /// A list of errors that the BatchImportEvidenceToAssessmentControl API returned.
    public var errors: [AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError]?

    public init (
        errors: [AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchImportEvidenceToAssessmentControlOutputResponseBody: Swift.Equatable {
    let errors: [AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError]?
}

extension BatchImportEvidenceToAssessmentControlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError?].self, forKey: .errors)
        var errorsDecoded0:[AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AuditManagerClientTypes.BatchImportEvidenceToAssessmentControlError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension AuditManagerClientTypes.ChangeLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case createdAt
        case createdBy
        case objectName
        case objectType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let objectName = self.objectName {
            try encodeContainer.encode(objectName, forKey: .objectName)
        }
        if let objectType = self.objectType {
            try encodeContainer.encode(objectType.rawValue, forKey: .objectType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ObjectTypeEnum.self, forKey: .objectType)
        objectType = objectTypeDecoded
        let objectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectName)
        objectName = objectNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ActionEnum.self, forKey: .action)
        action = actionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension AuditManagerClientTypes {
    /// The record of a change within Audit Manager. For example, this could be the status change of an assessment or the delegation of a control set.
    public struct ChangeLog: Swift.Equatable {
        /// The action that was performed.
        public var action: AuditManagerClientTypes.ActionEnum?
        /// The time when the action was performed and the changelog record was created.
        public var createdAt: ClientRuntime.Date?
        /// The IAM user or role that performed the action.
        public var createdBy: Swift.String?
        /// The name of the object that changed. This could be the name of an assessment, control, or control set.
        public var objectName: Swift.String?
        /// The object that was changed, such as an assessment, control, or control set.
        public var objectType: AuditManagerClientTypes.ObjectTypeEnum?

        public init (
            action: AuditManagerClientTypes.ActionEnum? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            objectName: Swift.String? = nil,
            objectType: AuditManagerClientTypes.ObjectTypeEnum? = nil
        )
        {
            self.action = action
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.objectName = objectName
            self.objectType = objectType
        }
    }

}

extension AuditManagerClientTypes.Control: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case arn
        case controlMappingSources
        case controlSources
        case createdAt
        case createdBy
        case description
        case id
        case lastUpdatedAt
        case lastUpdatedBy
        case name
        case tags
        case testingInformation
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionPlanInstructions = self.actionPlanInstructions {
            try encodeContainer.encode(actionPlanInstructions, forKey: .actionPlanInstructions)
        }
        if let actionPlanTitle = self.actionPlanTitle {
            try encodeContainer.encode(actionPlanTitle, forKey: .actionPlanTitle)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlMappingSources = controlMappingSources {
            var controlMappingSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlMappingSources)
            for controlmappingsource0 in controlMappingSources {
                try controlMappingSourcesContainer.encode(controlmappingsource0)
            }
        }
        if let controlSources = self.controlSources {
            try encodeContainer.encode(controlSources, forKey: .controlSources)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let lastUpdatedBy = self.lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let testingInformation = self.testingInformation {
            try encodeContainer.encode(testingInformation, forKey: .testingInformation)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ControlType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let testingInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testingInformation)
        testingInformation = testingInformationDecoded
        let actionPlanTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionPlanTitle)
        actionPlanTitle = actionPlanTitleDecoded
        let actionPlanInstructionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionPlanInstructions)
        actionPlanInstructions = actionPlanInstructionsDecoded
        let controlSourcesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSources)
        controlSources = controlSourcesDecoded
        let controlMappingSourcesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlMappingSource?].self, forKey: .controlMappingSources)
        var controlMappingSourcesDecoded0:[AuditManagerClientTypes.ControlMappingSource]? = nil
        if let controlMappingSourcesContainer = controlMappingSourcesContainer {
            controlMappingSourcesDecoded0 = [AuditManagerClientTypes.ControlMappingSource]()
            for structure0 in controlMappingSourcesContainer {
                if let structure0 = structure0 {
                    controlMappingSourcesDecoded0?.append(structure0)
                }
            }
        }
        controlMappingSources = controlMappingSourcesDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AuditManagerClientTypes {
    /// A control in Audit Manager.
    public struct Control: Swift.Equatable {
        /// The recommended actions to carry out if the control isn't fulfilled.
        public var actionPlanInstructions: Swift.String?
        /// The title of the action plan for remediating the control.
        public var actionPlanTitle: Swift.String?
        /// The Amazon Resource Name (ARN) of the control.
        public var arn: Swift.String?
        /// The data mapping sources for the control.
        public var controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]?
        /// The data source types that determine where Audit Manager collects evidence from for the control.
        public var controlSources: Swift.String?
        /// Specifies when the control was created.
        public var createdAt: ClientRuntime.Date?
        /// The IAM user or role that created the control.
        public var createdBy: Swift.String?
        /// The description of the control.
        public var description: Swift.String?
        /// The unique identifier for the control.
        public var id: Swift.String?
        /// Specifies when the control was most recently updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The IAM user or role that most recently updated the control.
        public var lastUpdatedBy: Swift.String?
        /// The name of the control.
        public var name: Swift.String?
        /// The tags associated with the control.
        public var tags: [Swift.String:Swift.String]?
        /// The steps that you should follow to determine if the control has been satisfied.
        public var testingInformation: Swift.String?
        /// The type of control, such as a custom control or a standard control.
        public var type: AuditManagerClientTypes.ControlType?

        public init (
            actionPlanInstructions: Swift.String? = nil,
            actionPlanTitle: Swift.String? = nil,
            arn: Swift.String? = nil,
            controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]? = nil,
            controlSources: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            testingInformation: Swift.String? = nil,
            type: AuditManagerClientTypes.ControlType? = nil
        )
        {
            self.actionPlanInstructions = actionPlanInstructions
            self.actionPlanTitle = actionPlanTitle
            self.arn = arn
            self.controlMappingSources = controlMappingSources
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.name = name
            self.tags = tags
            self.testingInformation = testingInformation
            self.type = type
        }
    }

}

extension AuditManagerClientTypes.ControlComment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorName
        case commentBody
        case postedDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = self.authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commentBody = self.commentBody {
            try encodeContainer.encode(commentBody, forKey: .commentBody)
        }
        if let postedDate = self.postedDate {
            try encodeContainer.encodeTimestamp(postedDate, format: .epochSeconds, forKey: .postedDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let commentBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentBody)
        commentBody = commentBodyDecoded
        let postedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .postedDate)
        postedDate = postedDateDecoded
    }
}

extension AuditManagerClientTypes {
    /// A comment that's posted by a user on a control. This includes the author's name, the comment text, and a timestamp.
    public struct ControlComment: Swift.Equatable {
        /// The name of the user who authored the comment.
        public var authorName: Swift.String?
        /// The body text of a control comment.
        public var commentBody: Swift.String?
        /// The time when the comment was posted.
        public var postedDate: ClientRuntime.Date?

        public init (
            authorName: Swift.String? = nil,
            commentBody: Swift.String? = nil,
            postedDate: ClientRuntime.Date? = nil
        )
        {
            self.authorName = authorName
            self.commentBody = commentBody
            self.postedDate = postedDate
        }
    }

}

extension AuditManagerClientTypes.ControlDomainInsights: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlsCountByNoncompliantEvidence
        case evidenceInsights
        case id
        case lastUpdated
        case name
        case totalControlsCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlsCountByNoncompliantEvidence = self.controlsCountByNoncompliantEvidence {
            try encodeContainer.encode(controlsCountByNoncompliantEvidence, forKey: .controlsCountByNoncompliantEvidence)
        }
        if let evidenceInsights = self.evidenceInsights {
            try encodeContainer.encode(evidenceInsights, forKey: .evidenceInsights)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let totalControlsCount = self.totalControlsCount {
            try encodeContainer.encode(totalControlsCount, forKey: .totalControlsCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let controlsCountByNoncompliantEvidenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .controlsCountByNoncompliantEvidence)
        controlsCountByNoncompliantEvidence = controlsCountByNoncompliantEvidenceDecoded
        let totalControlsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalControlsCount)
        totalControlsCount = totalControlsCountDecoded
        let evidenceInsightsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.EvidenceInsights.self, forKey: .evidenceInsights)
        evidenceInsights = evidenceInsightsDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes {
    /// A summary of the latest analytics data for a specific control domain. Control domain insights are grouped by control domain, and ranked by the highest total count of non-compliant evidence.
    public struct ControlDomainInsights: Swift.Equatable {
        /// The number of controls in the control domain that collected non-compliant evidence on the lastUpdated date.
        public var controlsCountByNoncompliantEvidence: Swift.Int?
        /// A breakdown of the compliance check status for the evidence thats associated with the control domain.
        public var evidenceInsights: AuditManagerClientTypes.EvidenceInsights?
        /// The unique identifier for the control domain.
        public var id: Swift.String?
        /// The time when the control domain insights were last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the control domain.
        public var name: Swift.String?
        /// The total number of controls in the control domain.
        public var totalControlsCount: Swift.Int?

        public init (
            controlsCountByNoncompliantEvidence: Swift.Int? = nil,
            evidenceInsights: AuditManagerClientTypes.EvidenceInsights? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            totalControlsCount: Swift.Int? = nil
        )
        {
            self.controlsCountByNoncompliantEvidence = controlsCountByNoncompliantEvidence
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
            self.totalControlsCount = totalControlsCount
        }
    }

}

extension AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlSetName
        case evidenceInsights
        case id
        case lastUpdated
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlSetName = self.controlSetName {
            try encodeContainer.encode(controlSetName, forKey: .controlSetName)
        }
        if let evidenceInsights = self.evidenceInsights {
            try encodeContainer.encode(evidenceInsights, forKey: .evidenceInsights)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let evidenceInsightsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.EvidenceInsights.self, forKey: .evidenceInsights)
        evidenceInsights = evidenceInsightsDecoded
        let controlSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetName)
        controlSetName = controlSetNameDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes {
    /// A summary of the latest analytics data for a specific control in a specific active assessment. Control insights are grouped by control domain, and ranked by the highest total count of non-compliant evidence.
    public struct ControlInsightsMetadataByAssessmentItem: Swift.Equatable {
        /// The name of the control set that the assessment control belongs to.
        public var controlSetName: Swift.String?
        /// A breakdown of the compliance check status for the evidence thats associated with the assessment control.
        public var evidenceInsights: AuditManagerClientTypes.EvidenceInsights?
        /// The unique identifier for the assessment control.
        public var id: Swift.String?
        /// The time when the assessment control insights were last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the assessment control.
        public var name: Swift.String?

        public init (
            controlSetName: Swift.String? = nil,
            evidenceInsights: AuditManagerClientTypes.EvidenceInsights? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.controlSetName = controlSetName
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
        }
    }

}

extension AuditManagerClientTypes.ControlInsightsMetadataItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceInsights
        case id
        case lastUpdated
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceInsights = self.evidenceInsights {
            try encodeContainer.encode(evidenceInsights, forKey: .evidenceInsights)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let evidenceInsightsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.EvidenceInsights.self, forKey: .evidenceInsights)
        evidenceInsights = evidenceInsightsDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes {
    /// A summary of the latest analytics data for a specific control. This data reflects the total counts for the specified control across all active assessments. Control insights are grouped by control domain, and ranked by the highest total count of non-compliant evidence.
    public struct ControlInsightsMetadataItem: Swift.Equatable {
        /// A breakdown of the compliance check status for the evidence thats associated with the control.
        public var evidenceInsights: AuditManagerClientTypes.EvidenceInsights?
        /// The unique identifier for the control.
        public var id: Swift.String?
        /// The time when the control insights were last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the control.
        public var name: Swift.String?

        public init (
            evidenceInsights: AuditManagerClientTypes.EvidenceInsights? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.evidenceInsights = evidenceInsights
            self.id = id
            self.lastUpdated = lastUpdated
            self.name = name
        }
    }

}

extension AuditManagerClientTypes.ControlMappingSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceDescription
        case sourceFrequency
        case sourceId
        case sourceKeyword
        case sourceName
        case sourceSetUpOption
        case sourceType
        case troubleshootingText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceDescription = self.sourceDescription {
            try encodeContainer.encode(sourceDescription, forKey: .sourceDescription)
        }
        if let sourceFrequency = self.sourceFrequency {
            try encodeContainer.encode(sourceFrequency.rawValue, forKey: .sourceFrequency)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let sourceKeyword = self.sourceKeyword {
            try encodeContainer.encode(sourceKeyword, forKey: .sourceKeyword)
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceSetUpOption = self.sourceSetUpOption {
            try encodeContainer.encode(sourceSetUpOption.rawValue, forKey: .sourceSetUpOption)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let troubleshootingText = self.troubleshootingText {
            try encodeContainer.encode(troubleshootingText, forKey: .troubleshootingText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDescription)
        sourceDescription = sourceDescriptionDecoded
        let sourceSetUpOptionDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceSetUpOption.self, forKey: .sourceSetUpOption)
        sourceSetUpOption = sourceSetUpOptionDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceKeywordDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceKeyword.self, forKey: .sourceKeyword)
        sourceKeyword = sourceKeywordDecoded
        let sourceFrequencyDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceFrequency.self, forKey: .sourceFrequency)
        sourceFrequency = sourceFrequencyDecoded
        let troubleshootingTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .troubleshootingText)
        troubleshootingText = troubleshootingTextDecoded
    }
}

extension AuditManagerClientTypes {
    /// The data source that determines where Audit Manager collects evidence from for the control.
    public struct ControlMappingSource: Swift.Equatable {
        /// The description of the source.
        public var sourceDescription: Swift.String?
        /// The frequency of evidence collection for the control mapping source.
        public var sourceFrequency: AuditManagerClientTypes.SourceFrequency?
        /// The unique identifier for the source.
        public var sourceId: Swift.String?
        /// The keyword to search for in CloudTrail logs, Config rules, Security Hub checks, and Amazon Web Services API names. To learn more about the supported keywords that you can use when mapping a control data source, see the following pages in the Audit Manager User Guide:
        ///
        /// * [Config rules supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-ash.html)
        ///
        /// * [Security Hub controls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-config.html)
        ///
        /// * [API calls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-api.html)
        ///
        /// * [CloudTrail event names supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-cloudtrail.html)
        public var sourceKeyword: AuditManagerClientTypes.SourceKeyword?
        /// The name of the source.
        public var sourceName: Swift.String?
        /// The setup option for the data source. This option reflects if the evidence collection is automated or manual.
        public var sourceSetUpOption: AuditManagerClientTypes.SourceSetUpOption?
        /// Specifies one of the five types of data sources for evidence collection.
        public var sourceType: AuditManagerClientTypes.SourceType?
        /// The instructions for troubleshooting the control.
        public var troubleshootingText: Swift.String?

        public init (
            sourceDescription: Swift.String? = nil,
            sourceFrequency: AuditManagerClientTypes.SourceFrequency? = nil,
            sourceId: Swift.String? = nil,
            sourceKeyword: AuditManagerClientTypes.SourceKeyword? = nil,
            sourceName: Swift.String? = nil,
            sourceSetUpOption: AuditManagerClientTypes.SourceSetUpOption? = nil,
            sourceType: AuditManagerClientTypes.SourceType? = nil,
            troubleshootingText: Swift.String? = nil
        )
        {
            self.sourceDescription = sourceDescription
            self.sourceFrequency = sourceFrequency
            self.sourceId = sourceId
            self.sourceKeyword = sourceKeyword
            self.sourceName = sourceName
            self.sourceSetUpOption = sourceSetUpOption
            self.sourceType = sourceType
            self.troubleshootingText = troubleshootingText
        }
    }

}

extension AuditManagerClientTypes.ControlMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case controlSources
        case createdAt
        case id
        case lastUpdatedAt
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlSources = self.controlSources {
            try encodeContainer.encode(controlSources, forKey: .controlSources)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let controlSourcesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSources)
        controlSources = controlSourcesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AuditManagerClientTypes {
    /// The metadata that's associated with the standard control or custom control.
    public struct ControlMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the control.
        public var arn: Swift.String?
        /// The data source that determines where Audit Manager collects evidence from for the control.
        public var controlSources: Swift.String?
        /// Specifies when the control was created.
        public var createdAt: ClientRuntime.Date?
        /// The unique identifier for the control.
        public var id: Swift.String?
        /// Specifies when the control was most recently updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the control.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            controlSources: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
        }
    }

}

extension AuditManagerClientTypes {
    public enum ControlResponse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automate
        case `defer`
        case ignore
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlResponse] {
            return [
                .automate,
                .defer,
                .ignore,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automate: return "AUTOMATE"
            case .defer: return "DEFER"
            case .ignore: return "IGNORE"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlResponse(rawValue: rawValue) ?? ControlResponse.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.ControlSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controls
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for control0 in controls {
                try controlsContainer.encode(control0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let controlsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Control?].self, forKey: .controls)
        var controlsDecoded0:[AuditManagerClientTypes.Control]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [AuditManagerClientTypes.Control]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
    }
}

extension AuditManagerClientTypes {
    /// A set of controls in Audit Manager.
    public struct ControlSet: Swift.Equatable {
        /// The list of controls within the control set.
        public var controls: [AuditManagerClientTypes.Control]?
        /// The identifier of the control set in the assessment. This is the control set name in a plain string format.
        public var id: Swift.String?
        /// The name of the control set.
        public var name: Swift.String?

        public init (
            controls: [AuditManagerClientTypes.Control]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.controls = controls
            self.id = id
            self.name = name
        }
    }

}

extension AuditManagerClientTypes {
    public enum ControlSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case reviewed
        case underReview
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlSetStatus] {
            return [
                .active,
                .reviewed,
                .underReview,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .reviewed: return "REVIEWED"
            case .underReview: return "UNDER_REVIEW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlSetStatus(rawValue: rawValue) ?? ControlSetStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum ControlStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inactive
        case reviewed
        case underReview
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlStatus] {
            return [
                .inactive,
                .reviewed,
                .underReview,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inactive: return "INACTIVE"
            case .reviewed: return "REVIEWED"
            case .underReview: return "UNDER_REVIEW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlStatus(rawValue: rawValue) ?? ControlStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum ControlType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlType] {
            return [
                .custom,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "Custom"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlType(rawValue: rawValue) ?? ControlType.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.CreateAssessmentFrameworkControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension AuditManagerClientTypes {
    /// The control entity attributes that uniquely identify an existing control to be added to a framework in Audit Manager.
    public struct CreateAssessmentFrameworkControl: Swift.Equatable {
        /// The unique identifier of the control.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension AuditManagerClientTypes.CreateAssessmentFrameworkControlSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controls
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for createassessmentframeworkcontrol0 in controls {
                try controlsContainer.encode(createassessmentframeworkcontrol0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let controlsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.CreateAssessmentFrameworkControl?].self, forKey: .controls)
        var controlsDecoded0:[AuditManagerClientTypes.CreateAssessmentFrameworkControl]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [AuditManagerClientTypes.CreateAssessmentFrameworkControl]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
    }
}

extension AuditManagerClientTypes {
    /// A controlSet entity that represents a collection of controls in Audit Manager. This doesn't contain the control set ID.
    public struct CreateAssessmentFrameworkControlSet: Swift.Equatable {
        /// The list of controls within the control set. This doesn't contain the control set ID.
        public var controls: [AuditManagerClientTypes.CreateAssessmentFrameworkControl]?
        /// The name of the control set.
        /// This member is required.
        public var name: Swift.String?

        public init (
            controls: [AuditManagerClientTypes.CreateAssessmentFrameworkControl]? = nil,
            name: Swift.String? = nil
        )
        {
            self.controls = controls
            self.name = name
        }
    }

}

extension CreateAssessmentFrameworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType
        case controlSets
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let controlSets = controlSets {
            var controlSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlSets)
            for createassessmentframeworkcontrolset0 in controlSets {
                try controlSetsContainer.encode(createassessmentframeworkcontrolset0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAssessmentFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessmentFrameworks"
    }
}

public struct CreateAssessmentFrameworkInput: Swift.Equatable {
    /// The compliance type that the new custom framework supports, such as CIS or HIPAA.
    public var complianceType: Swift.String?
    /// The control sets that are associated with the framework.
    /// This member is required.
    public var controlSets: [AuditManagerClientTypes.CreateAssessmentFrameworkControlSet]?
    /// An optional description for the new custom framework.
    public var description: Swift.String?
    /// The name of the new custom framework.
    /// This member is required.
    public var name: Swift.String?
    /// The tags that are associated with the framework.
    public var tags: [Swift.String:Swift.String]?

    public init (
        complianceType: Swift.String? = nil,
        controlSets: [AuditManagerClientTypes.CreateAssessmentFrameworkControlSet]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.complianceType = complianceType
        self.controlSets = controlSets
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateAssessmentFrameworkInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let complianceType: Swift.String?
    let controlSets: [AuditManagerClientTypes.CreateAssessmentFrameworkControlSet]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAssessmentFrameworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType
        case controlSets
        case description
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let controlSetsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.CreateAssessmentFrameworkControlSet?].self, forKey: .controlSets)
        var controlSetsDecoded0:[AuditManagerClientTypes.CreateAssessmentFrameworkControlSet]? = nil
        if let controlSetsContainer = controlSetsContainer {
            controlSetsDecoded0 = [AuditManagerClientTypes.CreateAssessmentFrameworkControlSet]()
            for structure0 in controlSetsContainer {
                if let structure0 = structure0 {
                    controlSetsDecoded0?.append(structure0)
                }
            }
        }
        controlSets = controlSetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssessmentFrameworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssessmentFrameworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAssessmentFrameworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssessmentFrameworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAssessmentFrameworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.framework = output.framework
        } else {
            self.framework = nil
        }
    }
}

public struct CreateAssessmentFrameworkOutputResponse: Swift.Equatable {
    /// The name of the new framework that the CreateAssessmentFramework API returned.
    public var framework: AuditManagerClientTypes.Framework?

    public init (
        framework: AuditManagerClientTypes.Framework? = nil
    )
    {
        self.framework = framework
    }
}

struct CreateAssessmentFrameworkOutputResponseBody: Swift.Equatable {
    let framework: AuditManagerClientTypes.Framework?
}

extension CreateAssessmentFrameworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case framework
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Framework.self, forKey: .framework)
        framework = frameworkDecoded
    }
}

extension CreateAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReportsDestination
        case description
        case frameworkId
        case name
        case roles
        case scope
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentReportsDestination = self.assessmentReportsDestination {
            try encodeContainer.encode(assessmentReportsDestination, forKey: .assessmentReportsDestination)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let frameworkId = self.frameworkId {
            try encodeContainer.encode(frameworkId, forKey: .frameworkId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for role0 in roles {
                try rolesContainer.encode(role0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessments"
    }
}

public struct CreateAssessmentInput: Swift.Equatable {
    /// The assessment report storage destination for the assessment that's being created.
    /// This member is required.
    public var assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    /// The optional description of the assessment to be created.
    public var description: Swift.String?
    /// The identifier for the framework that the assessment will be created from.
    /// This member is required.
    public var frameworkId: Swift.String?
    /// The name of the assessment to be created.
    /// This member is required.
    public var name: Swift.String?
    /// The list of roles for the assessment.
    /// This member is required.
    public var roles: [AuditManagerClientTypes.Role]?
    /// The wrapper that contains the Amazon Web Services accounts and services that are in scope for the assessment.
    /// This member is required.
    public var scope: AuditManagerClientTypes.Scope?
    /// The tags that are associated with the assessment.
    public var tags: [Swift.String:Swift.String]?

    public init (
        assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
        description: Swift.String? = nil,
        frameworkId: Swift.String? = nil,
        name: Swift.String? = nil,
        roles: [AuditManagerClientTypes.Role]? = nil,
        scope: AuditManagerClientTypes.Scope? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assessmentReportsDestination = assessmentReportsDestination
        self.description = description
        self.frameworkId = frameworkId
        self.name = name
        self.roles = roles
        self.scope = scope
        self.tags = tags
    }
}

struct CreateAssessmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    let scope: AuditManagerClientTypes.Scope?
    let roles: [AuditManagerClientTypes.Role]?
    let frameworkId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReportsDestination
        case description
        case frameworkId
        case name
        case roles
        case scope
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let assessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportsDestination.self, forKey: .assessmentReportsDestination)
        assessmentReportsDestination = assessmentReportsDestinationDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let rolesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .roles)
        var rolesDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let frameworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkId)
        frameworkId = frameworkIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct CreateAssessmentOutputResponse: Swift.Equatable {
    /// An entity that defines the scope of audit evidence collected by Audit Manager. An Audit Manager assessment is an implementation of an Audit Manager framework.
    public var assessment: AuditManagerClientTypes.Assessment?

    public init (
        assessment: AuditManagerClientTypes.Assessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct CreateAssessmentOutputResponseBody: Swift.Equatable {
    let assessment: AuditManagerClientTypes.Assessment?
}

extension CreateAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Assessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

extension CreateAssessmentReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case queryStatement
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
    }
}

extension CreateAssessmentReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/reports"
    }
}

public struct CreateAssessmentReportInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The description of the assessment report.
    public var description: Swift.String?
    /// The name of the new assessment report.
    /// This member is required.
    public var name: Swift.String?
    /// A SQL statement that represents an evidence finder query. Provide this parameter when you want to generate an assessment report from the results of an evidence finder search query. When you use this parameter, Audit Manager generates a one-time report using only the evidence from the query output. This report does not include any assessment evidence that was manually [added to a report using the console](https://docs.aws.amazon.com/userguide/generate-assessment-report.html#generate-assessment-report-include-evidence), or [associated with a report using the API](https://docs.aws.amazon.com/APIReference-evidenceFinder/API_BatchAssociateAssessmentReportEvidence.html). To use this parameter, the [enablementStatus](https://docs.aws.amazon.com/APIReference-evidenceFinder/API_EvidenceFinderSetup.html#auditmanager-Type-EvidenceFinderSetup-enablementStatus) of evidence finder must be ENABLED. For examples and help resolving queryStatement validation exceptions, see [Troubleshooting evidence finder issues](https://docs.aws.amazon.com/audit-manager/latest/userguide/evidence-finder-issues.html#querystatement-exceptions) in the AWS Audit Manager User Guide.
    public var queryStatement: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        queryStatement: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.description = description
        self.name = name
        self.queryStatement = queryStatement
    }
}

struct CreateAssessmentReportInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let queryStatement: Swift.String?
}

extension CreateAssessmentReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case queryStatement
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
    }
}

extension CreateAssessmentReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssessmentReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAssessmentReportOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssessmentReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAssessmentReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentReport = output.assessmentReport
        } else {
            self.assessmentReport = nil
        }
    }
}

public struct CreateAssessmentReportOutputResponse: Swift.Equatable {
    /// The new assessment report that the CreateAssessmentReport API returned.
    public var assessmentReport: AuditManagerClientTypes.AssessmentReport?

    public init (
        assessmentReport: AuditManagerClientTypes.AssessmentReport? = nil
    )
    {
        self.assessmentReport = assessmentReport
    }
}

struct CreateAssessmentReportOutputResponseBody: Swift.Equatable {
    let assessmentReport: AuditManagerClientTypes.AssessmentReport?
}

extension CreateAssessmentReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReport
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentReportDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReport.self, forKey: .assessmentReport)
        assessmentReport = assessmentReportDecoded
    }
}

extension CreateControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case controlMappingSources
        case description
        case name
        case tags
        case testingInformation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionPlanInstructions = self.actionPlanInstructions {
            try encodeContainer.encode(actionPlanInstructions, forKey: .actionPlanInstructions)
        }
        if let actionPlanTitle = self.actionPlanTitle {
            try encodeContainer.encode(actionPlanTitle, forKey: .actionPlanTitle)
        }
        if let controlMappingSources = controlMappingSources {
            var controlMappingSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlMappingSources)
            for createcontrolmappingsource0 in controlMappingSources {
                try controlMappingSourcesContainer.encode(createcontrolmappingsource0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let testingInformation = self.testingInformation {
            try encodeContainer.encode(testingInformation, forKey: .testingInformation)
        }
    }
}

extension CreateControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/controls"
    }
}

public struct CreateControlInput: Swift.Equatable {
    /// The recommended actions to carry out if the control isn't fulfilled.
    public var actionPlanInstructions: Swift.String?
    /// The title of the action plan for remediating the control.
    public var actionPlanTitle: Swift.String?
    /// The data mapping sources for the control.
    /// This member is required.
    public var controlMappingSources: [AuditManagerClientTypes.CreateControlMappingSource]?
    /// The description of the control.
    public var description: Swift.String?
    /// The name of the control.
    /// This member is required.
    public var name: Swift.String?
    /// The tags that are associated with the control.
    public var tags: [Swift.String:Swift.String]?
    /// The steps to follow to determine if the control is satisfied.
    public var testingInformation: Swift.String?

    public init (
        actionPlanInstructions: Swift.String? = nil,
        actionPlanTitle: Swift.String? = nil,
        controlMappingSources: [AuditManagerClientTypes.CreateControlMappingSource]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        testingInformation: Swift.String? = nil
    )
    {
        self.actionPlanInstructions = actionPlanInstructions
        self.actionPlanTitle = actionPlanTitle
        self.controlMappingSources = controlMappingSources
        self.description = description
        self.name = name
        self.tags = tags
        self.testingInformation = testingInformation
    }
}

struct CreateControlInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let testingInformation: Swift.String?
    let actionPlanTitle: Swift.String?
    let actionPlanInstructions: Swift.String?
    let controlMappingSources: [AuditManagerClientTypes.CreateControlMappingSource]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case controlMappingSources
        case description
        case name
        case tags
        case testingInformation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let testingInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testingInformation)
        testingInformation = testingInformationDecoded
        let actionPlanTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionPlanTitle)
        actionPlanTitle = actionPlanTitleDecoded
        let actionPlanInstructionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionPlanInstructions)
        actionPlanInstructions = actionPlanInstructionsDecoded
        let controlMappingSourcesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.CreateControlMappingSource?].self, forKey: .controlMappingSources)
        var controlMappingSourcesDecoded0:[AuditManagerClientTypes.CreateControlMappingSource]? = nil
        if let controlMappingSourcesContainer = controlMappingSourcesContainer {
            controlMappingSourcesDecoded0 = [AuditManagerClientTypes.CreateControlMappingSource]()
            for structure0 in controlMappingSourcesContainer {
                if let structure0 = structure0 {
                    controlMappingSourcesDecoded0?.append(structure0)
                }
            }
        }
        controlMappingSources = controlMappingSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AuditManagerClientTypes.CreateControlMappingSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceDescription
        case sourceFrequency
        case sourceKeyword
        case sourceName
        case sourceSetUpOption
        case sourceType
        case troubleshootingText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceDescription = self.sourceDescription {
            try encodeContainer.encode(sourceDescription, forKey: .sourceDescription)
        }
        if let sourceFrequency = self.sourceFrequency {
            try encodeContainer.encode(sourceFrequency.rawValue, forKey: .sourceFrequency)
        }
        if let sourceKeyword = self.sourceKeyword {
            try encodeContainer.encode(sourceKeyword, forKey: .sourceKeyword)
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceSetUpOption = self.sourceSetUpOption {
            try encodeContainer.encode(sourceSetUpOption.rawValue, forKey: .sourceSetUpOption)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let troubleshootingText = self.troubleshootingText {
            try encodeContainer.encode(troubleshootingText, forKey: .troubleshootingText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDescription)
        sourceDescription = sourceDescriptionDecoded
        let sourceSetUpOptionDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceSetUpOption.self, forKey: .sourceSetUpOption)
        sourceSetUpOption = sourceSetUpOptionDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceKeywordDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceKeyword.self, forKey: .sourceKeyword)
        sourceKeyword = sourceKeywordDecoded
        let sourceFrequencyDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.SourceFrequency.self, forKey: .sourceFrequency)
        sourceFrequency = sourceFrequencyDecoded
        let troubleshootingTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .troubleshootingText)
        troubleshootingText = troubleshootingTextDecoded
    }
}

extension AuditManagerClientTypes {
    /// The control mapping fields that represent the source for evidence collection, along with related parameters and metadata. This doesn't contain mappingID.
    public struct CreateControlMappingSource: Swift.Equatable {
        /// The description of the data source that determines where Audit Manager collects evidence from for the control.
        public var sourceDescription: Swift.String?
        /// The frequency of evidence collection for the control mapping source.
        public var sourceFrequency: AuditManagerClientTypes.SourceFrequency?
        /// The keyword to search for in CloudTrail logs, Config rules, Security Hub checks, and Amazon Web Services API names. To learn more about the supported keywords that you can use when mapping a control data source, see the following pages in the Audit Manager User Guide:
        ///
        /// * [Config rules supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-ash.html)
        ///
        /// * [Security Hub controls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-config.html)
        ///
        /// * [API calls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-api.html)
        ///
        /// * [CloudTrail event names supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-cloudtrail.html)
        public var sourceKeyword: AuditManagerClientTypes.SourceKeyword?
        /// The name of the control mapping data source.
        public var sourceName: Swift.String?
        /// The setup option for the data source, which reflects if the evidence collection is automated or manual.
        public var sourceSetUpOption: AuditManagerClientTypes.SourceSetUpOption?
        /// Specifies one of the five types of data sources for evidence collection.
        public var sourceType: AuditManagerClientTypes.SourceType?
        /// The instructions for troubleshooting the control.
        public var troubleshootingText: Swift.String?

        public init (
            sourceDescription: Swift.String? = nil,
            sourceFrequency: AuditManagerClientTypes.SourceFrequency? = nil,
            sourceKeyword: AuditManagerClientTypes.SourceKeyword? = nil,
            sourceName: Swift.String? = nil,
            sourceSetUpOption: AuditManagerClientTypes.SourceSetUpOption? = nil,
            sourceType: AuditManagerClientTypes.SourceType? = nil,
            troubleshootingText: Swift.String? = nil
        )
        {
            self.sourceDescription = sourceDescription
            self.sourceFrequency = sourceFrequency
            self.sourceKeyword = sourceKeyword
            self.sourceName = sourceName
            self.sourceSetUpOption = sourceSetUpOption
            self.sourceType = sourceType
            self.troubleshootingText = troubleshootingText
        }
    }

}

extension CreateControlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateControlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateControlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateControlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateControlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.control = output.control
        } else {
            self.control = nil
        }
    }
}

public struct CreateControlOutputResponse: Swift.Equatable {
    /// The new control that the CreateControl API returned.
    public var control: AuditManagerClientTypes.Control?

    public init (
        control: AuditManagerClientTypes.Control? = nil
    )
    {
        self.control = control
    }
}

struct CreateControlOutputResponseBody: Swift.Equatable {
    let control: AuditManagerClientTypes.Control?
}

extension CreateControlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case control
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Control.self, forKey: .control)
        control = controlDecoded
    }
}

extension AuditManagerClientTypes.CreateDelegationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case controlSetId
        case roleArn
        case roleType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let controlSetId = self.controlSetId {
            try encodeContainer.encode(controlSetId, forKey: .controlSetId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let roleType = self.roleType {
            try encodeContainer.encode(roleType.rawValue, forKey: .roleType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let controlSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetId)
        controlSetId = controlSetIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let roleTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.RoleType.self, forKey: .roleType)
        roleType = roleTypeDecoded
    }
}

extension AuditManagerClientTypes {
    /// A collection of attributes that's used to create a delegation for an assessment in Audit Manager.
    public struct CreateDelegationRequest: Swift.Equatable {
        /// A comment that's related to the delegation request.
        public var comment: Swift.String?
        /// The unique identifier for the control set.
        public var controlSetId: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role.
        public var roleArn: Swift.String?
        /// The type of customer persona. In CreateAssessment, roleType can only be PROCESS_OWNER. In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        public var roleType: AuditManagerClientTypes.RoleType?

        public init (
            comment: Swift.String? = nil,
            controlSetId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            roleType: AuditManagerClientTypes.RoleType? = nil
        )
        {
            self.comment = comment
            self.controlSetId = controlSetId
            self.roleArn = roleArn
            self.roleType = roleType
        }
    }

}

extension AuditManagerClientTypes.Delegation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
        case assessmentName
        case comment
        case controlSetId
        case createdBy
        case creationTime
        case id
        case lastUpdated
        case roleArn
        case roleType
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let controlSetId = self.controlSetId {
            try encodeContainer.encode(controlSetId, forKey: .controlSetId)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let roleType = self.roleType {
            try encodeContainer.encode(roleType.rawValue, forKey: .roleType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.DelegationStatus.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let roleTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.RoleType.self, forKey: .roleType)
        roleType = roleTypeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let controlSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetId)
        controlSetId = controlSetIdDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension AuditManagerClientTypes {
    /// The assignment of a control set to a delegate for review.
    public struct Delegation: Swift.Equatable {
        /// The identifier for the assessment that's associated with the delegation.
        public var assessmentId: Swift.String?
        /// The name of the assessment that's associated with the delegation.
        public var assessmentName: Swift.String?
        /// The comment that's related to the delegation.
        public var comment: Swift.String?
        /// The identifier for the control set that's associated with the delegation.
        public var controlSetId: Swift.String?
        /// The IAM user or role that created the delegation.
        public var createdBy: Swift.String?
        /// Specifies when the delegation was created.
        public var creationTime: ClientRuntime.Date?
        /// The unique identifier for the delegation.
        public var id: Swift.String?
        /// Specifies when the delegation was last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the IAM role.
        public var roleArn: Swift.String?
        /// The type of customer persona. In CreateAssessment, roleType can only be PROCESS_OWNER. In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        public var roleType: AuditManagerClientTypes.RoleType?
        /// The status of the delegation.
        public var status: AuditManagerClientTypes.DelegationStatus?

        public init (
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            comment: Swift.String? = nil,
            controlSetId: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            roleType: AuditManagerClientTypes.RoleType? = nil,
            status: AuditManagerClientTypes.DelegationStatus? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.comment = comment
            self.controlSetId = controlSetId
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.id = id
            self.lastUpdated = lastUpdated
            self.roleArn = roleArn
            self.roleType = roleType
            self.status = status
        }
    }

}

extension AuditManagerClientTypes.DelegationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
        case assessmentName
        case controlSetName
        case creationTime
        case id
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let controlSetName = self.controlSetName {
            try encodeContainer.encode(controlSetName, forKey: .controlSetName)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.DelegationStatus.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let controlSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetName)
        controlSetName = controlSetNameDecoded
    }
}

extension AuditManagerClientTypes {
    /// The metadata that's associated with the delegation.
    public struct DelegationMetadata: Swift.Equatable {
        /// The unique identifier for the assessment.
        public var assessmentId: Swift.String?
        /// The name of the associated assessment.
        public var assessmentName: Swift.String?
        /// Specifies the name of the control set that was delegated for review.
        public var controlSetName: Swift.String?
        /// Specifies when the delegation was created.
        public var creationTime: ClientRuntime.Date?
        /// The unique identifier for the delegation.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role.
        public var roleArn: Swift.String?
        /// The current status of the delegation.
        public var status: AuditManagerClientTypes.DelegationStatus?

        public init (
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            controlSetName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: AuditManagerClientTypes.DelegationStatus? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.controlSetName = controlSetName
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension AuditManagerClientTypes {
    public enum DelegationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case inProgress
        case underReview
        case sdkUnknown(Swift.String)

        public static var allCases: [DelegationStatus] {
            return [
                .complete,
                .inProgress,
                .underReview,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .inProgress: return "IN_PROGRESS"
            case .underReview: return "UNDER_REVIEW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DelegationStatus(rawValue: rawValue) ?? DelegationStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAssessmentFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkId = frameworkId else {
            return nil
        }
        return "/assessmentFrameworks/\(frameworkId.urlPercentEncoding())"
    }
}

public struct DeleteAssessmentFrameworkInput: Swift.Equatable {
    /// The identifier for the custom framework.
    /// This member is required.
    public var frameworkId: Swift.String?

    public init (
        frameworkId: Swift.String? = nil
    )
    {
        self.frameworkId = frameworkId
    }
}

struct DeleteAssessmentFrameworkInputBody: Swift.Equatable {
}

extension DeleteAssessmentFrameworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssessmentFrameworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentFrameworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAssessmentFrameworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentFrameworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentFrameworkOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAssessmentFrameworkShareInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let requestType = requestType else {
                let message = "Creating a URL Query Item failed. requestType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let requestTypeQueryItem = ClientRuntime.URLQueryItem(name: "requestType".urlPercentEncoding(), value: Swift.String(requestType.rawValue).urlPercentEncoding())
            items.append(requestTypeQueryItem)
            return items
        }
    }
}

extension DeleteAssessmentFrameworkShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let requestId = requestId else {
            return nil
        }
        return "/assessmentFrameworkShareRequests/\(requestId.urlPercentEncoding())"
    }
}

public struct DeleteAssessmentFrameworkShareInput: Swift.Equatable {
    /// The unique identifier for the share request to be deleted.
    /// This member is required.
    public var requestId: Swift.String?
    /// Specifies whether the share request is a sent request or a received request.
    /// This member is required.
    public var requestType: AuditManagerClientTypes.ShareRequestType?

    public init (
        requestId: Swift.String? = nil,
        requestType: AuditManagerClientTypes.ShareRequestType? = nil
    )
    {
        self.requestId = requestId
        self.requestType = requestType
    }
}

struct DeleteAssessmentFrameworkShareInputBody: Swift.Equatable {
}

extension DeleteAssessmentFrameworkShareInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssessmentFrameworkShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentFrameworkShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAssessmentFrameworkShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentFrameworkShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentFrameworkShareOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())"
    }
}

public struct DeleteAssessmentInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?

    public init (
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

struct DeleteAssessmentInputBody: Swift.Equatable {
}

extension DeleteAssessmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAssessmentReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let assessmentReportId = assessmentReportId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/reports/\(assessmentReportId.urlPercentEncoding())"
    }
}

public struct DeleteAssessmentReportInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the assessment report.
    /// This member is required.
    public var assessmentReportId: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        assessmentReportId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentReportId = assessmentReportId
    }
}

struct DeleteAssessmentReportInputBody: Swift.Equatable {
}

extension DeleteAssessmentReportInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssessmentReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAssessmentReportOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentReportOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let controlId = controlId else {
            return nil
        }
        return "/controls/\(controlId.urlPercentEncoding())"
    }
}

public struct DeleteControlInput: Swift.Equatable {
    /// The unique identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?

    public init (
        controlId: Swift.String? = nil
    )
    {
        self.controlId = controlId
    }
}

struct DeleteControlInputBody: Swift.Equatable {
}

extension DeleteControlInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteControlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteControlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteControlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteControlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteControlOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeregisterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account/deregisterAccount"
    }
}

public struct DeregisterAccountInput: Swift.Equatable {

    public init () { }
}

struct DeregisterAccountInputBody: Swift.Equatable {
}

extension DeregisterAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeregisterAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeregisterAccountOutputResponse: Swift.Equatable {
    /// The registration status of the account.
    public var status: AuditManagerClientTypes.AccountStatus?

    public init (
        status: AuditManagerClientTypes.AccountStatus? = nil
    )
    {
        self.status = status
    }
}

struct DeregisterAccountOutputResponseBody: Swift.Equatable {
    let status: AuditManagerClientTypes.AccountStatus?
}

extension DeregisterAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AccountStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeregisterOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

extension DeregisterOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account/deregisterOrganizationAdminAccount"
    }
}

public struct DeregisterOrganizationAdminAccountInput: Swift.Equatable {
    /// The identifier for the administrator account.
    public var adminAccountId: Swift.String?

    public init (
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct DeregisterOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
}

extension DeregisterOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension DeregisterOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterOrganizationAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterOrganizationAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterOrganizationAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterOrganizationAdminAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateAssessmentReportEvidenceFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFolderId = self.evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
    }
}

extension DisassociateAssessmentReportEvidenceFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/disassociateFromAssessmentReport"
    }
}

public struct DisassociateAssessmentReportEvidenceFolderInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
    }
}

struct DisassociateAssessmentReportEvidenceFolderInputBody: Swift.Equatable {
    let evidenceFolderId: Swift.String?
}

extension DisassociateAssessmentReportEvidenceFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolderId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
    }
}

extension DisassociateAssessmentReportEvidenceFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAssessmentReportEvidenceFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateAssessmentReportEvidenceFolderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAssessmentReportEvidenceFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateAssessmentReportEvidenceFolderOutputResponse: Swift.Equatable {

    public init () { }
}

extension AuditManagerClientTypes.Evidence: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReportSelection
        case attributes
        case awsAccountId
        case awsOrganization
        case complianceCheck
        case dataSource
        case eventName
        case eventSource
        case evidenceAwsAccountId
        case evidenceByType
        case evidenceFolderId
        case iamId
        case id
        case resourcesIncluded
        case time
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentReportSelection = self.assessmentReportSelection {
            try encodeContainer.encode(assessmentReportSelection, forKey: .assessmentReportSelection)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, evidenceAttributes0) in attributes {
                try attributesContainer.encode(evidenceAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsOrganization = self.awsOrganization {
            try encodeContainer.encode(awsOrganization, forKey: .awsOrganization)
        }
        if let complianceCheck = self.complianceCheck {
            try encodeContainer.encode(complianceCheck, forKey: .complianceCheck)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let eventSource = self.eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let evidenceAwsAccountId = self.evidenceAwsAccountId {
            try encodeContainer.encode(evidenceAwsAccountId, forKey: .evidenceAwsAccountId)
        }
        if let evidenceByType = self.evidenceByType {
            try encodeContainer.encode(evidenceByType, forKey: .evidenceByType)
        }
        if let evidenceFolderId = self.evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
        if let iamId = self.iamId {
            try encodeContainer.encode(iamId, forKey: .iamId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resourcesIncluded = resourcesIncluded {
            var resourcesIncludedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourcesIncluded)
            for resource0 in resourcesIncluded {
                try resourcesIncludedContainer.encode(resource0)
            }
        }
        if let time = self.time {
            try encodeContainer.encodeTimestamp(time, format: .epochSeconds, forKey: .time)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let evidenceAwsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceAwsAccountId)
        evidenceAwsAccountId = evidenceAwsAccountIdDecoded
        let timeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .time)
        time = timeDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let evidenceByTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceByType)
        evidenceByType = evidenceByTypeDecoded
        let resourcesIncludedContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Resource?].self, forKey: .resourcesIncluded)
        var resourcesIncludedDecoded0:[AuditManagerClientTypes.Resource]? = nil
        if let resourcesIncludedContainer = resourcesIncludedContainer {
            resourcesIncludedDecoded0 = [AuditManagerClientTypes.Resource]()
            for structure0 in resourcesIncludedContainer {
                if let structure0 = structure0 {
                    resourcesIncludedDecoded0?.append(structure0)
                }
            }
        }
        resourcesIncluded = resourcesIncludedDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, evidenceattributevalue0) in attributesContainer {
                if let evidenceattributevalue0 = evidenceattributevalue0 {
                    attributesDecoded0?[key0] = evidenceattributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let iamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamId)
        iamId = iamIdDecoded
        let complianceCheckDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceCheck)
        complianceCheck = complianceCheckDecoded
        let awsOrganizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsOrganization)
        awsOrganization = awsOrganizationDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let assessmentReportSelectionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentReportSelection)
        assessmentReportSelection = assessmentReportSelectionDecoded
    }
}

extension AuditManagerClientTypes {
    /// A record that contains the information needed to demonstrate compliance with the requirements specified by a control. Examples of evidence include change activity triggered by a user, or a system configuration snapshot.
    public struct Evidence: Swift.Equatable {
        /// Specifies whether the evidence is included in the assessment report.
        public var assessmentReportSelection: Swift.String?
        /// The names and values that are used by the evidence event. This includes an attribute name (such as allowUsersToChangePassword) and value (such as true or false).
        public var attributes: [Swift.String:Swift.String]?
        /// The identifier for the Amazon Web Services account.
        public var awsAccountId: Swift.String?
        /// The Amazon Web Services account that the evidence is collected from, and its organization path.
        public var awsOrganization: Swift.String?
        /// The evaluation status for automated evidence that falls under the compliance check category.
        ///
        /// * Audit Manager classes evidence as non-compliant if Security Hub reports a Fail result, or if Config reports a Non-compliant result.
        ///
        /// * Audit Manager classes evidence as compliant if Security Hub reports a Pass result, or if Config reports a Compliant result.
        ///
        /// * If a compliance check isn't available or applicable, then no compliance evaluation can be made for that evidence. This is the case if the evidence uses Config or Security Hub as the underlying data source type, but those services aren't enabled. This is also the case if the evidence uses an underlying data source type that doesn't support compliance checks (such as manual evidence, Amazon Web Services API calls, or CloudTrail).
        public var complianceCheck: Swift.String?
        /// The data source where the evidence was collected from.
        public var dataSource: Swift.String?
        /// The name of the evidence event.
        public var eventName: Swift.String?
        /// The Amazon Web Service that the evidence is collected from.
        public var eventSource: Swift.String?
        /// The identifier for the Amazon Web Services account.
        public var evidenceAwsAccountId: Swift.String?
        /// The type of automated evidence.
        public var evidenceByType: Swift.String?
        /// The identifier for the folder that the evidence is stored in.
        public var evidenceFolderId: Swift.String?
        /// The unique identifier for the IAM user or role that's associated with the evidence.
        public var iamId: Swift.String?
        /// The identifier for the evidence.
        public var id: Swift.String?
        /// The list of resources that are assessed to generate the evidence.
        public var resourcesIncluded: [AuditManagerClientTypes.Resource]?
        /// The timestamp that represents when the evidence was collected.
        public var time: ClientRuntime.Date?

        public init (
            assessmentReportSelection: Swift.String? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            awsAccountId: Swift.String? = nil,
            awsOrganization: Swift.String? = nil,
            complianceCheck: Swift.String? = nil,
            dataSource: Swift.String? = nil,
            eventName: Swift.String? = nil,
            eventSource: Swift.String? = nil,
            evidenceAwsAccountId: Swift.String? = nil,
            evidenceByType: Swift.String? = nil,
            evidenceFolderId: Swift.String? = nil,
            iamId: Swift.String? = nil,
            id: Swift.String? = nil,
            resourcesIncluded: [AuditManagerClientTypes.Resource]? = nil,
            time: ClientRuntime.Date? = nil
        )
        {
            self.assessmentReportSelection = assessmentReportSelection
            self.attributes = attributes
            self.awsAccountId = awsAccountId
            self.awsOrganization = awsOrganization
            self.complianceCheck = complianceCheck
            self.dataSource = dataSource
            self.eventName = eventName
            self.eventSource = eventSource
            self.evidenceAwsAccountId = evidenceAwsAccountId
            self.evidenceByType = evidenceByType
            self.evidenceFolderId = evidenceFolderId
            self.iamId = iamId
            self.id = id
            self.resourcesIncluded = resourcesIncluded
            self.time = time
        }
    }

}

extension AuditManagerClientTypes {
    public enum EvidenceFinderBackfillStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [EvidenceFinderBackfillStatus] {
            return [
                .completed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvidenceFinderBackfillStatus(rawValue: rawValue) ?? EvidenceFinderBackfillStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.EvidenceFinderEnablement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backfillStatus
        case enablementStatus
        case error
        case eventDataStoreArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backfillStatus = self.backfillStatus {
            try encodeContainer.encode(backfillStatus.rawValue, forKey: .backfillStatus)
        }
        if let enablementStatus = self.enablementStatus {
            try encodeContainer.encode(enablementStatus.rawValue, forKey: .enablementStatus)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let eventDataStoreArn = self.eventDataStoreArn {
            try encodeContainer.encode(eventDataStoreArn, forKey: .eventDataStoreArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStoreArn)
        eventDataStoreArn = eventDataStoreArnDecoded
        let enablementStatusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.EvidenceFinderEnablementStatus.self, forKey: .enablementStatus)
        enablementStatus = enablementStatusDecoded
        let backfillStatusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.EvidenceFinderBackfillStatus.self, forKey: .backfillStatus)
        backfillStatus = backfillStatusDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

extension AuditManagerClientTypes {
    /// The settings object that specifies whether evidence finder is enabled. This object also describes the related event data store, and the backfill status for populating the event data store with evidence data.
    public struct EvidenceFinderEnablement: Swift.Equatable {
        /// The current status of the evidence data backfill process. The backfill starts after you enable evidence finder. During this task, Audit Manager populates an event data store with your past evidence data so that your evidence can be queried.
        ///
        /// * NOT_STARTED means that the backfill hasnt started yet.
        ///
        /// * IN_PROGRESS means that the backfill is in progress. This can take up to 24 hours to complete, depending on the amount of evidence data.
        ///
        /// * COMPLETED means that the backfill is complete. All of your past evidence is now queryable.
        public var backfillStatus: AuditManagerClientTypes.EvidenceFinderBackfillStatus?
        /// The current status of the evidence finder feature and the related event data store.
        ///
        /// * ENABLE_IN_PROGRESS means that you requested to enable evidence finder. An event data store is currently being created to support evidence finder queries.
        ///
        /// * ENABLED means that an event data store was successfully created and evidence finder is enabled. We recommend that you wait 24 hours until the event data store is backfilled with your past evidence data. You can use evidence finder in the meantime, but not all data might be available until the backfill is complete.
        ///
        /// * DISABLE_IN_PROGRESS means that you requested to disable evidence finder, and your request is pending the deletion of the event data store.
        ///
        /// * DISABLED means that you have permanently disabled evidence finder and the event data store has been deleted. You can't re-enable evidence finder after this point.
        public var enablementStatus: AuditManagerClientTypes.EvidenceFinderEnablementStatus?
        /// Represents any errors that occurred when enabling or disabling evidence finder.
        public var error: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudTrail Lake event data store thats used by evidence finder. The event data store is the lake of evidence data that evidence finder runs queries against.
        public var eventDataStoreArn: Swift.String?

        public init (
            backfillStatus: AuditManagerClientTypes.EvidenceFinderBackfillStatus? = nil,
            enablementStatus: AuditManagerClientTypes.EvidenceFinderEnablementStatus? = nil,
            error: Swift.String? = nil,
            eventDataStoreArn: Swift.String? = nil
        )
        {
            self.backfillStatus = backfillStatus
            self.enablementStatus = enablementStatus
            self.error = error
            self.eventDataStoreArn = eventDataStoreArn
        }
    }

}

extension AuditManagerClientTypes {
    public enum EvidenceFinderEnablementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disableInProgress
        case enabled
        case enableInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [EvidenceFinderEnablementStatus] {
            return [
                .disabled,
                .disableInProgress,
                .enabled,
                .enableInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case .enableInProgress: return "ENABLE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvidenceFinderEnablementStatus(rawValue: rawValue) ?? EvidenceFinderEnablementStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.EvidenceInsights: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compliantEvidenceCount
        case inconclusiveEvidenceCount
        case noncompliantEvidenceCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compliantEvidenceCount = self.compliantEvidenceCount {
            try encodeContainer.encode(compliantEvidenceCount, forKey: .compliantEvidenceCount)
        }
        if let inconclusiveEvidenceCount = self.inconclusiveEvidenceCount {
            try encodeContainer.encode(inconclusiveEvidenceCount, forKey: .inconclusiveEvidenceCount)
        }
        if let noncompliantEvidenceCount = self.noncompliantEvidenceCount {
            try encodeContainer.encode(noncompliantEvidenceCount, forKey: .noncompliantEvidenceCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncompliantEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noncompliantEvidenceCount)
        noncompliantEvidenceCount = noncompliantEvidenceCountDecoded
        let compliantEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantEvidenceCount)
        compliantEvidenceCount = compliantEvidenceCountDecoded
        let inconclusiveEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inconclusiveEvidenceCount)
        inconclusiveEvidenceCount = inconclusiveEvidenceCountDecoded
    }
}

extension AuditManagerClientTypes {
    /// A breakdown of the latest compliance check status for the evidence in your Audit Manager assessments.
    public struct EvidenceInsights: Swift.Equatable {
        /// The number of compliance check evidence that Audit Manager classified as compliant. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public var compliantEvidenceCount: Swift.Int?
        /// The number of evidence that a compliance check ruling isn't available for. Evidence is inconclusive when the associated control uses Security Hub or Config as a data source but you didn't enable those services. This is also the case when a control uses a data source that doesnt support compliance checks (for example, manual evidence, API calls, or CloudTrail). If evidence has a compliance check status of not applicable in the console, it's classified as inconclusive in EvidenceInsights data.
        public var inconclusiveEvidenceCount: Swift.Int?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public var noncompliantEvidenceCount: Swift.Int?

        public init (
            compliantEvidenceCount: Swift.Int? = nil,
            inconclusiveEvidenceCount: Swift.Int? = nil,
            noncompliantEvidenceCount: Swift.Int? = nil
        )
        {
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
        }
    }

}

extension AuditManagerClientTypes.Framework: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case complianceType
        case controlSets
        case controlSources
        case createdAt
        case createdBy
        case description
        case id
        case lastUpdatedAt
        case lastUpdatedBy
        case logo
        case name
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let controlSets = controlSets {
            var controlSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlSets)
            for controlset0 in controlSets {
                try controlSetsContainer.encode(controlset0)
            }
        }
        if let controlSources = self.controlSources {
            try encodeContainer.encode(controlSources, forKey: .controlSources)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let lastUpdatedBy = self.lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let logo = self.logo {
            try encodeContainer.encode(logo, forKey: .logo)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.FrameworkType.self, forKey: .type)
        type = typeDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let logoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logo)
        logo = logoDecoded
        let controlSourcesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSources)
        controlSources = controlSourcesDecoded
        let controlSetsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlSet?].self, forKey: .controlSets)
        var controlSetsDecoded0:[AuditManagerClientTypes.ControlSet]? = nil
        if let controlSetsContainer = controlSetsContainer {
            controlSetsDecoded0 = [AuditManagerClientTypes.ControlSet]()
            for structure0 in controlSetsContainer {
                if let structure0 = structure0 {
                    controlSetsDecoded0?.append(structure0)
                }
            }
        }
        controlSets = controlSetsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AuditManagerClientTypes {
    /// The file that's used to structure and automate Audit Manager assessments for a given compliance standard.
    public struct Framework: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the framework.
        public var arn: Swift.String?
        /// The compliance type that the new custom framework supports, such as CIS or HIPAA.
        public var complianceType: Swift.String?
        /// The control sets that are associated with the framework.
        public var controlSets: [AuditManagerClientTypes.ControlSet]?
        /// The sources that Audit Manager collects evidence from for the control.
        public var controlSources: Swift.String?
        /// Specifies when the framework was created.
        public var createdAt: ClientRuntime.Date?
        /// The IAM user or role that created the framework.
        public var createdBy: Swift.String?
        /// The description of the framework.
        public var description: Swift.String?
        /// The unique identifier for the framework.
        public var id: Swift.String?
        /// Specifies when the framework was most recently updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The IAM user or role that most recently updated the framework.
        public var lastUpdatedBy: Swift.String?
        /// The logo that's associated with the framework.
        public var logo: Swift.String?
        /// The name of the framework.
        public var name: Swift.String?
        /// The tags that are associated with the framework.
        public var tags: [Swift.String:Swift.String]?
        /// The framework type, such as a custom framework or a standard framework.
        public var type: AuditManagerClientTypes.FrameworkType?

        public init (
            arn: Swift.String? = nil,
            complianceType: Swift.String? = nil,
            controlSets: [AuditManagerClientTypes.ControlSet]? = nil,
            controlSources: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            logo: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: AuditManagerClientTypes.FrameworkType? = nil
        )
        {
            self.arn = arn
            self.complianceType = complianceType
            self.controlSets = controlSets
            self.controlSources = controlSources
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.logo = logo
            self.name = name
            self.tags = tags
            self.type = type
        }
    }

}

extension AuditManagerClientTypes.FrameworkMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType
        case description
        case logo
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let logo = self.logo {
            try encodeContainer.encode(logo, forKey: .logo)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let logoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logo)
        logo = logoDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
    }
}

extension AuditManagerClientTypes {
    /// The metadata of a framework, such as the name, ID, or description.
    public struct FrameworkMetadata: Swift.Equatable {
        /// The compliance standard that's associated with the framework. For example, this could be PCI DSS or HIPAA.
        public var complianceType: Swift.String?
        /// The description of the framework.
        public var description: Swift.String?
        /// The logo that's associated with the framework.
        public var logo: Swift.String?
        /// The name of the framework.
        public var name: Swift.String?

        public init (
            complianceType: Swift.String? = nil,
            description: Swift.String? = nil,
            logo: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.complianceType = complianceType
            self.description = description
            self.logo = logo
            self.name = name
        }
    }

}

extension AuditManagerClientTypes {
    public enum FrameworkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [FrameworkType] {
            return [
                .custom,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "Custom"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FrameworkType(rawValue: rawValue) ?? FrameworkType.sdkUnknown(rawValue)
        }
    }
}

extension GetAccountStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account/status"
    }
}

public struct GetAccountStatusInput: Swift.Equatable {

    public init () { }
}

struct GetAccountStatusInputBody: Swift.Equatable {
}

extension GetAccountStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccountStatusOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAccountStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct GetAccountStatusOutputResponse: Swift.Equatable {
    /// The status of the Amazon Web Services account.
    public var status: AuditManagerClientTypes.AccountStatus?

    public init (
        status: AuditManagerClientTypes.AccountStatus? = nil
    )
    {
        self.status = status
    }
}

struct GetAccountStatusOutputResponseBody: Swift.Equatable {
    let status: AuditManagerClientTypes.AccountStatus?
}

extension GetAccountStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AccountStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetAssessmentFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkId = frameworkId else {
            return nil
        }
        return "/assessmentFrameworks/\(frameworkId.urlPercentEncoding())"
    }
}

public struct GetAssessmentFrameworkInput: Swift.Equatable {
    /// The identifier for the framework.
    /// This member is required.
    public var frameworkId: Swift.String?

    public init (
        frameworkId: Swift.String? = nil
    )
    {
        self.frameworkId = frameworkId
    }
}

struct GetAssessmentFrameworkInputBody: Swift.Equatable {
}

extension GetAssessmentFrameworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssessmentFrameworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssessmentFrameworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAssessmentFrameworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssessmentFrameworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAssessmentFrameworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.framework = output.framework
        } else {
            self.framework = nil
        }
    }
}

public struct GetAssessmentFrameworkOutputResponse: Swift.Equatable {
    /// The framework that the GetAssessmentFramework API returned.
    public var framework: AuditManagerClientTypes.Framework?

    public init (
        framework: AuditManagerClientTypes.Framework? = nil
    )
    {
        self.framework = framework
    }
}

struct GetAssessmentFrameworkOutputResponseBody: Swift.Equatable {
    let framework: AuditManagerClientTypes.Framework?
}

extension GetAssessmentFrameworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case framework
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Framework.self, forKey: .framework)
        framework = frameworkDecoded
    }
}

extension GetAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())"
    }
}

public struct GetAssessmentInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?

    public init (
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

struct GetAssessmentInputBody: Swift.Equatable {
}

extension GetAssessmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
            self.userRole = output.userRole
        } else {
            self.assessment = nil
            self.userRole = nil
        }
    }
}

public struct GetAssessmentOutputResponse: Swift.Equatable {
    /// An entity that defines the scope of audit evidence collected by Audit Manager. An Audit Manager assessment is an implementation of an Audit Manager framework.
    public var assessment: AuditManagerClientTypes.Assessment?
    /// The wrapper that contains the Audit Manager role information of the current user. This includes the role type and IAM Amazon Resource Name (ARN).
    public var userRole: AuditManagerClientTypes.Role?

    public init (
        assessment: AuditManagerClientTypes.Assessment? = nil,
        userRole: AuditManagerClientTypes.Role? = nil
    )
    {
        self.assessment = assessment
        self.userRole = userRole
    }
}

struct GetAssessmentOutputResponseBody: Swift.Equatable {
    let assessment: AuditManagerClientTypes.Assessment?
    let userRole: AuditManagerClientTypes.Role?
}

extension GetAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
        case userRole
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Assessment.self, forKey: .assessment)
        assessment = assessmentDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Role.self, forKey: .userRole)
        userRole = userRoleDecoded
    }
}

extension GetAssessmentReportUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let assessmentReportId = assessmentReportId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/reports/\(assessmentReportId.urlPercentEncoding())/url"
    }
}

public struct GetAssessmentReportUrlInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the assessment report.
    /// This member is required.
    public var assessmentReportId: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        assessmentReportId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentReportId = assessmentReportId
    }
}

struct GetAssessmentReportUrlInputBody: Swift.Equatable {
}

extension GetAssessmentReportUrlInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssessmentReportUrlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssessmentReportUrlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAssessmentReportUrlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssessmentReportUrlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAssessmentReportUrlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.preSignedUrl = output.preSignedUrl
        } else {
            self.preSignedUrl = nil
        }
    }
}

public struct GetAssessmentReportUrlOutputResponse: Swift.Equatable {
    /// Short for uniform resource locator. A URL is used as a unique identifier to locate a resource on the internet.
    public var preSignedUrl: AuditManagerClientTypes.URL?

    public init (
        preSignedUrl: AuditManagerClientTypes.URL? = nil
    )
    {
        self.preSignedUrl = preSignedUrl
    }
}

struct GetAssessmentReportUrlOutputResponseBody: Swift.Equatable {
    let preSignedUrl: AuditManagerClientTypes.URL?
}

extension GetAssessmentReportUrlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preSignedUrl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preSignedUrlDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.URL.self, forKey: .preSignedUrl)
        preSignedUrl = preSignedUrlDecoded
    }
}

extension GetChangeLogsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let controlSetId = controlSetId {
                let controlSetIdQueryItem = ClientRuntime.URLQueryItem(name: "controlSetId".urlPercentEncoding(), value: Swift.String(controlSetId).urlPercentEncoding())
                items.append(controlSetIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let controlId = controlId {
                let controlIdQueryItem = ClientRuntime.URLQueryItem(name: "controlId".urlPercentEncoding(), value: Swift.String(controlId).urlPercentEncoding())
                items.append(controlIdQueryItem)
            }
            return items
        }
    }
}

extension GetChangeLogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/changelogs"
    }
}

public struct GetChangeLogsInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the control.
    public var controlId: Swift.String?
    /// The unique identifier for the control set.
    public var controlSetId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetChangeLogsInputBody: Swift.Equatable {
}

extension GetChangeLogsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChangeLogsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChangeLogsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChangeLogsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChangeLogsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetChangeLogsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changeLogs = output.changeLogs
            self.nextToken = output.nextToken
        } else {
            self.changeLogs = nil
            self.nextToken = nil
        }
    }
}

public struct GetChangeLogsOutputResponse: Swift.Equatable {
    /// The list of user activity for the control.
    public var changeLogs: [AuditManagerClientTypes.ChangeLog]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        changeLogs: [AuditManagerClientTypes.ChangeLog]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.changeLogs = changeLogs
        self.nextToken = nextToken
    }
}

struct GetChangeLogsOutputResponseBody: Swift.Equatable {
    let changeLogs: [AuditManagerClientTypes.ChangeLog]?
    let nextToken: Swift.String?
}

extension GetChangeLogsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeLogs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeLogsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ChangeLog?].self, forKey: .changeLogs)
        var changeLogsDecoded0:[AuditManagerClientTypes.ChangeLog]? = nil
        if let changeLogsContainer = changeLogsContainer {
            changeLogsDecoded0 = [AuditManagerClientTypes.ChangeLog]()
            for structure0 in changeLogsContainer {
                if let structure0 = structure0 {
                    changeLogsDecoded0?.append(structure0)
                }
            }
        }
        changeLogs = changeLogsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let controlId = controlId else {
            return nil
        }
        return "/controls/\(controlId.urlPercentEncoding())"
    }
}

public struct GetControlInput: Swift.Equatable {
    /// The identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?

    public init (
        controlId: Swift.String? = nil
    )
    {
        self.controlId = controlId
    }
}

struct GetControlInputBody: Swift.Equatable {
}

extension GetControlInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetControlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetControlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetControlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetControlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetControlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.control = output.control
        } else {
            self.control = nil
        }
    }
}

public struct GetControlOutputResponse: Swift.Equatable {
    /// The name of the control that the GetControl API returned.
    public var control: AuditManagerClientTypes.Control?

    public init (
        control: AuditManagerClientTypes.Control? = nil
    )
    {
        self.control = control
    }
}

struct GetControlOutputResponseBody: Swift.Equatable {
    let control: AuditManagerClientTypes.Control?
}

extension GetControlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case control
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Control.self, forKey: .control)
        control = controlDecoded
    }
}

extension GetDelegationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetDelegationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delegations"
    }
}

public struct GetDelegationsInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDelegationsInputBody: Swift.Equatable {
}

extension GetDelegationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDelegationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDelegationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDelegationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDelegationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDelegationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.delegations = output.delegations
            self.nextToken = output.nextToken
        } else {
            self.delegations = nil
            self.nextToken = nil
        }
    }
}

public struct GetDelegationsOutputResponse: Swift.Equatable {
    /// The list of delegations that the GetDelegations API returned.
    public var delegations: [AuditManagerClientTypes.DelegationMetadata]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        delegations: [AuditManagerClientTypes.DelegationMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.delegations = delegations
        self.nextToken = nextToken
    }
}

struct GetDelegationsOutputResponseBody: Swift.Equatable {
    let delegations: [AuditManagerClientTypes.DelegationMetadata]?
    let nextToken: Swift.String?
}

extension GetDelegationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegations
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegationsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.DelegationMetadata?].self, forKey: .delegations)
        var delegationsDecoded0:[AuditManagerClientTypes.DelegationMetadata]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [AuditManagerClientTypes.DelegationMetadata]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetEvidenceByEvidenceFolderInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetEvidenceByEvidenceFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        guard let evidenceFolderId = evidenceFolderId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/evidenceFolders/\(evidenceFolderId.urlPercentEncoding())/evidence"
    }
}

public struct GetEvidenceByEvidenceFolderInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The unique identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlSetId = controlSetId
        self.evidenceFolderId = evidenceFolderId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetEvidenceByEvidenceFolderInputBody: Swift.Equatable {
}

extension GetEvidenceByEvidenceFolderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEvidenceByEvidenceFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEvidenceByEvidenceFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEvidenceByEvidenceFolderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEvidenceByEvidenceFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEvidenceByEvidenceFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.evidence = output.evidence
            self.nextToken = output.nextToken
        } else {
            self.evidence = nil
            self.nextToken = nil
        }
    }
}

public struct GetEvidenceByEvidenceFolderOutputResponse: Swift.Equatable {
    /// The list of evidence that the GetEvidenceByEvidenceFolder API returned.
    public var evidence: [AuditManagerClientTypes.Evidence]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        evidence: [AuditManagerClientTypes.Evidence]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evidence = evidence
        self.nextToken = nextToken
    }
}

struct GetEvidenceByEvidenceFolderOutputResponseBody: Swift.Equatable {
    let evidence: [AuditManagerClientTypes.Evidence]?
    let nextToken: Swift.String?
}

extension GetEvidenceByEvidenceFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidence
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Evidence?].self, forKey: .evidence)
        var evidenceDecoded0:[AuditManagerClientTypes.Evidence]? = nil
        if let evidenceContainer = evidenceContainer {
            evidenceDecoded0 = [AuditManagerClientTypes.Evidence]()
            for structure0 in evidenceContainer {
                if let structure0 = structure0 {
                    evidenceDecoded0?.append(structure0)
                }
            }
        }
        evidence = evidenceDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetEvidenceFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        guard let evidenceFolderId = evidenceFolderId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/evidenceFolders/\(evidenceFolderId.urlPercentEncoding())"
    }
}

public struct GetEvidenceFolderInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The unique identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlSetId = controlSetId
        self.evidenceFolderId = evidenceFolderId
    }
}

struct GetEvidenceFolderInputBody: Swift.Equatable {
}

extension GetEvidenceFolderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEvidenceFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEvidenceFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEvidenceFolderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEvidenceFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEvidenceFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.evidenceFolder = output.evidenceFolder
        } else {
            self.evidenceFolder = nil
        }
    }
}

public struct GetEvidenceFolderOutputResponse: Swift.Equatable {
    /// The folder that the evidence is stored in.
    public var evidenceFolder: AuditManagerClientTypes.AssessmentEvidenceFolder?

    public init (
        evidenceFolder: AuditManagerClientTypes.AssessmentEvidenceFolder? = nil
    )
    {
        self.evidenceFolder = evidenceFolder
    }
}

struct GetEvidenceFolderOutputResponseBody: Swift.Equatable {
    let evidenceFolder: AuditManagerClientTypes.AssessmentEvidenceFolder?
}

extension GetEvidenceFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentEvidenceFolder.self, forKey: .evidenceFolder)
        evidenceFolder = evidenceFolderDecoded
    }
}

extension GetEvidenceFoldersByAssessmentControlInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetEvidenceFoldersByAssessmentControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        guard let controlId = controlId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/evidenceFolders-by-assessment-control/\(controlSetId.urlPercentEncoding())/\(controlId.urlPercentEncoding())"
    }
}

public struct GetEvidenceFoldersByAssessmentControlInput: Swift.Equatable {
    /// The identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?
    /// The identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetEvidenceFoldersByAssessmentControlInputBody: Swift.Equatable {
}

extension GetEvidenceFoldersByAssessmentControlInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEvidenceFoldersByAssessmentControlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEvidenceFoldersByAssessmentControlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEvidenceFoldersByAssessmentControlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEvidenceFoldersByAssessmentControlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEvidenceFoldersByAssessmentControlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.evidenceFolders = output.evidenceFolders
            self.nextToken = output.nextToken
        } else {
            self.evidenceFolders = nil
            self.nextToken = nil
        }
    }
}

public struct GetEvidenceFoldersByAssessmentControlOutputResponse: Swift.Equatable {
    /// The list of evidence folders that the GetEvidenceFoldersByAssessmentControl API returned.
    public var evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evidenceFolders = evidenceFolders
        self.nextToken = nextToken
    }
}

struct GetEvidenceFoldersByAssessmentControlOutputResponseBody: Swift.Equatable {
    let evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]?
    let nextToken: Swift.String?
}

extension GetEvidenceFoldersByAssessmentControlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolders
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFoldersContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentEvidenceFolder?].self, forKey: .evidenceFolders)
        var evidenceFoldersDecoded0:[AuditManagerClientTypes.AssessmentEvidenceFolder]? = nil
        if let evidenceFoldersContainer = evidenceFoldersContainer {
            evidenceFoldersDecoded0 = [AuditManagerClientTypes.AssessmentEvidenceFolder]()
            for structure0 in evidenceFoldersContainer {
                if let structure0 = structure0 {
                    evidenceFoldersDecoded0?.append(structure0)
                }
            }
        }
        evidenceFolders = evidenceFoldersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetEvidenceFoldersByAssessmentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetEvidenceFoldersByAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/evidenceFolders"
    }
}

public struct GetEvidenceFoldersByAssessmentInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetEvidenceFoldersByAssessmentInputBody: Swift.Equatable {
}

extension GetEvidenceFoldersByAssessmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEvidenceFoldersByAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEvidenceFoldersByAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEvidenceFoldersByAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEvidenceFoldersByAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEvidenceFoldersByAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.evidenceFolders = output.evidenceFolders
            self.nextToken = output.nextToken
        } else {
            self.evidenceFolders = nil
            self.nextToken = nil
        }
    }
}

public struct GetEvidenceFoldersByAssessmentOutputResponse: Swift.Equatable {
    /// The list of evidence folders that the GetEvidenceFoldersByAssessment API returned.
    public var evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evidenceFolders = evidenceFolders
        self.nextToken = nextToken
    }
}

struct GetEvidenceFoldersByAssessmentOutputResponseBody: Swift.Equatable {
    let evidenceFolders: [AuditManagerClientTypes.AssessmentEvidenceFolder]?
    let nextToken: Swift.String?
}

extension GetEvidenceFoldersByAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidenceFolders
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFoldersContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentEvidenceFolder?].self, forKey: .evidenceFolders)
        var evidenceFoldersDecoded0:[AuditManagerClientTypes.AssessmentEvidenceFolder]? = nil
        if let evidenceFoldersContainer = evidenceFoldersContainer {
            evidenceFoldersDecoded0 = [AuditManagerClientTypes.AssessmentEvidenceFolder]()
            for structure0 in evidenceFoldersContainer {
                if let structure0 = structure0 {
                    evidenceFoldersDecoded0?.append(structure0)
                }
            }
        }
        evidenceFolders = evidenceFoldersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetEvidenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        guard let evidenceFolderId = evidenceFolderId else {
            return nil
        }
        guard let evidenceId = evidenceId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/evidenceFolders/\(evidenceFolderId.urlPercentEncoding())/evidence/\(evidenceId.urlPercentEncoding())"
    }
}

public struct GetEvidenceInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The unique identifier for the folder that the evidence is stored in.
    /// This member is required.
    public var evidenceFolderId: Swift.String?
    /// The unique identifier for the evidence.
    /// This member is required.
    public var evidenceId: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        evidenceFolderId: Swift.String? = nil,
        evidenceId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlSetId = controlSetId
        self.evidenceFolderId = evidenceFolderId
        self.evidenceId = evidenceId
    }
}

struct GetEvidenceInputBody: Swift.Equatable {
}

extension GetEvidenceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEvidenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEvidenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEvidenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEvidenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEvidenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.evidence = output.evidence
        } else {
            self.evidence = nil
        }
    }
}

public struct GetEvidenceOutputResponse: Swift.Equatable {
    /// The evidence that the GetEvidenceResponse API returned.
    public var evidence: AuditManagerClientTypes.Evidence?

    public init (
        evidence: AuditManagerClientTypes.Evidence? = nil
    )
    {
        self.evidence = evidence
    }
}

struct GetEvidenceOutputResponseBody: Swift.Equatable {
    let evidence: AuditManagerClientTypes.Evidence?
}

extension GetEvidenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evidence
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Evidence.self, forKey: .evidence)
        evidence = evidenceDecoded
    }
}

extension GetInsightsByAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/insights/assessments/\(assessmentId.urlPercentEncoding())"
    }
}

public struct GetInsightsByAssessmentInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?

    public init (
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

struct GetInsightsByAssessmentInputBody: Swift.Equatable {
}

extension GetInsightsByAssessmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInsightsByAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightsByAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetInsightsByAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightsByAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetInsightsByAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.insights = output.insights
        } else {
            self.insights = nil
        }
    }
}

public struct GetInsightsByAssessmentOutputResponse: Swift.Equatable {
    /// The assessment analytics data that the GetInsightsByAssessment API returned.
    public var insights: AuditManagerClientTypes.InsightsByAssessment?

    public init (
        insights: AuditManagerClientTypes.InsightsByAssessment? = nil
    )
    {
        self.insights = insights
    }
}

struct GetInsightsByAssessmentOutputResponseBody: Swift.Equatable {
    let insights: AuditManagerClientTypes.InsightsByAssessment?
}

extension GetInsightsByAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insights
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.InsightsByAssessment.self, forKey: .insights)
        insights = insightsDecoded
    }
}

extension GetInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights"
    }
}

public struct GetInsightsInput: Swift.Equatable {

    public init () { }
}

struct GetInsightsInputBody: Swift.Equatable {
}

extension GetInsightsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInsightsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetInsightsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetInsightsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.insights = output.insights
        } else {
            self.insights = nil
        }
    }
}

public struct GetInsightsOutputResponse: Swift.Equatable {
    /// The analytics data that the GetInsights API returned.
    public var insights: AuditManagerClientTypes.Insights?

    public init (
        insights: AuditManagerClientTypes.Insights? = nil
    )
    {
        self.insights = insights
    }
}

struct GetInsightsOutputResponseBody: Swift.Equatable {
    let insights: AuditManagerClientTypes.Insights?
}

extension GetInsightsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insights
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Insights.self, forKey: .insights)
        insights = insightsDecoded
    }
}

extension GetOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account/organizationAdminAccount"
    }
}

public struct GetOrganizationAdminAccountInput: Swift.Equatable {

    public init () { }
}

struct GetOrganizationAdminAccountInputBody: Swift.Equatable {
}

extension GetOrganizationAdminAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOrganizationAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetOrganizationAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOrganizationAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetOrganizationAdminAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adminAccountId = output.adminAccountId
            self.organizationId = output.organizationId
        } else {
            self.adminAccountId = nil
            self.organizationId = nil
        }
    }
}

public struct GetOrganizationAdminAccountOutputResponse: Swift.Equatable {
    /// The identifier for the administrator account.
    public var adminAccountId: Swift.String?
    /// The identifier for the organization.
    public var organizationId: Swift.String?

    public init (
        adminAccountId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.organizationId = organizationId
    }
}

struct GetOrganizationAdminAccountOutputResponseBody: Swift.Equatable {
    let adminAccountId: Swift.String?
    let organizationId: Swift.String?
}

extension GetOrganizationAdminAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId
        case organizationId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension GetServicesInScopeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/services"
    }
}

public struct GetServicesInScopeInput: Swift.Equatable {

    public init () { }
}

struct GetServicesInScopeInputBody: Swift.Equatable {
}

extension GetServicesInScopeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServicesInScopeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServicesInScopeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServicesInScopeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServicesInScopeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetServicesInScopeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceMetadata = output.serviceMetadata
        } else {
            self.serviceMetadata = nil
        }
    }
}

public struct GetServicesInScopeOutputResponse: Swift.Equatable {
    /// The metadata that's associated with the Amazon Web Service.
    public var serviceMetadata: [AuditManagerClientTypes.ServiceMetadata]?

    public init (
        serviceMetadata: [AuditManagerClientTypes.ServiceMetadata]? = nil
    )
    {
        self.serviceMetadata = serviceMetadata
    }
}

struct GetServicesInScopeOutputResponseBody: Swift.Equatable {
    let serviceMetadata: [AuditManagerClientTypes.ServiceMetadata]?
}

extension GetServicesInScopeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceMetadata
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceMetadataContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ServiceMetadata?].self, forKey: .serviceMetadata)
        var serviceMetadataDecoded0:[AuditManagerClientTypes.ServiceMetadata]? = nil
        if let serviceMetadataContainer = serviceMetadataContainer {
            serviceMetadataDecoded0 = [AuditManagerClientTypes.ServiceMetadata]()
            for structure0 in serviceMetadataContainer {
                if let structure0 = structure0 {
                    serviceMetadataDecoded0?.append(structure0)
                }
            }
        }
        serviceMetadata = serviceMetadataDecoded0
    }
}

extension GetSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let attribute = attribute else {
            return nil
        }
        return "/settings/\(attribute.rawValue.urlPercentEncoding())"
    }
}

public struct GetSettingsInput: Swift.Equatable {
    /// The list of SettingAttribute enum values.
    /// This member is required.
    public var attribute: AuditManagerClientTypes.SettingAttribute?

    public init (
        attribute: AuditManagerClientTypes.SettingAttribute? = nil
    )
    {
        self.attribute = attribute
    }
}

struct GetSettingsInputBody: Swift.Equatable {
}

extension GetSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.settings = output.settings
        } else {
            self.settings = nil
        }
    }
}

public struct GetSettingsOutputResponse: Swift.Equatable {
    /// The settings object that holds all supported Audit Manager settings.
    public var settings: AuditManagerClientTypes.Settings?

    public init (
        settings: AuditManagerClientTypes.Settings? = nil
    )
    {
        self.settings = settings
    }
}

struct GetSettingsOutputResponseBody: Swift.Equatable {
    let settings: AuditManagerClientTypes.Settings?
}

extension GetSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension AuditManagerClientTypes.Insights: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeAssessmentsCount
        case assessmentControlsCountByNoncompliantEvidence
        case compliantEvidenceCount
        case inconclusiveEvidenceCount
        case lastUpdated
        case noncompliantEvidenceCount
        case totalAssessmentControlsCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeAssessmentsCount = self.activeAssessmentsCount {
            try encodeContainer.encode(activeAssessmentsCount, forKey: .activeAssessmentsCount)
        }
        if let assessmentControlsCountByNoncompliantEvidence = self.assessmentControlsCountByNoncompliantEvidence {
            try encodeContainer.encode(assessmentControlsCountByNoncompliantEvidence, forKey: .assessmentControlsCountByNoncompliantEvidence)
        }
        if let compliantEvidenceCount = self.compliantEvidenceCount {
            try encodeContainer.encode(compliantEvidenceCount, forKey: .compliantEvidenceCount)
        }
        if let inconclusiveEvidenceCount = self.inconclusiveEvidenceCount {
            try encodeContainer.encode(inconclusiveEvidenceCount, forKey: .inconclusiveEvidenceCount)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let noncompliantEvidenceCount = self.noncompliantEvidenceCount {
            try encodeContainer.encode(noncompliantEvidenceCount, forKey: .noncompliantEvidenceCount)
        }
        if let totalAssessmentControlsCount = self.totalAssessmentControlsCount {
            try encodeContainer.encode(totalAssessmentControlsCount, forKey: .totalAssessmentControlsCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeAssessmentsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeAssessmentsCount)
        activeAssessmentsCount = activeAssessmentsCountDecoded
        let noncompliantEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noncompliantEvidenceCount)
        noncompliantEvidenceCount = noncompliantEvidenceCountDecoded
        let compliantEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantEvidenceCount)
        compliantEvidenceCount = compliantEvidenceCountDecoded
        let inconclusiveEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inconclusiveEvidenceCount)
        inconclusiveEvidenceCount = inconclusiveEvidenceCountDecoded
        let assessmentControlsCountByNoncompliantEvidenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assessmentControlsCountByNoncompliantEvidence)
        assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidenceDecoded
        let totalAssessmentControlsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAssessmentControlsCount)
        totalAssessmentControlsCount = totalAssessmentControlsCountDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes {
    /// A summary of the latest analytics data for all your active assessments. This summary is a snapshot of the data that your active assessments collected on the lastUpdated date. Its important to understand that the following totals are daily counts based on this date  they arent a total sum to date. The Insights data is eventually consistent. This means that, when you read data from Insights, the response might not instantly reflect the results of a recently completed write or update operation. If you repeat your read request after a few hours, the response should return the latest data. If you delete an assessment or change its status to inactive, InsightsByAssessment includes data for that assessment as follows.
    ///
    /// * Inactive assessments - If Audit Manager collected evidence for your assessment before you changed it inactive, that evidence is included in the InsightsByAssessment counts for that day.
    ///
    /// * Deleted assessments - If Audit Manager collected evidence for your assessment before you deleted it, that evidence isn't included in the InsightsByAssessment counts for that day.
    public struct Insights: Swift.Equatable {
        /// The number of active assessments in Audit Manager.
        public var activeAssessmentsCount: Swift.Int?
        /// The number of assessment controls that collected non-compliant evidence on the lastUpdated date.
        public var assessmentControlsCountByNoncompliantEvidence: Swift.Int?
        /// The number of compliance check evidence that Audit Manager classified as compliant on the lastUpdated date. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public var compliantEvidenceCount: Swift.Int?
        /// The number of evidence without a compliance check ruling. Evidence is inconclusive when the associated control uses Security Hub or Config as a data source but you didn't enable those services. This is also the case when a control uses a data source that doesnt support compliance checks (for example: manual evidence, API calls, or CloudTrail). If evidence has a compliance check status of not applicable, it's classed as inconclusive in Insights data.
        public var inconclusiveEvidenceCount: Swift.Int?
        /// The time when the cross-assessment insights were last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant on the lastUpdated date. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public var noncompliantEvidenceCount: Swift.Int?
        /// The total number of controls across all active assessments.
        public var totalAssessmentControlsCount: Swift.Int?

        public init (
            activeAssessmentsCount: Swift.Int? = nil,
            assessmentControlsCountByNoncompliantEvidence: Swift.Int? = nil,
            compliantEvidenceCount: Swift.Int? = nil,
            inconclusiveEvidenceCount: Swift.Int? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            noncompliantEvidenceCount: Swift.Int? = nil,
            totalAssessmentControlsCount: Swift.Int? = nil
        )
        {
            self.activeAssessmentsCount = activeAssessmentsCount
            self.assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidence
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.lastUpdated = lastUpdated
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
            self.totalAssessmentControlsCount = totalAssessmentControlsCount
        }
    }

}

extension AuditManagerClientTypes.InsightsByAssessment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentControlsCountByNoncompliantEvidence
        case compliantEvidenceCount
        case inconclusiveEvidenceCount
        case lastUpdated
        case noncompliantEvidenceCount
        case totalAssessmentControlsCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentControlsCountByNoncompliantEvidence = self.assessmentControlsCountByNoncompliantEvidence {
            try encodeContainer.encode(assessmentControlsCountByNoncompliantEvidence, forKey: .assessmentControlsCountByNoncompliantEvidence)
        }
        if let compliantEvidenceCount = self.compliantEvidenceCount {
            try encodeContainer.encode(compliantEvidenceCount, forKey: .compliantEvidenceCount)
        }
        if let inconclusiveEvidenceCount = self.inconclusiveEvidenceCount {
            try encodeContainer.encode(inconclusiveEvidenceCount, forKey: .inconclusiveEvidenceCount)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let noncompliantEvidenceCount = self.noncompliantEvidenceCount {
            try encodeContainer.encode(noncompliantEvidenceCount, forKey: .noncompliantEvidenceCount)
        }
        if let totalAssessmentControlsCount = self.totalAssessmentControlsCount {
            try encodeContainer.encode(totalAssessmentControlsCount, forKey: .totalAssessmentControlsCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noncompliantEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noncompliantEvidenceCount)
        noncompliantEvidenceCount = noncompliantEvidenceCountDecoded
        let compliantEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantEvidenceCount)
        compliantEvidenceCount = compliantEvidenceCountDecoded
        let inconclusiveEvidenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inconclusiveEvidenceCount)
        inconclusiveEvidenceCount = inconclusiveEvidenceCountDecoded
        let assessmentControlsCountByNoncompliantEvidenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assessmentControlsCountByNoncompliantEvidence)
        assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidenceDecoded
        let totalAssessmentControlsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAssessmentControlsCount)
        totalAssessmentControlsCount = totalAssessmentControlsCountDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AuditManagerClientTypes {
    /// A summary of the latest analytics data for a specific active assessment. This summary is a snapshot of the data that was collected on the lastUpdated date. Its important to understand that the totals in InsightsByAssessment are daily counts based on this date  they arent a total sum to date. The InsightsByAssessment data is eventually consistent. This means that when you read data from InsightsByAssessment, the response might not instantly reflect the results of a recently completed write or update operation. If you repeat your read request after a few hours, the response returns the latest data. If you delete an assessment or change its status to inactive, InsightsByAssessment includes data for that assessment as follows.
    ///
    /// * Inactive assessments - If Audit Manager collected evidence for your assessment before you changed it inactive, that evidence is included in the InsightsByAssessment counts for that day.
    ///
    /// * Deleted assessments - If Audit Manager collected evidence for your assessment before you deleted it, that evidence isn't included in the InsightsByAssessment counts for that day.
    public struct InsightsByAssessment: Swift.Equatable {
        /// The number of assessment controls that collected non-compliant evidence on the lastUpdated date.
        public var assessmentControlsCountByNoncompliantEvidence: Swift.Int?
        /// The number of compliance check evidence that Audit Manager classified as compliant. This includes evidence that was collected from Security Hub with a Pass ruling, or collected from Config with a Compliant ruling.
        public var compliantEvidenceCount: Swift.Int?
        /// The amount of evidence without a compliance check ruling. Evidence is inconclusive if the associated control uses Security Hub or Config as a data source and you didn't enable those services. This is also the case if a control uses a data source that doesnt support compliance checks (for example, manual evidence, API calls, or CloudTrail). If evidence has a compliance check status of not applicable, it's classified as inconclusive in InsightsByAssessment data.
        public var inconclusiveEvidenceCount: Swift.Int?
        /// The time when the assessment insights were last updated.
        public var lastUpdated: ClientRuntime.Date?
        /// The number of compliance check evidence that Audit Manager classified as non-compliant. This includes evidence that was collected from Security Hub with a Fail ruling, or collected from Config with a Non-compliant ruling.
        public var noncompliantEvidenceCount: Swift.Int?
        /// The total number of controls in the assessment.
        public var totalAssessmentControlsCount: Swift.Int?

        public init (
            assessmentControlsCountByNoncompliantEvidence: Swift.Int? = nil,
            compliantEvidenceCount: Swift.Int? = nil,
            inconclusiveEvidenceCount: Swift.Int? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            noncompliantEvidenceCount: Swift.Int? = nil,
            totalAssessmentControlsCount: Swift.Int? = nil
        )
        {
            self.assessmentControlsCountByNoncompliantEvidence = assessmentControlsCountByNoncompliantEvidence
            self.compliantEvidenceCount = compliantEvidenceCount
            self.inconclusiveEvidenceCount = inconclusiveEvidenceCount
            self.lastUpdated = lastUpdated
            self.noncompliantEvidenceCount = noncompliantEvidenceCount
            self.totalAssessmentControlsCount = totalAssessmentControlsCount
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal service error occurred during the processing of your request. Try again later.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuditManagerClientTypes {
    public enum KeywordInputType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case selectFromList
        case sdkUnknown(Swift.String)

        public static var allCases: [KeywordInputType] {
            return [
                .selectFromList,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .selectFromList: return "SELECT_FROM_LIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KeywordInputType(rawValue: rawValue) ?? KeywordInputType.sdkUnknown(rawValue)
        }
    }
}

extension ListAssessmentControlInsightsByControlDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let controlDomainId = controlDomainId else {
                let message = "Creating a URL Query Item failed. controlDomainId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let controlDomainIdQueryItem = ClientRuntime.URLQueryItem(name: "controlDomainId".urlPercentEncoding(), value: Swift.String(controlDomainId).urlPercentEncoding())
            items.append(controlDomainIdQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let assessmentId = assessmentId else {
                let message = "Creating a URL Query Item failed. assessmentId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let assessmentIdQueryItem = ClientRuntime.URLQueryItem(name: "assessmentId".urlPercentEncoding(), value: Swift.String(assessmentId).urlPercentEncoding())
            items.append(assessmentIdQueryItem)
            return items
        }
    }
}

extension ListAssessmentControlInsightsByControlDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights/controls-by-assessment"
    }
}

public struct ListAssessmentControlInsightsByControlDomainInput: Swift.Equatable {
    /// The unique identifier for the active assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The unique identifier for the control domain.
    /// This member is required.
    public var controlDomainId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        controlDomainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlDomainId = controlDomainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentControlInsightsByControlDomainInputBody: Swift.Equatable {
}

extension ListAssessmentControlInsightsByControlDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssessmentControlInsightsByControlDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentControlInsightsByControlDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssessmentControlInsightsByControlDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentControlInsightsByControlDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssessmentControlInsightsByControlDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.controlInsightsByAssessment = output.controlInsightsByAssessment
            self.nextToken = output.nextToken
        } else {
            self.controlInsightsByAssessment = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentControlInsightsByControlDomainOutputResponse: Swift.Equatable {
    /// The assessment control analytics data that the ListAssessmentControlInsightsByControlDomain API returned.
    public var controlInsightsByAssessment: [AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        controlInsightsByAssessment: [AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlInsightsByAssessment = controlInsightsByAssessment
        self.nextToken = nextToken
    }
}

struct ListAssessmentControlInsightsByControlDomainOutputResponseBody: Swift.Equatable {
    let controlInsightsByAssessment: [AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem]?
    let nextToken: Swift.String?
}

extension ListAssessmentControlInsightsByControlDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlInsightsByAssessment
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlInsightsByAssessmentContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem?].self, forKey: .controlInsightsByAssessment)
        var controlInsightsByAssessmentDecoded0:[AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem]? = nil
        if let controlInsightsByAssessmentContainer = controlInsightsByAssessmentContainer {
            controlInsightsByAssessmentDecoded0 = [AuditManagerClientTypes.ControlInsightsMetadataByAssessmentItem]()
            for structure0 in controlInsightsByAssessmentContainer {
                if let structure0 = structure0 {
                    controlInsightsByAssessmentDecoded0?.append(structure0)
                }
            }
        }
        controlInsightsByAssessment = controlInsightsByAssessmentDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssessmentFrameworkShareRequestsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let requestType = requestType else {
                let message = "Creating a URL Query Item failed. requestType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let requestTypeQueryItem = ClientRuntime.URLQueryItem(name: "requestType".urlPercentEncoding(), value: Swift.String(requestType.rawValue).urlPercentEncoding())
            items.append(requestTypeQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssessmentFrameworkShareRequestsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessmentFrameworkShareRequests"
    }
}

public struct ListAssessmentFrameworkShareRequestsInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// Specifies whether the share request is a sent request or a received request.
    /// This member is required.
    public var requestType: AuditManagerClientTypes.ShareRequestType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        requestType: AuditManagerClientTypes.ShareRequestType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.requestType = requestType
    }
}

struct ListAssessmentFrameworkShareRequestsInputBody: Swift.Equatable {
}

extension ListAssessmentFrameworkShareRequestsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssessmentFrameworkShareRequestsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentFrameworkShareRequestsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssessmentFrameworkShareRequestsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentFrameworkShareRequestsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssessmentFrameworkShareRequestsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentFrameworkShareRequests = output.assessmentFrameworkShareRequests
            self.nextToken = output.nextToken
        } else {
            self.assessmentFrameworkShareRequests = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentFrameworkShareRequestsOutputResponse: Swift.Equatable {
    /// The list of share requests that the ListAssessmentFrameworkShareRequests API returned.
    public var assessmentFrameworkShareRequests: [AuditManagerClientTypes.AssessmentFrameworkShareRequest]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentFrameworkShareRequests: [AuditManagerClientTypes.AssessmentFrameworkShareRequest]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentFrameworkShareRequests = assessmentFrameworkShareRequests
        self.nextToken = nextToken
    }
}

struct ListAssessmentFrameworkShareRequestsOutputResponseBody: Swift.Equatable {
    let assessmentFrameworkShareRequests: [AuditManagerClientTypes.AssessmentFrameworkShareRequest]?
    let nextToken: Swift.String?
}

extension ListAssessmentFrameworkShareRequestsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentFrameworkShareRequests
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentFrameworkShareRequestsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentFrameworkShareRequest?].self, forKey: .assessmentFrameworkShareRequests)
        var assessmentFrameworkShareRequestsDecoded0:[AuditManagerClientTypes.AssessmentFrameworkShareRequest]? = nil
        if let assessmentFrameworkShareRequestsContainer = assessmentFrameworkShareRequestsContainer {
            assessmentFrameworkShareRequestsDecoded0 = [AuditManagerClientTypes.AssessmentFrameworkShareRequest]()
            for structure0 in assessmentFrameworkShareRequestsContainer {
                if let structure0 = structure0 {
                    assessmentFrameworkShareRequestsDecoded0?.append(structure0)
                }
            }
        }
        assessmentFrameworkShareRequests = assessmentFrameworkShareRequestsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssessmentFrameworksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let frameworkType = frameworkType else {
                let message = "Creating a URL Query Item failed. frameworkType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let frameworkTypeQueryItem = ClientRuntime.URLQueryItem(name: "frameworkType".urlPercentEncoding(), value: Swift.String(frameworkType.rawValue).urlPercentEncoding())
            items.append(frameworkTypeQueryItem)
            return items
        }
    }
}

extension ListAssessmentFrameworksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessmentFrameworks"
    }
}

public struct ListAssessmentFrameworksInput: Swift.Equatable {
    /// The type of framework, such as a standard framework or a custom framework.
    /// This member is required.
    public var frameworkType: AuditManagerClientTypes.FrameworkType?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        frameworkType: AuditManagerClientTypes.FrameworkType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.frameworkType = frameworkType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentFrameworksInputBody: Swift.Equatable {
}

extension ListAssessmentFrameworksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssessmentFrameworksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentFrameworksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssessmentFrameworksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentFrameworksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssessmentFrameworksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.frameworkMetadataList = output.frameworkMetadataList
            self.nextToken = output.nextToken
        } else {
            self.frameworkMetadataList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentFrameworksOutputResponse: Swift.Equatable {
    /// The list of metadata objects for the framework.
    public var frameworkMetadataList: [AuditManagerClientTypes.AssessmentFrameworkMetadata]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        frameworkMetadataList: [AuditManagerClientTypes.AssessmentFrameworkMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.frameworkMetadataList = frameworkMetadataList
        self.nextToken = nextToken
    }
}

struct ListAssessmentFrameworksOutputResponseBody: Swift.Equatable {
    let frameworkMetadataList: [AuditManagerClientTypes.AssessmentFrameworkMetadata]?
    let nextToken: Swift.String?
}

extension ListAssessmentFrameworksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkMetadataList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkMetadataListContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentFrameworkMetadata?].self, forKey: .frameworkMetadataList)
        var frameworkMetadataListDecoded0:[AuditManagerClientTypes.AssessmentFrameworkMetadata]? = nil
        if let frameworkMetadataListContainer = frameworkMetadataListContainer {
            frameworkMetadataListDecoded0 = [AuditManagerClientTypes.AssessmentFrameworkMetadata]()
            for structure0 in frameworkMetadataListContainer {
                if let structure0 = structure0 {
                    frameworkMetadataListDecoded0?.append(structure0)
                }
            }
        }
        frameworkMetadataList = frameworkMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssessmentReportsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssessmentReportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessmentReports"
    }
}

public struct ListAssessmentReportsInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentReportsInputBody: Swift.Equatable {
}

extension ListAssessmentReportsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssessmentReportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentReportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssessmentReportsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentReportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssessmentReportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentReports = output.assessmentReports
            self.nextToken = output.nextToken
        } else {
            self.assessmentReports = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentReportsOutputResponse: Swift.Equatable {
    /// The list of assessment reports that the ListAssessmentReports API returned.
    public var assessmentReports: [AuditManagerClientTypes.AssessmentReportMetadata]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentReports: [AuditManagerClientTypes.AssessmentReportMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentReports = assessmentReports
        self.nextToken = nextToken
    }
}

struct ListAssessmentReportsOutputResponseBody: Swift.Equatable {
    let assessmentReports: [AuditManagerClientTypes.AssessmentReportMetadata]?
    let nextToken: Swift.String?
}

extension ListAssessmentReportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReports
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentReportsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentReportMetadata?].self, forKey: .assessmentReports)
        var assessmentReportsDecoded0:[AuditManagerClientTypes.AssessmentReportMetadata]? = nil
        if let assessmentReportsContainer = assessmentReportsContainer {
            assessmentReportsDecoded0 = [AuditManagerClientTypes.AssessmentReportMetadata]()
            for structure0 in assessmentReportsContainer {
                if let structure0 = structure0 {
                    assessmentReportsDecoded0?.append(structure0)
                }
            }
        }
        assessmentReports = assessmentReportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssessmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListAssessmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessments"
    }
}

public struct ListAssessmentsInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The current status of the assessment.
    public var status: AuditManagerClientTypes.AssessmentStatus?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: AuditManagerClientTypes.AssessmentStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListAssessmentsInputBody: Swift.Equatable {
}

extension ListAssessmentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssessmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssessmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssessmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentMetadata = output.assessmentMetadata
            self.nextToken = output.nextToken
        } else {
            self.assessmentMetadata = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentsOutputResponse: Swift.Equatable {
    /// The metadata that's associated with the assessment.
    public var assessmentMetadata: [AuditManagerClientTypes.AssessmentMetadataItem]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentMetadata: [AuditManagerClientTypes.AssessmentMetadataItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentMetadata = assessmentMetadata
        self.nextToken = nextToken
    }
}

struct ListAssessmentsOutputResponseBody: Swift.Equatable {
    let assessmentMetadata: [AuditManagerClientTypes.AssessmentMetadataItem]?
    let nextToken: Swift.String?
}

extension ListAssessmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentMetadata
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentMetadataContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AssessmentMetadataItem?].self, forKey: .assessmentMetadata)
        var assessmentMetadataDecoded0:[AuditManagerClientTypes.AssessmentMetadataItem]? = nil
        if let assessmentMetadataContainer = assessmentMetadataContainer {
            assessmentMetadataDecoded0 = [AuditManagerClientTypes.AssessmentMetadataItem]()
            for structure0 in assessmentMetadataContainer {
                if let structure0 = structure0 {
                    assessmentMetadataDecoded0?.append(structure0)
                }
            }
        }
        assessmentMetadata = assessmentMetadataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListControlDomainInsightsByAssessmentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let assessmentId = assessmentId else {
                let message = "Creating a URL Query Item failed. assessmentId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let assessmentIdQueryItem = ClientRuntime.URLQueryItem(name: "assessmentId".urlPercentEncoding(), value: Swift.String(assessmentId).urlPercentEncoding())
            items.append(assessmentIdQueryItem)
            return items
        }
    }
}

extension ListControlDomainInsightsByAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights/control-domains-by-assessment"
    }
}

public struct ListControlDomainInsightsByAssessmentInput: Swift.Equatable {
    /// The unique identifier for the active assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        assessmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListControlDomainInsightsByAssessmentInputBody: Swift.Equatable {
}

extension ListControlDomainInsightsByAssessmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListControlDomainInsightsByAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListControlDomainInsightsByAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListControlDomainInsightsByAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListControlDomainInsightsByAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListControlDomainInsightsByAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.controlDomainInsights = output.controlDomainInsights
            self.nextToken = output.nextToken
        } else {
            self.controlDomainInsights = nil
            self.nextToken = nil
        }
    }
}

public struct ListControlDomainInsightsByAssessmentOutputResponse: Swift.Equatable {
    /// The control domain analytics data that the ListControlDomainInsightsByAssessment API returned.
    public var controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlDomainInsights = controlDomainInsights
        self.nextToken = nextToken
    }
}

struct ListControlDomainInsightsByAssessmentOutputResponseBody: Swift.Equatable {
    let controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]?
    let nextToken: Swift.String?
}

extension ListControlDomainInsightsByAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlDomainInsights
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDomainInsightsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlDomainInsights?].self, forKey: .controlDomainInsights)
        var controlDomainInsightsDecoded0:[AuditManagerClientTypes.ControlDomainInsights]? = nil
        if let controlDomainInsightsContainer = controlDomainInsightsContainer {
            controlDomainInsightsDecoded0 = [AuditManagerClientTypes.ControlDomainInsights]()
            for structure0 in controlDomainInsightsContainer {
                if let structure0 = structure0 {
                    controlDomainInsightsDecoded0?.append(structure0)
                }
            }
        }
        controlDomainInsights = controlDomainInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListControlDomainInsightsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListControlDomainInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights/control-domains"
    }
}

public struct ListControlDomainInsightsInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListControlDomainInsightsInputBody: Swift.Equatable {
}

extension ListControlDomainInsightsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListControlDomainInsightsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListControlDomainInsightsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListControlDomainInsightsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListControlDomainInsightsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListControlDomainInsightsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.controlDomainInsights = output.controlDomainInsights
            self.nextToken = output.nextToken
        } else {
            self.controlDomainInsights = nil
            self.nextToken = nil
        }
    }
}

public struct ListControlDomainInsightsOutputResponse: Swift.Equatable {
    /// The control domain analytics data that the ListControlDomainInsights API returned.
    public var controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlDomainInsights = controlDomainInsights
        self.nextToken = nextToken
    }
}

struct ListControlDomainInsightsOutputResponseBody: Swift.Equatable {
    let controlDomainInsights: [AuditManagerClientTypes.ControlDomainInsights]?
    let nextToken: Swift.String?
}

extension ListControlDomainInsightsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlDomainInsights
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDomainInsightsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlDomainInsights?].self, forKey: .controlDomainInsights)
        var controlDomainInsightsDecoded0:[AuditManagerClientTypes.ControlDomainInsights]? = nil
        if let controlDomainInsightsContainer = controlDomainInsightsContainer {
            controlDomainInsightsDecoded0 = [AuditManagerClientTypes.ControlDomainInsights]()
            for structure0 in controlDomainInsightsContainer {
                if let structure0 = structure0 {
                    controlDomainInsightsDecoded0?.append(structure0)
                }
            }
        }
        controlDomainInsights = controlDomainInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListControlInsightsByControlDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let controlDomainId = controlDomainId else {
                let message = "Creating a URL Query Item failed. controlDomainId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let controlDomainIdQueryItem = ClientRuntime.URLQueryItem(name: "controlDomainId".urlPercentEncoding(), value: Swift.String(controlDomainId).urlPercentEncoding())
            items.append(controlDomainIdQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListControlInsightsByControlDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights/controls"
    }
}

public struct ListControlInsightsByControlDomainInput: Swift.Equatable {
    /// The unique identifier for the control domain.
    /// This member is required.
    public var controlDomainId: Swift.String?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        controlDomainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlDomainId = controlDomainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListControlInsightsByControlDomainInputBody: Swift.Equatable {
}

extension ListControlInsightsByControlDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListControlInsightsByControlDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListControlInsightsByControlDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListControlInsightsByControlDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListControlInsightsByControlDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListControlInsightsByControlDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.controlInsightsMetadata = output.controlInsightsMetadata
            self.nextToken = output.nextToken
        } else {
            self.controlInsightsMetadata = nil
            self.nextToken = nil
        }
    }
}

public struct ListControlInsightsByControlDomainOutputResponse: Swift.Equatable {
    /// The control analytics data that the ListControlInsightsByControlDomain API returned.
    public var controlInsightsMetadata: [AuditManagerClientTypes.ControlInsightsMetadataItem]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        controlInsightsMetadata: [AuditManagerClientTypes.ControlInsightsMetadataItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlInsightsMetadata = controlInsightsMetadata
        self.nextToken = nextToken
    }
}

struct ListControlInsightsByControlDomainOutputResponseBody: Swift.Equatable {
    let controlInsightsMetadata: [AuditManagerClientTypes.ControlInsightsMetadataItem]?
    let nextToken: Swift.String?
}

extension ListControlInsightsByControlDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlInsightsMetadata
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlInsightsMetadataContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlInsightsMetadataItem?].self, forKey: .controlInsightsMetadata)
        var controlInsightsMetadataDecoded0:[AuditManagerClientTypes.ControlInsightsMetadataItem]? = nil
        if let controlInsightsMetadataContainer = controlInsightsMetadataContainer {
            controlInsightsMetadataDecoded0 = [AuditManagerClientTypes.ControlInsightsMetadataItem]()
            for structure0 in controlInsightsMetadataContainer {
                if let structure0 = structure0 {
                    controlInsightsMetadataDecoded0?.append(structure0)
                }
            }
        }
        controlInsightsMetadata = controlInsightsMetadataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListControlsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let controlType = controlType else {
                let message = "Creating a URL Query Item failed. controlType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let controlTypeQueryItem = ClientRuntime.URLQueryItem(name: "controlType".urlPercentEncoding(), value: Swift.String(controlType.rawValue).urlPercentEncoding())
            items.append(controlTypeQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListControlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/controls"
    }
}

public struct ListControlsInput: Swift.Equatable {
    /// The type of control, such as a standard control or a custom control.
    /// This member is required.
    public var controlType: AuditManagerClientTypes.ControlType?
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        controlType: AuditManagerClientTypes.ControlType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlType = controlType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListControlsInputBody: Swift.Equatable {
}

extension ListControlsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListControlsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListControlsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListControlsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListControlsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListControlsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.controlMetadataList = output.controlMetadataList
            self.nextToken = output.nextToken
        } else {
            self.controlMetadataList = nil
            self.nextToken = nil
        }
    }
}

public struct ListControlsOutputResponse: Swift.Equatable {
    /// The list of control metadata objects that the ListControls API returned.
    public var controlMetadataList: [AuditManagerClientTypes.ControlMetadata]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        controlMetadataList: [AuditManagerClientTypes.ControlMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlMetadataList = controlMetadataList
        self.nextToken = nextToken
    }
}

struct ListControlsOutputResponseBody: Swift.Equatable {
    let controlMetadataList: [AuditManagerClientTypes.ControlMetadata]?
    let nextToken: Swift.String?
}

extension ListControlsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlMetadataList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlMetadataListContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlMetadata?].self, forKey: .controlMetadataList)
        var controlMetadataListDecoded0:[AuditManagerClientTypes.ControlMetadata]? = nil
        if let controlMetadataListContainer = controlMetadataListContainer {
            controlMetadataListDecoded0 = [AuditManagerClientTypes.ControlMetadata]()
            for structure0 in controlMetadataListContainer {
                if let structure0 = structure0 {
                    controlMetadataListDecoded0?.append(structure0)
                }
            }
        }
        controlMetadataList = controlMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListKeywordsForDataSourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let source = source else {
                let message = "Creating a URL Query Item failed. source is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let sourceQueryItem = ClientRuntime.URLQueryItem(name: "source".urlPercentEncoding(), value: Swift.String(source.rawValue).urlPercentEncoding())
            items.append(sourceQueryItem)
            return items
        }
    }
}

extension ListKeywordsForDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dataSourceKeywords"
    }
}

public struct ListKeywordsForDataSourceInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The control mapping data source that the keywords apply to.
    /// This member is required.
    public var source: AuditManagerClientTypes.SourceType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        source: AuditManagerClientTypes.SourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.source = source
    }
}

struct ListKeywordsForDataSourceInputBody: Swift.Equatable {
}

extension ListKeywordsForDataSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListKeywordsForDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListKeywordsForDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListKeywordsForDataSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKeywordsForDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListKeywordsForDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.keywords = output.keywords
            self.nextToken = output.nextToken
        } else {
            self.keywords = nil
            self.nextToken = nil
        }
    }
}

public struct ListKeywordsForDataSourceOutputResponse: Swift.Equatable {
    /// The list of keywords for the event mapping source.
    public var keywords: [Swift.String]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        keywords: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keywords = keywords
        self.nextToken = nextToken
    }
}

struct ListKeywordsForDataSourceOutputResponseBody: Swift.Equatable {
    let keywords: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListKeywordsForDataSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keywords
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keywordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keywords)
        var keywordsDecoded0:[Swift.String]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [Swift.String]()
            for string0 in keywordsContainer {
                if let string0 = string0 {
                    keywordsDecoded0?.append(string0)
                }
            }
        }
        keywords = keywordsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNotificationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListNotificationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/notifications"
    }
}

public struct ListNotificationsInput: Swift.Equatable {
    /// Represents the maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNotificationsInputBody: Swift.Equatable {
}

extension ListNotificationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNotificationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNotificationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notifications = output.notifications
        } else {
            self.nextToken = nil
            self.notifications = nil
        }
    }
}

public struct ListNotificationsOutputResponse: Swift.Equatable {
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The returned list of notifications.
    public var notifications: [AuditManagerClientTypes.Notification]?

    public init (
        nextToken: Swift.String? = nil,
        notifications: [AuditManagerClientTypes.Notification]? = nil
    )
    {
        self.nextToken = nextToken
        self.notifications = notifications
    }
}

struct ListNotificationsOutputResponseBody: Swift.Equatable {
    let notifications: [AuditManagerClientTypes.Notification]?
    let nextToken: Swift.String?
}

extension ListNotificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case notifications
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Notification?].self, forKey: .notifications)
        var notificationsDecoded0:[AuditManagerClientTypes.Notification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [AuditManagerClientTypes.Notification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags that the ListTagsForResource API returned.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AuditManagerClientTypes.ManualEvidence: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3ResourcePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ResourcePath = self.s3ResourcePath {
            try encodeContainer.encode(s3ResourcePath, forKey: .s3ResourcePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ResourcePath)
        s3ResourcePath = s3ResourcePathDecoded
    }
}

extension AuditManagerClientTypes {
    /// Evidence that's uploaded to Audit Manager manually.
    public struct ManualEvidence: Swift.Equatable {
        /// The Amazon S3 URL that points to a manual evidence object.
        public var s3ResourcePath: Swift.String?

        public init (
            s3ResourcePath: Swift.String? = nil
        )
        {
            self.s3ResourcePath = s3ResourcePath
        }
    }

}

extension AuditManagerClientTypes.Notification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
        case assessmentName
        case controlSetId
        case controlSetName
        case description
        case eventTime
        case id
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let controlSetId = self.controlSetId {
            try encodeContainer.encode(controlSetId, forKey: .controlSetId)
        }
        if let controlSetName = self.controlSetName {
            try encodeContainer.encode(controlSetName, forKey: .controlSetName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let controlSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetId)
        controlSetId = controlSetIdDecoded
        let controlSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlSetName)
        controlSetName = controlSetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension AuditManagerClientTypes {
    /// The notification that informs a user of an update in Audit Manager. For example, this includes the notification that's sent when a control set is delegated for review.
    public struct Notification: Swift.Equatable {
        /// The identifier for the assessment.
        public var assessmentId: Swift.String?
        /// The name of the related assessment.
        public var assessmentName: Swift.String?
        /// The identifier for the control set.
        public var controlSetId: Swift.String?
        /// Specifies the name of the control set that the notification is about.
        public var controlSetName: Swift.String?
        /// The description of the notification.
        public var description: Swift.String?
        /// The time when the notification was sent.
        public var eventTime: ClientRuntime.Date?
        /// The unique identifier for the notification.
        public var id: Swift.String?
        /// The sender of the notification.
        public var source: Swift.String?

        public init (
            assessmentId: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            controlSetId: Swift.String? = nil,
            controlSetName: Swift.String? = nil,
            description: Swift.String? = nil,
            eventTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.assessmentId = assessmentId
            self.assessmentName = assessmentName
            self.controlSetId = controlSetId
            self.controlSetName = controlSetName
            self.description = description
            self.eventTime = eventTime
            self.id = id
            self.source = source
        }
    }

}

extension AuditManagerClientTypes {
    public enum ObjectTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assessment
        case assessmentReport
        case control
        case controlSet
        case delegation
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectTypeEnum] {
            return [
                .assessment,
                .assessmentReport,
                .control,
                .controlSet,
                .delegation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assessment: return "ASSESSMENT"
            case .assessmentReport: return "ASSESSMENT_REPORT"
            case .control: return "CONTROL"
            case .controlSet: return "CONTROL_SET"
            case .delegation: return "DELEGATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectTypeEnum(rawValue: rawValue) ?? ObjectTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension RegisterAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccount
        case kmsKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegatedAdminAccount = self.delegatedAdminAccount {
            try encodeContainer.encode(delegatedAdminAccount, forKey: .delegatedAdminAccount)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }
}

extension RegisterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account/registerAccount"
    }
}

public struct RegisterAccountInput: Swift.Equatable {
    /// The delegated administrator account for Audit Manager.
    public var delegatedAdminAccount: Swift.String?
    /// The KMS key details.
    public var kmsKey: Swift.String?

    public init (
        delegatedAdminAccount: Swift.String? = nil,
        kmsKey: Swift.String? = nil
    )
    {
        self.delegatedAdminAccount = delegatedAdminAccount
        self.kmsKey = kmsKey
    }
}

struct RegisterAccountInputBody: Swift.Equatable {
    let kmsKey: Swift.String?
    let delegatedAdminAccount: Swift.String?
}

extension RegisterAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccount
        case kmsKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let delegatedAdminAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccount)
        delegatedAdminAccount = delegatedAdminAccountDecoded
    }
}

extension RegisterAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegisterAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct RegisterAccountOutputResponse: Swift.Equatable {
    /// The status of the account registration request.
    public var status: AuditManagerClientTypes.AccountStatus?

    public init (
        status: AuditManagerClientTypes.AccountStatus? = nil
    )
    {
        self.status = status
    }
}

struct RegisterAccountOutputResponseBody: Swift.Equatable {
    let status: AuditManagerClientTypes.AccountStatus?
}

extension RegisterAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AccountStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension RegisterOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

extension RegisterOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account/registerOrganizationAdminAccount"
    }
}

public struct RegisterOrganizationAdminAccountInput: Swift.Equatable {
    /// The identifier for the delegated administrator account.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init (
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct RegisterOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
}

extension RegisterOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension RegisterOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterOrganizationAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterOrganizationAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterOrganizationAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegisterOrganizationAdminAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adminAccountId = output.adminAccountId
            self.organizationId = output.organizationId
        } else {
            self.adminAccountId = nil
            self.organizationId = nil
        }
    }
}

public struct RegisterOrganizationAdminAccountOutputResponse: Swift.Equatable {
    /// The identifier for the delegated administrator account.
    public var adminAccountId: Swift.String?
    /// The identifier for the organization.
    public var organizationId: Swift.String?

    public init (
        adminAccountId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.organizationId = organizationId
    }
}

struct RegisterOrganizationAdminAccountOutputResponseBody: Swift.Equatable {
    let adminAccountId: Swift.String?
    let organizationId: Swift.String?
}

extension RegisterOrganizationAdminAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId
        case organizationId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension AuditManagerClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case complianceCheck
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let complianceCheck = self.complianceCheck {
            try encodeContainer.encode(complianceCheck, forKey: .complianceCheck)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let complianceCheckDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceCheck)
        complianceCheck = complianceCheckDecoded
    }
}

extension AuditManagerClientTypes {
    /// A system asset that's evaluated in an Audit Manager assessment.
    public struct Resource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the resource.
        public var arn: Swift.String?
        /// The evaluation status for a resource that was assessed when collecting compliance check evidence.
        ///
        /// * Audit Manager classes the resource as non-compliant if Security Hub reports a Fail result, or if Config reports a Non-compliant result.
        ///
        /// * Audit Manager classes the resource as compliant if Security Hub reports a Pass result, or if Config reports a Compliant result.
        ///
        /// * If a compliance check isn't available or applicable, then no compliance evaluation can be made for that resource. This is the case if a resource assessment uses Config or Security Hub as the underlying data source type, but those services aren't enabled. This is also the case if the resource assessment uses an underlying data source type that doesn't support compliance checks (such as manual evidence, Amazon Web Services API calls, or CloudTrail).
        public var complianceCheck: Swift.String?
        /// The value of the resource.
        public var value: Swift.String?

        public init (
            arn: Swift.String? = nil,
            complianceCheck: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.arn = arn
            self.complianceCheck = complianceCheck
            self.value = value
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource that's specified in the request can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of resource that's affected by the error.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AuditManagerClientTypes.Role: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case roleType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let roleType = self.roleType {
            try encodeContainer.encode(roleType.rawValue, forKey: .roleType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.RoleType.self, forKey: .roleType)
        roleType = roleTypeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AuditManagerClientTypes {
    /// The wrapper that contains the Audit Manager role information of the current user. This includes the role type and IAM Amazon Resource Name (ARN).
    public struct Role: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the IAM role.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The type of customer persona. In CreateAssessment, roleType can only be PROCESS_OWNER. In UpdateSettings, roleType can only be PROCESS_OWNER. In BatchCreateDelegationByAssessment, roleType can only be RESOURCE_OWNER.
        /// This member is required.
        public var roleType: AuditManagerClientTypes.RoleType?

        public init (
            roleArn: Swift.String? = nil,
            roleType: AuditManagerClientTypes.RoleType? = nil
        )
        {
            self.roleArn = roleArn
            self.roleType = roleType
        }
    }

}

extension AuditManagerClientTypes {
    public enum RoleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case processOwner
        case resourceOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [RoleType] {
            return [
                .processOwner,
                .resourceOwner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .processOwner: return "PROCESS_OWNER"
            case .resourceOwner: return "RESOURCE_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoleType(rawValue: rawValue) ?? RoleType.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.Scope: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccounts
        case awsServices
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccounts = awsAccounts {
            var awsAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccounts)
            for awsaccount0 in awsAccounts {
                try awsAccountsContainer.encode(awsaccount0)
            }
        }
        if let awsServices = awsServices {
            var awsServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsServices)
            for awsservice0 in awsServices {
                try awsServicesContainer.encode(awsservice0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AWSAccount?].self, forKey: .awsAccounts)
        var awsAccountsDecoded0:[AuditManagerClientTypes.AWSAccount]? = nil
        if let awsAccountsContainer = awsAccountsContainer {
            awsAccountsDecoded0 = [AuditManagerClientTypes.AWSAccount]()
            for structure0 in awsAccountsContainer {
                if let structure0 = structure0 {
                    awsAccountsDecoded0?.append(structure0)
                }
            }
        }
        awsAccounts = awsAccountsDecoded0
        let awsServicesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.AWSService?].self, forKey: .awsServices)
        var awsServicesDecoded0:[AuditManagerClientTypes.AWSService]? = nil
        if let awsServicesContainer = awsServicesContainer {
            awsServicesDecoded0 = [AuditManagerClientTypes.AWSService]()
            for structure0 in awsServicesContainer {
                if let structure0 = structure0 {
                    awsServicesDecoded0?.append(structure0)
                }
            }
        }
        awsServices = awsServicesDecoded0
    }
}

extension AuditManagerClientTypes {
    /// The wrapper that contains the Amazon Web Services accounts and services that are in scope for the assessment.
    public struct Scope: Swift.Equatable {
        /// The Amazon Web Services accounts that are included in the scope of the assessment.
        public var awsAccounts: [AuditManagerClientTypes.AWSAccount]?
        /// The Amazon Web Services services that are included in the scope of the assessment.
        public var awsServices: [AuditManagerClientTypes.AWSService]?

        public init (
            awsAccounts: [AuditManagerClientTypes.AWSAccount]? = nil,
            awsServices: [AuditManagerClientTypes.AWSService]? = nil
        )
        {
            self.awsAccounts = awsAccounts
            self.awsServices = awsServices
        }
    }

}

extension AuditManagerClientTypes.ServiceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case description
        case displayName
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
    }
}

extension AuditManagerClientTypes {
    /// The metadata that's associated with the Amazon Web Service.
    public struct ServiceMetadata: Swift.Equatable {
        /// The category that the Amazon Web Service belongs to, such as compute, storage, or database.
        public var category: Swift.String?
        /// The description of the Amazon Web Service.
        public var description: Swift.String?
        /// The display name of the Amazon Web Service.
        public var displayName: Swift.String?
        /// The name of the Amazon Web Service.
        public var name: Swift.String?

        public init (
            category: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.category = category
            self.description = description
            self.displayName = displayName
            self.name = name
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've reached your account quota for this resource type. To perform the requested action, delete some existing resources or [request a quota increase](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) from the Service Quotas console. For a list of Audit Manager service quotas, see [Quotas and restrictions for Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/service-quotas.html).
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuditManagerClientTypes {
    public enum SettingAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case defaultAssessmentReportsDestination
        case defaultProcessOwners
        case evidenceFinderEnablement
        case isAwsOrgEnabled
        case snsTopic
        case sdkUnknown(Swift.String)

        public static var allCases: [SettingAttribute] {
            return [
                .all,
                .defaultAssessmentReportsDestination,
                .defaultProcessOwners,
                .evidenceFinderEnablement,
                .isAwsOrgEnabled,
                .snsTopic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .defaultAssessmentReportsDestination: return "DEFAULT_ASSESSMENT_REPORTS_DESTINATION"
            case .defaultProcessOwners: return "DEFAULT_PROCESS_OWNERS"
            case .evidenceFinderEnablement: return "EVIDENCE_FINDER_ENABLEMENT"
            case .isAwsOrgEnabled: return "IS_AWS_ORG_ENABLED"
            case .snsTopic: return "SNS_TOPIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SettingAttribute(rawValue: rawValue) ?? SettingAttribute.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAssessmentReportsDestination
        case defaultProcessOwners
        case evidenceFinderEnablement
        case isAwsOrgEnabled
        case kmsKey
        case snsTopic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAssessmentReportsDestination = self.defaultAssessmentReportsDestination {
            try encodeContainer.encode(defaultAssessmentReportsDestination, forKey: .defaultAssessmentReportsDestination)
        }
        if let defaultProcessOwners = defaultProcessOwners {
            var defaultProcessOwnersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultProcessOwners)
            for role0 in defaultProcessOwners {
                try defaultProcessOwnersContainer.encode(role0)
            }
        }
        if let evidenceFinderEnablement = self.evidenceFinderEnablement {
            try encodeContainer.encode(evidenceFinderEnablement, forKey: .evidenceFinderEnablement)
        }
        if let isAwsOrgEnabled = self.isAwsOrgEnabled {
            try encodeContainer.encode(isAwsOrgEnabled, forKey: .isAwsOrgEnabled)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let snsTopic = self.snsTopic {
            try encodeContainer.encode(snsTopic, forKey: .snsTopic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isAwsOrgEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAwsOrgEnabled)
        isAwsOrgEnabled = isAwsOrgEnabledDecoded
        let snsTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopic)
        snsTopic = snsTopicDecoded
        let defaultAssessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportsDestination.self, forKey: .defaultAssessmentReportsDestination)
        defaultAssessmentReportsDestination = defaultAssessmentReportsDestinationDecoded
        let defaultProcessOwnersContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .defaultProcessOwners)
        var defaultProcessOwnersDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let defaultProcessOwnersContainer = defaultProcessOwnersContainer {
            defaultProcessOwnersDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in defaultProcessOwnersContainer {
                if let structure0 = structure0 {
                    defaultProcessOwnersDecoded0?.append(structure0)
                }
            }
        }
        defaultProcessOwners = defaultProcessOwnersDecoded0
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let evidenceFinderEnablementDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.EvidenceFinderEnablement.self, forKey: .evidenceFinderEnablement)
        evidenceFinderEnablement = evidenceFinderEnablementDecoded
    }
}

extension AuditManagerClientTypes {
    /// The settings object that holds all supported Audit Manager settings.
    public struct Settings: Swift.Equatable {
        /// The default storage destination for assessment reports.
        public var defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
        /// The designated default audit owners.
        public var defaultProcessOwners: [AuditManagerClientTypes.Role]?
        /// The current evidence finder status and event data store details.
        public var evidenceFinderEnablement: AuditManagerClientTypes.EvidenceFinderEnablement?
        /// Specifies whether Organizations is enabled.
        public var isAwsOrgEnabled: Swift.Bool?
        /// The KMS key details.
        public var kmsKey: Swift.String?
        /// The designated Amazon Simple Notification Service (Amazon SNS) topic.
        public var snsTopic: Swift.String?

        public init (
            defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
            defaultProcessOwners: [AuditManagerClientTypes.Role]? = nil,
            evidenceFinderEnablement: AuditManagerClientTypes.EvidenceFinderEnablement? = nil,
            isAwsOrgEnabled: Swift.Bool? = nil,
            kmsKey: Swift.String? = nil,
            snsTopic: Swift.String? = nil
        )
        {
            self.defaultAssessmentReportsDestination = defaultAssessmentReportsDestination
            self.defaultProcessOwners = defaultProcessOwners
            self.evidenceFinderEnablement = evidenceFinderEnablement
            self.isAwsOrgEnabled = isAwsOrgEnabled
            self.kmsKey = kmsKey
            self.snsTopic = snsTopic
        }
    }

}

extension AuditManagerClientTypes {
    public enum ShareRequestAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accept
        case decline
        case revoke
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareRequestAction] {
            return [
                .accept,
                .decline,
                .revoke,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accept: return "ACCEPT"
            case .decline: return "DECLINE"
            case .revoke: return "REVOKE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareRequestAction(rawValue: rawValue) ?? ShareRequestAction.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum ShareRequestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case declined
        case expired
        case expiring
        case failed
        case replicating
        case revoked
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareRequestStatus] {
            return [
                .active,
                .declined,
                .expired,
                .expiring,
                .failed,
                .replicating,
                .revoked,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .declined: return "DECLINED"
            case .expired: return "EXPIRED"
            case .expiring: return "EXPIRING"
            case .failed: return "FAILED"
            case .replicating: return "REPLICATING"
            case .revoked: return "REVOKED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareRequestStatus(rawValue: rawValue) ?? ShareRequestStatus.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum ShareRequestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case received
        case sent
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareRequestType] {
            return [
                .received,
                .sent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .received: return "RECEIVED"
            case .sent: return "SENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareRequestType(rawValue: rawValue) ?? ShareRequestType.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum SourceFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceFrequency] {
            return [
                .daily,
                .monthly,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .monthly: return "MONTHLY"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceFrequency(rawValue: rawValue) ?? SourceFrequency.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes.SourceKeyword: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keywordInputType
        case keywordValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keywordInputType = self.keywordInputType {
            try encodeContainer.encode(keywordInputType.rawValue, forKey: .keywordInputType)
        }
        if let keywordValue = self.keywordValue {
            try encodeContainer.encode(keywordValue, forKey: .keywordValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keywordInputTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.KeywordInputType.self, forKey: .keywordInputType)
        keywordInputType = keywordInputTypeDecoded
        let keywordValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keywordValue)
        keywordValue = keywordValueDecoded
    }
}

extension AuditManagerClientTypes {
    /// The keyword to search for in CloudTrail logs, Config rules, Security Hub checks, and Amazon Web Services API names. To learn more about the supported keywords that you can use when mapping a control data source, see the following pages in the Audit Manager User Guide:
    ///
    /// * [Config rules supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-ash.html)
    ///
    /// * [Security Hub controls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-config.html)
    ///
    /// * [API calls supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-api.html)
    ///
    /// * [CloudTrail event names supported by Audit Manager](https://docs.aws.amazon.com/audit-manager/latest/userguide/control-data-sources-cloudtrail.html)
    public struct SourceKeyword: Swift.Equatable {
        /// The input method for the keyword.
        public var keywordInputType: AuditManagerClientTypes.KeywordInputType?
        /// The value of the keyword that's used when mapping a control data source. For example, this can be a CloudTrail event name, a rule name for Config, a Security Hub control, or the name of an Amazon Web Services API call. If youre mapping a data source to a rule in Config, the keywordValue that you specify depends on the type of rule:
        ///
        /// * For [managed rules](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html), you can use the rule identifier as the keywordValue. You can find the rule identifier from the [list of Config managed rules](https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html).
        ///
        /// * Managed rule name: [s3-bucket-acl-prohibited](https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-acl-prohibited.html)keywordValue: S3_BUCKET_ACL_PROHIBITED
        ///
        ///
        ///
        ///
        /// * For [custom rules](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html), you form the keywordValue by adding the Custom_ prefix to the rule name. This prefix distinguishes the rule from a managed rule.
        ///
        /// * Custom rule name: my-custom-config-rule keywordValue: Custom_my-custom-config-rule
        ///
        ///
        ///
        ///
        /// * For [service-linked rules](https://docs.aws.amazon.com/config/latest/developerguide/service-linked-awsconfig-rules.html), you form the keywordValue by adding the Custom_ prefix to the rule name. In addition, you remove the suffix ID that appears at the end of the rule name.
        ///
        /// * Service-linked rule name: CustomRuleForAccount-conformance-pack-szsm1uv0w keywordValue: Custom_CustomRuleForAccount-conformance-pack
        ///
        /// * Service-linked rule name: OrgConfigRule-s3-bucket-versioning-enabled-dbgzf8ba keywordValue: Custom_OrgConfigRule-s3-bucket-versioning-enabled
        public var keywordValue: Swift.String?

        public init (
            keywordInputType: AuditManagerClientTypes.KeywordInputType? = nil,
            keywordValue: Swift.String? = nil
        )
        {
            self.keywordInputType = keywordInputType
            self.keywordValue = keywordValue
        }
    }

}

extension AuditManagerClientTypes {
    public enum SourceSetUpOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case proceduralControlsMapping
        case systemControlsMapping
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceSetUpOption] {
            return [
                .proceduralControlsMapping,
                .systemControlsMapping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .proceduralControlsMapping: return "Procedural_Controls_Mapping"
            case .systemControlsMapping: return "System_Controls_Mapping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceSetUpOption(rawValue: rawValue) ?? SourceSetUpOption.sdkUnknown(rawValue)
        }
    }
}

extension AuditManagerClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsApiCall
        case awsCloudtrail
        case awsConfig
        case awsSecurityHub
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .awsApiCall,
                .awsCloudtrail,
                .awsConfig,
                .awsSecurityHub,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsApiCall: return "AWS_API_Call"
            case .awsCloudtrail: return "AWS_Cloudtrail"
            case .awsConfig: return "AWS_Config"
            case .awsSecurityHub: return "AWS_Security_Hub"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension StartAssessmentFrameworkShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case destinationAccount
        case destinationRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let destinationAccount = self.destinationAccount {
            try encodeContainer.encode(destinationAccount, forKey: .destinationAccount)
        }
        if let destinationRegion = self.destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
    }
}

extension StartAssessmentFrameworkShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkId = frameworkId else {
            return nil
        }
        return "/assessmentFrameworks/\(frameworkId.urlPercentEncoding())/shareRequests"
    }
}

public struct StartAssessmentFrameworkShareInput: Swift.Equatable {
    /// An optional comment from the sender about the share request.
    public var comment: Swift.String?
    /// The Amazon Web Services account of the recipient.
    /// This member is required.
    public var destinationAccount: Swift.String?
    /// The Amazon Web Services Region of the recipient.
    /// This member is required.
    public var destinationRegion: Swift.String?
    /// The unique identifier for the custom framework to be shared.
    /// This member is required.
    public var frameworkId: Swift.String?

    public init (
        comment: Swift.String? = nil,
        destinationAccount: Swift.String? = nil,
        destinationRegion: Swift.String? = nil,
        frameworkId: Swift.String? = nil
    )
    {
        self.comment = comment
        self.destinationAccount = destinationAccount
        self.destinationRegion = destinationRegion
        self.frameworkId = frameworkId
    }
}

struct StartAssessmentFrameworkShareInputBody: Swift.Equatable {
    let destinationAccount: Swift.String?
    let destinationRegion: Swift.String?
    let comment: Swift.String?
}

extension StartAssessmentFrameworkShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case destinationAccount
        case destinationRegion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationAccount)
        destinationAccount = destinationAccountDecoded
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension StartAssessmentFrameworkShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAssessmentFrameworkShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartAssessmentFrameworkShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAssessmentFrameworkShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartAssessmentFrameworkShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentFrameworkShareRequest = output.assessmentFrameworkShareRequest
        } else {
            self.assessmentFrameworkShareRequest = nil
        }
    }
}

public struct StartAssessmentFrameworkShareOutputResponse: Swift.Equatable {
    /// The share request that's created by the StartAssessmentFrameworkShare API.
    public var assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest?

    public init (
        assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest? = nil
    )
    {
        self.assessmentFrameworkShareRequest = assessmentFrameworkShareRequest
    }
}

struct StartAssessmentFrameworkShareOutputResponseBody: Swift.Equatable {
    let assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest?
}

extension StartAssessmentFrameworkShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentFrameworkShareRequest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentFrameworkShareRequestDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentFrameworkShareRequest.self, forKey: .assessmentFrameworkShareRequest)
        assessmentFrameworkShareRequest = assessmentFrameworkShareRequestDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags that are associated with the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuditManagerClientTypes.URL: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hyperlinkName
        case link
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hyperlinkName = self.hyperlinkName {
            try encodeContainer.encode(hyperlinkName, forKey: .hyperlinkName)
        }
        if let link = self.link {
            try encodeContainer.encode(link, forKey: .link)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hyperlinkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hyperlinkName)
        hyperlinkName = hyperlinkNameDecoded
        let linkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .link)
        link = linkDecoded
    }
}

extension AuditManagerClientTypes {
    /// Short for uniform resource locator. A URL is used as a unique identifier to locate a resource on the internet.
    public struct URL: Swift.Equatable {
        /// The name or word that's used as a hyperlink to the URL.
        public var hyperlinkName: Swift.String?
        /// The unique identifier for the internet resource.
        public var link: Swift.String?

        public init (
            hyperlinkName: Swift.String? = nil,
            link: Swift.String? = nil
        )
        {
            self.hyperlinkName = hyperlinkName
            self.link = link
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the specified resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name or key of the tag.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAssessmentControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentBody
        case controlStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentBody = self.commentBody {
            try encodeContainer.encode(commentBody, forKey: .commentBody)
        }
        if let controlStatus = self.controlStatus {
            try encodeContainer.encode(controlStatus.rawValue, forKey: .controlStatus)
        }
    }
}

extension UpdateAssessmentControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        guard let controlId = controlId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/controls/\(controlId.urlPercentEncoding())"
    }
}

public struct UpdateAssessmentControlInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The comment body text for the control.
    public var commentBody: Swift.String?
    /// The unique identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?
    /// The unique identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The status of the control.
    public var controlStatus: AuditManagerClientTypes.ControlStatus?

    public init (
        assessmentId: Swift.String? = nil,
        commentBody: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        controlStatus: AuditManagerClientTypes.ControlStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.commentBody = commentBody
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.controlStatus = controlStatus
    }
}

struct UpdateAssessmentControlInputBody: Swift.Equatable {
    let controlStatus: AuditManagerClientTypes.ControlStatus?
    let commentBody: Swift.String?
}

extension UpdateAssessmentControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentBody
        case controlStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlStatusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ControlStatus.self, forKey: .controlStatus)
        controlStatus = controlStatusDecoded
        let commentBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentBody)
        commentBody = commentBodyDecoded
    }
}

extension UpdateAssessmentControlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentControlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAssessmentControlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentControlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAssessmentControlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.control = output.control
        } else {
            self.control = nil
        }
    }
}

public struct UpdateAssessmentControlOutputResponse: Swift.Equatable {
    /// The name of the updated control set that the UpdateAssessmentControl API returned.
    public var control: AuditManagerClientTypes.AssessmentControl?

    public init (
        control: AuditManagerClientTypes.AssessmentControl? = nil
    )
    {
        self.control = control
    }
}

struct UpdateAssessmentControlOutputResponseBody: Swift.Equatable {
    let control: AuditManagerClientTypes.AssessmentControl?
}

extension UpdateAssessmentControlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case control
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentControl.self, forKey: .control)
        control = controlDecoded
    }
}

extension UpdateAssessmentControlSetStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateAssessmentControlSetStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        guard let controlSetId = controlSetId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/controlSets/\(controlSetId.urlPercentEncoding())/status"
    }
}

public struct UpdateAssessmentControlSetStatusInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The comment that's related to the status update.
    /// This member is required.
    public var comment: Swift.String?
    /// The unique identifier for the control set.
    /// This member is required.
    public var controlSetId: Swift.String?
    /// The status of the control set that's being updated.
    /// This member is required.
    public var status: AuditManagerClientTypes.ControlSetStatus?

    public init (
        assessmentId: Swift.String? = nil,
        comment: Swift.String? = nil,
        controlSetId: Swift.String? = nil,
        status: AuditManagerClientTypes.ControlSetStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.comment = comment
        self.controlSetId = controlSetId
        self.status = status
    }
}

struct UpdateAssessmentControlSetStatusInputBody: Swift.Equatable {
    let status: AuditManagerClientTypes.ControlSetStatus?
    let comment: Swift.String?
}

extension UpdateAssessmentControlSetStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ControlSetStatus.self, forKey: .status)
        status = statusDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension UpdateAssessmentControlSetStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentControlSetStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAssessmentControlSetStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentControlSetStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAssessmentControlSetStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.controlSet = output.controlSet
        } else {
            self.controlSet = nil
        }
    }
}

public struct UpdateAssessmentControlSetStatusOutputResponse: Swift.Equatable {
    /// The name of the updated control set that the UpdateAssessmentControlSetStatus API returned.
    public var controlSet: AuditManagerClientTypes.AssessmentControlSet?

    public init (
        controlSet: AuditManagerClientTypes.AssessmentControlSet? = nil
    )
    {
        self.controlSet = controlSet
    }
}

struct UpdateAssessmentControlSetStatusOutputResponseBody: Swift.Equatable {
    let controlSet: AuditManagerClientTypes.AssessmentControlSet?
}

extension UpdateAssessmentControlSetStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlSet
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlSetDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentControlSet.self, forKey: .controlSet)
        controlSet = controlSetDecoded
    }
}

extension AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controls
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for createassessmentframeworkcontrol0 in controls {
                try controlsContainer.encode(createassessmentframeworkcontrol0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let controlsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.CreateAssessmentFrameworkControl?].self, forKey: .controls)
        var controlsDecoded0:[AuditManagerClientTypes.CreateAssessmentFrameworkControl]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [AuditManagerClientTypes.CreateAssessmentFrameworkControl]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
    }
}

extension AuditManagerClientTypes {
    /// A controlSet entity that represents a collection of controls in Audit Manager. This doesn't contain the control set ID.
    public struct UpdateAssessmentFrameworkControlSet: Swift.Equatable {
        /// The list of controls that are contained within the control set.
        /// This member is required.
        public var controls: [AuditManagerClientTypes.CreateAssessmentFrameworkControl]?
        /// The unique identifier for the control set.
        public var id: Swift.String?
        /// The name of the control set.
        /// This member is required.
        public var name: Swift.String?

        public init (
            controls: [AuditManagerClientTypes.CreateAssessmentFrameworkControl]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.controls = controls
            self.id = id
            self.name = name
        }
    }

}

extension UpdateAssessmentFrameworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType
        case controlSets
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let controlSets = controlSets {
            var controlSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlSets)
            for updateassessmentframeworkcontrolset0 in controlSets {
                try controlSetsContainer.encode(updateassessmentframeworkcontrolset0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAssessmentFrameworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let frameworkId = frameworkId else {
            return nil
        }
        return "/assessmentFrameworks/\(frameworkId.urlPercentEncoding())"
    }
}

public struct UpdateAssessmentFrameworkInput: Swift.Equatable {
    /// The compliance type that the new custom framework supports, such as CIS or HIPAA.
    public var complianceType: Swift.String?
    /// The control sets that are associated with the framework.
    /// This member is required.
    public var controlSets: [AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet]?
    /// The description of the updated framework.
    public var description: Swift.String?
    /// The unique identifier for the framework.
    /// This member is required.
    public var frameworkId: Swift.String?
    /// The name of the framework to be updated.
    /// This member is required.
    public var name: Swift.String?

    public init (
        complianceType: Swift.String? = nil,
        controlSets: [AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet]? = nil,
        description: Swift.String? = nil,
        frameworkId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.complianceType = complianceType
        self.controlSets = controlSets
        self.description = description
        self.frameworkId = frameworkId
        self.name = name
    }
}

struct UpdateAssessmentFrameworkInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let complianceType: Swift.String?
    let controlSets: [AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet]?
}

extension UpdateAssessmentFrameworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType
        case controlSets
        case description
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let controlSetsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet?].self, forKey: .controlSets)
        var controlSetsDecoded0:[AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet]? = nil
        if let controlSetsContainer = controlSetsContainer {
            controlSetsDecoded0 = [AuditManagerClientTypes.UpdateAssessmentFrameworkControlSet]()
            for structure0 in controlSetsContainer {
                if let structure0 = structure0 {
                    controlSetsDecoded0?.append(structure0)
                }
            }
        }
        controlSets = controlSetsDecoded0
    }
}

extension UpdateAssessmentFrameworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentFrameworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAssessmentFrameworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentFrameworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAssessmentFrameworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.framework = output.framework
        } else {
            self.framework = nil
        }
    }
}

public struct UpdateAssessmentFrameworkOutputResponse: Swift.Equatable {
    /// The name of the framework.
    public var framework: AuditManagerClientTypes.Framework?

    public init (
        framework: AuditManagerClientTypes.Framework? = nil
    )
    {
        self.framework = framework
    }
}

struct UpdateAssessmentFrameworkOutputResponseBody: Swift.Equatable {
    let framework: AuditManagerClientTypes.Framework?
}

extension UpdateAssessmentFrameworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case framework
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Framework.self, forKey: .framework)
        framework = frameworkDecoded
    }
}

extension UpdateAssessmentFrameworkShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case requestType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let requestType = self.requestType {
            try encodeContainer.encode(requestType.rawValue, forKey: .requestType)
        }
    }
}

extension UpdateAssessmentFrameworkShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let requestId = requestId else {
            return nil
        }
        return "/assessmentFrameworkShareRequests/\(requestId.urlPercentEncoding())"
    }
}

public struct UpdateAssessmentFrameworkShareInput: Swift.Equatable {
    /// Specifies the update action for the share request.
    /// This member is required.
    public var action: AuditManagerClientTypes.ShareRequestAction?
    /// The unique identifier for the share request.
    /// This member is required.
    public var requestId: Swift.String?
    /// Specifies whether the share request is a sent request or a received request.
    /// This member is required.
    public var requestType: AuditManagerClientTypes.ShareRequestType?

    public init (
        action: AuditManagerClientTypes.ShareRequestAction? = nil,
        requestId: Swift.String? = nil,
        requestType: AuditManagerClientTypes.ShareRequestType? = nil
    )
    {
        self.action = action
        self.requestId = requestId
        self.requestType = requestType
    }
}

struct UpdateAssessmentFrameworkShareInputBody: Swift.Equatable {
    let requestType: AuditManagerClientTypes.ShareRequestType?
    let action: AuditManagerClientTypes.ShareRequestAction?
}

extension UpdateAssessmentFrameworkShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case requestType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestTypeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ShareRequestType.self, forKey: .requestType)
        requestType = requestTypeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ShareRequestAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateAssessmentFrameworkShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentFrameworkShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAssessmentFrameworkShareOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentFrameworkShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAssessmentFrameworkShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessmentFrameworkShareRequest = output.assessmentFrameworkShareRequest
        } else {
            self.assessmentFrameworkShareRequest = nil
        }
    }
}

public struct UpdateAssessmentFrameworkShareOutputResponse: Swift.Equatable {
    /// The updated share request that's returned by the UpdateAssessmentFrameworkShare operation.
    public var assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest?

    public init (
        assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest? = nil
    )
    {
        self.assessmentFrameworkShareRequest = assessmentFrameworkShareRequest
    }
}

struct UpdateAssessmentFrameworkShareOutputResponseBody: Swift.Equatable {
    let assessmentFrameworkShareRequest: AuditManagerClientTypes.AssessmentFrameworkShareRequest?
}

extension UpdateAssessmentFrameworkShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentFrameworkShareRequest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentFrameworkShareRequestDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentFrameworkShareRequest.self, forKey: .assessmentFrameworkShareRequest)
        assessmentFrameworkShareRequest = assessmentFrameworkShareRequestDecoded
    }
}

extension UpdateAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentDescription
        case assessmentName
        case assessmentReportsDestination
        case roles
        case scope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentDescription = self.assessmentDescription {
            try encodeContainer.encode(assessmentDescription, forKey: .assessmentDescription)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let assessmentReportsDestination = self.assessmentReportsDestination {
            try encodeContainer.encode(assessmentReportsDestination, forKey: .assessmentReportsDestination)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for role0 in roles {
                try rolesContainer.encode(role0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
    }
}

extension UpdateAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())"
    }
}

public struct UpdateAssessmentInput: Swift.Equatable {
    /// The description of the assessment.
    public var assessmentDescription: Swift.String?
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The name of the assessment to be updated.
    public var assessmentName: Swift.String?
    /// The assessment report storage destination for the assessment that's being updated.
    public var assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    /// The list of roles for the assessment.
    public var roles: [AuditManagerClientTypes.Role]?
    /// The scope of the assessment.
    /// This member is required.
    public var scope: AuditManagerClientTypes.Scope?

    public init (
        assessmentDescription: Swift.String? = nil,
        assessmentId: Swift.String? = nil,
        assessmentName: Swift.String? = nil,
        assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
        roles: [AuditManagerClientTypes.Role]? = nil,
        scope: AuditManagerClientTypes.Scope? = nil
    )
    {
        self.assessmentDescription = assessmentDescription
        self.assessmentId = assessmentId
        self.assessmentName = assessmentName
        self.assessmentReportsDestination = assessmentReportsDestination
        self.roles = roles
        self.scope = scope
    }
}

struct UpdateAssessmentInputBody: Swift.Equatable {
    let assessmentName: Swift.String?
    let assessmentDescription: Swift.String?
    let scope: AuditManagerClientTypes.Scope?
    let assessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    let roles: [AuditManagerClientTypes.Role]?
}

extension UpdateAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentDescription
        case assessmentName
        case assessmentReportsDestination
        case roles
        case scope
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentDescription)
        assessmentDescription = assessmentDescriptionDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let assessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportsDestination.self, forKey: .assessmentReportsDestination)
        assessmentReportsDestination = assessmentReportsDestinationDecoded
        let rolesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .roles)
        var rolesDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
    }
}

extension UpdateAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAssessmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct UpdateAssessmentOutputResponse: Swift.Equatable {
    /// The response object for the UpdateAssessmentRequest API. This is the name of the updated assessment.
    public var assessment: AuditManagerClientTypes.Assessment?

    public init (
        assessment: AuditManagerClientTypes.Assessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct UpdateAssessmentOutputResponseBody: Swift.Equatable {
    let assessment: AuditManagerClientTypes.Assessment?
}

extension UpdateAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Assessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

extension UpdateAssessmentStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateAssessmentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assessmentId = assessmentId else {
            return nil
        }
        return "/assessments/\(assessmentId.urlPercentEncoding())/status"
    }
}

public struct UpdateAssessmentStatusInput: Swift.Equatable {
    /// The unique identifier for the assessment.
    /// This member is required.
    public var assessmentId: Swift.String?
    /// The current status of the assessment.
    /// This member is required.
    public var status: AuditManagerClientTypes.AssessmentStatus?

    public init (
        assessmentId: Swift.String? = nil,
        status: AuditManagerClientTypes.AssessmentStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.status = status
    }
}

struct UpdateAssessmentStatusInputBody: Swift.Equatable {
    let status: AuditManagerClientTypes.AssessmentStatus?
}

extension UpdateAssessmentStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateAssessmentStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAssessmentStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAssessmentStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct UpdateAssessmentStatusOutputResponse: Swift.Equatable {
    /// The name of the updated assessment that the UpdateAssessmentStatus API returned.
    public var assessment: AuditManagerClientTypes.Assessment?

    public init (
        assessment: AuditManagerClientTypes.Assessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct UpdateAssessmentStatusOutputResponseBody: Swift.Equatable {
    let assessment: AuditManagerClientTypes.Assessment?
}

extension UpdateAssessmentStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Assessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

extension UpdateControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case controlMappingSources
        case description
        case name
        case testingInformation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionPlanInstructions = self.actionPlanInstructions {
            try encodeContainer.encode(actionPlanInstructions, forKey: .actionPlanInstructions)
        }
        if let actionPlanTitle = self.actionPlanTitle {
            try encodeContainer.encode(actionPlanTitle, forKey: .actionPlanTitle)
        }
        if let controlMappingSources = controlMappingSources {
            var controlMappingSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlMappingSources)
            for controlmappingsource0 in controlMappingSources {
                try controlMappingSourcesContainer.encode(controlmappingsource0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let testingInformation = self.testingInformation {
            try encodeContainer.encode(testingInformation, forKey: .testingInformation)
        }
    }
}

extension UpdateControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let controlId = controlId else {
            return nil
        }
        return "/controls/\(controlId.urlPercentEncoding())"
    }
}

public struct UpdateControlInput: Swift.Equatable {
    /// The recommended actions to carry out if the control isn't fulfilled.
    public var actionPlanInstructions: Swift.String?
    /// The title of the action plan for remediating the control.
    public var actionPlanTitle: Swift.String?
    /// The identifier for the control.
    /// This member is required.
    public var controlId: Swift.String?
    /// The data mapping sources for the control.
    /// This member is required.
    public var controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]?
    /// The optional description of the control.
    public var description: Swift.String?
    /// The name of the updated control.
    /// This member is required.
    public var name: Swift.String?
    /// The steps that you should follow to determine if the control is met.
    public var testingInformation: Swift.String?

    public init (
        actionPlanInstructions: Swift.String? = nil,
        actionPlanTitle: Swift.String? = nil,
        controlId: Swift.String? = nil,
        controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        testingInformation: Swift.String? = nil
    )
    {
        self.actionPlanInstructions = actionPlanInstructions
        self.actionPlanTitle = actionPlanTitle
        self.controlId = controlId
        self.controlMappingSources = controlMappingSources
        self.description = description
        self.name = name
        self.testingInformation = testingInformation
    }
}

struct UpdateControlInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let testingInformation: Swift.String?
    let actionPlanTitle: Swift.String?
    let actionPlanInstructions: Swift.String?
    let controlMappingSources: [AuditManagerClientTypes.ControlMappingSource]?
}

extension UpdateControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case controlMappingSources
        case description
        case name
        case testingInformation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let testingInformationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testingInformation)
        testingInformation = testingInformationDecoded
        let actionPlanTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionPlanTitle)
        actionPlanTitle = actionPlanTitleDecoded
        let actionPlanInstructionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionPlanInstructions)
        actionPlanInstructions = actionPlanInstructionsDecoded
        let controlMappingSourcesContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ControlMappingSource?].self, forKey: .controlMappingSources)
        var controlMappingSourcesDecoded0:[AuditManagerClientTypes.ControlMappingSource]? = nil
        if let controlMappingSourcesContainer = controlMappingSourcesContainer {
            controlMappingSourcesDecoded0 = [AuditManagerClientTypes.ControlMappingSource]()
            for structure0 in controlMappingSourcesContainer {
                if let structure0 = structure0 {
                    controlMappingSourcesDecoded0?.append(structure0)
                }
            }
        }
        controlMappingSources = controlMappingSourcesDecoded0
    }
}

extension UpdateControlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateControlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateControlOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateControlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateControlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.control = output.control
        } else {
            self.control = nil
        }
    }
}

public struct UpdateControlOutputResponse: Swift.Equatable {
    /// The name of the updated control set that the UpdateControl API returned.
    public var control: AuditManagerClientTypes.Control?

    public init (
        control: AuditManagerClientTypes.Control? = nil
    )
    {
        self.control = control
    }
}

struct UpdateControlOutputResponseBody: Swift.Equatable {
    let control: AuditManagerClientTypes.Control?
}

extension UpdateControlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case control
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Control.self, forKey: .control)
        control = controlDecoded
    }
}

extension UpdateSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAssessmentReportsDestination
        case defaultProcessOwners
        case evidenceFinderEnabled
        case kmsKey
        case snsTopic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAssessmentReportsDestination = self.defaultAssessmentReportsDestination {
            try encodeContainer.encode(defaultAssessmentReportsDestination, forKey: .defaultAssessmentReportsDestination)
        }
        if let defaultProcessOwners = defaultProcessOwners {
            var defaultProcessOwnersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultProcessOwners)
            for role0 in defaultProcessOwners {
                try defaultProcessOwnersContainer.encode(role0)
            }
        }
        if let evidenceFinderEnabled = self.evidenceFinderEnabled {
            try encodeContainer.encode(evidenceFinderEnabled, forKey: .evidenceFinderEnabled)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let snsTopic = self.snsTopic {
            try encodeContainer.encode(snsTopic, forKey: .snsTopic)
        }
    }
}

extension UpdateSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings"
    }
}

public struct UpdateSettingsInput: Swift.Equatable {
    /// The default storage destination for assessment reports.
    public var defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    /// A list of the default audit owners.
    public var defaultProcessOwners: [AuditManagerClientTypes.Role]?
    /// Specifies whether the evidence finder feature is enabled. Change this attribute to enable or disable evidence finder. When you use this attribute to disable evidence finder, Audit Manager deletes the event data store thats used to query your evidence data. As a result, you cant re-enable evidence finder and use the feature again. Your only alternative is to [deregister](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_DeregisterAccount.html) and then [re-register](https://docs.aws.amazon.com/audit-manager/latest/APIReference/API_RegisterAccount.html) Audit Manager. Disabling evidence finder is permanent, so consider this decision carefully before you proceed. If youre using Audit Manager as a delegated administrator, keep in mind that this action applies to all member accounts in your organization.
    public var evidenceFinderEnabled: Swift.Bool?
    /// The KMS key details.
    public var kmsKey: Swift.String?
    /// The Amazon Simple Notification Service (Amazon SNS) topic that Audit Manager sends notifications to.
    public var snsTopic: Swift.String?

    public init (
        defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination? = nil,
        defaultProcessOwners: [AuditManagerClientTypes.Role]? = nil,
        evidenceFinderEnabled: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        snsTopic: Swift.String? = nil
    )
    {
        self.defaultAssessmentReportsDestination = defaultAssessmentReportsDestination
        self.defaultProcessOwners = defaultProcessOwners
        self.evidenceFinderEnabled = evidenceFinderEnabled
        self.kmsKey = kmsKey
        self.snsTopic = snsTopic
    }
}

struct UpdateSettingsInputBody: Swift.Equatable {
    let snsTopic: Swift.String?
    let defaultAssessmentReportsDestination: AuditManagerClientTypes.AssessmentReportsDestination?
    let defaultProcessOwners: [AuditManagerClientTypes.Role]?
    let kmsKey: Swift.String?
    let evidenceFinderEnabled: Swift.Bool?
}

extension UpdateSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAssessmentReportsDestination
        case defaultProcessOwners
        case evidenceFinderEnabled
        case kmsKey
        case snsTopic
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopic)
        snsTopic = snsTopicDecoded
        let defaultAssessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.AssessmentReportsDestination.self, forKey: .defaultAssessmentReportsDestination)
        defaultAssessmentReportsDestination = defaultAssessmentReportsDestinationDecoded
        let defaultProcessOwnersContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.Role?].self, forKey: .defaultProcessOwners)
        var defaultProcessOwnersDecoded0:[AuditManagerClientTypes.Role]? = nil
        if let defaultProcessOwnersContainer = defaultProcessOwnersContainer {
            defaultProcessOwnersDecoded0 = [AuditManagerClientTypes.Role]()
            for structure0 in defaultProcessOwnersContainer {
                if let structure0 = structure0 {
                    defaultProcessOwnersDecoded0?.append(structure0)
                }
            }
        }
        defaultProcessOwners = defaultProcessOwnersDecoded0
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let evidenceFinderEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .evidenceFinderEnabled)
        evidenceFinderEnabled = evidenceFinderEnabledDecoded
    }
}

extension UpdateSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.settings = output.settings
        } else {
            self.settings = nil
        }
    }
}

public struct UpdateSettingsOutputResponse: Swift.Equatable {
    /// The current list of settings.
    public var settings: AuditManagerClientTypes.Settings?

    public init (
        settings: AuditManagerClientTypes.Settings? = nil
    )
    {
        self.settings = settings
    }
}

struct UpdateSettingsOutputResponseBody: Swift.Equatable {
    let settings: AuditManagerClientTypes.Settings?
}

extension UpdateSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case settings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingsDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension ValidateAssessmentReportIntegrityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3RelativePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3RelativePath = self.s3RelativePath {
            try encodeContainer.encode(s3RelativePath, forKey: .s3RelativePath)
        }
    }
}

extension ValidateAssessmentReportIntegrityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assessmentReports/integrity"
    }
}

public struct ValidateAssessmentReportIntegrityInput: Swift.Equatable {
    /// The relative path of the Amazon S3 bucket that the assessment report is stored in.
    /// This member is required.
    public var s3RelativePath: Swift.String?

    public init (
        s3RelativePath: Swift.String? = nil
    )
    {
        self.s3RelativePath = s3RelativePath
    }
}

struct ValidateAssessmentReportIntegrityInputBody: Swift.Equatable {
    let s3RelativePath: Swift.String?
}

extension ValidateAssessmentReportIntegrityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3RelativePath
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3RelativePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3RelativePath)
        s3RelativePath = s3RelativePathDecoded
    }
}

extension ValidateAssessmentReportIntegrityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidateAssessmentReportIntegrityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ValidateAssessmentReportIntegrityOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateAssessmentReportIntegrityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidateAssessmentReportIntegrityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.signatureAlgorithm = output.signatureAlgorithm
            self.signatureDateTime = output.signatureDateTime
            self.signatureKeyId = output.signatureKeyId
            self.signatureValid = output.signatureValid
            self.validationErrors = output.validationErrors
        } else {
            self.signatureAlgorithm = nil
            self.signatureDateTime = nil
            self.signatureKeyId = nil
            self.signatureValid = nil
            self.validationErrors = nil
        }
    }
}

public struct ValidateAssessmentReportIntegrityOutputResponse: Swift.Equatable {
    /// The signature algorithm that's used to code sign the assessment report file.
    public var signatureAlgorithm: Swift.String?
    /// The date and time signature that specifies when the assessment report was created.
    public var signatureDateTime: Swift.String?
    /// The unique identifier for the validation signature key.
    public var signatureKeyId: Swift.String?
    /// Specifies whether the signature key is valid.
    public var signatureValid: Swift.Bool?
    /// Represents any errors that occurred when validating the assessment report.
    public var validationErrors: [Swift.String]?

    public init (
        signatureAlgorithm: Swift.String? = nil,
        signatureDateTime: Swift.String? = nil,
        signatureKeyId: Swift.String? = nil,
        signatureValid: Swift.Bool? = nil,
        validationErrors: [Swift.String]? = nil
    )
    {
        self.signatureAlgorithm = signatureAlgorithm
        self.signatureDateTime = signatureDateTime
        self.signatureKeyId = signatureKeyId
        self.signatureValid = signatureValid
        self.validationErrors = validationErrors
    }
}

struct ValidateAssessmentReportIntegrityOutputResponseBody: Swift.Equatable {
    let signatureValid: Swift.Bool?
    let signatureAlgorithm: Swift.String?
    let signatureDateTime: Swift.String?
    let signatureKeyId: Swift.String?
    let validationErrors: [Swift.String]?
}

extension ValidateAssessmentReportIntegrityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signatureAlgorithm
        case signatureDateTime
        case signatureKeyId
        case signatureValid
        case validationErrors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signatureValidDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .signatureValid)
        signatureValid = signatureValidDecoded
        let signatureAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signatureAlgorithm)
        signatureAlgorithm = signatureAlgorithmDecoded
        let signatureDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signatureDateTime)
        signatureDateTime = signatureDateTimeDecoded
        let signatureKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signatureKeyId)
        signatureKeyId = signatureKeyIdDecoded
        let validationErrorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validationErrors)
        var validationErrorsDecoded0:[Swift.String]? = nil
        if let validationErrorsContainer = validationErrorsContainer {
            validationErrorsDecoded0 = [Swift.String]()
            for string0 in validationErrorsContainer {
                if let string0 = string0 {
                    validationErrorsDecoded0?.append(string0)
                }
            }
        }
        validationErrors = validationErrorsDecoded0
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has invalid or missing parameters.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that caused the error, if applicable.
    public var fields: [AuditManagerClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason the request failed validation.
    public var reason: AuditManagerClientTypes.ValidationExceptionReason?

    public init (
        fields: [AuditManagerClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AuditManagerClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AuditManagerClientTypes.ValidationExceptionReason?
    let fields: [AuditManagerClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AuditManagerClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([AuditManagerClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[AuditManagerClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [AuditManagerClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension AuditManagerClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuditManagerClientTypes {
    /// Indicates that the request has invalid or missing parameters for the field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The body of the error message.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation error.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension AuditManagerClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
