// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct ActivatePipelineInputBodyMiddleware: Middleware {
    public let id: String = "ActivatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivatePipelineInput>
    public typealias MOutput = OperationOutput<ActivatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivatePipelineOutputError>
}

extension ActivatePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivatePipelineInput(parameterValues: \(String(describing: parameterValues)), pipelineId: \(String(describing: pipelineId)), startTimestamp: \(String(describing: startTimestamp)))"}
}

extension ActivatePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterValues
        case pipelineId
        case startTimestamp
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterValues = parameterValues {
            var parameterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterValues)
            for parametervaluelist0 in parameterValues {
                try parameterValuesContainer.encode(parametervaluelist0)
            }
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let startTimestamp = startTimestamp {
            try encodeContainer.encode(startTimestamp.timeIntervalSince1970, forKey: .startTimestamp)
        }
    }
}

public struct ActivatePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "ActivatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivatePipelineInput>
    public typealias MOutput = OperationOutput<ActivatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivatePipelineOutputError>
}

public struct ActivatePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "ActivatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivatePipelineInput>
    public typealias MOutput = OperationOutput<ActivatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivatePipelineOutputError>
}

/// <p>Contains the parameters for ActivatePipeline.</p>
public struct ActivatePipelineInput: Equatable {
    /// <p>A list of parameter values to pass to the pipeline at activation.</p>
    public let parameterValues: [ParameterValue]?
    /// <p>The ID of the pipeline.</p>
    public let pipelineId: String?
    /// <p>The date and time to resume the pipeline. By default, the pipeline resumes from the last completed execution.</p>
    public let startTimestamp: Date?

    public init (
        parameterValues: [ParameterValue]? = nil,
        pipelineId: String? = nil,
        startTimestamp: Date? = nil
    )
    {
        self.parameterValues = parameterValues
        self.pipelineId = pipelineId
        self.startTimestamp = startTimestamp
    }
}

struct ActivatePipelineInputBody: Equatable {
    public let pipelineId: String?
    public let parameterValues: [ParameterValue]?
    public let startTimestamp: Date?
}

extension ActivatePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameterValues
        case pipelineId
        case startTimestamp
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let parameterValuesContainer = try containerValues.decodeIfPresent([ParameterValue?].self, forKey: .parameterValues)
        var parameterValuesDecoded0:[ParameterValue]? = nil
        if let parameterValuesContainer = parameterValuesContainer {
            parameterValuesDecoded0 = [ParameterValue]()
            for structure0 in parameterValuesContainer {
                if let structure0 = structure0 {
                    parameterValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterValues = parameterValuesDecoded0
        let startTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
    }
}

extension ActivatePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivatePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ActivatePipelineOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivatePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivatePipelineOutputResponse()"}
}

extension ActivatePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of ActivatePipeline.</p>
public struct ActivatePipelineOutputResponse: Equatable {

    public init() {}
}

struct ActivatePipelineOutputResponseBody: Equatable {
}

extension ActivatePipelineOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AddTagsInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsInput>
    public typealias MOutput = OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsOutputError>
}

extension AddTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsInput(pipelineId: \(String(describing: pipelineId)), tags: \(String(describing: tags)))"}
}

extension AddTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineId
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct AddTagsInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsInput>
    public typealias MOutput = OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsOutputError>
}

public struct AddTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsInput>
    public typealias MOutput = OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsOutputError>
}

/// <p>Contains the parameters for AddTags.</p>
public struct AddTagsInput: Equatable {
    /// <p>The ID of the pipeline.</p>
    public let pipelineId: String?
    /// <p>The tags to add, as key/value pairs.</p>
    public let tags: [Tag]?

    public init (
        pipelineId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.pipelineId = pipelineId
        self.tags = tags
    }
}

struct AddTagsInputBody: Equatable {
    public let pipelineId: String?
    public let tags: [Tag]?
}

extension AddTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineId
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsOutputResponse()"}
}

extension AddTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of AddTags.</p>
public struct AddTagsOutputResponse: Equatable {

    public init() {}
}

struct AddTagsOutputResponseBody: Equatable {
}

extension AddTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreatePipelineInputBodyMiddleware: Middleware {
    public let id: String = "CreatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePipelineOutputError>
}

extension CreatePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePipelineInput(description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)), uniqueId: \(String(describing: uniqueId)))"}
}

extension CreatePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case tags
        case uniqueId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let uniqueId = uniqueId {
            try encodeContainer.encode(uniqueId, forKey: .uniqueId)
        }
    }
}

public struct CreatePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePipelineOutputError>
}

public struct CreatePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePipelineOutputError>
}

/// <p>Contains the parameters for CreatePipeline.</p>
public struct CreatePipelineInput: Equatable {
    /// <p>The description for the pipeline.</p>
    public let description: String?
    /// <p>The name for the pipeline. You can use the same name for multiple pipelines associated with your AWS account,
    ///             because AWS Data Pipeline assigns each pipeline a unique pipeline identifier.</p>
    public let name: String?
    /// <p>A list of tags to associate with the pipeline at creation. Tags let you control access to pipelines.
    ///             For more information, see <a href="http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-control-access.html">Controlling User Access to Pipelines</a>
    ///             in the <i>AWS Data Pipeline Developer Guide</i>.</p>
    public let tags: [Tag]?
    /// <p>A unique identifier. This identifier is not the same as the pipeline identifier assigned by AWS Data Pipeline.
    ///             You are responsible for defining the format and ensuring the uniqueness of this identifier. You use this
    ///             parameter to ensure idempotency during repeated calls to <code>CreatePipeline</code>. For example, if the
    ///             first call to <code>CreatePipeline</code> does not succeed, you can pass in the same unique identifier and
    ///             pipeline name combination on a subsequent call to <code>CreatePipeline</code>. <code>CreatePipeline</code>
    ///             ensures that if a pipeline already exists with the same name and unique identifier, a new pipeline is not
    ///             created. Instead, you'll receive the pipeline identifier from the previous attempt. The uniqueness of the
    ///             name and unique identifier combination is scoped to the AWS account or IAM user credentials.</p>
    public let uniqueId: String?

    public init (
        description: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil,
        uniqueId: String? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.uniqueId = uniqueId
    }
}

struct CreatePipelineInputBody: Equatable {
    public let name: String?
    public let uniqueId: String?
    public let description: String?
    public let tags: [Tag]?
}

extension CreatePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case tags
        case uniqueId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let uniqueIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uniqueId)
        uniqueId = uniqueIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePipelineOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePipelineOutputResponse(pipelineId: \(String(describing: pipelineId)))"}
}

extension CreatePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePipelineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pipelineId = output.pipelineId
        } else {
            self.pipelineId = nil
        }
    }
}

/// <p>Contains the output of CreatePipeline.</p>
public struct CreatePipelineOutputResponse: Equatable {
    /// <p>The ID that AWS Data Pipeline assigns the newly created pipeline. For example, <code>df-06372391ZG65EXAMPLE</code>.</p>
    public let pipelineId: String?

    public init (
        pipelineId: String? = nil
    )
    {
        self.pipelineId = pipelineId
    }
}

struct CreatePipelineOutputResponseBody: Equatable {
    public let pipelineId: String?
}

extension CreatePipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
    }
}

public struct DeactivatePipelineInputBodyMiddleware: Middleware {
    public let id: String = "DeactivatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivatePipelineInput>
    public typealias MOutput = OperationOutput<DeactivatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivatePipelineOutputError>
}

extension DeactivatePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeactivatePipelineInput(cancelActive: \(String(describing: cancelActive)), pipelineId: \(String(describing: pipelineId)))"}
}

extension DeactivatePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cancelActive
        case pipelineId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cancelActive = cancelActive {
            try encodeContainer.encode(cancelActive, forKey: .cancelActive)
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
    }
}

public struct DeactivatePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "DeactivatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivatePipelineInput>
    public typealias MOutput = OperationOutput<DeactivatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivatePipelineOutputError>
}

public struct DeactivatePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "DeactivatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivatePipelineInput>
    public typealias MOutput = OperationOutput<DeactivatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivatePipelineOutputError>
}

/// <p>Contains the parameters for DeactivatePipeline.</p>
public struct DeactivatePipelineInput: Equatable {
    /// <p>Indicates whether to cancel any running objects. The default is true,
    ///           which sets the state of any running objects to <code>CANCELED</code>.
    ///           If this value is false, the pipeline is deactivated after all
    ///           running objects finish.</p>
    public let cancelActive: Bool?
    /// <p>The ID of the pipeline.</p>
    public let pipelineId: String?

    public init (
        cancelActive: Bool? = nil,
        pipelineId: String? = nil
    )
    {
        self.cancelActive = cancelActive
        self.pipelineId = pipelineId
    }
}

struct DeactivatePipelineInputBody: Equatable {
    public let pipelineId: String?
    public let cancelActive: Bool?
}

extension DeactivatePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cancelActive
        case pipelineId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let cancelActiveDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .cancelActive)
        cancelActive = cancelActiveDecoded
    }
}

extension DeactivatePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeactivatePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeactivatePipelineOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivatePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeactivatePipelineOutputResponse()"}
}

extension DeactivatePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of DeactivatePipeline.</p>
public struct DeactivatePipelineOutputResponse: Equatable {

    public init() {}
}

struct DeactivatePipelineOutputResponseBody: Equatable {
}

extension DeactivatePipelineOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePipelineInputBodyMiddleware: Middleware {
    public let id: String = "DeletePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePipelineOutputError>
}

extension DeletePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePipelineInput(pipelineId: \(String(describing: pipelineId)))"}
}

extension DeletePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
    }
}

public struct DeletePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePipelineOutputError>
}

public struct DeletePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePipelineOutputError>
}

/// <p>Contains the parameters for DeletePipeline.</p>
public struct DeletePipelineInput: Equatable {
    /// <p>The ID of the pipeline.</p>
    public let pipelineId: String?

    public init (
        pipelineId: String? = nil
    )
    {
        self.pipelineId = pipelineId
    }
}

struct DeletePipelineInputBody: Equatable {
    public let pipelineId: String?
}

extension DeletePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
    }
}

extension DeletePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePipelineOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePipelineOutputResponse()"}
}

extension DeletePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePipelineOutputResponse: Equatable {

    public init() {}
}

struct DeletePipelineOutputResponseBody: Equatable {
}

extension DeletePipelineOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeObjectsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeObjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeObjectsInput>
    public typealias MOutput = OperationOutput<DescribeObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeObjectsOutputError>
}

extension DescribeObjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeObjectsInput(evaluateExpressions: \(String(describing: evaluateExpressions)), marker: \(String(describing: marker)), objectIds: \(String(describing: objectIds)), pipelineId: \(String(describing: pipelineId)))"}
}

extension DescribeObjectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evaluateExpressions
        case marker
        case objectIds
        case pipelineId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if evaluateExpressions != false {
            try encodeContainer.encode(evaluateExpressions, forKey: .evaluateExpressions)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let objectIds = objectIds {
            var objectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectIds)
            for idlist0 in objectIds {
                try objectIdsContainer.encode(idlist0)
            }
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
    }
}

public struct DescribeObjectsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeObjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeObjectsInput>
    public typealias MOutput = OperationOutput<DescribeObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeObjectsOutputError>
}

public struct DescribeObjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeObjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeObjectsInput>
    public typealias MOutput = OperationOutput<DescribeObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeObjectsOutputError>
}

/// <p>Contains the parameters for DescribeObjects.</p>
public struct DescribeObjectsInput: Equatable {
    /// <p>Indicates whether any expressions in the object should be evaluated when the object descriptions are returned.</p>
    public let evaluateExpressions: Bool
    /// <p>The starting point for the results to be returned. For the first call, this value should be empty.
    ///            As long as there are more results, continue to call <code>DescribeObjects</code> with
    ///            the marker value from the previous call to retrieve the next set of results.</p>
    public let marker: String?
    /// <p>The IDs of the pipeline objects that contain the definitions to be described. You can pass as many as 25 identifiers in a single call to <code>DescribeObjects</code>.</p>
    public let objectIds: [String]?
    /// <p>The ID of the pipeline that contains the object definitions.</p>
    public let pipelineId: String?

    public init (
        evaluateExpressions: Bool = false,
        marker: String? = nil,
        objectIds: [String]? = nil,
        pipelineId: String? = nil
    )
    {
        self.evaluateExpressions = evaluateExpressions
        self.marker = marker
        self.objectIds = objectIds
        self.pipelineId = pipelineId
    }
}

struct DescribeObjectsInputBody: Equatable {
    public let pipelineId: String?
    public let objectIds: [String]?
    public let evaluateExpressions: Bool
    public let marker: String?
}

extension DescribeObjectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evaluateExpressions
        case marker
        case objectIds
        case pipelineId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let objectIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .objectIds)
        var objectIdsDecoded0:[String]? = nil
        if let objectIdsContainer = objectIdsContainer {
            objectIdsDecoded0 = [String]()
            for string0 in objectIdsContainer {
                if let string0 = string0 {
                    objectIdsDecoded0?.append(string0)
                }
            }
        }
        objectIds = objectIdsDecoded0
        let evaluateExpressionsDecoded = try containerValues.decode(Bool.self, forKey: .evaluateExpressions)
        evaluateExpressions = evaluateExpressionsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeObjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeObjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeObjectsOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeObjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeObjectsOutputResponse(hasMoreResults: \(String(describing: hasMoreResults)), marker: \(String(describing: marker)), pipelineObjects: \(String(describing: pipelineObjects)))"}
}

extension DescribeObjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeObjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hasMoreResults = output.hasMoreResults
            self.marker = output.marker
            self.pipelineObjects = output.pipelineObjects
        } else {
            self.hasMoreResults = false
            self.marker = nil
            self.pipelineObjects = nil
        }
    }
}

/// <p>Contains the output of DescribeObjects.</p>
public struct DescribeObjectsOutputResponse: Equatable {
    /// <p>Indicates whether there are more results to return.</p>
    public let hasMoreResults: Bool
    /// <p>The starting point for the next page of results. To view the next page of results, call <code>DescribeObjects</code>
    ///            again with this marker value. If the value is null, there are no more results.</p>
    public let marker: String?
    /// <p>An array of object definitions.</p>
    public let pipelineObjects: [PipelineObject]?

    public init (
        hasMoreResults: Bool = false,
        marker: String? = nil,
        pipelineObjects: [PipelineObject]? = nil
    )
    {
        self.hasMoreResults = hasMoreResults
        self.marker = marker
        self.pipelineObjects = pipelineObjects
    }
}

struct DescribeObjectsOutputResponseBody: Equatable {
    public let pipelineObjects: [PipelineObject]?
    public let marker: String?
    public let hasMoreResults: Bool
}

extension DescribeObjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hasMoreResults
        case marker
        case pipelineObjects
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineObjectsContainer = try containerValues.decodeIfPresent([PipelineObject?].self, forKey: .pipelineObjects)
        var pipelineObjectsDecoded0:[PipelineObject]? = nil
        if let pipelineObjectsContainer = pipelineObjectsContainer {
            pipelineObjectsDecoded0 = [PipelineObject]()
            for structure0 in pipelineObjectsContainer {
                if let structure0 = structure0 {
                    pipelineObjectsDecoded0?.append(structure0)
                }
            }
        }
        pipelineObjects = pipelineObjectsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let hasMoreResultsDecoded = try containerValues.decode(Bool.self, forKey: .hasMoreResults)
        hasMoreResults = hasMoreResultsDecoded
    }
}

public struct DescribePipelinesInputBodyMiddleware: Middleware {
    public let id: String = "DescribePipelinesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePipelinesInput>
    public typealias MOutput = OperationOutput<DescribePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePipelinesOutputError>
}

extension DescribePipelinesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePipelinesInput(pipelineIds: \(String(describing: pipelineIds)))"}
}

extension DescribePipelinesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineIds = pipelineIds {
            var pipelineIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineIds)
            for idlist0 in pipelineIds {
                try pipelineIdsContainer.encode(idlist0)
            }
        }
    }
}

public struct DescribePipelinesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePipelinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePipelinesInput>
    public typealias MOutput = OperationOutput<DescribePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePipelinesOutputError>
}

public struct DescribePipelinesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePipelinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePipelinesInput>
    public typealias MOutput = OperationOutput<DescribePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePipelinesOutputError>
}

/// <p>Contains the parameters for DescribePipelines.</p>
public struct DescribePipelinesInput: Equatable {
    /// <p>The IDs of the pipelines to describe. You can pass as many as 25 identifiers in a single call.
    ///             To obtain pipeline IDs, call <a>ListPipelines</a>.</p>
    public let pipelineIds: [String]?

    public init (
        pipelineIds: [String]? = nil
    )
    {
        self.pipelineIds = pipelineIds
    }
}

struct DescribePipelinesInputBody: Equatable {
    public let pipelineIds: [String]?
}

extension DescribePipelinesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .pipelineIds)
        var pipelineIdsDecoded0:[String]? = nil
        if let pipelineIdsContainer = pipelineIdsContainer {
            pipelineIdsDecoded0 = [String]()
            for string0 in pipelineIdsContainer {
                if let string0 = string0 {
                    pipelineIdsDecoded0?.append(string0)
                }
            }
        }
        pipelineIds = pipelineIdsDecoded0
    }
}

extension DescribePipelinesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePipelinesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePipelinesOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePipelinesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePipelinesOutputResponse(pipelineDescriptionList: \(String(describing: pipelineDescriptionList)))"}
}

extension DescribePipelinesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePipelinesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pipelineDescriptionList = output.pipelineDescriptionList
        } else {
            self.pipelineDescriptionList = nil
        }
    }
}

/// <p>Contains the output of DescribePipelines.</p>
public struct DescribePipelinesOutputResponse: Equatable {
    /// <p>An array of descriptions for the specified pipelines.</p>
    public let pipelineDescriptionList: [PipelineDescription]?

    public init (
        pipelineDescriptionList: [PipelineDescription]? = nil
    )
    {
        self.pipelineDescriptionList = pipelineDescriptionList
    }
}

struct DescribePipelinesOutputResponseBody: Equatable {
    public let pipelineDescriptionList: [PipelineDescription]?
}

extension DescribePipelinesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineDescriptionList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDescriptionListContainer = try containerValues.decodeIfPresent([PipelineDescription?].self, forKey: .pipelineDescriptionList)
        var pipelineDescriptionListDecoded0:[PipelineDescription]? = nil
        if let pipelineDescriptionListContainer = pipelineDescriptionListContainer {
            pipelineDescriptionListDecoded0 = [PipelineDescription]()
            for structure0 in pipelineDescriptionListContainer {
                if let structure0 = structure0 {
                    pipelineDescriptionListDecoded0?.append(structure0)
                }
            }
        }
        pipelineDescriptionList = pipelineDescriptionListDecoded0
    }
}

public struct EvaluateExpressionInputBodyMiddleware: Middleware {
    public let id: String = "EvaluateExpressionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EvaluateExpressionInput>,
                  next: H) -> Swift.Result<OperationOutput<EvaluateExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EvaluateExpressionInput>
    public typealias MOutput = OperationOutput<EvaluateExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EvaluateExpressionOutputError>
}

extension EvaluateExpressionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EvaluateExpressionInput(expression: \(String(describing: expression)), objectId: \(String(describing: objectId)), pipelineId: \(String(describing: pipelineId)))"}
}

extension EvaluateExpressionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expression
        case objectId
        case pipelineId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let objectId = objectId {
            try encodeContainer.encode(objectId, forKey: .objectId)
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
    }
}

public struct EvaluateExpressionInputHeadersMiddleware: Middleware {
    public let id: String = "EvaluateExpressionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EvaluateExpressionInput>,
                  next: H) -> Swift.Result<OperationOutput<EvaluateExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EvaluateExpressionInput>
    public typealias MOutput = OperationOutput<EvaluateExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EvaluateExpressionOutputError>
}

public struct EvaluateExpressionInputQueryItemMiddleware: Middleware {
    public let id: String = "EvaluateExpressionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EvaluateExpressionInput>,
                  next: H) -> Swift.Result<OperationOutput<EvaluateExpressionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EvaluateExpressionInput>
    public typealias MOutput = OperationOutput<EvaluateExpressionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EvaluateExpressionOutputError>
}

/// <p>Contains the parameters for EvaluateExpression.</p>
public struct EvaluateExpressionInput: Equatable {
    /// <p>The expression to evaluate.</p>
    public let expression: String?
    /// <p>The ID of the object.</p>
    public let objectId: String?
    /// <p>The ID of the pipeline.</p>
    public let pipelineId: String?

    public init (
        expression: String? = nil,
        objectId: String? = nil,
        pipelineId: String? = nil
    )
    {
        self.expression = expression
        self.objectId = objectId
        self.pipelineId = pipelineId
    }
}

struct EvaluateExpressionInputBody: Equatable {
    public let pipelineId: String?
    public let objectId: String?
    public let expression: String?
}

extension EvaluateExpressionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expression
        case objectId
        case pipelineId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let objectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectId)
        objectId = objectIdDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension EvaluateExpressionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EvaluateExpressionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskNotFoundException" : self = .taskNotFoundException(try TaskNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EvaluateExpressionOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case taskNotFoundException(TaskNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EvaluateExpressionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EvaluateExpressionOutputResponse(evaluatedExpression: \(String(describing: evaluatedExpression)))"}
}

extension EvaluateExpressionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EvaluateExpressionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.evaluatedExpression = output.evaluatedExpression
        } else {
            self.evaluatedExpression = nil
        }
    }
}

/// <p>Contains the output of EvaluateExpression.</p>
public struct EvaluateExpressionOutputResponse: Equatable {
    /// <p>The evaluated expression.</p>
    public let evaluatedExpression: String?

    public init (
        evaluatedExpression: String? = nil
    )
    {
        self.evaluatedExpression = evaluatedExpression
    }
}

struct EvaluateExpressionOutputResponseBody: Equatable {
    public let evaluatedExpression: String?
}

extension EvaluateExpressionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evaluatedExpression
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluatedExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evaluatedExpression)
        evaluatedExpression = evaluatedExpressionDecoded
    }
}

extension Field: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case refValue
        case stringValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let refValue = refValue {
            try encodeContainer.encode(refValue, forKey: .refValue)
        }
        if let stringValue = stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let refValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refValue)
        refValue = refValueDecoded
    }
}

extension Field: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Field(key: \(String(describing: key)), refValue: \(String(describing: refValue)), stringValue: \(String(describing: stringValue)))"}
}

/// <p>A key-value pair that describes a property of a pipeline object. The value is specified as either a string value (<code>StringValue</code>) or a reference to another object (<code>RefValue</code>) but not as both.</p>
public struct Field: Equatable {
    /// <p>The field identifier.</p>
    public let key: String?
    /// <p>The field value, expressed as the identifier of another object.</p>
    public let refValue: String?
    /// <p>The field value, expressed as a String.</p>
    public let stringValue: String?

    public init (
        key: String? = nil,
        refValue: String? = nil,
        stringValue: String? = nil
    )
    {
        self.key = key
        self.refValue = refValue
        self.stringValue = stringValue
    }
}

public struct GetPipelineDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "GetPipelineDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPipelineDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPipelineDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPipelineDefinitionInput>
    public typealias MOutput = OperationOutput<GetPipelineDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPipelineDefinitionOutputError>
}

extension GetPipelineDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPipelineDefinitionInput(pipelineId: \(String(describing: pipelineId)), version: \(String(describing: version)))"}
}

extension GetPipelineDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineId
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct GetPipelineDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetPipelineDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPipelineDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPipelineDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPipelineDefinitionInput>
    public typealias MOutput = OperationOutput<GetPipelineDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPipelineDefinitionOutputError>
}

public struct GetPipelineDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPipelineDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPipelineDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPipelineDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPipelineDefinitionInput>
    public typealias MOutput = OperationOutput<GetPipelineDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPipelineDefinitionOutputError>
}

/// <p>Contains the parameters for GetPipelineDefinition.</p>
public struct GetPipelineDefinitionInput: Equatable {
    /// <p>The ID of the pipeline.</p>
    public let pipelineId: String?
    /// <p>The version of the pipeline definition to retrieve. Set this parameter to <code>latest</code> (default)
    ///             to use the last definition saved to the pipeline or <code>active</code> to use the last definition
    ///             that was activated.</p>
    public let version: String?

    public init (
        pipelineId: String? = nil,
        version: String? = nil
    )
    {
        self.pipelineId = pipelineId
        self.version = version
    }
}

struct GetPipelineDefinitionInputBody: Equatable {
    public let pipelineId: String?
    public let version: String?
}

extension GetPipelineDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineId
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetPipelineDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPipelineDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPipelineDefinitionOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPipelineDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPipelineDefinitionOutputResponse(parameterObjects: \(String(describing: parameterObjects)), parameterValues: \(String(describing: parameterValues)), pipelineObjects: \(String(describing: pipelineObjects)))"}
}

extension GetPipelineDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPipelineDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.parameterObjects = output.parameterObjects
            self.parameterValues = output.parameterValues
            self.pipelineObjects = output.pipelineObjects
        } else {
            self.parameterObjects = nil
            self.parameterValues = nil
            self.pipelineObjects = nil
        }
    }
}

/// <p>Contains the output of GetPipelineDefinition.</p>
public struct GetPipelineDefinitionOutputResponse: Equatable {
    /// <p>The parameter objects used in the pipeline definition.</p>
    public let parameterObjects: [ParameterObject]?
    /// <p>The parameter values used in the pipeline definition.</p>
    public let parameterValues: [ParameterValue]?
    /// <p>The objects defined in the pipeline.</p>
    public let pipelineObjects: [PipelineObject]?

    public init (
        parameterObjects: [ParameterObject]? = nil,
        parameterValues: [ParameterValue]? = nil,
        pipelineObjects: [PipelineObject]? = nil
    )
    {
        self.parameterObjects = parameterObjects
        self.parameterValues = parameterValues
        self.pipelineObjects = pipelineObjects
    }
}

struct GetPipelineDefinitionOutputResponseBody: Equatable {
    public let pipelineObjects: [PipelineObject]?
    public let parameterObjects: [ParameterObject]?
    public let parameterValues: [ParameterValue]?
}

extension GetPipelineDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameterObjects
        case parameterValues
        case pipelineObjects
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineObjectsContainer = try containerValues.decodeIfPresent([PipelineObject?].self, forKey: .pipelineObjects)
        var pipelineObjectsDecoded0:[PipelineObject]? = nil
        if let pipelineObjectsContainer = pipelineObjectsContainer {
            pipelineObjectsDecoded0 = [PipelineObject]()
            for structure0 in pipelineObjectsContainer {
                if let structure0 = structure0 {
                    pipelineObjectsDecoded0?.append(structure0)
                }
            }
        }
        pipelineObjects = pipelineObjectsDecoded0
        let parameterObjectsContainer = try containerValues.decodeIfPresent([ParameterObject?].self, forKey: .parameterObjects)
        var parameterObjectsDecoded0:[ParameterObject]? = nil
        if let parameterObjectsContainer = parameterObjectsContainer {
            parameterObjectsDecoded0 = [ParameterObject]()
            for structure0 in parameterObjectsContainer {
                if let structure0 = structure0 {
                    parameterObjectsDecoded0?.append(structure0)
                }
            }
        }
        parameterObjects = parameterObjectsDecoded0
        let parameterValuesContainer = try containerValues.decodeIfPresent([ParameterValue?].self, forKey: .parameterValues)
        var parameterValuesDecoded0:[ParameterValue]? = nil
        if let parameterValuesContainer = parameterValuesContainer {
            parameterValuesDecoded0 = [ParameterValue]()
            for structure0 in parameterValuesContainer {
                if let structure0 = structure0 {
                    parameterValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterValues = parameterValuesDecoded0
    }
}

extension InstanceIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case document
        case signature
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let signature = signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .document)
        document = documentDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signature)
        signature = signatureDecoded
    }
}

extension InstanceIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceIdentity(document: \(String(describing: document)), signature: \(String(describing: signature)))"}
}

/// <p><p>Identity information for the EC2 instance that is hosting the task runner. You can get this value by calling a metadata URI from the EC2 instance.
///             For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AESDG-chapter-instancedata.html">Instance Metadata</a> in the <i>Amazon Elastic Compute Cloud User Guide.</i>
///             Passing in this value proves that your task runner is running on an EC2 instance, and ensures the proper AWS Data Pipeline service charges are applied to your pipeline.</p></p>
public struct InstanceIdentity: Equatable {
    /// <p>A description of an EC2 instance that is generated when the instance is launched and exposed to the instance via the instance metadata service in the form of a JSON representation of an object.</p>
    public let document: String?
    /// <p>A signature which can be used to verify the accuracy and authenticity of the information provided in the instance identity document.</p>
    public let signature: String?

    public init (
        document: String? = nil,
        signature: String? = nil
    )
    {
        self.document = document
        self.signature = signature
    }
}

extension InternalServiceError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceError(message: \(String(describing: message)))"}
}

extension InternalServiceError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal service error occurred.</p>
public struct InternalServiceError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>Description of the error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Equatable {
    public let message: String?
}

extension InternalServiceErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was not valid. Verify that your request was properly formatted, that the signature was generated with the correct credentials, and that you haven't exceeded any of the service limits for your account.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Description of the error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListPipelinesInputBodyMiddleware: Middleware {
    public let id: String = "ListPipelinesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelinesOutputError>
}

extension ListPipelinesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPipelinesInput(marker: \(String(describing: marker)))"}
}

extension ListPipelinesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case marker
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
    }
}

public struct ListPipelinesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPipelinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelinesOutputError>
}

public struct ListPipelinesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPipelinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelinesOutputError>
}

/// <p>Contains the parameters for ListPipelines.</p>
public struct ListPipelinesInput: Equatable {
    /// <p>The starting point for the results to be returned. For the first call, this value should be empty.
    ///            As long as there are more results, continue to call <code>ListPipelines</code> with
    ///            the marker value from the previous call to retrieve the next set of results.</p>
    public let marker: String?

    public init (
        marker: String? = nil
    )
    {
        self.marker = marker
    }
}

struct ListPipelinesInputBody: Equatable {
    public let marker: String?
}

extension ListPipelinesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListPipelinesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPipelinesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPipelinesOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPipelinesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPipelinesOutputResponse(hasMoreResults: \(String(describing: hasMoreResults)), marker: \(String(describing: marker)), pipelineIdList: \(String(describing: pipelineIdList)))"}
}

extension ListPipelinesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPipelinesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hasMoreResults = output.hasMoreResults
            self.marker = output.marker
            self.pipelineIdList = output.pipelineIdList
        } else {
            self.hasMoreResults = false
            self.marker = nil
            self.pipelineIdList = nil
        }
    }
}

/// <p>Contains the output of ListPipelines.</p>
public struct ListPipelinesOutputResponse: Equatable {
    /// <p>Indicates whether there are more results that can be obtained by a subsequent call.</p>
    public let hasMoreResults: Bool
    /// <p>The starting point for the next page of results. To view the next page of results, call <code>ListPipelinesOutput</code>
    ///            again with this marker value. If the value is null, there are no more results.</p>
    public let marker: String?
    /// <p>The pipeline identifiers. If you require additional information about the pipelines, you can use these identifiers to call
    ///             <a>DescribePipelines</a> and <a>GetPipelineDefinition</a>.</p>
    public let pipelineIdList: [PipelineIdName]?

    public init (
        hasMoreResults: Bool = false,
        marker: String? = nil,
        pipelineIdList: [PipelineIdName]? = nil
    )
    {
        self.hasMoreResults = hasMoreResults
        self.marker = marker
        self.pipelineIdList = pipelineIdList
    }
}

struct ListPipelinesOutputResponseBody: Equatable {
    public let pipelineIdList: [PipelineIdName]?
    public let marker: String?
    public let hasMoreResults: Bool
}

extension ListPipelinesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hasMoreResults
        case marker
        case pipelineIdList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdListContainer = try containerValues.decodeIfPresent([PipelineIdName?].self, forKey: .pipelineIdList)
        var pipelineIdListDecoded0:[PipelineIdName]? = nil
        if let pipelineIdListContainer = pipelineIdListContainer {
            pipelineIdListDecoded0 = [PipelineIdName]()
            for structure0 in pipelineIdListContainer {
                if let structure0 = structure0 {
                    pipelineIdListDecoded0?.append(structure0)
                }
            }
        }
        pipelineIdList = pipelineIdListDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let hasMoreResultsDecoded = try containerValues.decode(Bool.self, forKey: .hasMoreResults)
        hasMoreResults = hasMoreResultsDecoded
    }
}

extension Operator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for stringlist0 in values {
                try valuesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OperatorType.self, forKey: .type)
        type = typeDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Operator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Operator(type: \(String(describing: type)), values: \(String(describing: values)))"}
}

/// <p>Contains a logical operation for comparing the value of a field with a specified value.</p>
public struct Operator: Equatable {
    /// <p>
    ///             The logical operation to be performed: equal (<code>EQ</code>), equal reference (<code>REF_EQ</code>), less than or equal (<code>LE</code>), greater than or equal (<code>GE</code>), or between (<code>BETWEEN</code>). Equal reference (<code>REF_EQ</code>) can be used only with reference fields. The other comparison types can be used only with String fields. The comparison types you can use apply only to certain object fields, as detailed below.
    ///         </p>
    ///         <p>
    ///           The comparison operators EQ and REF_EQ act on the following fields:
    ///         </p>
    ///         <ul>
    ///             <li>name</li>
    ///             <li>@sphere</li>
    ///             <li>parent</li>
    ///             <li>@componentParent</li>
    ///             <li>@instanceParent</li>
    ///             <li>@status</li>
    ///             <li>@scheduledStartTime</li>
    ///             <li>@scheduledEndTime</li>
    ///             <li>@actualStartTime</li>
    ///             <li>@actualEndTime</li>
    ///         </ul>
    ///
    ///         <p>
    ///             The comparison operators <code>GE</code>, <code>LE</code>, and <code>BETWEEN</code> act on the following fields:
    ///         </p>
    ///         <ul>
    ///             <li>@scheduledStartTime</li>
    ///             <li>@scheduledEndTime</li>
    ///             <li>@actualStartTime</li>
    ///             <li>@actualEndTime</li>
    ///         </ul>
    ///         <p>Note that fields beginning with the at sign (@) are read-only and set by the web service. When you name fields, you should choose names containing only alpha-numeric values, as symbols may be reserved by AWS Data Pipeline. User-defined fields that you add to a pipeline should prefix their name with the string "my".</p>
    public let type: OperatorType?
    /// <p>The value that the actual field value will be compared with.</p>
    public let values: [String]?

    public init (
        type: OperatorType? = nil,
        values: [String]? = nil
    )
    {
        self.type = type
        self.values = values
    }
}

public enum OperatorType {
    case between
    case equal
    case greaterthanorequal
    case lessthanorequal
    case referenceequal
    case sdkUnknown(String)
}

extension OperatorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperatorType] {
        return [
            .between,
            .equal,
            .greaterthanorequal,
            .lessthanorequal,
            .referenceequal,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .between: return "BETWEEN"
        case .equal: return "EQ"
        case .greaterthanorequal: return "GE"
        case .lessthanorequal: return "LE"
        case .referenceequal: return "REF_EQ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperatorType(rawValue: rawValue) ?? OperatorType.sdkUnknown(rawValue)
    }
}

extension ParameterAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case stringValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let stringValue = stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
    }
}

extension ParameterAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterAttribute(key: \(String(describing: key)), stringValue: \(String(describing: stringValue)))"}
}

/// <p>The attributes allowed or specified with a parameter object.</p>
public struct ParameterAttribute: Equatable {
    /// <p>The field identifier.</p>
    public let key: String?
    /// <p>The field value, expressed as a String.</p>
    public let stringValue: String?

    public init (
        key: String? = nil,
        stringValue: String? = nil
    )
    {
        self.key = key
        self.stringValue = stringValue
    }
}

extension ParameterObject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for parameterattributelist0 in attributes {
                try attributesContainer.encode(parameterattributelist0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let attributesContainer = try containerValues.decodeIfPresent([ParameterAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ParameterAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ParameterAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ParameterObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterObject(attributes: \(String(describing: attributes)), id: \(String(describing: id)))"}
}

/// <p>Contains information about a parameter object.</p>
public struct ParameterObject: Equatable {
    /// <p>The attributes of the parameter object.</p>
    public let attributes: [ParameterAttribute]?
    /// <p>The ID of the parameter object. </p>
    public let id: String?

    public init (
        attributes: [ParameterAttribute]? = nil,
        id: String? = nil
    )
    {
        self.attributes = attributes
        self.id = id
    }
}

extension ParameterValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case stringValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let stringValue = stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
    }
}

extension ParameterValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterValue(id: \(String(describing: id)), stringValue: \(String(describing: stringValue)))"}
}

/// <p>A value or list of parameter values. </p>
public struct ParameterValue: Equatable {
    /// <p>The ID of the parameter value.</p>
    public let id: String?
    /// <p>The field value, expressed as a String.</p>
    public let stringValue: String?

    public init (
        id: String? = nil,
        stringValue: String? = nil
    )
    {
        self.id = id
        self.stringValue = stringValue
    }
}

extension PipelineDeletedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineDeletedException(message: \(String(describing: message)))"}
}

extension PipelineDeletedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PipelineDeletedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified pipeline has been deleted.</p>
public struct PipelineDeletedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Description of the error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PipelineDeletedExceptionBody: Equatable {
    public let message: String?
}

extension PipelineDeletedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PipelineDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case fields
        case name
        case pipelineId
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldlist0 in fields {
                try fieldsContainer.encode(fieldlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Field?].self, forKey: .fields)
        var fieldsDecoded0:[Field]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Field]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PipelineDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineDescription(description: \(String(describing: description)), fields: \(String(describing: fields)), name: \(String(describing: name)), pipelineId: \(String(describing: pipelineId)), tags: \(String(describing: tags)))"}
}

/// <p>Contains pipeline metadata.</p>
public struct PipelineDescription: Equatable {
    /// <p>Description of the pipeline.</p>
    public let description: String?
    /// <p>A list of read-only fields that contain metadata about the pipeline: @userId, @accountId, and @pipelineState.</p>
    public let fields: [Field]?
    /// <p>The name of the pipeline.</p>
    public let name: String?
    /// <p>The pipeline identifier that was assigned by AWS Data Pipeline. This is a string of the form <code>df-297EG78HU43EEXAMPLE</code>.</p>
    public let pipelineId: String?
    /// <p>A list of tags to associated with a pipeline. Tags let you control access to pipelines.
    ///             For more information, see <a href="http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-control-access.html">Controlling User Access to Pipelines</a> in the <i>AWS Data Pipeline Developer Guide</i>.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        fields: [Field]? = nil,
        name: String? = nil,
        pipelineId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.fields = fields
        self.name = name
        self.pipelineId = pipelineId
        self.tags = tags
    }
}

extension PipelineIdName: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension PipelineIdName: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineIdName(id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Contains the name and identifier of a pipeline.</p>
public struct PipelineIdName: Equatable {
    /// <p>The ID of the pipeline that was assigned by AWS Data Pipeline. This is a string of the form <code>df-297EG78HU43EEXAMPLE</code>.</p>
    public let id: String?
    /// <p>The name of the pipeline.</p>
    public let name: String?

    public init (
        id: String? = nil,
        name: String? = nil
    )
    {
        self.id = id
        self.name = name
    }
}

extension PipelineNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineNotFoundException(message: \(String(describing: message)))"}
}

extension PipelineNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PipelineNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified pipeline was not found. Verify that you used the correct user and account identifiers.</p>
public struct PipelineNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Description of the error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PipelineNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension PipelineNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PipelineObject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fields
        case id
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldlist0 in fields {
                try fieldsContainer.encode(fieldlist0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Field?].self, forKey: .fields)
        var fieldsDecoded0:[Field]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Field]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension PipelineObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineObject(fields: \(String(describing: fields)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Contains information about a pipeline object. This can be a logical, physical, or physical attempt pipeline object. The complete set of components of a pipeline defines the pipeline.</p>
public struct PipelineObject: Equatable {
    /// <p>Key-value pairs that define the properties of the object.</p>
    public let fields: [Field]?
    /// <p>The ID of the object.</p>
    public let id: String?
    /// <p>The name of the object.</p>
    public let name: String?

    public init (
        fields: [Field]? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.fields = fields
        self.id = id
        self.name = name
    }
}

public struct PollForTaskInputBodyMiddleware: Middleware {
    public let id: String = "PollForTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PollForTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<PollForTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PollForTaskInput>
    public typealias MOutput = OperationOutput<PollForTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PollForTaskOutputError>
}

extension PollForTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PollForTaskInput(hostname: \(String(describing: hostname)), instanceIdentity: \(String(describing: instanceIdentity)), workerGroup: \(String(describing: workerGroup)))"}
}

extension PollForTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostname
        case instanceIdentity
        case workerGroup
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let instanceIdentity = instanceIdentity {
            try encodeContainer.encode(instanceIdentity, forKey: .instanceIdentity)
        }
        if let workerGroup = workerGroup {
            try encodeContainer.encode(workerGroup, forKey: .workerGroup)
        }
    }
}

public struct PollForTaskInputHeadersMiddleware: Middleware {
    public let id: String = "PollForTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PollForTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<PollForTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PollForTaskInput>
    public typealias MOutput = OperationOutput<PollForTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PollForTaskOutputError>
}

public struct PollForTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "PollForTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PollForTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<PollForTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PollForTaskInput>
    public typealias MOutput = OperationOutput<PollForTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PollForTaskOutputError>
}

/// <p>Contains the parameters for PollForTask.</p>
public struct PollForTaskInput: Equatable {
    /// <p>The public DNS name of the calling task runner.</p>
    public let hostname: String?
    /// <p>Identity information for the EC2 instance that is hosting the task runner. You can get this value from the instance using <code>http://169.254.169.254/latest/meta-data/instance-id</code>. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AESDG-chapter-instancedata.html">Instance Metadata</a> in the <i>Amazon Elastic Compute Cloud User Guide.</i> Passing in this value proves that your task runner is running on an EC2 instance, and ensures the proper AWS Data Pipeline service charges are applied to your pipeline.</p>
    public let instanceIdentity: InstanceIdentity?
    /// <p>The type of task the task runner is configured to accept and process. The worker group is set as a field on objects in the pipeline when they are created.
    ///             You can only specify a single value for <code>workerGroup</code> in the call to <code>PollForTask</code>. There are no wildcard values permitted in
    ///             <code>workerGroup</code>; the string must be an exact, case-sensitive, match.</p>
    public let workerGroup: String?

    public init (
        hostname: String? = nil,
        instanceIdentity: InstanceIdentity? = nil,
        workerGroup: String? = nil
    )
    {
        self.hostname = hostname
        self.instanceIdentity = instanceIdentity
        self.workerGroup = workerGroup
    }
}

struct PollForTaskInputBody: Equatable {
    public let workerGroup: String?
    public let hostname: String?
    public let instanceIdentity: InstanceIdentity?
}

extension PollForTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hostname
        case instanceIdentity
        case workerGroup
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerGroup)
        workerGroup = workerGroupDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let instanceIdentityDecoded = try containerValues.decodeIfPresent(InstanceIdentity.self, forKey: .instanceIdentity)
        instanceIdentity = instanceIdentityDecoded
    }
}

extension PollForTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PollForTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskNotFoundException" : self = .taskNotFoundException(try TaskNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PollForTaskOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case taskNotFoundException(TaskNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PollForTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PollForTaskOutputResponse(taskObject: \(String(describing: taskObject)))"}
}

extension PollForTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PollForTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.taskObject = output.taskObject
        } else {
            self.taskObject = nil
        }
    }
}

/// <p>Contains the output of PollForTask.</p>
public struct PollForTaskOutputResponse: Equatable {
    /// <p>The information needed to complete the task that is being assigned to the task runner. One of the fields returned in this object is <code>taskId</code>,
    ///             which contains an identifier for the task being assigned. The calling task runner uses <code>taskId</code> in subsequent calls to <a>ReportTaskProgress</a>
    ///             and <a>SetTaskStatus</a>.</p>
    public let taskObject: TaskObject?

    public init (
        taskObject: TaskObject? = nil
    )
    {
        self.taskObject = taskObject
    }
}

struct PollForTaskOutputResponseBody: Equatable {
    public let taskObject: TaskObject?
}

extension PollForTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskObject
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskObjectDecoded = try containerValues.decodeIfPresent(TaskObject.self, forKey: .taskObject)
        taskObject = taskObjectDecoded
    }
}

public struct PutPipelineDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "PutPipelineDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPipelineDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPipelineDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPipelineDefinitionInput>
    public typealias MOutput = OperationOutput<PutPipelineDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPipelineDefinitionOutputError>
}

extension PutPipelineDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPipelineDefinitionInput(parameterObjects: \(String(describing: parameterObjects)), parameterValues: \(String(describing: parameterValues)), pipelineId: \(String(describing: pipelineId)), pipelineObjects: \(String(describing: pipelineObjects)))"}
}

extension PutPipelineDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterObjects
        case parameterValues
        case pipelineId
        case pipelineObjects
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterObjects = parameterObjects {
            var parameterObjectsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterObjects)
            for parameterobjectlist0 in parameterObjects {
                try parameterObjectsContainer.encode(parameterobjectlist0)
            }
        }
        if let parameterValues = parameterValues {
            var parameterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterValues)
            for parametervaluelist0 in parameterValues {
                try parameterValuesContainer.encode(parametervaluelist0)
            }
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let pipelineObjects = pipelineObjects {
            var pipelineObjectsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineObjects)
            for pipelineobjectlist0 in pipelineObjects {
                try pipelineObjectsContainer.encode(pipelineobjectlist0)
            }
        }
    }
}

public struct PutPipelineDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "PutPipelineDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPipelineDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPipelineDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPipelineDefinitionInput>
    public typealias MOutput = OperationOutput<PutPipelineDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPipelineDefinitionOutputError>
}

public struct PutPipelineDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutPipelineDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPipelineDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPipelineDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPipelineDefinitionInput>
    public typealias MOutput = OperationOutput<PutPipelineDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPipelineDefinitionOutputError>
}

/// <p>Contains the parameters for PutPipelineDefinition.</p>
public struct PutPipelineDefinitionInput: Equatable {
    /// <p>The parameter objects used with the pipeline.</p>
    public let parameterObjects: [ParameterObject]?
    /// <p>The parameter values used with the pipeline.</p>
    public let parameterValues: [ParameterValue]?
    /// <p>The ID of the pipeline.</p>
    public let pipelineId: String?
    /// <p>The objects that define the pipeline. These objects overwrite the existing pipeline definition.</p>
    public let pipelineObjects: [PipelineObject]?

    public init (
        parameterObjects: [ParameterObject]? = nil,
        parameterValues: [ParameterValue]? = nil,
        pipelineId: String? = nil,
        pipelineObjects: [PipelineObject]? = nil
    )
    {
        self.parameterObjects = parameterObjects
        self.parameterValues = parameterValues
        self.pipelineId = pipelineId
        self.pipelineObjects = pipelineObjects
    }
}

struct PutPipelineDefinitionInputBody: Equatable {
    public let pipelineId: String?
    public let pipelineObjects: [PipelineObject]?
    public let parameterObjects: [ParameterObject]?
    public let parameterValues: [ParameterValue]?
}

extension PutPipelineDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameterObjects
        case parameterValues
        case pipelineId
        case pipelineObjects
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let pipelineObjectsContainer = try containerValues.decodeIfPresent([PipelineObject?].self, forKey: .pipelineObjects)
        var pipelineObjectsDecoded0:[PipelineObject]? = nil
        if let pipelineObjectsContainer = pipelineObjectsContainer {
            pipelineObjectsDecoded0 = [PipelineObject]()
            for structure0 in pipelineObjectsContainer {
                if let structure0 = structure0 {
                    pipelineObjectsDecoded0?.append(structure0)
                }
            }
        }
        pipelineObjects = pipelineObjectsDecoded0
        let parameterObjectsContainer = try containerValues.decodeIfPresent([ParameterObject?].self, forKey: .parameterObjects)
        var parameterObjectsDecoded0:[ParameterObject]? = nil
        if let parameterObjectsContainer = parameterObjectsContainer {
            parameterObjectsDecoded0 = [ParameterObject]()
            for structure0 in parameterObjectsContainer {
                if let structure0 = structure0 {
                    parameterObjectsDecoded0?.append(structure0)
                }
            }
        }
        parameterObjects = parameterObjectsDecoded0
        let parameterValuesContainer = try containerValues.decodeIfPresent([ParameterValue?].self, forKey: .parameterValues)
        var parameterValuesDecoded0:[ParameterValue]? = nil
        if let parameterValuesContainer = parameterValuesContainer {
            parameterValuesDecoded0 = [ParameterValue]()
            for structure0 in parameterValuesContainer {
                if let structure0 = structure0 {
                    parameterValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterValues = parameterValuesDecoded0
    }
}

extension PutPipelineDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPipelineDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPipelineDefinitionOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPipelineDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPipelineDefinitionOutputResponse(errored: \(String(describing: errored)), validationErrors: \(String(describing: validationErrors)), validationWarnings: \(String(describing: validationWarnings)))"}
}

extension PutPipelineDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutPipelineDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errored = output.errored
            self.validationErrors = output.validationErrors
            self.validationWarnings = output.validationWarnings
        } else {
            self.errored = false
            self.validationErrors = nil
            self.validationWarnings = nil
        }
    }
}

/// <p>Contains the output of PutPipelineDefinition.</p>
public struct PutPipelineDefinitionOutputResponse: Equatable {
    /// <p>Indicates whether there were validation errors, and the pipeline definition is stored but cannot be
    ///             activated until you correct the pipeline and call <code>PutPipelineDefinition</code> to commit the corrected pipeline.</p>
    public let errored: Bool
    /// <p>The validation errors that are associated with the objects defined in <code>pipelineObjects</code>.</p>
    public let validationErrors: [ValidationError]?
    /// <p>The validation warnings that are associated with the objects defined in <code>pipelineObjects</code>.</p>
    public let validationWarnings: [ValidationWarning]?

    public init (
        errored: Bool = false,
        validationErrors: [ValidationError]? = nil,
        validationWarnings: [ValidationWarning]? = nil
    )
    {
        self.errored = errored
        self.validationErrors = validationErrors
        self.validationWarnings = validationWarnings
    }
}

struct PutPipelineDefinitionOutputResponseBody: Equatable {
    public let validationErrors: [ValidationError]?
    public let validationWarnings: [ValidationWarning]?
    public let errored: Bool
}

extension PutPipelineDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errored
        case validationErrors
        case validationWarnings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationErrorsContainer = try containerValues.decodeIfPresent([ValidationError?].self, forKey: .validationErrors)
        var validationErrorsDecoded0:[ValidationError]? = nil
        if let validationErrorsContainer = validationErrorsContainer {
            validationErrorsDecoded0 = [ValidationError]()
            for structure0 in validationErrorsContainer {
                if let structure0 = structure0 {
                    validationErrorsDecoded0?.append(structure0)
                }
            }
        }
        validationErrors = validationErrorsDecoded0
        let validationWarningsContainer = try containerValues.decodeIfPresent([ValidationWarning?].self, forKey: .validationWarnings)
        var validationWarningsDecoded0:[ValidationWarning]? = nil
        if let validationWarningsContainer = validationWarningsContainer {
            validationWarningsDecoded0 = [ValidationWarning]()
            for structure0 in validationWarningsContainer {
                if let structure0 = structure0 {
                    validationWarningsDecoded0?.append(structure0)
                }
            }
        }
        validationWarnings = validationWarningsDecoded0
        let erroredDecoded = try containerValues.decode(Bool.self, forKey: .errored)
        errored = erroredDecoded
    }
}

extension Query: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case selectors
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectors = selectors {
            var selectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectors)
            for selectorlist0 in selectors {
                try selectorsContainer.encode(selectorlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectorsContainer = try containerValues.decodeIfPresent([Selector?].self, forKey: .selectors)
        var selectorsDecoded0:[Selector]? = nil
        if let selectorsContainer = selectorsContainer {
            selectorsDecoded0 = [Selector]()
            for structure0 in selectorsContainer {
                if let structure0 = structure0 {
                    selectorsDecoded0?.append(structure0)
                }
            }
        }
        selectors = selectorsDecoded0
    }
}

extension Query: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Query(selectors: \(String(describing: selectors)))"}
}

/// <p>Defines the query to run against an object.</p>
public struct Query: Equatable {
    /// <p>List of selectors that define the query. An object must satisfy all of the selectors to match the query.</p>
    public let selectors: [Selector]?

    public init (
        selectors: [Selector]? = nil
    )
    {
        self.selectors = selectors
    }
}

public struct QueryObjectsInputBodyMiddleware: Middleware {
    public let id: String = "QueryObjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryObjectsInput>
    public typealias MOutput = OperationOutput<QueryObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryObjectsOutputError>
}

extension QueryObjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryObjectsInput(limit: \(String(describing: limit)), marker: \(String(describing: marker)), pipelineId: \(String(describing: pipelineId)), query: \(String(describing: query)), sphere: \(String(describing: sphere)))"}
}

extension QueryObjectsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit
        case marker
        case pipelineId
        case query
        case sphere
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let query = query {
            try encodeContainer.encode(query, forKey: .query)
        }
        if let sphere = sphere {
            try encodeContainer.encode(sphere, forKey: .sphere)
        }
    }
}

public struct QueryObjectsInputHeadersMiddleware: Middleware {
    public let id: String = "QueryObjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryObjectsInput>
    public typealias MOutput = OperationOutput<QueryObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryObjectsOutputError>
}

public struct QueryObjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "QueryObjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryObjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryObjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryObjectsInput>
    public typealias MOutput = OperationOutput<QueryObjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryObjectsOutputError>
}

/// <p>Contains the parameters for QueryObjects.</p>
public struct QueryObjectsInput: Equatable {
    /// <p>The maximum number of object names that <code>QueryObjects</code> will return in a single call. The default value is 100. </p>
    public let limit: Int?
    /// <p>The starting point for the results to be returned. For the first call, this value should be empty.
    ///            As long as there are more results, continue to call <code>QueryObjects</code> with
    ///            the marker value from the previous call to retrieve the next set of results.</p>
    public let marker: String?
    /// <p>The ID of the pipeline.</p>
    public let pipelineId: String?
    /// <p>The query that defines the objects to be returned. The <code>Query</code> object can contain a maximum of ten selectors.
    ///             The conditions in the query are limited to top-level String fields in the object.
    ///             These filters can be applied to components, instances, and attempts.</p>
    public let query: Query?
    /// <p>Indicates whether the query applies to components or instances. The possible values are:	
    ///             <code>COMPONENT</code>, <code>INSTANCE</code>, and <code>ATTEMPT</code>.</p>
    public let sphere: String?

    public init (
        limit: Int? = nil,
        marker: String? = nil,
        pipelineId: String? = nil,
        query: Query? = nil,
        sphere: String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.pipelineId = pipelineId
        self.query = query
        self.sphere = sphere
    }
}

struct QueryObjectsInputBody: Equatable {
    public let pipelineId: String?
    public let query: Query?
    public let sphere: String?
    public let marker: String?
    public let limit: Int?
}

extension QueryObjectsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit
        case marker
        case pipelineId
        case query
        case sphere
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let queryDecoded = try containerValues.decodeIfPresent(Query.self, forKey: .query)
        query = queryDecoded
        let sphereDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sphere)
        sphere = sphereDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension QueryObjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension QueryObjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum QueryObjectsOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension QueryObjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryObjectsOutputResponse(hasMoreResults: \(String(describing: hasMoreResults)), ids: \(String(describing: ids)), marker: \(String(describing: marker)))"}
}

extension QueryObjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: QueryObjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.hasMoreResults = output.hasMoreResults
            self.ids = output.ids
            self.marker = output.marker
        } else {
            self.hasMoreResults = false
            self.ids = nil
            self.marker = nil
        }
    }
}

/// <p>Contains the output of QueryObjects.</p>
public struct QueryObjectsOutputResponse: Equatable {
    /// <p>Indicates whether there are more results that can be obtained by a subsequent call.</p>
    public let hasMoreResults: Bool
    /// <p>The identifiers that match the query selectors.</p>
    public let ids: [String]?
    /// <p>The starting point for the next page of results. To view the next page of results, call <code>QueryObjects</code>
    ///            again with this marker value. If the value is null, there are no more results.</p>
    public let marker: String?

    public init (
        hasMoreResults: Bool = false,
        ids: [String]? = nil,
        marker: String? = nil
    )
    {
        self.hasMoreResults = hasMoreResults
        self.ids = ids
        self.marker = marker
    }
}

struct QueryObjectsOutputResponseBody: Equatable {
    public let ids: [String]?
    public let marker: String?
    public let hasMoreResults: Bool
}

extension QueryObjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hasMoreResults
        case ids
        case marker
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let hasMoreResultsDecoded = try containerValues.decode(Bool.self, forKey: .hasMoreResults)
        hasMoreResults = hasMoreResultsDecoded
    }
}

public struct RemoveTagsInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsOutputError>
}

extension RemoveTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsInput(pipelineId: \(String(describing: pipelineId)), tagKeys: \(String(describing: tagKeys)))"}
}

extension RemoveTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineId
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for stringlist0 in tagKeys {
                try tagKeysContainer.encode(stringlist0)
            }
        }
    }
}

public struct RemoveTagsInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsOutputError>
}

public struct RemoveTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsOutputError>
}

/// <p>Contains the parameters for RemoveTags.</p>
public struct RemoveTagsInput: Equatable {
    /// <p>The ID of the pipeline.</p>
    public let pipelineId: String?
    /// <p>The keys of the tags to remove.</p>
    public let tagKeys: [String]?

    public init (
        pipelineId: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.pipelineId = pipelineId
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsInputBody: Equatable {
    public let pipelineId: String?
    public let tagKeys: [String]?
}

extension RemoveTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineId
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsOutputResponse()"}
}

extension RemoveTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of RemoveTags.</p>
public struct RemoveTagsOutputResponse: Equatable {

    public init() {}
}

struct RemoveTagsOutputResponseBody: Equatable {
}

extension RemoveTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ReportTaskProgressInputBodyMiddleware: Middleware {
    public let id: String = "ReportTaskProgressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReportTaskProgressInput>,
                  next: H) -> Swift.Result<OperationOutput<ReportTaskProgressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReportTaskProgressInput>
    public typealias MOutput = OperationOutput<ReportTaskProgressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReportTaskProgressOutputError>
}

extension ReportTaskProgressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportTaskProgressInput(fields: \(String(describing: fields)), taskId: \(String(describing: taskId)))"}
}

extension ReportTaskProgressInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fields
        case taskId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldlist0 in fields {
                try fieldsContainer.encode(fieldlist0)
            }
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }
}

public struct ReportTaskProgressInputHeadersMiddleware: Middleware {
    public let id: String = "ReportTaskProgressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReportTaskProgressInput>,
                  next: H) -> Swift.Result<OperationOutput<ReportTaskProgressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReportTaskProgressInput>
    public typealias MOutput = OperationOutput<ReportTaskProgressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReportTaskProgressOutputError>
}

public struct ReportTaskProgressInputQueryItemMiddleware: Middleware {
    public let id: String = "ReportTaskProgressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReportTaskProgressInput>,
                  next: H) -> Swift.Result<OperationOutput<ReportTaskProgressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReportTaskProgressInput>
    public typealias MOutput = OperationOutput<ReportTaskProgressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReportTaskProgressOutputError>
}

/// <p>Contains the parameters for ReportTaskProgress.</p>
public struct ReportTaskProgressInput: Equatable {
    /// <p>Key-value pairs that define the properties of the ReportTaskProgressInput object.</p>
    public let fields: [Field]?
    /// <p>The ID of the task assigned to the task runner. This value is provided in the response for <a>PollForTask</a>.</p>
    public let taskId: String?

    public init (
        fields: [Field]? = nil,
        taskId: String? = nil
    )
    {
        self.fields = fields
        self.taskId = taskId
    }
}

struct ReportTaskProgressInputBody: Equatable {
    public let taskId: String?
    public let fields: [Field]?
}

extension ReportTaskProgressInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fields
        case taskId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Field?].self, forKey: .fields)
        var fieldsDecoded0:[Field]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Field]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ReportTaskProgressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReportTaskProgressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskNotFoundException" : self = .taskNotFoundException(try TaskNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReportTaskProgressOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case taskNotFoundException(TaskNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReportTaskProgressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportTaskProgressOutputResponse(canceled: \(String(describing: canceled)))"}
}

extension ReportTaskProgressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReportTaskProgressOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canceled = output.canceled
        } else {
            self.canceled = false
        }
    }
}

/// <p>Contains the output of ReportTaskProgress.</p>
public struct ReportTaskProgressOutputResponse: Equatable {
    /// <p>If true, the calling task runner should cancel processing of the task. The task runner does not need to call <a>SetTaskStatus</a> for canceled tasks.</p>
    public let canceled: Bool

    public init (
        canceled: Bool = false
    )
    {
        self.canceled = canceled
    }
}

struct ReportTaskProgressOutputResponseBody: Equatable {
    public let canceled: Bool
}

extension ReportTaskProgressOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canceled
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canceledDecoded = try containerValues.decode(Bool.self, forKey: .canceled)
        canceled = canceledDecoded
    }
}

public struct ReportTaskRunnerHeartbeatInputBodyMiddleware: Middleware {
    public let id: String = "ReportTaskRunnerHeartbeatInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReportTaskRunnerHeartbeatInput>,
                  next: H) -> Swift.Result<OperationOutput<ReportTaskRunnerHeartbeatOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReportTaskRunnerHeartbeatInput>
    public typealias MOutput = OperationOutput<ReportTaskRunnerHeartbeatOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReportTaskRunnerHeartbeatOutputError>
}

extension ReportTaskRunnerHeartbeatInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportTaskRunnerHeartbeatInput(hostname: \(String(describing: hostname)), taskrunnerId: \(String(describing: taskrunnerId)), workerGroup: \(String(describing: workerGroup)))"}
}

extension ReportTaskRunnerHeartbeatInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostname
        case taskrunnerId
        case workerGroup
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let taskrunnerId = taskrunnerId {
            try encodeContainer.encode(taskrunnerId, forKey: .taskrunnerId)
        }
        if let workerGroup = workerGroup {
            try encodeContainer.encode(workerGroup, forKey: .workerGroup)
        }
    }
}

public struct ReportTaskRunnerHeartbeatInputHeadersMiddleware: Middleware {
    public let id: String = "ReportTaskRunnerHeartbeatInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReportTaskRunnerHeartbeatInput>,
                  next: H) -> Swift.Result<OperationOutput<ReportTaskRunnerHeartbeatOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReportTaskRunnerHeartbeatInput>
    public typealias MOutput = OperationOutput<ReportTaskRunnerHeartbeatOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReportTaskRunnerHeartbeatOutputError>
}

public struct ReportTaskRunnerHeartbeatInputQueryItemMiddleware: Middleware {
    public let id: String = "ReportTaskRunnerHeartbeatInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReportTaskRunnerHeartbeatInput>,
                  next: H) -> Swift.Result<OperationOutput<ReportTaskRunnerHeartbeatOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReportTaskRunnerHeartbeatInput>
    public typealias MOutput = OperationOutput<ReportTaskRunnerHeartbeatOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReportTaskRunnerHeartbeatOutputError>
}

/// <p>Contains the parameters for ReportTaskRunnerHeartbeat.</p>
public struct ReportTaskRunnerHeartbeatInput: Equatable {
    /// <p>The public DNS name of the task runner.</p>
    public let hostname: String?
    /// <p>The ID of the task runner. This value should be unique across your AWS account. In the case of AWS Data Pipeline Task Runner
    ///             launched on a resource managed by AWS Data Pipeline, the web service provides a unique identifier when it launches the application.
    ///             If you have written a custom task runner, you should assign a unique identifier for the task runner.</p>
    public let taskrunnerId: String?
    /// <p>The type of task the task runner is configured to accept and process. The worker group is set as a field on objects in the pipeline when they are created.
    ///             You can only specify a single value for <code>workerGroup</code>. There are no wildcard values permitted in <code>workerGroup</code>; the string
    ///             must be an exact, case-sensitive, match.</p>
    public let workerGroup: String?

    public init (
        hostname: String? = nil,
        taskrunnerId: String? = nil,
        workerGroup: String? = nil
    )
    {
        self.hostname = hostname
        self.taskrunnerId = taskrunnerId
        self.workerGroup = workerGroup
    }
}

struct ReportTaskRunnerHeartbeatInputBody: Equatable {
    public let taskrunnerId: String?
    public let workerGroup: String?
    public let hostname: String?
}

extension ReportTaskRunnerHeartbeatInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hostname
        case taskrunnerId
        case workerGroup
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskrunnerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskrunnerId)
        taskrunnerId = taskrunnerIdDecoded
        let workerGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workerGroup)
        workerGroup = workerGroupDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostname)
        hostname = hostnameDecoded
    }
}

extension ReportTaskRunnerHeartbeatOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReportTaskRunnerHeartbeatOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReportTaskRunnerHeartbeatOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReportTaskRunnerHeartbeatOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReportTaskRunnerHeartbeatOutputResponse(terminate: \(String(describing: terminate)))"}
}

extension ReportTaskRunnerHeartbeatOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReportTaskRunnerHeartbeatOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.terminate = output.terminate
        } else {
            self.terminate = false
        }
    }
}

/// <p>Contains the output of ReportTaskRunnerHeartbeat.</p>
public struct ReportTaskRunnerHeartbeatOutputResponse: Equatable {
    /// <p>Indicates whether the calling task runner should terminate.</p>
    public let terminate: Bool

    public init (
        terminate: Bool = false
    )
    {
        self.terminate = terminate
    }
}

struct ReportTaskRunnerHeartbeatOutputResponseBody: Equatable {
    public let terminate: Bool
}

extension ReportTaskRunnerHeartbeatOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case terminate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminateDecoded = try containerValues.decode(Bool.self, forKey: .terminate)
        terminate = terminateDecoded
    }
}

extension Selector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldName
        case `operator` = "operator"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldName = fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`, forKey: .`operator`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(Operator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension Selector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Selector(fieldName: \(String(describing: fieldName)), operator: \(String(describing: `operator`)))"}
}

/// <p>A comparision that is used to determine whether a query should return this object.</p>
public struct Selector: Equatable {
    /// <p>Contains a logical operation for comparing the value of a field with a specified value.</p>
    public let `operator`: Operator?
    /// <p>The name of the field that the operator will be applied to. The field name is the "key" portion of the field definition in the pipeline definition syntax that is used by the AWS Data Pipeline API. If the field is not set on the object, the condition fails.</p>
    public let fieldName: String?

    public init (
        `operator`: Operator? = nil,
        fieldName: String? = nil
    )
    {
        self.`operator` = `operator`
        self.fieldName = fieldName
    }
}

public struct SetStatusInputBodyMiddleware: Middleware {
    public let id: String = "SetStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<SetStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetStatusInput>
    public typealias MOutput = OperationOutput<SetStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetStatusOutputError>
}

extension SetStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetStatusInput(objectIds: \(String(describing: objectIds)), pipelineId: \(String(describing: pipelineId)), status: \(String(describing: status)))"}
}

extension SetStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case objectIds
        case pipelineId
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIds = objectIds {
            var objectIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectIds)
            for idlist0 in objectIds {
                try objectIdsContainer.encode(idlist0)
            }
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }
}

public struct SetStatusInputHeadersMiddleware: Middleware {
    public let id: String = "SetStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<SetStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetStatusInput>
    public typealias MOutput = OperationOutput<SetStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetStatusOutputError>
}

public struct SetStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "SetStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<SetStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetStatusInput>
    public typealias MOutput = OperationOutput<SetStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetStatusOutputError>
}

/// <p>Contains the parameters for SetStatus.</p>
public struct SetStatusInput: Equatable {
    /// <p>The IDs of the objects. The corresponding objects can be either physical or components, but not a mix of both types.</p>
    public let objectIds: [String]?
    /// <p>The ID of the pipeline that contains the objects.</p>
    public let pipelineId: String?
    /// <p>The status to be set on all the objects specified in <code>objectIds</code>. For components, use <code>PAUSE</code> or <code>RESUME</code>.
    ///             For instances, use <code>TRY_CANCEL</code>, <code>RERUN</code>, or <code>MARK_FINISHED</code>.</p>
    public let status: String?

    public init (
        objectIds: [String]? = nil,
        pipelineId: String? = nil,
        status: String? = nil
    )
    {
        self.objectIds = objectIds
        self.pipelineId = pipelineId
        self.status = status
    }
}

struct SetStatusInputBody: Equatable {
    public let pipelineId: String?
    public let objectIds: [String]?
    public let status: String?
}

extension SetStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case objectIds
        case pipelineId
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let objectIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .objectIds)
        var objectIdsDecoded0:[String]? = nil
        if let objectIdsContainer = objectIdsContainer {
            objectIdsDecoded0 = [String]()
            for string0 in objectIdsContainer {
                if let string0 = string0 {
                    objectIdsDecoded0?.append(string0)
                }
            }
        }
        objectIds = objectIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SetStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetStatusOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetStatusOutputResponse()"}
}

extension SetStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetStatusOutputResponse: Equatable {

    public init() {}
}

struct SetStatusOutputResponseBody: Equatable {
}

extension SetStatusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetTaskStatusInputBodyMiddleware: Middleware {
    public let id: String = "SetTaskStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTaskStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTaskStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTaskStatusInput>
    public typealias MOutput = OperationOutput<SetTaskStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTaskStatusOutputError>
}

extension SetTaskStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetTaskStatusInput(errorId: \(String(describing: errorId)), errorMessage: \(String(describing: errorMessage)), errorStackTrace: \(String(describing: errorStackTrace)), taskId: \(String(describing: taskId)), taskStatus: \(String(describing: taskStatus)))"}
}

extension SetTaskStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorId
        case errorMessage
        case errorStackTrace
        case taskId
        case taskStatus
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorId = errorId {
            try encodeContainer.encode(errorId, forKey: .errorId)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorStackTrace = errorStackTrace {
            try encodeContainer.encode(errorStackTrace, forKey: .errorStackTrace)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStatus = taskStatus {
            try encodeContainer.encode(taskStatus.rawValue, forKey: .taskStatus)
        }
    }
}

public struct SetTaskStatusInputHeadersMiddleware: Middleware {
    public let id: String = "SetTaskStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTaskStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTaskStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTaskStatusInput>
    public typealias MOutput = OperationOutput<SetTaskStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTaskStatusOutputError>
}

public struct SetTaskStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "SetTaskStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTaskStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTaskStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTaskStatusInput>
    public typealias MOutput = OperationOutput<SetTaskStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTaskStatusOutputError>
}

/// <p>Contains the parameters for SetTaskStatus.</p>
public struct SetTaskStatusInput: Equatable {
    /// <p>If an error occurred during the task, this value specifies the error code. This value is set on the physical attempt object.
    ///             It is used to display error information to the user. It should not start with string "Service_" which is reserved by the system.</p>
    public let errorId: String?
    /// <p>If an error occurred during the task, this value specifies a text description of the error. This value is set on the physical attempt object.
    ///             It is used to display error information to the user. The web service does not parse this value.</p>
    public let errorMessage: String?
    /// <p>If an error occurred during the task, this value specifies the stack trace associated with the error. This value is set on the physical attempt object.
    ///             It is used to display error information to the user. The web service does not parse this value.</p>
    public let errorStackTrace: String?
    /// <p>The ID of the task assigned to the task runner. This value is provided in the response for <a>PollForTask</a>.</p>
    public let taskId: String?
    /// <p>If <code>FINISHED</code>, the task successfully completed. If <code>FAILED</code>, the task ended unsuccessfully. Preconditions use false.</p>
    public let taskStatus: TaskStatus?

    public init (
        errorId: String? = nil,
        errorMessage: String? = nil,
        errorStackTrace: String? = nil,
        taskId: String? = nil,
        taskStatus: TaskStatus? = nil
    )
    {
        self.errorId = errorId
        self.errorMessage = errorMessage
        self.errorStackTrace = errorStackTrace
        self.taskId = taskId
        self.taskStatus = taskStatus
    }
}

struct SetTaskStatusInputBody: Equatable {
    public let taskId: String?
    public let taskStatus: TaskStatus?
    public let errorId: String?
    public let errorMessage: String?
    public let errorStackTrace: String?
}

extension SetTaskStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorId
        case errorMessage
        case errorStackTrace
        case taskId
        case taskStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskStatusDecoded = try containerValues.decodeIfPresent(TaskStatus.self, forKey: .taskStatus)
        taskStatus = taskStatusDecoded
        let errorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorId)
        errorId = errorIdDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorStackTraceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorStackTrace)
        errorStackTrace = errorStackTraceDecoded
    }
}

extension SetTaskStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetTaskStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TaskNotFoundException" : self = .taskNotFoundException(try TaskNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetTaskStatusOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case taskNotFoundException(TaskNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetTaskStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetTaskStatusOutputResponse()"}
}

extension SetTaskStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Contains the output of SetTaskStatus.</p>
public struct SetTaskStatusOutputResponse: Equatable {

    public init() {}
}

struct SetTaskStatusOutputResponseBody: Equatable {
}

extension SetTaskStatusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Tags are key/value pairs defined by a user and associated with a pipeline to control access. AWS Data Pipeline allows you to associate ten tags per pipeline.
///             For more information, see <a href="http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-control-access.html">Controlling User Access to Pipelines</a> in the <i>AWS Data Pipeline Developer Guide</i>.</p>
public struct Tag: Equatable {
    /// <p>The key name of a tag defined by a user.
    ///             For more information, see <a href="http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-control-access.html">Controlling User Access to Pipelines</a> in the <i>AWS Data Pipeline Developer Guide</i>.</p>
    public let key: String?
    /// <p>The optional value portion of a tag defined by a user.
    ///             For more information, see <a href="http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-control-access.html">Controlling User Access to Pipelines</a> in the <i>AWS Data Pipeline Developer Guide</i>.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TaskNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskNotFoundException(message: \(String(describing: message)))"}
}

extension TaskNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TaskNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified task was not found. </p>
public struct TaskNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Description of the error message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TaskNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension TaskNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TaskObject: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attemptId
        case objects
        case pipelineId
        case taskId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attemptId = attemptId {
            try encodeContainer.encode(attemptId, forKey: .attemptId)
        }
        if let objects = objects {
            var objectsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .objects)
            for (dictKey0, pipelineobjectmap0) in objects {
                try objectsContainer.encode(pipelineobjectmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let attemptIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attemptId)
        attemptId = attemptIdDecoded
        let objectsContainer = try containerValues.decodeIfPresent([String: PipelineObject?].self, forKey: .objects)
        var objectsDecoded0: [String:PipelineObject]? = nil
        if let objectsContainer = objectsContainer {
            objectsDecoded0 = [String:PipelineObject]()
            for (key0, pipelineobject0) in objectsContainer {
                if let pipelineobject0 = pipelineobject0 {
                    objectsDecoded0?[key0] = pipelineobject0
                }
            }
        }
        objects = objectsDecoded0
    }
}

extension TaskObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaskObject(attemptId: \(String(describing: attemptId)), objects: \(String(describing: objects)), pipelineId: \(String(describing: pipelineId)), taskId: \(String(describing: taskId)))"}
}

/// <p>Contains information about a pipeline task that is assigned to a task runner.</p>
public struct TaskObject: Equatable {
    /// <p>The ID of the pipeline task attempt object. AWS Data Pipeline uses this value to track how many times a task is attempted.</p>
    public let attemptId: String?
    /// <p>Connection information for the location where the task runner will publish the output of the task.</p>
    public let objects: [String:PipelineObject]?
    /// <p>The ID of the pipeline that provided the task.</p>
    public let pipelineId: String?
    /// <p>An internal identifier for the task. This ID is passed to the <a>SetTaskStatus</a> and <a>ReportTaskProgress</a> actions.</p>
    public let taskId: String?

    public init (
        attemptId: String? = nil,
        objects: [String:PipelineObject]? = nil,
        pipelineId: String? = nil,
        taskId: String? = nil
    )
    {
        self.attemptId = attemptId
        self.objects = objects
        self.pipelineId = pipelineId
        self.taskId = taskId
    }
}

public enum TaskStatus {
    case failed
    case `false`
    case finished
    case sdkUnknown(String)
}

extension TaskStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TaskStatus] {
        return [
            .failed,
            .false,
            .finished,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .false: return "FALSE"
        case .finished: return "FINISHED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TaskStatus(rawValue: rawValue) ?? TaskStatus.sdkUnknown(rawValue)
    }
}

public struct ValidatePipelineDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "ValidatePipelineDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidatePipelineDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidatePipelineDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidatePipelineDefinitionInput>
    public typealias MOutput = OperationOutput<ValidatePipelineDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidatePipelineDefinitionOutputError>
}

extension ValidatePipelineDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidatePipelineDefinitionInput(parameterObjects: \(String(describing: parameterObjects)), parameterValues: \(String(describing: parameterValues)), pipelineId: \(String(describing: pipelineId)), pipelineObjects: \(String(describing: pipelineObjects)))"}
}

extension ValidatePipelineDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterObjects
        case parameterValues
        case pipelineId
        case pipelineObjects
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterObjects = parameterObjects {
            var parameterObjectsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterObjects)
            for parameterobjectlist0 in parameterObjects {
                try parameterObjectsContainer.encode(parameterobjectlist0)
            }
        }
        if let parameterValues = parameterValues {
            var parameterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterValues)
            for parametervaluelist0 in parameterValues {
                try parameterValuesContainer.encode(parametervaluelist0)
            }
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let pipelineObjects = pipelineObjects {
            var pipelineObjectsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineObjects)
            for pipelineobjectlist0 in pipelineObjects {
                try pipelineObjectsContainer.encode(pipelineobjectlist0)
            }
        }
    }
}

public struct ValidatePipelineDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "ValidatePipelineDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidatePipelineDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidatePipelineDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidatePipelineDefinitionInput>
    public typealias MOutput = OperationOutput<ValidatePipelineDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidatePipelineDefinitionOutputError>
}

public struct ValidatePipelineDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "ValidatePipelineDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidatePipelineDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidatePipelineDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidatePipelineDefinitionInput>
    public typealias MOutput = OperationOutput<ValidatePipelineDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidatePipelineDefinitionOutputError>
}

/// <p>Contains the parameters for ValidatePipelineDefinition.</p>
public struct ValidatePipelineDefinitionInput: Equatable {
    /// <p>The parameter objects used with the pipeline.</p>
    public let parameterObjects: [ParameterObject]?
    /// <p>The parameter values used with the pipeline.</p>
    public let parameterValues: [ParameterValue]?
    /// <p>The ID of the pipeline.</p>
    public let pipelineId: String?
    /// <p>The objects that define the pipeline changes to validate against the pipeline.</p>
    public let pipelineObjects: [PipelineObject]?

    public init (
        parameterObjects: [ParameterObject]? = nil,
        parameterValues: [ParameterValue]? = nil,
        pipelineId: String? = nil,
        pipelineObjects: [PipelineObject]? = nil
    )
    {
        self.parameterObjects = parameterObjects
        self.parameterValues = parameterValues
        self.pipelineId = pipelineId
        self.pipelineObjects = pipelineObjects
    }
}

struct ValidatePipelineDefinitionInputBody: Equatable {
    public let pipelineId: String?
    public let pipelineObjects: [PipelineObject]?
    public let parameterObjects: [ParameterObject]?
    public let parameterValues: [ParameterValue]?
}

extension ValidatePipelineDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameterObjects
        case parameterValues
        case pipelineId
        case pipelineObjects
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let pipelineObjectsContainer = try containerValues.decodeIfPresent([PipelineObject?].self, forKey: .pipelineObjects)
        var pipelineObjectsDecoded0:[PipelineObject]? = nil
        if let pipelineObjectsContainer = pipelineObjectsContainer {
            pipelineObjectsDecoded0 = [PipelineObject]()
            for structure0 in pipelineObjectsContainer {
                if let structure0 = structure0 {
                    pipelineObjectsDecoded0?.append(structure0)
                }
            }
        }
        pipelineObjects = pipelineObjectsDecoded0
        let parameterObjectsContainer = try containerValues.decodeIfPresent([ParameterObject?].self, forKey: .parameterObjects)
        var parameterObjectsDecoded0:[ParameterObject]? = nil
        if let parameterObjectsContainer = parameterObjectsContainer {
            parameterObjectsDecoded0 = [ParameterObject]()
            for structure0 in parameterObjectsContainer {
                if let structure0 = structure0 {
                    parameterObjectsDecoded0?.append(structure0)
                }
            }
        }
        parameterObjects = parameterObjectsDecoded0
        let parameterValuesContainer = try containerValues.decodeIfPresent([ParameterValue?].self, forKey: .parameterValues)
        var parameterValuesDecoded0:[ParameterValue]? = nil
        if let parameterValuesContainer = parameterValuesContainer {
            parameterValuesDecoded0 = [ParameterValue]()
            for structure0 in parameterValuesContainer {
                if let structure0 = structure0 {
                    parameterValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterValues = parameterValuesDecoded0
    }
}

extension ValidatePipelineDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidatePipelineDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineDeletedException" : self = .pipelineDeletedException(try PipelineDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidatePipelineDefinitionOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case pipelineDeletedException(PipelineDeletedException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidatePipelineDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidatePipelineDefinitionOutputResponse(errored: \(String(describing: errored)), validationErrors: \(String(describing: validationErrors)), validationWarnings: \(String(describing: validationWarnings)))"}
}

extension ValidatePipelineDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidatePipelineDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errored = output.errored
            self.validationErrors = output.validationErrors
            self.validationWarnings = output.validationWarnings
        } else {
            self.errored = false
            self.validationErrors = nil
            self.validationWarnings = nil
        }
    }
}

/// <p>Contains the output of ValidatePipelineDefinition.</p>
public struct ValidatePipelineDefinitionOutputResponse: Equatable {
    /// <p>Indicates whether there were validation errors.</p>
    public let errored: Bool
    /// <p>Any validation errors that were found.</p>
    public let validationErrors: [ValidationError]?
    /// <p>Any validation warnings that were found.</p>
    public let validationWarnings: [ValidationWarning]?

    public init (
        errored: Bool = false,
        validationErrors: [ValidationError]? = nil,
        validationWarnings: [ValidationWarning]? = nil
    )
    {
        self.errored = errored
        self.validationErrors = validationErrors
        self.validationWarnings = validationWarnings
    }
}

struct ValidatePipelineDefinitionOutputResponseBody: Equatable {
    public let validationErrors: [ValidationError]?
    public let validationWarnings: [ValidationWarning]?
    public let errored: Bool
}

extension ValidatePipelineDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errored
        case validationErrors
        case validationWarnings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationErrorsContainer = try containerValues.decodeIfPresent([ValidationError?].self, forKey: .validationErrors)
        var validationErrorsDecoded0:[ValidationError]? = nil
        if let validationErrorsContainer = validationErrorsContainer {
            validationErrorsDecoded0 = [ValidationError]()
            for structure0 in validationErrorsContainer {
                if let structure0 = structure0 {
                    validationErrorsDecoded0?.append(structure0)
                }
            }
        }
        validationErrors = validationErrorsDecoded0
        let validationWarningsContainer = try containerValues.decodeIfPresent([ValidationWarning?].self, forKey: .validationWarnings)
        var validationWarningsDecoded0:[ValidationWarning]? = nil
        if let validationWarningsContainer = validationWarningsContainer {
            validationWarningsDecoded0 = [ValidationWarning]()
            for structure0 in validationWarningsContainer {
                if let structure0 = structure0 {
                    validationWarningsDecoded0?.append(structure0)
                }
            }
        }
        validationWarnings = validationWarningsDecoded0
        let erroredDecoded = try containerValues.decode(Bool.self, forKey: .errored)
        errored = erroredDecoded
    }
}

extension ValidationError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errors
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for validationmessages0 in errors {
                try errorsContainer.encode(validationmessages0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let errorsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .errors)
        var errorsDecoded0:[String]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [String]()
            for string0 in errorsContainer {
                if let string0 = string0 {
                    errorsDecoded0?.append(string0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension ValidationError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationError(errors: \(String(describing: errors)), id: \(String(describing: id)))"}
}

/// <p>Defines a validation error. Validation errors prevent pipeline activation. The set of validation errors that can be returned are defined by AWS Data Pipeline.</p>
public struct ValidationError: Equatable {
    /// <p>A description of the validation error.</p>
    public let errors: [String]?
    /// <p>The identifier of the object that contains the validation error.</p>
    public let id: String?

    public init (
        errors: [String]? = nil,
        id: String? = nil
    )
    {
        self.errors = errors
        self.id = id
    }
}

extension ValidationWarning: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case warnings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let warnings = warnings {
            var warningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .warnings)
            for validationmessages0 in warnings {
                try warningsContainer.encode(validationmessages0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let warningsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .warnings)
        var warningsDecoded0:[String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension ValidationWarning: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationWarning(id: \(String(describing: id)), warnings: \(String(describing: warnings)))"}
}

/// <p>Defines a validation warning. Validation warnings do not prevent pipeline activation. The set of validation warnings that can be returned are defined by AWS Data Pipeline.</p>
public struct ValidationWarning: Equatable {
    /// <p>The identifier of the object that contains the validation warning.</p>
    public let id: String?
    /// <p>A description of the validation warning.</p>
    public let warnings: [String]?

    public init (
        id: String? = nil,
        warnings: [String]? = nil
    )
    {
        self.id = id
        self.warnings = warnings
    }
}
