// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have permission to perform the action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
    }
}

extension GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateClientDeviceWithCoreDeviceEntry(thingName: \(Swift.String(describing: thingName)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains a request to associate a client device with a core device. The <a href="https://docs.aws.amazon.com/greengrass/v2/APIReference/API_BatchAssociateClientDeviceWithCoreDevice.html">BatchAssociateClientDeviceWithCoreDevice operation consumes a list of these
    ///       requests.
    public struct AssociateClientDeviceWithCoreDeviceEntry: Swift.Equatable {
        /// The name of the IoT thing that represents the client device to associate.
        /// This member is required.
        public var thingName: Swift.String?

        public init (
            thingName: Swift.String? = nil
        )
        {
            self.thingName = thingName
        }
    }

}

extension GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateClientDeviceWithCoreDeviceErrorEntry(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), thingName: \(Swift.String(describing: thingName)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains an error that occurs from a request to associate a client device with a core
    ///       device. The <a href="https://docs.aws.amazon.com/greengrass/v2/APIReference/API_BatchAssociateClientDeviceWithCoreDevice.html">BatchAssociateClientDeviceWithCoreDevice operation returns a list of these
    ///       errors.
    public struct AssociateClientDeviceWithCoreDeviceErrorEntry: Swift.Equatable {
        /// The error code for the request.
        public var code: Swift.String?
        /// A message that provides additional information about the error.
        public var message: Swift.String?
        /// The name of the IoT thing whose associate request failed.
        public var thingName: Swift.String?

        public init (
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.thingName = thingName
        }
    }

}

extension GreengrassV2ClientTypes.AssociatedClientDevice: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationTimestamp
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationTimestamp = associationTimestamp {
            try encodeContainer.encode(associationTimestamp.timeIntervalSince1970, forKey: .associationTimestamp)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let associationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .associationTimestamp)
        associationTimestamp = associationTimestampDecoded
    }
}

extension GreengrassV2ClientTypes.AssociatedClientDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatedClientDevice(associationTimestamp: \(Swift.String(describing: associationTimestamp)), thingName: \(Swift.String(describing: thingName)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a client device that is associated to a core device for cloud
    ///       discovery.
    public struct AssociatedClientDevice: Swift.Equatable {
        /// The time that the client device was associated, expressed in ISO 8601 format.
        public var associationTimestamp: ClientRuntime.Date?
        /// The name of the IoT thing that represents the associated client device.
        public var thingName: Swift.String?

        public init (
            associationTimestamp: ClientRuntime.Date? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.associationTimestamp = associationTimestamp
            self.thingName = thingName
        }
    }

}

public struct BatchAssociateClientDeviceWithCoreDeviceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateClientDeviceWithCoreDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateClientDeviceWithCoreDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateClientDeviceWithCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateClientDeviceWithCoreDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateClientDeviceWithCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateClientDeviceWithCoreDeviceOutputError>
}

extension BatchAssociateClientDeviceWithCoreDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAssociateClientDeviceWithCoreDeviceInput(coreDeviceThingName: \(Swift.String(describing: coreDeviceThingName)), entries: \(Swift.String(describing: entries)))"}
}

extension BatchAssociateClientDeviceWithCoreDeviceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for associateclientdevicewithcoredeviceentrylist0 in entries {
                try entriesContainer.encode(associateclientdevicewithcoredeviceentrylist0)
            }
        }
    }
}

public struct BatchAssociateClientDeviceWithCoreDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateClientDeviceWithCoreDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateClientDeviceWithCoreDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateClientDeviceWithCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateClientDeviceWithCoreDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateClientDeviceWithCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateClientDeviceWithCoreDeviceOutputError>
}

public struct BatchAssociateClientDeviceWithCoreDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateClientDeviceWithCoreDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateClientDeviceWithCoreDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateClientDeviceWithCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateClientDeviceWithCoreDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateClientDeviceWithCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateClientDeviceWithCoreDeviceOutputError>
}

public struct BatchAssociateClientDeviceWithCoreDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateClientDeviceWithCoreDeviceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BatchAssociateClientDeviceWithCoreDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateClientDeviceWithCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreDeviceThingName = input.coreDeviceThingName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreDeviceThingName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/associateClientDevices"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchAssociateClientDeviceWithCoreDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateClientDeviceWithCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateClientDeviceWithCoreDeviceOutputError>
}

public struct BatchAssociateClientDeviceWithCoreDeviceInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The list of client devices to associate.
    public var entries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry]?

    public init (
        coreDeviceThingName: Swift.String? = nil,
        entries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry]? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.entries = entries
    }
}

struct BatchAssociateClientDeviceWithCoreDeviceInputBody: Swift.Equatable {
    public let entries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry]?
}

extension BatchAssociateClientDeviceWithCoreDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry?].self, forKey: .entries)
        var entriesDecoded0:[GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchAssociateClientDeviceWithCoreDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateClientDeviceWithCoreDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAssociateClientDeviceWithCoreDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateClientDeviceWithCoreDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAssociateClientDeviceWithCoreDeviceOutputResponse(errorEntries: \(Swift.String(describing: errorEntries)))"}
}

extension BatchAssociateClientDeviceWithCoreDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchAssociateClientDeviceWithCoreDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchAssociateClientDeviceWithCoreDeviceOutputResponse: Swift.Equatable {
    /// The list of any errors for the entries in the request. Each error entry contains the name
    ///       of the IoT thing that failed to associate.
    public var errorEntries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry]?

    public init (
        errorEntries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchAssociateClientDeviceWithCoreDeviceOutputResponseBody: Swift.Equatable {
    public let errorEntries: [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry]?
}

extension BatchAssociateClientDeviceWithCoreDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [GreengrassV2ClientTypes.AssociateClientDeviceWithCoreDeviceErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

public struct BatchDisassociateClientDeviceFromCoreDeviceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateClientDeviceFromCoreDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateClientDeviceFromCoreDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateClientDeviceFromCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateClientDeviceFromCoreDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateClientDeviceFromCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateClientDeviceFromCoreDeviceOutputError>
}

extension BatchDisassociateClientDeviceFromCoreDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDisassociateClientDeviceFromCoreDeviceInput(coreDeviceThingName: \(Swift.String(describing: coreDeviceThingName)), entries: \(Swift.String(describing: entries)))"}
}

extension BatchDisassociateClientDeviceFromCoreDeviceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for disassociateclientdevicefromcoredeviceentrylist0 in entries {
                try entriesContainer.encode(disassociateclientdevicefromcoredeviceentrylist0)
            }
        }
    }
}

public struct BatchDisassociateClientDeviceFromCoreDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateClientDeviceFromCoreDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateClientDeviceFromCoreDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateClientDeviceFromCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateClientDeviceFromCoreDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateClientDeviceFromCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateClientDeviceFromCoreDeviceOutputError>
}

public struct BatchDisassociateClientDeviceFromCoreDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateClientDeviceFromCoreDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateClientDeviceFromCoreDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateClientDeviceFromCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateClientDeviceFromCoreDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateClientDeviceFromCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateClientDeviceFromCoreDeviceOutputError>
}

public struct BatchDisassociateClientDeviceFromCoreDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateClientDeviceFromCoreDeviceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BatchDisassociateClientDeviceFromCoreDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateClientDeviceFromCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreDeviceThingName = input.coreDeviceThingName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreDeviceThingName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/disassociateClientDevices"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDisassociateClientDeviceFromCoreDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateClientDeviceFromCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateClientDeviceFromCoreDeviceOutputError>
}

public struct BatchDisassociateClientDeviceFromCoreDeviceInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The list of client devices to disassociate.
    public var entries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry]?

    public init (
        coreDeviceThingName: Swift.String? = nil,
        entries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry]? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.entries = entries
    }
}

struct BatchDisassociateClientDeviceFromCoreDeviceInputBody: Swift.Equatable {
    public let entries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry]?
}

extension BatchDisassociateClientDeviceFromCoreDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry?].self, forKey: .entries)
        var entriesDecoded0:[GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchDisassociateClientDeviceFromCoreDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateClientDeviceFromCoreDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisassociateClientDeviceFromCoreDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateClientDeviceFromCoreDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDisassociateClientDeviceFromCoreDeviceOutputResponse(errorEntries: \(Swift.String(describing: errorEntries)))"}
}

extension BatchDisassociateClientDeviceFromCoreDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDisassociateClientDeviceFromCoreDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchDisassociateClientDeviceFromCoreDeviceOutputResponse: Swift.Equatable {
    /// The list of errors (if any) for the entries in the request. Each error entry contains the
    ///       name of the IoT thing that failed to disassociate.
    public var errorEntries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry]?

    public init (
        errorEntries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchDisassociateClientDeviceFromCoreDeviceOutputResponseBody: Swift.Equatable {
    public let errorEntries: [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry]?
}

extension BatchDisassociateClientDeviceFromCoreDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

extension CancelDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelDeploymentInput(deploymentId: \(Swift.String(describing: deploymentId)))"}
}

extension CancelDeploymentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CancelDeploymentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelDeploymentOutputError>
}

public struct CancelDeploymentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelDeploymentOutputError>
}

public struct CancelDeploymentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelDeploymentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CancelDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let deploymentId = input.deploymentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deploymentId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/deployments/\(deploymentId.urlPercentEncoding())/cancel"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelDeploymentOutputError>
}

public struct CancelDeploymentInput: Swift.Equatable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init (
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct CancelDeploymentInputBody: Swift.Equatable {
}

extension CancelDeploymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelDeploymentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelDeploymentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelDeploymentOutputResponse(message: \(Swift.String(describing: message)))"}
}

extension CancelDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct CancelDeploymentOutputResponse: Swift.Equatable {
    /// A message that communicates if the cancel was successful.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CancelDeploymentOutputResponseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CancelDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassV2ClientTypes {
    public enum CloudComponentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deployable
        case deprecated
        case failed
        case initiated
        case requested
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudComponentState] {
            return [
                .deployable,
                .deprecated,
                .failed,
                .initiated,
                .requested,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deployable: return "DEPLOYABLE"
            case .deprecated: return "DEPRECATED"
            case .failed: return "FAILED"
            case .initiated: return "INITIATED"
            case .requested: return "REQUESTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudComponentState(rawValue: rawValue) ?? CloudComponentState.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.CloudComponentStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentState
        case errors
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentState = componentState {
            try encodeContainer.encode(componentState.rawValue, forKey: .componentState)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .errors)
            for (dictKey0, stringmap0) in errors {
                try errorsContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentStateDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.CloudComponentState.self, forKey: .componentState)
        componentState = componentStateDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .errors)
        var errorsDecoded0: [Swift.String:Swift.String]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in errorsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    errorsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension GreengrassV2ClientTypes.CloudComponentStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudComponentStatus(componentState: \(Swift.String(describing: componentState)), errors: \(Swift.String(describing: errors)), message: \(Swift.String(describing: message)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains the status of a component in the IoT Greengrass service.
    public struct CloudComponentStatus: Swift.Equatable {
        /// The state of the component.
        public var componentState: GreengrassV2ClientTypes.CloudComponentState?
        /// A dictionary of errors that communicate why the component is in an error state. For
        ///       example, if IoT Greengrass can't access an artifact for the component, then errors contains
        ///       the artifact's URI as a key, and the error message as the value for that key.
        public var errors: [Swift.String:Swift.String]?
        /// A message that communicates details, such as errors, about the status of the component.
        public var message: Swift.String?

        public init (
            componentState: GreengrassV2ClientTypes.CloudComponentState? = nil,
            errors: [Swift.String:Swift.String]? = nil,
            message: Swift.String? = nil
        )
        {
            self.componentState = componentState
            self.errors = errors
            self.message = message
        }
    }

}

extension GreengrassV2ClientTypes.Component: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentName
        case latestVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let latestVersion = latestVersion {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.ComponentLatestVersion.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
    }
}

extension GreengrassV2ClientTypes.Component: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Component(arn: \(Swift.String(describing: arn)), componentName: \(Swift.String(describing: componentName)), latestVersion: \(Swift.String(describing: latestVersion)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component.
    public struct Component: Swift.Equatable {
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the component version.
        public var arn: Swift.String?
        /// The name of the component.
        public var componentName: Swift.String?
        /// The latest version of the component and its details.
        public var latestVersion: GreengrassV2ClientTypes.ComponentLatestVersion?

        public init (
            arn: Swift.String? = nil,
            componentName: Swift.String? = nil,
            latestVersion: GreengrassV2ClientTypes.ComponentLatestVersion? = nil
        )
        {
            self.arn = arn
            self.componentName = componentName
            self.latestVersion = latestVersion
        }
    }

}

extension GreengrassV2ClientTypes.ComponentCandidate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentVersion
        case versionRequirements
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let versionRequirements = versionRequirements {
            var versionRequirementsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .versionRequirements)
            for (dictKey0, componentversionrequirementmap0) in versionRequirements {
                try versionRequirementsContainer.encode(componentversionrequirementmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let versionRequirementsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .versionRequirements)
        var versionRequirementsDecoded0: [Swift.String:Swift.String]? = nil
        if let versionRequirementsContainer = versionRequirementsContainer {
            versionRequirementsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in versionRequirementsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    versionRequirementsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        versionRequirements = versionRequirementsDecoded0
    }
}

extension GreengrassV2ClientTypes.ComponentCandidate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentCandidate(componentName: \(Swift.String(describing: componentName)), componentVersion: \(Swift.String(describing: componentVersion)), versionRequirements: \(Swift.String(describing: versionRequirements)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component that is a candidate to deploy to a Greengrass core
    ///       device.
    public struct ComponentCandidate: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// The version requirements for the component's dependencies. Greengrass core devices get the
        ///       version requirements from component recipes.
        ///          IoT Greengrass V2 uses semantic version constraints. For more information, see <a href="https://semver.org/">Semantic Versioning.
        public var versionRequirements: [Swift.String:Swift.String]?

        public init (
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            versionRequirements: [Swift.String:Swift.String]? = nil
        )
        {
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.versionRequirements = versionRequirements
        }
    }

}

extension GreengrassV2ClientTypes.ComponentConfigurationUpdate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case merge
        case reset
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let merge = merge {
            try encodeContainer.encode(merge, forKey: .merge)
        }
        if let reset = reset {
            var resetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reset)
            for componentconfigurationpathlist0 in reset {
                try resetContainer.encode(componentconfigurationpathlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .merge)
        merge = mergeDecoded
        let resetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reset)
        var resetDecoded0:[Swift.String]? = nil
        if let resetContainer = resetContainer {
            resetDecoded0 = [Swift.String]()
            for string0 in resetContainer {
                if let string0 = string0 {
                    resetDecoded0?.append(string0)
                }
            }
        }
        reset = resetDecoded0
    }
}

extension GreengrassV2ClientTypes.ComponentConfigurationUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentConfigurationUpdate(merge: \(Swift.String(describing: merge)), reset: \(Swift.String(describing: reset)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a deployment's update to a component's configuration on
    ///       Greengrass core devices. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html">Update component
    ///         configurations in the IoT Greengrass V2 Developer Guide.
    public struct ComponentConfigurationUpdate: Swift.Equatable {
        /// A serialized JSON string that contains the configuration object to merge to target
        ///       devices. The core device merges this configuration with the component's existing
        ///       configuration. If this is the first time a component deploys on a device, the core device
        ///       merges this configuration with the component's default configuration. This means that the core
        ///       device keeps it's existing configuration for keys and values that you don't specify in this
        ///       object. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html#merge-configuration-update">Merge configuration updates in the IoT Greengrass V2 Developer
        ///           Guide.
        public var merge: Swift.String?
        /// The list of configuration nodes to reset to default values on target devices. Use JSON
        ///       pointers to specify each node to reset. JSON pointers start with a forward slash
        ///       (/) and use forward slashes to separate the key for each level in the object.
        ///       For more information, see the <a href="https://tools.ietf.org/html/rfc6901">JSON pointer
        ///         specification and <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html#reset-configuration-update">Reset configuration updates in the IoT Greengrass V2 Developer
        ///             Guide.
        public var reset: [Swift.String]?

        public init (
            merge: Swift.String? = nil,
            reset: [Swift.String]? = nil
        )
        {
            self.merge = merge
            self.reset = reset
        }
    }

}

extension GreengrassV2ClientTypes.ComponentDependencyRequirement: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencyType
        case versionRequirement
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependencyType = dependencyType {
            try encodeContainer.encode(dependencyType.rawValue, forKey: .dependencyType)
        }
        if let versionRequirement = versionRequirement {
            try encodeContainer.encode(versionRequirement, forKey: .versionRequirement)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionRequirementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRequirement)
        versionRequirement = versionRequirementDecoded
        let dependencyTypeDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.ComponentDependencyType.self, forKey: .dependencyType)
        dependencyType = dependencyTypeDecoded
    }
}

extension GreengrassV2ClientTypes.ComponentDependencyRequirement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentDependencyRequirement(dependencyType: \(Swift.String(describing: dependencyType)), versionRequirement: \(Swift.String(describing: versionRequirement)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component dependency for a Lambda function component.
    public struct ComponentDependencyRequirement: Swift.Equatable {
        /// The type of this dependency. Choose from the following options:
        ///
        ///
        ///
        ///                   SOFT  The component doesn't restart if the dependency changes
        ///           state.
        ///
        ///
        ///
        ///                   HARD  The component restarts if the dependency changes
        ///           state.
        ///
        ///
        ///          Default: HARD
        ///
        public var dependencyType: GreengrassV2ClientTypes.ComponentDependencyType?
        /// The component version requirement for the component dependency.
        ///          IoT Greengrass V2 uses semantic version constraints. For more information, see <a href="https://semver.org/">Semantic Versioning.
        public var versionRequirement: Swift.String?

        public init (
            dependencyType: GreengrassV2ClientTypes.ComponentDependencyType? = nil,
            versionRequirement: Swift.String? = nil
        )
        {
            self.dependencyType = dependencyType
            self.versionRequirement = versionRequirement
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum ComponentDependencyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hard
        case soft
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentDependencyType] {
            return [
                .hard,
                .soft,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hard: return "HARD"
            case .soft: return "SOFT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentDependencyType(rawValue: rawValue) ?? ComponentDependencyType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.ComponentDeploymentSpecification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersion
        case configurationUpdate
        case runWith
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let configurationUpdate = configurationUpdate {
            try encodeContainer.encode(configurationUpdate, forKey: .configurationUpdate)
        }
        if let runWith = runWith {
            try encodeContainer.encode(runWith, forKey: .runWith)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let configurationUpdateDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.ComponentConfigurationUpdate.self, forKey: .configurationUpdate)
        configurationUpdate = configurationUpdateDecoded
        let runWithDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.ComponentRunWith.self, forKey: .runWith)
        runWith = runWithDecoded
    }
}

extension GreengrassV2ClientTypes.ComponentDeploymentSpecification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentDeploymentSpecification(componentVersion: \(Swift.String(describing: componentVersion)), configurationUpdate: \(Swift.String(describing: configurationUpdate)), runWith: \(Swift.String(describing: runWith)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component to deploy.
    public struct ComponentDeploymentSpecification: Swift.Equatable {
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// The configuration updates to deploy for the component. You can define
        ///       reset updates and merge updates. A reset updates
        ///       the keys that you specify to the default configuration for the component. A merge updates the
        ///       core device's component configuration with the keys and values that you specify. The IoT Greengrass Core
        ///       software applies reset updates before it applies merge updates. For more information, see
        ///       <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/update-component-configurations.html">Update component
        ///         configurations in the IoT Greengrass V2 Developer Guide.
        public var configurationUpdate: GreengrassV2ClientTypes.ComponentConfigurationUpdate?
        /// The system user and group that the IoT Greengrass Core software uses to run component processes on the
        ///       core device. If you omit this parameter, the IoT Greengrass Core software uses the system user and group
        ///       that you configure for the core device. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user">Configure the user and group that run components in the IoT Greengrass V2 Developer
        ///         Guide.
        public var runWith: GreengrassV2ClientTypes.ComponentRunWith?

        public init (
            componentVersion: Swift.String? = nil,
            configurationUpdate: GreengrassV2ClientTypes.ComponentConfigurationUpdate? = nil,
            runWith: GreengrassV2ClientTypes.ComponentRunWith? = nil
        )
        {
            self.componentVersion = componentVersion
            self.configurationUpdate = configurationUpdate
            self.runWith = runWith
        }
    }

}

extension GreengrassV2ClientTypes.ComponentLatestVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentVersion
        case creationTimestamp
        case description
        case platforms
        case publisher
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let platforms = platforms {
            var platformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platforms)
            for componentplatformlist0 in platforms {
                try platformsContainer.encode(componentplatformlist0)
            }
        }
        if let publisher = publisher {
            try encodeContainer.encode(publisher, forKey: .publisher)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let publisherDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publisher)
        publisher = publisherDecoded
        let platformsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ComponentPlatform?].self, forKey: .platforms)
        var platformsDecoded0:[GreengrassV2ClientTypes.ComponentPlatform]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [GreengrassV2ClientTypes.ComponentPlatform]()
            for structure0 in platformsContainer {
                if let structure0 = structure0 {
                    platformsDecoded0?.append(structure0)
                }
            }
        }
        platforms = platformsDecoded0
    }
}

extension GreengrassV2ClientTypes.ComponentLatestVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentLatestVersion(arn: \(Swift.String(describing: arn)), componentVersion: \(Swift.String(describing: componentVersion)), creationTimestamp: \(Swift.String(describing: creationTimestamp)), description: \(Swift.String(describing: description)), platforms: \(Swift.String(describing: platforms)), publisher: \(Swift.String(describing: publisher)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about the latest version of a component.
    public struct ComponentLatestVersion: Swift.Equatable {
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the component version.
        public var arn: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// The time at which the component was created, expressed in ISO 8601 format.
        public var creationTimestamp: ClientRuntime.Date?
        /// The description of the component version.
        public var description: Swift.String?
        /// The platforms that the component version supports.
        public var platforms: [GreengrassV2ClientTypes.ComponentPlatform]?
        /// The publisher of the component version.
        public var publisher: Swift.String?

        public init (
            arn: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            creationTimestamp: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            platforms: [GreengrassV2ClientTypes.ComponentPlatform]? = nil,
            publisher: Swift.String? = nil
        )
        {
            self.arn = arn
            self.componentVersion = componentVersion
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.platforms = platforms
            self.publisher = publisher
        }
    }

}

extension GreengrassV2ClientTypes.ComponentPlatform: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, platformattributesmap0) in attributes {
                try attributesContainer.encode(platformattributesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in attributesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    attributesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension GreengrassV2ClientTypes.ComponentPlatform: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentPlatform(attributes: \(Swift.String(describing: attributes)), name: \(Swift.String(describing: name)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a platform that a component supports.
    public struct ComponentPlatform: Swift.Equatable {
        /// A dictionary of attributes for the platform. The IoT Greengrass Core software defines the
        ///         os and platform by default. You can specify additional platform
        ///       attributes for a core device when you deploy the Greengrass nucleus component. For more information,
        ///       see the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/greengrass-nucleus-component.html">Greengrass nucleus
        ///         component in the IoT Greengrass V2 Developer Guide.
        public var attributes: [Swift.String:Swift.String]?
        /// The friendly name of the platform. This name helps you identify the platform.
        ///          If you omit this parameter, IoT Greengrass creates a friendly name from the os and
        ///         architecture of the platform.
        public var name: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.name = name
        }
    }

}

extension GreengrassV2ClientTypes.ComponentRunWith: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case posixUser
        case systemResourceLimits
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let posixUser = posixUser {
            try encodeContainer.encode(posixUser, forKey: .posixUser)
        }
        if let systemResourceLimits = systemResourceLimits {
            try encodeContainer.encode(systemResourceLimits, forKey: .systemResourceLimits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let posixUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .posixUser)
        posixUser = posixUserDecoded
        let systemResourceLimitsDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.SystemResourceLimits.self, forKey: .systemResourceLimits)
        systemResourceLimits = systemResourceLimitsDecoded
    }
}

extension GreengrassV2ClientTypes.ComponentRunWith: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentRunWith(posixUser: \(Swift.String(describing: posixUser)), systemResourceLimits: \(Swift.String(describing: systemResourceLimits)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information system user and group that the IoT Greengrass Core software uses to run component
    ///       processes on the core device. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user">Configure the user and group that run components in the IoT Greengrass V2 Developer
    ///         Guide.
    public struct ComponentRunWith: Swift.Equatable {
        /// The POSIX system user and (optional) group to use to run this component. Specify the user
        ///       and group separated by a colon (:) in the following format:
        ///         user:group. The group is optional. If you don't specify a group, the IoT Greengrass Core
        ///       software uses the primary user for the group.
        ///          If you omit this parameter, the IoT Greengrass Core software uses the default system user and group that
        ///       you configure on the Greengrass nucleus component. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-user">Configure the user and group that run components.
        public var posixUser: Swift.String?
        /// The system resource limits to apply to this component's process on the core device.
        ///          If you omit this parameter, the IoT Greengrass Core software uses the default system resource limits
        ///       that you configure on the Greengrass nucleus component. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-system-resource-limits">Configure system resource limits for components.
        public var systemResourceLimits: GreengrassV2ClientTypes.SystemResourceLimits?

        public init (
            posixUser: Swift.String? = nil,
            systemResourceLimits: GreengrassV2ClientTypes.SystemResourceLimits? = nil
        )
        {
            self.posixUser = posixUser
            self.systemResourceLimits = systemResourceLimits
        }
    }

}

extension GreengrassV2ClientTypes.ComponentVersionListItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentName
        case componentVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GreengrassV2ClientTypes.ComponentVersionListItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentVersionListItem(arn: \(Swift.String(describing: arn)), componentName: \(Swift.String(describing: componentName)), componentVersion: \(Swift.String(describing: componentVersion)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component version in a list.
    public struct ComponentVersionListItem: Swift.Equatable {
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the component version.
        public var arn: Swift.String?
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?

        public init (
            arn: Swift.String? = nil,
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.componentName = componentName
            self.componentVersion = componentVersion
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum ComponentVisibilityScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentVisibilityScope] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentVisibilityScope(rawValue: rawValue) ?? ComponentVisibilityScope.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request has conflicting operations. This can occur if you're trying to perform more
///       than one operation on the same resource at the same time.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource that conflicts with the request.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource that conflicts with the request.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension GreengrassV2ClientTypes.CoreDevice: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreDeviceThingName
        case lastStatusUpdateTimestamp
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreDeviceThingName = coreDeviceThingName {
            try encodeContainer.encode(coreDeviceThingName, forKey: .coreDeviceThingName)
        }
        if let lastStatusUpdateTimestamp = lastStatusUpdateTimestamp {
            try encodeContainer.encode(lastStatusUpdateTimestamp.timeIntervalSince1970, forKey: .lastStatusUpdateTimestamp)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreDeviceThingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreDeviceThingName)
        coreDeviceThingName = coreDeviceThingNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.CoreDeviceStatus.self, forKey: .status)
        status = statusDecoded
        let lastStatusUpdateTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastStatusUpdateTimestamp)
        lastStatusUpdateTimestamp = lastStatusUpdateTimestampDecoded
    }
}

extension GreengrassV2ClientTypes.CoreDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CoreDevice(coreDeviceThingName: \(Swift.String(describing: coreDeviceThingName)), lastStatusUpdateTimestamp: \(Swift.String(describing: lastStatusUpdateTimestamp)), status: \(Swift.String(describing: status)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a Greengrass core device, which is an IoT thing that runs the IoT Greengrass
    ///       Core software.
    public struct CoreDevice: Swift.Equatable {
        /// The name of the core device. This is also the name of the IoT thing.
        public var coreDeviceThingName: Swift.String?
        /// The time at which the core device's status last updated, expressed in ISO 8601
        ///       format.
        public var lastStatusUpdateTimestamp: ClientRuntime.Date?
        /// The status of the core device. Core devices can have the following statuses:
        ///
        ///
        ///
        ///                   HEALTHY  The IoT Greengrass Core software and all components run on the core device without issue.
        ///
        ///
        ///
        ///                   UNHEALTHY  The IoT Greengrass Core software or a component is in a failed state
        ///           on the core device.
        ///
        ///
        public var status: GreengrassV2ClientTypes.CoreDeviceStatus?

        public init (
            coreDeviceThingName: Swift.String? = nil,
            lastStatusUpdateTimestamp: ClientRuntime.Date? = nil,
            status: GreengrassV2ClientTypes.CoreDeviceStatus? = nil
        )
        {
            self.coreDeviceThingName = coreDeviceThingName
            self.lastStatusUpdateTimestamp = lastStatusUpdateTimestamp
            self.status = status
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum CoreDeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CoreDeviceStatus] {
            return [
                .healthy,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoreDeviceStatus(rawValue: rawValue) ?? CoreDeviceStatus.sdkUnknown(rawValue)
        }
    }
}

public struct CreateComponentVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateComponentVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateComponentVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateComponentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateComponentVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateComponentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateComponentVersionOutputError>
}

extension CreateComponentVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateComponentVersionInput(clientToken: \(Swift.String(describing: clientToken)), inlineRecipe: \(Swift.String(describing: inlineRecipe)), lambdaFunction: \(Swift.String(describing: lambdaFunction)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateComponentVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case inlineRecipe
        case lambdaFunction
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let inlineRecipe = inlineRecipe {
            try encodeContainer.encode(inlineRecipe.base64EncodedString(), forKey: .inlineRecipe)
        }
        if let lambdaFunction = lambdaFunction {
            try encodeContainer.encode(lambdaFunction, forKey: .lambdaFunction)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateComponentVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateComponentVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateComponentVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateComponentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateComponentVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateComponentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateComponentVersionOutputError>
}

public struct CreateComponentVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateComponentVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateComponentVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateComponentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateComponentVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateComponentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateComponentVersionOutputError>
}

public struct CreateComponentVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateComponentVersionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateComponentVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateComponentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/createComponentVersion"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateComponentVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateComponentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateComponentVersionOutputError>
}

public struct CreateComponentVersionInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you can provide to ensure that the request is idempotent.
    ///     Idempotency means that the request is successfully processed only once, even if you send the request multiple times.
    ///     When a request succeeds, and you specify the same client token for subsequent successful requests, the IoT Greengrass V2 service
    ///     returns the successful response that it caches from the previous request. IoT Greengrass V2 caches successful responses for
    ///     idempotent requests for up to 8 hours.
    public var clientToken: Swift.String?
    /// The recipe to use to create the component. The recipe defines the component's metadata,
    ///       parameters, dependencies, lifecycle, artifacts, and platform compatibility.
    ///          You must specify either inlineRecipe or lambdaFunction.
    public var inlineRecipe: ClientRuntime.Data?
    /// The parameters to create a component from a Lambda function.
    ///          You must specify either inlineRecipe or lambdaFunction.
    public var lambdaFunction: GreengrassV2ClientTypes.LambdaFunctionRecipeSource?
    /// A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        inlineRecipe: ClientRuntime.Data? = nil,
        lambdaFunction: GreengrassV2ClientTypes.LambdaFunctionRecipeSource? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.inlineRecipe = inlineRecipe
        self.lambdaFunction = lambdaFunction
        self.tags = tags
    }
}

struct CreateComponentVersionInputBody: Swift.Equatable {
    public let inlineRecipe: ClientRuntime.Data?
    public let lambdaFunction: GreengrassV2ClientTypes.LambdaFunctionRecipeSource?
    public let tags: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateComponentVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case inlineRecipe
        case lambdaFunction
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlineRecipeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .inlineRecipe)
        inlineRecipe = inlineRecipeDecoded
        let lambdaFunctionDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaFunctionRecipeSource.self, forKey: .lambdaFunction)
        lambdaFunction = lambdaFunctionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateComponentVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateComponentVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestAlreadyInProgressException" : self = .requestAlreadyInProgressException(try RequestAlreadyInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateComponentVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestAlreadyInProgressException(RequestAlreadyInProgressException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateComponentVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateComponentVersionOutputResponse(arn: \(Swift.String(describing: arn)), componentName: \(Swift.String(describing: componentName)), componentVersion: \(Swift.String(describing: componentVersion)), creationTimestamp: \(Swift.String(describing: creationTimestamp)), status: \(Swift.String(describing: status)))"}
}

extension CreateComponentVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateComponentVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.componentName = output.componentName
            self.componentVersion = output.componentVersion
            self.creationTimestamp = output.creationTimestamp
            self.status = output.status
        } else {
            self.arn = nil
            self.componentName = nil
            self.componentVersion = nil
            self.creationTimestamp = nil
            self.status = nil
        }
    }
}

public struct CreateComponentVersionOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the component version.
    public var arn: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var componentName: Swift.String?
    /// The version of the component.
    /// This member is required.
    public var componentVersion: Swift.String?
    /// The time at which the component was created, expressed in ISO 8601 format.
    /// This member is required.
    public var creationTimestamp: ClientRuntime.Date?
    /// The status of the component version in IoT Greengrass V2. This status
    ///       is different from the status of the component on a core device.
    /// This member is required.
    public var status: GreengrassV2ClientTypes.CloudComponentStatus?

    public init (
        arn: Swift.String? = nil,
        componentName: Swift.String? = nil,
        componentVersion: Swift.String? = nil,
        creationTimestamp: ClientRuntime.Date? = nil,
        status: GreengrassV2ClientTypes.CloudComponentStatus? = nil
    )
    {
        self.arn = arn
        self.componentName = componentName
        self.componentVersion = componentVersion
        self.creationTimestamp = creationTimestamp
        self.status = status
    }
}

struct CreateComponentVersionOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let componentName: Swift.String?
    public let componentVersion: Swift.String?
    public let creationTimestamp: ClientRuntime.Date?
    public let status: GreengrassV2ClientTypes.CloudComponentStatus?
}

extension CreateComponentVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentName
        case componentVersion
        case creationTimestamp
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.CloudComponentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateDeploymentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentOutputError>
}

extension CreateDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeploymentInput(clientToken: \(Swift.String(describing: clientToken)), components: \(Swift.String(describing: components)), deploymentName: \(Swift.String(describing: deploymentName)), deploymentPolicies: \(Swift.String(describing: deploymentPolicies)), iotJobConfiguration: \(Swift.String(describing: iotJobConfiguration)), tags: \(Swift.String(describing: tags)), targetArn: \(Swift.String(describing: targetArn)))"}
}

extension CreateDeploymentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case components
        case deploymentName
        case deploymentPolicies
        case iotJobConfiguration
        case tags
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .components)
            for (dictKey0, componentdeploymentspecifications0) in components {
                try componentsContainer.encode(componentdeploymentspecifications0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let deploymentName = deploymentName {
            try encodeContainer.encode(deploymentName, forKey: .deploymentName)
        }
        if let deploymentPolicies = deploymentPolicies {
            try encodeContainer.encode(deploymentPolicies, forKey: .deploymentPolicies)
        }
        if let iotJobConfiguration = iotJobConfiguration {
            try encodeContainer.encode(iotJobConfiguration, forKey: .iotJobConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

public struct CreateDeploymentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDeploymentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/deployments"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you can provide to ensure that the request is idempotent.
    ///     Idempotency means that the request is successfully processed only once, even if you send the request multiple times.
    ///     When a request succeeds, and you specify the same client token for subsequent successful requests, the IoT Greengrass V2 service
    ///     returns the successful response that it caches from the previous request. IoT Greengrass V2 caches successful responses for
    ///     idempotent requests for up to 8 hours.
    public var clientToken: Swift.String?
    /// The components to deploy. This is a dictionary, where each key is the name of a component,
    ///         and each key's value is the version and configuration to deploy for that component.
    public var components: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]?
    /// The name of the deployment.
    public var deploymentName: Swift.String?
    /// The deployment policies for the deployment. These policies define how the deployment
    ///       updates components and handles failure.
    public var deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies?
    /// The job configuration for the deployment configuration. The job configuration specifies
    ///       the rollout, timeout, and stop configurations for the deployment configuration.
    public var iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration?
    /// A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the target IoT thing or thing group.
    /// This member is required.
    public var targetArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        components: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]? = nil,
        deploymentName: Swift.String? = nil,
        deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies? = nil,
        iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.components = components
        self.deploymentName = deploymentName
        self.deploymentPolicies = deploymentPolicies
        self.iotJobConfiguration = iotJobConfiguration
        self.tags = tags
        self.targetArn = targetArn
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    public let targetArn: Swift.String?
    public let deploymentName: Swift.String?
    public let components: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]?
    public let iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration?
    public let deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies?
    public let tags: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case components
        case deploymentName
        case deploymentPolicies
        case iotJobConfiguration
        case tags
        case targetArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let deploymentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let componentsContainer = try containerValues.decodeIfPresent([Swift.String: GreengrassV2ClientTypes.ComponentDeploymentSpecification?].self, forKey: .components)
        var componentsDecoded0: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]()
            for (key0, componentdeploymentspecification0) in componentsContainer {
                if let componentdeploymentspecification0 = componentdeploymentspecification0 {
                    componentsDecoded0?[key0] = componentdeploymentspecification0
                }
            }
        }
        components = componentsDecoded0
        let iotJobConfigurationDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentIoTJobConfiguration.self, forKey: .iotJobConfiguration)
        iotJobConfiguration = iotJobConfigurationDecoded
        let deploymentPoliciesDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentPolicies.self, forKey: .deploymentPolicies)
        deploymentPolicies = deploymentPoliciesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestAlreadyInProgressException" : self = .requestAlreadyInProgressException(try RequestAlreadyInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestAlreadyInProgressException(RequestAlreadyInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeploymentOutputResponse(deploymentId: \(Swift.String(describing: deploymentId)), iotJobArn: \(Swift.String(describing: iotJobArn)), iotJobId: \(Swift.String(describing: iotJobId)))"}
}

extension CreateDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentId = output.deploymentId
            self.iotJobArn = output.iotJobArn
            self.iotJobId = output.iotJobId
        } else {
            self.deploymentId = nil
            self.iotJobArn = nil
            self.iotJobId = nil
        }
    }
}

public struct CreateDeploymentOutputResponse: Swift.Equatable {
    /// The ID of the deployment.
    public var deploymentId: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the IoT job that applies the deployment to target devices.
    public var iotJobArn: Swift.String?
    /// The ID of the IoT job that applies the deployment to target devices.
    public var iotJobId: Swift.String?

    public init (
        deploymentId: Swift.String? = nil,
        iotJobArn: Swift.String? = nil,
        iotJobId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.iotJobArn = iotJobArn
        self.iotJobId = iotJobId
    }
}

struct CreateDeploymentOutputResponseBody: Swift.Equatable {
    public let deploymentId: Swift.String?
    public let iotJobId: Swift.String?
    public let iotJobArn: Swift.String?
}

extension CreateDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case iotJobArn
        case iotJobId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let iotJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobId)
        iotJobId = iotJobIdDecoded
        let iotJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobArn)
        iotJobArn = iotJobArnDecoded
    }
}

extension DeleteComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteComponentInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteComponentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteComponentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteComponentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let arn = input.arn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("arn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/components/\(arn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the component version.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteComponentInputBody: Swift.Equatable {
}

extension DeleteComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteComponentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteComponentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteComponentOutputResponse()"}
}

extension DeleteComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteComponentOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteComponentOutputResponseBody: Swift.Equatable {
}

extension DeleteComponentOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCoreDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCoreDeviceInput(coreDeviceThingName: \(Swift.String(describing: coreDeviceThingName)))"}
}

extension DeleteCoreDeviceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteCoreDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCoreDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCoreDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCoreDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCoreDeviceOutputError>
}

public struct DeleteCoreDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCoreDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCoreDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCoreDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCoreDeviceOutputError>
}

public struct DeleteCoreDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCoreDeviceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteCoreDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreDeviceThingName = input.coreDeviceThingName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreDeviceThingName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCoreDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCoreDeviceOutputError>
}

public struct DeleteCoreDeviceInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?

    public init (
        coreDeviceThingName: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
    }
}

struct DeleteCoreDeviceInputBody: Swift.Equatable {
}

extension DeleteCoreDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCoreDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCoreDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCoreDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCoreDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCoreDeviceOutputResponse()"}
}

extension DeleteCoreDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCoreDeviceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCoreDeviceOutputResponseBody: Swift.Equatable {
}

extension DeleteCoreDeviceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GreengrassV2ClientTypes.Deployment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp
        case deploymentId
        case deploymentName
        case deploymentStatus
        case isLatestForTarget
        case revisionId
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentName = deploymentName {
            try encodeContainer.encode(deploymentName, forKey: .deploymentName)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if isLatestForTarget != false {
            try encodeContainer.encode(isLatestForTarget, forKey: .isLatestForTarget)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let isLatestForTargetDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isLatestForTarget)
        isLatestForTarget = isLatestForTargetDecoded
    }
}

extension GreengrassV2ClientTypes.Deployment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Deployment(creationTimestamp: \(Swift.String(describing: creationTimestamp)), deploymentId: \(Swift.String(describing: deploymentId)), deploymentName: \(Swift.String(describing: deploymentName)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), isLatestForTarget: \(Swift.String(describing: isLatestForTarget)), revisionId: \(Swift.String(describing: revisionId)), targetArn: \(Swift.String(describing: targetArn)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a deployment.
    public struct Deployment: Swift.Equatable {
        /// The time at which the deployment was created, expressed in ISO 8601 format.
        public var creationTimestamp: ClientRuntime.Date?
        /// The ID of the deployment.
        public var deploymentId: Swift.String?
        /// The name of the deployment.
        public var deploymentName: Swift.String?
        /// The status of the deployment.
        public var deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus?
        /// Whether or not the deployment is the latest revision for its target.
        public var isLatestForTarget: Swift.Bool
        /// The revision number of the deployment.
        public var revisionId: Swift.String?
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the target IoT thing or thing group.
        public var targetArn: Swift.String?

        public init (
            creationTimestamp: ClientRuntime.Date? = nil,
            deploymentId: Swift.String? = nil,
            deploymentName: Swift.String? = nil,
            deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus? = nil,
            isLatestForTarget: Swift.Bool = false,
            revisionId: Swift.String? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.creationTimestamp = creationTimestamp
            self.deploymentId = deploymentId
            self.deploymentName = deploymentName
            self.deploymentStatus = deploymentStatus
            self.isLatestForTarget = isLatestForTarget
            self.revisionId = revisionId
            self.targetArn = targetArn
        }
    }

}

extension GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentComponentUpdatePolicyAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentComponentUpdatePolicy(action: \(Swift.String(describing: action)), timeoutInSeconds: \(Swift.String(describing: timeoutInSeconds)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a deployment's policy that defines when components are safe to
    ///       update.
    ///          Each component on a device can report whether or not it's ready to update. After a
    ///       component and its dependencies are ready, they can apply the update in the deployment. You can
    ///       configure whether or not the deployment notifies components of an update and waits for a
    ///       response. You specify the amount of time each component has to respond to the update
    ///       notification.
    public struct DeploymentComponentUpdatePolicy: Swift.Equatable {
        /// Whether or not to notify components and wait for components to become safe to update.
        ///       Choose from the following options:
        ///
        ///
        ///
        ///                   NOTIFY_COMPONENTS  The deployment notifies each component before
        ///           it stops and updates that component. Components can use the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-subscribetocomponentupdates">SubscribeToComponentUpdates IPC operation to receive these notifications. Then,
        ///           components can respond with the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-defercomponentupdate">DeferComponentUpdate IPC operation. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/create-deployments.html">Create deployments in the IoT Greengrass V2 Developer Guide.
        ///
        ///
        ///
        ///                   SKIP_NOTIFY_COMPONENTS  The deployment doesn't notify components
        ///           or wait for them to be safe to update.
        ///
        ///
        ///          Default: NOTIFY_COMPONENTS
        ///
        public var action: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicyAction?
        /// The amount of time in seconds that each component on a device has to report that it's safe
        ///       to update. If the component waits for longer than this timeout, then the deployment proceeds
        ///       on the device.
        ///          Default: 60
        ///
        public var timeoutInSeconds: Swift.Int

        public init (
            action: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicyAction? = nil,
            timeoutInSeconds: Swift.Int = 0
        )
        {
            self.action = action
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum DeploymentComponentUpdatePolicyAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notifyComponents
        case skipNotifyComponents
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentComponentUpdatePolicyAction] {
            return [
                .notifyComponents,
                .skipNotifyComponents,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notifyComponents: return "NOTIFY_COMPONENTS"
            case .skipNotifyComponents: return "SKIP_NOTIFY_COMPONENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentComponentUpdatePolicyAction(rawValue: rawValue) ?? DeploymentComponentUpdatePolicyAction.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
    }
}

extension GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentConfigurationValidationPolicy(timeoutInSeconds: \(Swift.String(describing: timeoutInSeconds)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about how long a component on a core device can validate its
    ///       configuration updates before it times out. Components can use the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-subscribetovalidateconfigurationupdates">SubscribeToValidateConfigurationUpdates IPC operation to receive notifications when
    ///       a deployment specifies a configuration update. Then, components can respond with the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/interprocess-communication.html#ipc-operation-sendconfigurationvalidityreport">SendConfigurationValidityReport IPC operation. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/create-deployments.html">Create deployments in the IoT Greengrass V2 Developer Guide.
    public struct DeploymentConfigurationValidationPolicy: Swift.Equatable {
        /// The amount of time in seconds that a component can validate its configuration updates. If
        ///       the validation time exceeds this timeout, then the deployment proceeds for the device.
        ///          Default: 30
        ///
        public var timeoutInSeconds: Swift.Int

        public init (
            timeoutInSeconds: Swift.Int = 0
        )
        {
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum DeploymentFailureHandlingPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case doNothing
        case rollback
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentFailureHandlingPolicy] {
            return [
                .doNothing,
                .rollback,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .doNothing: return "DO_NOTHING"
            case .rollback: return "ROLLBACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentFailureHandlingPolicy(rawValue: rawValue) ?? DeploymentFailureHandlingPolicy.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes {
    public enum DeploymentHistoryFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case latestOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentHistoryFilter] {
            return [
                .all,
                .latestOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .latestOnly: return "LATEST_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentHistoryFilter(rawValue: rawValue) ?? DeploymentHistoryFilter.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.DeploymentIoTJobConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortConfig
        case jobExecutionsRolloutConfig
        case timeoutConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortConfig = abortConfig {
            try encodeContainer.encode(abortConfig, forKey: .abortConfig)
        }
        if let jobExecutionsRolloutConfig = jobExecutionsRolloutConfig {
            try encodeContainer.encode(jobExecutionsRolloutConfig, forKey: .jobExecutionsRolloutConfig)
        }
        if let timeoutConfig = timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobAbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobTimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
    }
}

extension GreengrassV2ClientTypes.DeploymentIoTJobConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentIoTJobConfiguration(abortConfig: \(Swift.String(describing: abortConfig)), jobExecutionsRolloutConfig: \(Swift.String(describing: jobExecutionsRolloutConfig)), timeoutConfig: \(Swift.String(describing: timeoutConfig)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about an IoT job configuration.
    public struct DeploymentIoTJobConfiguration: Swift.Equatable {
        /// The stop configuration for the job. This configuration defines when and how to stop a job
        ///       rollout.
        public var abortConfig: GreengrassV2ClientTypes.IoTJobAbortConfig?
        /// The rollout configuration for the job. This configuration defines the rate at which the
        ///       job rolls out to the fleet of target devices.
        public var jobExecutionsRolloutConfig: GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig?
        /// The timeout configuration for the job. This configuration defines the amount of time each
        ///       device has to complete the job.
        public var timeoutConfig: GreengrassV2ClientTypes.IoTJobTimeoutConfig?

        public init (
            abortConfig: GreengrassV2ClientTypes.IoTJobAbortConfig? = nil,
            jobExecutionsRolloutConfig: GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig? = nil,
            timeoutConfig: GreengrassV2ClientTypes.IoTJobTimeoutConfig? = nil
        )
        {
            self.abortConfig = abortConfig
            self.jobExecutionsRolloutConfig = jobExecutionsRolloutConfig
            self.timeoutConfig = timeoutConfig
        }
    }

}

extension GreengrassV2ClientTypes.DeploymentPolicies: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentUpdatePolicy
        case configurationValidationPolicy
        case failureHandlingPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentUpdatePolicy = componentUpdatePolicy {
            try encodeContainer.encode(componentUpdatePolicy, forKey: .componentUpdatePolicy)
        }
        if let configurationValidationPolicy = configurationValidationPolicy {
            try encodeContainer.encode(configurationValidationPolicy, forKey: .configurationValidationPolicy)
        }
        if let failureHandlingPolicy = failureHandlingPolicy {
            try encodeContainer.encode(failureHandlingPolicy.rawValue, forKey: .failureHandlingPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureHandlingPolicyDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentFailureHandlingPolicy.self, forKey: .failureHandlingPolicy)
        failureHandlingPolicy = failureHandlingPolicyDecoded
        let componentUpdatePolicyDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy.self, forKey: .componentUpdatePolicy)
        componentUpdatePolicy = componentUpdatePolicyDecoded
        let configurationValidationPolicyDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy.self, forKey: .configurationValidationPolicy)
        configurationValidationPolicy = configurationValidationPolicyDecoded
    }
}

extension GreengrassV2ClientTypes.DeploymentPolicies: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentPolicies(componentUpdatePolicy: \(Swift.String(describing: componentUpdatePolicy)), configurationValidationPolicy: \(Swift.String(describing: configurationValidationPolicy)), failureHandlingPolicy: \(Swift.String(describing: failureHandlingPolicy)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about policies that define how a deployment updates components and
    ///       handles failure.
    public struct DeploymentPolicies: Swift.Equatable {
        /// The component update policy for the configuration deployment. This policy defines when
        ///       it's safe to deploy the configuration to devices.
        public var componentUpdatePolicy: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy?
        /// The configuration validation policy for the configuration deployment. This policy defines
        ///       how long each component has to validate its configure updates.
        public var configurationValidationPolicy: GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy?
        /// The failure handling policy for the configuration deployment. This policy defines what to
        ///       do if the deployment fails.
        ///          Default: ROLLBACK
        ///
        public var failureHandlingPolicy: GreengrassV2ClientTypes.DeploymentFailureHandlingPolicy?

        public init (
            componentUpdatePolicy: GreengrassV2ClientTypes.DeploymentComponentUpdatePolicy? = nil,
            configurationValidationPolicy: GreengrassV2ClientTypes.DeploymentConfigurationValidationPolicy? = nil,
            failureHandlingPolicy: GreengrassV2ClientTypes.DeploymentFailureHandlingPolicy? = nil
        )
        {
            self.componentUpdatePolicy = componentUpdatePolicy
            self.configurationValidationPolicy = configurationValidationPolicy
            self.failureHandlingPolicy = failureHandlingPolicy
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case canceled
        case completed
        case failed
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .active,
                .canceled,
                .completed,
                .failed,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension DescribeComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeComponentInput(arn: \(Swift.String(describing: arn)))"}
}

extension DescribeComponentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeComponentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeComponentOutputError>
}

public struct DescribeComponentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeComponentOutputError>
}

public struct DescribeComponentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeComponentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let arn = input.arn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("arn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/components/\(arn.urlPercentEncoding())/metadata"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeComponentOutputError>
}

public struct DescribeComponentInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the component version.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DescribeComponentInputBody: Swift.Equatable {
}

extension DescribeComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeComponentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeComponentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeComponentOutputResponse(arn: \(Swift.String(describing: arn)), componentName: \(Swift.String(describing: componentName)), componentVersion: \(Swift.String(describing: componentVersion)), creationTimestamp: \(Swift.String(describing: creationTimestamp)), description: \(Swift.String(describing: description)), platforms: \(Swift.String(describing: platforms)), publisher: \(Swift.String(describing: publisher)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.componentName = output.componentName
            self.componentVersion = output.componentVersion
            self.creationTimestamp = output.creationTimestamp
            self.description = output.description
            self.platforms = output.platforms
            self.publisher = output.publisher
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.componentName = nil
            self.componentVersion = nil
            self.creationTimestamp = nil
            self.description = nil
            self.platforms = nil
            self.publisher = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct DescribeComponentOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the component version.
    public var arn: Swift.String?
    /// The name of the component.
    public var componentName: Swift.String?
    /// The version of the component.
    public var componentVersion: Swift.String?
    /// The time at which the component was created, expressed in ISO 8601 format.
    public var creationTimestamp: ClientRuntime.Date?
    /// The description of the component version.
    public var description: Swift.String?
    /// The platforms that the component version supports.
    public var platforms: [GreengrassV2ClientTypes.ComponentPlatform]?
    /// The publisher of the component version.
    public var publisher: Swift.String?
    /// The status of the component version in IoT Greengrass V2. This status
    ///       is different from the status of the component on a core device.
    public var status: GreengrassV2ClientTypes.CloudComponentStatus?
    /// A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        componentName: Swift.String? = nil,
        componentVersion: Swift.String? = nil,
        creationTimestamp: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        platforms: [GreengrassV2ClientTypes.ComponentPlatform]? = nil,
        publisher: Swift.String? = nil,
        status: GreengrassV2ClientTypes.CloudComponentStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.componentName = componentName
        self.componentVersion = componentVersion
        self.creationTimestamp = creationTimestamp
        self.description = description
        self.platforms = platforms
        self.publisher = publisher
        self.status = status
        self.tags = tags
    }
}

struct DescribeComponentOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let componentName: Swift.String?
    public let componentVersion: Swift.String?
    public let creationTimestamp: ClientRuntime.Date?
    public let publisher: Swift.String?
    public let description: Swift.String?
    public let status: GreengrassV2ClientTypes.CloudComponentStatus?
    public let platforms: [GreengrassV2ClientTypes.ComponentPlatform]?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentName
        case componentVersion
        case creationTimestamp
        case description
        case platforms
        case publisher
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let publisherDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publisher)
        publisher = publisherDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.CloudComponentStatus.self, forKey: .status)
        status = statusDecoded
        let platformsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ComponentPlatform?].self, forKey: .platforms)
        var platformsDecoded0:[GreengrassV2ClientTypes.ComponentPlatform]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [GreengrassV2ClientTypes.ComponentPlatform]()
            for structure0 in platformsContainer {
                if let structure0 = structure0 {
                    platformsDecoded0?.append(structure0)
                }
            }
        }
        platforms = platformsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
    }
}

extension GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateClientDeviceFromCoreDeviceEntry(thingName: \(Swift.String(describing: thingName)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains a request to disassociate a client device from a core device. The <a href="https://docs.aws.amazon.com/greengrass/v2/APIReference/API_BatchDisassociateClientDeviceWithCoreDevice.html">BatchDisassociateClientDeviceWithCoreDevice operation consumes a list of these
    ///       requests.
    public struct DisassociateClientDeviceFromCoreDeviceEntry: Swift.Equatable {
        /// The name of the IoT thing that represents the client device to disassociate.
        /// This member is required.
        public var thingName: Swift.String?

        public init (
            thingName: Swift.String? = nil
        )
        {
            self.thingName = thingName
        }
    }

}

extension GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case thingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let thingName = thingName {
            try encodeContainer.encode(thingName, forKey: .thingName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassV2ClientTypes.DisassociateClientDeviceFromCoreDeviceErrorEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateClientDeviceFromCoreDeviceErrorEntry(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), thingName: \(Swift.String(describing: thingName)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains an error that occurs from a request to disassociate a client device from a core
    ///       device. The <a href="https://docs.aws.amazon.com/greengrass/v2/APIReference/API_BatchDisassociateClientDeviceWithCoreDevice.html">BatchDisassociateClientDeviceWithCoreDevice operation returns a list of these
    ///       errors.
    public struct DisassociateClientDeviceFromCoreDeviceErrorEntry: Swift.Equatable {
        /// The error code for the request.
        public var code: Swift.String?
        /// A message that provides additional information about the error.
        public var message: Swift.String?
        /// The name of the IoT thing whose disassociate request failed.
        public var thingName: Swift.String?

        public init (
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            thingName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.thingName = thingName
        }
    }

}

extension GreengrassV2ClientTypes.EffectiveDeployment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreDeviceExecutionStatus
        case creationTimestamp
        case deploymentId
        case deploymentName
        case description
        case iotJobArn
        case iotJobId
        case modifiedTimestamp
        case reason
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreDeviceExecutionStatus = coreDeviceExecutionStatus {
            try encodeContainer.encode(coreDeviceExecutionStatus.rawValue, forKey: .coreDeviceExecutionStatus)
        }
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentName = deploymentName {
            try encodeContainer.encode(deploymentName, forKey: .deploymentName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iotJobArn = iotJobArn {
            try encodeContainer.encode(iotJobArn, forKey: .iotJobArn)
        }
        if let iotJobId = iotJobId {
            try encodeContainer.encode(iotJobId, forKey: .iotJobId)
        }
        if let modifiedTimestamp = modifiedTimestamp {
            try encodeContainer.encode(modifiedTimestamp.timeIntervalSince1970, forKey: .modifiedTimestamp)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let iotJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobId)
        iotJobId = iotJobIdDecoded
        let iotJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobArn)
        iotJobArn = iotJobArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let coreDeviceExecutionStatusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.EffectiveDeploymentExecutionStatus.self, forKey: .coreDeviceExecutionStatus)
        coreDeviceExecutionStatus = coreDeviceExecutionStatusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
    }
}

extension GreengrassV2ClientTypes.EffectiveDeployment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EffectiveDeployment(coreDeviceExecutionStatus: \(Swift.String(describing: coreDeviceExecutionStatus)), creationTimestamp: \(Swift.String(describing: creationTimestamp)), deploymentId: \(Swift.String(describing: deploymentId)), deploymentName: \(Swift.String(describing: deploymentName)), description: \(Swift.String(describing: description)), iotJobArn: \(Swift.String(describing: iotJobArn)), iotJobId: \(Swift.String(describing: iotJobId)), modifiedTimestamp: \(Swift.String(describing: modifiedTimestamp)), reason: \(Swift.String(describing: reason)), targetArn: \(Swift.String(describing: targetArn)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a deployment job that IoT Greengrass sends to a Greengrass core device.
    public struct EffectiveDeployment: Swift.Equatable {
        /// The status of the deployment job on the Greengrass core device.
        /// This member is required.
        public var coreDeviceExecutionStatus: GreengrassV2ClientTypes.EffectiveDeploymentExecutionStatus?
        /// The time at which the deployment was created, expressed in ISO 8601 format.
        /// This member is required.
        public var creationTimestamp: ClientRuntime.Date?
        /// The ID of the deployment.
        /// This member is required.
        public var deploymentId: Swift.String?
        /// The name of the deployment.
        /// This member is required.
        public var deploymentName: Swift.String?
        /// The description of the deployment job.
        public var description: Swift.String?
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the IoT job that applies the deployment to target devices.
        public var iotJobArn: Swift.String?
        /// The ID of the IoT job that applies the deployment to target devices.
        public var iotJobId: Swift.String?
        /// The time at which the deployment job was last modified, expressed in ISO 8601
        ///       format.
        /// This member is required.
        public var modifiedTimestamp: ClientRuntime.Date?
        /// The reason code for the update, if the job was updated.
        public var reason: Swift.String?
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the target IoT thing or thing group.
        /// This member is required.
        public var targetArn: Swift.String?

        public init (
            coreDeviceExecutionStatus: GreengrassV2ClientTypes.EffectiveDeploymentExecutionStatus? = nil,
            creationTimestamp: ClientRuntime.Date? = nil,
            deploymentId: Swift.String? = nil,
            deploymentName: Swift.String? = nil,
            description: Swift.String? = nil,
            iotJobArn: Swift.String? = nil,
            iotJobId: Swift.String? = nil,
            modifiedTimestamp: ClientRuntime.Date? = nil,
            reason: Swift.String? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.coreDeviceExecutionStatus = coreDeviceExecutionStatus
            self.creationTimestamp = creationTimestamp
            self.deploymentId = deploymentId
            self.deploymentName = deploymentName
            self.description = description
            self.iotJobArn = iotJobArn
            self.iotJobId = iotJobId
            self.modifiedTimestamp = modifiedTimestamp
            self.reason = reason
            self.targetArn = targetArn
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum EffectiveDeploymentExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case completed
        case failed
        case inProgress
        case queued
        case rejected
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [EffectiveDeploymentExecutionStatus] {
            return [
                .canceled,
                .completed,
                .failed,
                .inProgress,
                .queued,
                .rejected,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .rejected: return "REJECTED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EffectiveDeploymentExecutionStatus(rawValue: rawValue) ?? EffectiveDeploymentExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetComponentInput(arn: \(Swift.String(describing: arn)), recipeOutputFormat: \(Swift.String(describing: recipeOutputFormat)))"}
}

extension GetComponentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetComponentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentOutputError>
}

public struct GetComponentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let recipeOutputFormat = input.operationInput.recipeOutputFormat {
            let recipeOutputFormatQueryItem = ClientRuntime.URLQueryItem(name: "recipeOutputFormat".urlPercentEncoding(), value: Swift.String(recipeOutputFormat.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(recipeOutputFormatQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentOutputError>
}

public struct GetComponentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let arn = input.arn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("arn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/components/\(arn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentOutputError>
}

public struct GetComponentInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the component version.
    /// This member is required.
    public var arn: Swift.String?
    /// The format of the recipe.
    public var recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat?

    public init (
        arn: Swift.String? = nil,
        recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat? = nil
    )
    {
        self.arn = arn
        self.recipeOutputFormat = recipeOutputFormat
    }
}

struct GetComponentInputBody: Swift.Equatable {
}

extension GetComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComponentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetComponentOutputResponse(recipe: \(Swift.String(describing: recipe)), recipeOutputFormat: \(Swift.String(describing: recipeOutputFormat)), tags: \(Swift.String(describing: tags)))"}
}

extension GetComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recipe = output.recipe
            self.recipeOutputFormat = output.recipeOutputFormat
            self.tags = output.tags
        } else {
            self.recipe = nil
            self.recipeOutputFormat = nil
            self.tags = nil
        }
    }
}

public struct GetComponentOutputResponse: Swift.Equatable {
    /// The recipe of the component version.
    /// This member is required.
    public var recipe: ClientRuntime.Data?
    /// The format of the recipe.
    /// This member is required.
    public var recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat?
    /// A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        recipe: ClientRuntime.Data? = nil,
        recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.recipe = recipe
        self.recipeOutputFormat = recipeOutputFormat
        self.tags = tags
    }
}

struct GetComponentOutputResponseBody: Swift.Equatable {
    public let recipeOutputFormat: GreengrassV2ClientTypes.RecipeOutputFormat?
    public let recipe: ClientRuntime.Data?
    public let tags: [Swift.String:Swift.String]?
}

extension GetComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipe
        case recipeOutputFormat
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeOutputFormatDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.RecipeOutputFormat.self, forKey: .recipeOutputFormat)
        recipeOutputFormat = recipeOutputFormatDecoded
        let recipeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .recipe)
        recipe = recipeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetComponentVersionArtifactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetComponentVersionArtifactInput(arn: \(Swift.String(describing: arn)), artifactName: \(Swift.String(describing: artifactName)))"}
}

extension GetComponentVersionArtifactInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetComponentVersionArtifactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentVersionArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetComponentVersionArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentVersionArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetComponentVersionArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentVersionArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentVersionArtifactOutputError>
}

public struct GetComponentVersionArtifactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentVersionArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetComponentVersionArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentVersionArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetComponentVersionArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentVersionArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentVersionArtifactOutputError>
}

public struct GetComponentVersionArtifactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentVersionArtifactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetComponentVersionArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentVersionArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let arn = input.arn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("arn is nil and needs a value for the path of this operation"))))
        }
        guard let artifactName = input.artifactName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("artifactName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/components/\(arn.urlPercentEncoding())/artifacts/\(artifactName)"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetComponentVersionArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentVersionArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentVersionArtifactOutputError>
}

public struct GetComponentVersionArtifactInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the component version. Specify the ARN of a public component version.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the artifact.
    ///          You can use the <a href="https://docs.aws.amazon.com/greengrass/v2/APIReference/API_GetComponent.html">GetComponent operation to
    ///       download the component recipe, which includes the URI of the artifact. The artifact name is
    ///       the section of the URI after the scheme. For example, in the artifact URI
    ///         greengrass:SomeArtifact.zip, the artifact name is
    ///       SomeArtifact.zip.
    /// This member is required.
    public var artifactName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        artifactName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.artifactName = artifactName
    }
}

struct GetComponentVersionArtifactInputBody: Swift.Equatable {
}

extension GetComponentVersionArtifactInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentVersionArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentVersionArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComponentVersionArtifactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentVersionArtifactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetComponentVersionArtifactOutputResponse(preSignedUrl: \(Swift.String(describing: preSignedUrl)))"}
}

extension GetComponentVersionArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetComponentVersionArtifactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.preSignedUrl = output.preSignedUrl
        } else {
            self.preSignedUrl = nil
        }
    }
}

public struct GetComponentVersionArtifactOutputResponse: Swift.Equatable {
    /// The URL of the artifact.
    /// This member is required.
    public var preSignedUrl: Swift.String?

    public init (
        preSignedUrl: Swift.String? = nil
    )
    {
        self.preSignedUrl = preSignedUrl
    }
}

struct GetComponentVersionArtifactOutputResponseBody: Swift.Equatable {
    public let preSignedUrl: Swift.String?
}

extension GetComponentVersionArtifactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preSignedUrl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preSignedUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preSignedUrl)
        preSignedUrl = preSignedUrlDecoded
    }
}

extension GetCoreDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCoreDeviceInput(coreDeviceThingName: \(Swift.String(describing: coreDeviceThingName)))"}
}

extension GetCoreDeviceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCoreDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCoreDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCoreDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreDeviceOutputError>
}

public struct GetCoreDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCoreDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCoreDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreDeviceOutputError>
}

public struct GetCoreDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCoreDeviceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetCoreDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreDeviceThingName = input.coreDeviceThingName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreDeviceThingName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCoreDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCoreDeviceOutputError>
}

public struct GetCoreDeviceInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?

    public init (
        coreDeviceThingName: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
    }
}

struct GetCoreDeviceInputBody: Swift.Equatable {
}

extension GetCoreDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCoreDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCoreDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCoreDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCoreDeviceOutputResponse(architecture: \(Swift.String(describing: architecture)), coreDeviceThingName: \(Swift.String(describing: coreDeviceThingName)), coreVersion: \(Swift.String(describing: coreVersion)), lastStatusUpdateTimestamp: \(Swift.String(describing: lastStatusUpdateTimestamp)), platform: \(Swift.String(describing: platform)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension GetCoreDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCoreDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.architecture = output.architecture
            self.coreDeviceThingName = output.coreDeviceThingName
            self.coreVersion = output.coreVersion
            self.lastStatusUpdateTimestamp = output.lastStatusUpdateTimestamp
            self.platform = output.platform
            self.status = output.status
            self.tags = output.tags
        } else {
            self.architecture = nil
            self.coreDeviceThingName = nil
            self.coreVersion = nil
            self.lastStatusUpdateTimestamp = nil
            self.platform = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetCoreDeviceOutputResponse: Swift.Equatable {
    /// The computer architecture of the core device.
    public var architecture: Swift.String?
    /// The name of the core device. This is also the name of the IoT thing.
    public var coreDeviceThingName: Swift.String?
    /// The version of the IoT Greengrass Core software that the core device runs. This version is equivalent to
    ///       the version of the Greengrass nucleus component that runs on the core device. For more information,
    ///       see the <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/greengrass-nucleus-component.html">Greengrass nucleus
    ///         component in the IoT Greengrass V2 Developer Guide.
    public var coreVersion: Swift.String?
    /// The time at which the core device's status last updated, expressed in ISO 8601
    ///       format.
    public var lastStatusUpdateTimestamp: ClientRuntime.Date?
    /// The operating system platform that the core device runs.
    public var platform: Swift.String?
    /// The status of the core device. The core device status can be:
    ///
    ///
    ///
    ///                   HEALTHY  The IoT Greengrass Core software and all components run on the core device without issue.
    ///
    ///
    ///
    ///                   UNHEALTHY  The IoT Greengrass Core software or a component is in a failed state
    ///           on the core device.
    ///
    ///
    public var status: GreengrassV2ClientTypes.CoreDeviceStatus?
    /// A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        architecture: Swift.String? = nil,
        coreDeviceThingName: Swift.String? = nil,
        coreVersion: Swift.String? = nil,
        lastStatusUpdateTimestamp: ClientRuntime.Date? = nil,
        platform: Swift.String? = nil,
        status: GreengrassV2ClientTypes.CoreDeviceStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.architecture = architecture
        self.coreDeviceThingName = coreDeviceThingName
        self.coreVersion = coreVersion
        self.lastStatusUpdateTimestamp = lastStatusUpdateTimestamp
        self.platform = platform
        self.status = status
        self.tags = tags
    }
}

struct GetCoreDeviceOutputResponseBody: Swift.Equatable {
    public let coreDeviceThingName: Swift.String?
    public let coreVersion: Swift.String?
    public let platform: Swift.String?
    public let architecture: Swift.String?
    public let status: GreengrassV2ClientTypes.CoreDeviceStatus?
    public let lastStatusUpdateTimestamp: ClientRuntime.Date?
    public let tags: [Swift.String:Swift.String]?
}

extension GetCoreDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case coreDeviceThingName
        case coreVersion
        case lastStatusUpdateTimestamp
        case platform
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreDeviceThingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreDeviceThingName)
        coreDeviceThingName = coreDeviceThingNameDecoded
        let coreVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreVersion)
        coreVersion = coreVersionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecture)
        architecture = architectureDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.CoreDeviceStatus.self, forKey: .status)
        status = statusDecoded
        let lastStatusUpdateTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastStatusUpdateTimestamp)
        lastStatusUpdateTimestamp = lastStatusUpdateTimestampDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeploymentInput(deploymentId: \(Swift.String(describing: deploymentId)))"}
}

extension GetDeploymentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDeploymentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeploymentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let deploymentId = input.deploymentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deploymentId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/deployments/\(deploymentId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInput: Swift.Equatable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init (
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct GetDeploymentInputBody: Swift.Equatable {
}

extension GetDeploymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeploymentOutputResponse(components: \(Swift.String(describing: components)), creationTimestamp: \(Swift.String(describing: creationTimestamp)), deploymentId: \(Swift.String(describing: deploymentId)), deploymentName: \(Swift.String(describing: deploymentName)), deploymentPolicies: \(Swift.String(describing: deploymentPolicies)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), iotJobArn: \(Swift.String(describing: iotJobArn)), iotJobConfiguration: \(Swift.String(describing: iotJobConfiguration)), iotJobId: \(Swift.String(describing: iotJobId)), isLatestForTarget: \(Swift.String(describing: isLatestForTarget)), revisionId: \(Swift.String(describing: revisionId)), tags: \(Swift.String(describing: tags)), targetArn: \(Swift.String(describing: targetArn)))"}
}

extension GetDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.components = output.components
            self.creationTimestamp = output.creationTimestamp
            self.deploymentId = output.deploymentId
            self.deploymentName = output.deploymentName
            self.deploymentPolicies = output.deploymentPolicies
            self.deploymentStatus = output.deploymentStatus
            self.iotJobArn = output.iotJobArn
            self.iotJobConfiguration = output.iotJobConfiguration
            self.iotJobId = output.iotJobId
            self.isLatestForTarget = output.isLatestForTarget
            self.revisionId = output.revisionId
            self.tags = output.tags
            self.targetArn = output.targetArn
        } else {
            self.components = nil
            self.creationTimestamp = nil
            self.deploymentId = nil
            self.deploymentName = nil
            self.deploymentPolicies = nil
            self.deploymentStatus = nil
            self.iotJobArn = nil
            self.iotJobConfiguration = nil
            self.iotJobId = nil
            self.isLatestForTarget = false
            self.revisionId = nil
            self.tags = nil
            self.targetArn = nil
        }
    }
}

public struct GetDeploymentOutputResponse: Swift.Equatable {
    /// The components to deploy. This is a dictionary, where each key is the name of a component,
    ///         and each key's value is the version and configuration to deploy for that component.
    public var components: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]?
    /// The time at which the deployment was created, expressed in ISO 8601 format.
    public var creationTimestamp: ClientRuntime.Date?
    /// The ID of the deployment.
    public var deploymentId: Swift.String?
    /// The name of the deployment.
    public var deploymentName: Swift.String?
    /// The deployment policies for the deployment. These policies define how the deployment
    ///       updates components and handles failure.
    public var deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies?
    /// The status of the deployment.
    public var deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus?
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the IoT job that applies the deployment to target devices.
    public var iotJobArn: Swift.String?
    /// The job configuration for the deployment configuration. The job configuration specifies
    ///       the rollout, timeout, and stop configurations for the deployment configuration.
    public var iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration?
    /// The ID of the IoT job that applies the deployment to target devices.
    public var iotJobId: Swift.String?
    /// Whether or not the deployment is the latest revision for its target.
    public var isLatestForTarget: Swift.Bool
    /// The revision number of the deployment.
    public var revisionId: Swift.String?
    /// A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the target IoT thing or thing group.
    public var targetArn: Swift.String?

    public init (
        components: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]? = nil,
        creationTimestamp: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentName: Swift.String? = nil,
        deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies? = nil,
        deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus? = nil,
        iotJobArn: Swift.String? = nil,
        iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration? = nil,
        iotJobId: Swift.String? = nil,
        isLatestForTarget: Swift.Bool = false,
        revisionId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.components = components
        self.creationTimestamp = creationTimestamp
        self.deploymentId = deploymentId
        self.deploymentName = deploymentName
        self.deploymentPolicies = deploymentPolicies
        self.deploymentStatus = deploymentStatus
        self.iotJobArn = iotJobArn
        self.iotJobConfiguration = iotJobConfiguration
        self.iotJobId = iotJobId
        self.isLatestForTarget = isLatestForTarget
        self.revisionId = revisionId
        self.tags = tags
        self.targetArn = targetArn
    }
}

struct GetDeploymentOutputResponseBody: Swift.Equatable {
    public let targetArn: Swift.String?
    public let revisionId: Swift.String?
    public let deploymentId: Swift.String?
    public let deploymentName: Swift.String?
    public let deploymentStatus: GreengrassV2ClientTypes.DeploymentStatus?
    public let iotJobId: Swift.String?
    public let iotJobArn: Swift.String?
    public let components: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]?
    public let deploymentPolicies: GreengrassV2ClientTypes.DeploymentPolicies?
    public let iotJobConfiguration: GreengrassV2ClientTypes.DeploymentIoTJobConfiguration?
    public let creationTimestamp: ClientRuntime.Date?
    public let isLatestForTarget: Swift.Bool
    public let tags: [Swift.String:Swift.String]?
}

extension GetDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components
        case creationTimestamp
        case deploymentId
        case deploymentName
        case deploymentPolicies
        case deploymentStatus
        case iotJobArn
        case iotJobConfiguration
        case iotJobId
        case isLatestForTarget
        case revisionId
        case tags
        case targetArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentName)
        deploymentName = deploymentNameDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let iotJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobId)
        iotJobId = iotJobIdDecoded
        let iotJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobArn)
        iotJobArn = iotJobArnDecoded
        let componentsContainer = try containerValues.decodeIfPresent([Swift.String: GreengrassV2ClientTypes.ComponentDeploymentSpecification?].self, forKey: .components)
        var componentsDecoded0: [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Swift.String:GreengrassV2ClientTypes.ComponentDeploymentSpecification]()
            for (key0, componentdeploymentspecification0) in componentsContainer {
                if let componentdeploymentspecification0 = componentdeploymentspecification0 {
                    componentsDecoded0?[key0] = componentdeploymentspecification0
                }
            }
        }
        components = componentsDecoded0
        let deploymentPoliciesDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentPolicies.self, forKey: .deploymentPolicies)
        deploymentPolicies = deploymentPoliciesDecoded
        let iotJobConfigurationDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.DeploymentIoTJobConfiguration.self, forKey: .iotJobConfiguration)
        iotJobConfiguration = iotJobConfigurationDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let isLatestForTargetDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isLatestForTarget)
        isLatestForTarget = isLatestForTargetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GreengrassV2ClientTypes.InstalledComponent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentVersion
        case isRoot
        case lifecycleState
        case lifecycleStateDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if isRoot != false {
            try encodeContainer.encode(isRoot, forKey: .isRoot)
        }
        if let lifecycleState = lifecycleState {
            try encodeContainer.encode(lifecycleState.rawValue, forKey: .lifecycleState)
        }
        if let lifecycleStateDetails = lifecycleStateDetails {
            try encodeContainer.encode(lifecycleStateDetails, forKey: .lifecycleStateDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let lifecycleStateDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.InstalledComponentLifecycleState.self, forKey: .lifecycleState)
        lifecycleState = lifecycleStateDecoded
        let lifecycleStateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycleStateDetails)
        lifecycleStateDetails = lifecycleStateDetailsDecoded
        let isRootDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isRoot)
        isRoot = isRootDecoded
    }
}

extension GreengrassV2ClientTypes.InstalledComponent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstalledComponent(componentName: \(Swift.String(describing: componentName)), componentVersion: \(Swift.String(describing: componentVersion)), isRoot: \(Swift.String(describing: isRoot)), lifecycleState: \(Swift.String(describing: lifecycleState)), lifecycleStateDetails: \(Swift.String(describing: lifecycleStateDetails)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component on a Greengrass core device.
    public struct InstalledComponent: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// Whether or not the component is a root component.
        public var isRoot: Swift.Bool
        /// The lifecycle state of the component.
        public var lifecycleState: GreengrassV2ClientTypes.InstalledComponentLifecycleState?
        /// The details about the lifecycle state of the component.
        public var lifecycleStateDetails: Swift.String?

        public init (
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            isRoot: Swift.Bool = false,
            lifecycleState: GreengrassV2ClientTypes.InstalledComponentLifecycleState? = nil,
            lifecycleStateDetails: Swift.String? = nil
        )
        {
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.isRoot = isRoot
            self.lifecycleState = lifecycleState
            self.lifecycleStateDetails = lifecycleStateDetails
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum InstalledComponentLifecycleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case broken
        case errored
        case finished
        case installed
        case new
        case running
        case starting
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [InstalledComponentLifecycleState] {
            return [
                .broken,
                .errored,
                .finished,
                .installed,
                .new,
                .running,
                .starting,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .broken: return "BROKEN"
            case .errored: return "ERRORED"
            case .finished: return "FINISHED"
            case .installed: return "INSTALLED"
            case .new: return "NEW"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstalledComponentLifecycleState(rawValue: rawValue) ?? InstalledComponentLifecycleState.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// IoT Greengrass can't process your request right now. Try again later.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The amount of time to wait before you retry the request.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassV2ClientTypes {
    public enum IoTJobAbortAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancel
        case sdkUnknown(Swift.String)

        public static var allCases: [IoTJobAbortAction] {
            return [
                .cancel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IoTJobAbortAction(rawValue: rawValue) ?? IoTJobAbortAction.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.IoTJobAbortConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criteriaList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criteriaList = criteriaList {
            var criteriaListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .criteriaList)
            for iotjobabortcriterialist0 in criteriaList {
                try criteriaListContainer.encode(iotjobabortcriterialist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criteriaListContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.IoTJobAbortCriteria?].self, forKey: .criteriaList)
        var criteriaListDecoded0:[GreengrassV2ClientTypes.IoTJobAbortCriteria]? = nil
        if let criteriaListContainer = criteriaListContainer {
            criteriaListDecoded0 = [GreengrassV2ClientTypes.IoTJobAbortCriteria]()
            for structure0 in criteriaListContainer {
                if let structure0 = structure0 {
                    criteriaListDecoded0?.append(structure0)
                }
            }
        }
        criteriaList = criteriaListDecoded0
    }
}

extension GreengrassV2ClientTypes.IoTJobAbortConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IoTJobAbortConfig(criteriaList: \(Swift.String(describing: criteriaList)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains a list of criteria that define when and how to cancel a configuration
    ///       deployment.
    public struct IoTJobAbortConfig: Swift.Equatable {
        /// The list of criteria that define when and how to cancel the configuration deployment.
        /// This member is required.
        public var criteriaList: [GreengrassV2ClientTypes.IoTJobAbortCriteria]?

        public init (
            criteriaList: [GreengrassV2ClientTypes.IoTJobAbortCriteria]? = nil
        )
        {
            self.criteriaList = criteriaList
        }
    }

}

extension GreengrassV2ClientTypes.IoTJobAbortCriteria: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case failureType
        case minNumberOfExecutedThings
        case thresholdPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let failureType = failureType {
            try encodeContainer.encode(failureType.rawValue, forKey: .failureType)
        }
        if minNumberOfExecutedThings != 0 {
            try encodeContainer.encode(minNumberOfExecutedThings, forKey: .minNumberOfExecutedThings)
        }
        if thresholdPercentage != 0.0 {
            try encodeContainer.encode(thresholdPercentage, forKey: .thresholdPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureTypeDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobExecutionFailureType.self, forKey: .failureType)
        failureType = failureTypeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobAbortAction.self, forKey: .action)
        action = actionDecoded
        let thresholdPercentageDecoded = try containerValues.decode(Swift.Double.self, forKey: .thresholdPercentage)
        thresholdPercentage = thresholdPercentageDecoded
        let minNumberOfExecutedThingsDecoded = try containerValues.decode(Swift.Int.self, forKey: .minNumberOfExecutedThings)
        minNumberOfExecutedThings = minNumberOfExecutedThingsDecoded
    }
}

extension GreengrassV2ClientTypes.IoTJobAbortCriteria: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IoTJobAbortCriteria(action: \(Swift.String(describing: action)), failureType: \(Swift.String(describing: failureType)), minNumberOfExecutedThings: \(Swift.String(describing: minNumberOfExecutedThings)), thresholdPercentage: \(Swift.String(describing: thresholdPercentage)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains criteria that define when and how to cancel a job.
    ///          The deployment stops if the following conditions are true:
    ///          <ol>
    ///
    ///                The number of things that receive the deployment exceeds the
    ///           minNumberOfExecutedThings.
    ///
    ///
    ///                The percentage of failures with type failureType exceeds the
    ///           thresholdPercentage.
    ///
    ///          </ol>
    public struct IoTJobAbortCriteria: Swift.Equatable {
        /// The action to perform when the criteria are met.
        /// This member is required.
        public var action: GreengrassV2ClientTypes.IoTJobAbortAction?
        /// The type of job deployment failure that can cancel a job.
        /// This member is required.
        public var failureType: GreengrassV2ClientTypes.IoTJobExecutionFailureType?
        /// The minimum number of things that receive the configuration before the job can
        ///       cancel.
        /// This member is required.
        public var minNumberOfExecutedThings: Swift.Int
        /// The minimum percentage of failureType failures that occur before the job can
        ///       cancel.
        ///          This parameter supports up to two digits after the decimal (for example, you can specify
        ///       10.9 or 10.99, but not 10.999).
        /// This member is required.
        public var thresholdPercentage: Swift.Double

        public init (
            action: GreengrassV2ClientTypes.IoTJobAbortAction? = nil,
            failureType: GreengrassV2ClientTypes.IoTJobExecutionFailureType? = nil,
            minNumberOfExecutedThings: Swift.Int = 0,
            thresholdPercentage: Swift.Double = 0.0
        )
        {
            self.action = action
            self.failureType = failureType
            self.minNumberOfExecutedThings = minNumberOfExecutedThings
            self.thresholdPercentage = thresholdPercentage
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum IoTJobExecutionFailureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case failed
        case rejected
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [IoTJobExecutionFailureType] {
            return [
                .all,
                .failed,
                .rejected,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .rejected: return "REJECTED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IoTJobExecutionFailureType(rawValue: rawValue) ?? IoTJobExecutionFailureType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exponentialRate
        case maximumPerMinute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exponentialRate = exponentialRate {
            try encodeContainer.encode(exponentialRate, forKey: .exponentialRate)
        }
        if maximumPerMinute != 0 {
            try encodeContainer.encode(maximumPerMinute, forKey: .maximumPerMinute)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exponentialRateDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobExponentialRolloutRate.self, forKey: .exponentialRate)
        exponentialRate = exponentialRateDecoded
        let maximumPerMinuteDecoded = try containerValues.decode(Swift.Int.self, forKey: .maximumPerMinute)
        maximumPerMinute = maximumPerMinuteDecoded
    }
}

extension GreengrassV2ClientTypes.IoTJobExecutionsRolloutConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IoTJobExecutionsRolloutConfig(exponentialRate: \(Swift.String(describing: exponentialRate)), maximumPerMinute: \(Swift.String(describing: maximumPerMinute)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about the rollout configuration for a job. This configuration defines
    ///       the rate at which the job deploys a configuration to a fleet of target devices.
    public struct IoTJobExecutionsRolloutConfig: Swift.Equatable {
        /// The exponential rate to increase the job rollout rate.
        public var exponentialRate: GreengrassV2ClientTypes.IoTJobExponentialRolloutRate?
        /// The maximum number of devices that receive a pending job notification, per minute.
        public var maximumPerMinute: Swift.Int

        public init (
            exponentialRate: GreengrassV2ClientTypes.IoTJobExponentialRolloutRate? = nil,
            maximumPerMinute: Swift.Int = 0
        )
        {
            self.exponentialRate = exponentialRate
            self.maximumPerMinute = maximumPerMinute
        }
    }

}

extension GreengrassV2ClientTypes.IoTJobExponentialRolloutRate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseRatePerMinute
        case incrementFactor
        case rateIncreaseCriteria
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if baseRatePerMinute != 0 {
            try encodeContainer.encode(baseRatePerMinute, forKey: .baseRatePerMinute)
        }
        if incrementFactor != 0.0 {
            try encodeContainer.encode(incrementFactor, forKey: .incrementFactor)
        }
        if let rateIncreaseCriteria = rateIncreaseCriteria {
            try encodeContainer.encode(rateIncreaseCriteria, forKey: .rateIncreaseCriteria)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseRatePerMinuteDecoded = try containerValues.decode(Swift.Int.self, forKey: .baseRatePerMinute)
        baseRatePerMinute = baseRatePerMinuteDecoded
        let incrementFactorDecoded = try containerValues.decode(Swift.Double.self, forKey: .incrementFactor)
        incrementFactor = incrementFactorDecoded
        let rateIncreaseCriteriaDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria.self, forKey: .rateIncreaseCriteria)
        rateIncreaseCriteria = rateIncreaseCriteriaDecoded
    }
}

extension GreengrassV2ClientTypes.IoTJobExponentialRolloutRate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IoTJobExponentialRolloutRate(baseRatePerMinute: \(Swift.String(describing: baseRatePerMinute)), incrementFactor: \(Swift.String(describing: incrementFactor)), rateIncreaseCriteria: \(Swift.String(describing: rateIncreaseCriteria)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about an exponential rollout rate for a configuration deployment
    ///       job.
    public struct IoTJobExponentialRolloutRate: Swift.Equatable {
        /// The minimum number of devices that receive a pending job notification, per minute, when
        ///       the job starts. This parameter defines the initial rollout rate of the job.
        /// This member is required.
        public var baseRatePerMinute: Swift.Int
        /// The exponential factor to increase the rollout rate for the job.
        ///          This parameter supports up to one digit after the decimal (for example, you can specify
        ///       1.5, but not 1.55).
        /// This member is required.
        public var incrementFactor: Swift.Double
        /// The criteria to increase the rollout rate for the job.
        /// This member is required.
        public var rateIncreaseCriteria: GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria?

        public init (
            baseRatePerMinute: Swift.Int = 0,
            incrementFactor: Swift.Double = 0.0,
            rateIncreaseCriteria: GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria? = nil
        )
        {
            self.baseRatePerMinute = baseRatePerMinute
            self.incrementFactor = incrementFactor
            self.rateIncreaseCriteria = rateIncreaseCriteria
        }
    }

}

extension GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfNotifiedThings
        case numberOfSucceededThings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfNotifiedThings != 0 {
            try encodeContainer.encode(numberOfNotifiedThings, forKey: .numberOfNotifiedThings)
        }
        if numberOfSucceededThings != 0 {
            try encodeContainer.encode(numberOfSucceededThings, forKey: .numberOfSucceededThings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfNotifiedThingsDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfNotifiedThings)
        numberOfNotifiedThings = numberOfNotifiedThingsDecoded
        let numberOfSucceededThingsDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfSucceededThings)
        numberOfSucceededThings = numberOfSucceededThingsDecoded
    }
}

extension GreengrassV2ClientTypes.IoTJobRateIncreaseCriteria: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IoTJobRateIncreaseCriteria(numberOfNotifiedThings: \(Swift.String(describing: numberOfNotifiedThings)), numberOfSucceededThings: \(Swift.String(describing: numberOfSucceededThings)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about criteria to meet before a job increases its rollout rate.
    ///       Specify either numberOfNotifiedThings or
    ///       numberOfSucceededThings.
    public struct IoTJobRateIncreaseCriteria: Swift.Equatable {
        /// The number of devices to receive the job notification before the rollout rate
        ///       increases.
        public var numberOfNotifiedThings: Swift.Int
        /// The number of devices to successfully run the configuration job before the rollout rate
        ///       increases.
        public var numberOfSucceededThings: Swift.Int

        public init (
            numberOfNotifiedThings: Swift.Int = 0,
            numberOfSucceededThings: Swift.Int = 0
        )
        {
            self.numberOfNotifiedThings = numberOfNotifiedThings
            self.numberOfSucceededThings = numberOfSucceededThings
        }
    }

}

extension GreengrassV2ClientTypes.IoTJobTimeoutConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inProgressTimeoutInMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if inProgressTimeoutInMinutes != 0 {
            try encodeContainer.encode(inProgressTimeoutInMinutes, forKey: .inProgressTimeoutInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inProgressTimeoutInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .inProgressTimeoutInMinutes)
        inProgressTimeoutInMinutes = inProgressTimeoutInMinutesDecoded
    }
}

extension GreengrassV2ClientTypes.IoTJobTimeoutConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IoTJobTimeoutConfig(inProgressTimeoutInMinutes: \(Swift.String(describing: inProgressTimeoutInMinutes)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about the timeout configuration for a job.
    public struct IoTJobTimeoutConfig: Swift.Equatable {
        /// The amount of time, in minutes, that devices have to complete the job. The timer starts
        ///       when the job status is set to IN_PROGRESS. If the job status doesn't change to a
        ///       terminal state before the time expires, then the job status is set to
        ///       TIMED_OUT.
        ///          The timeout interval must be between 1 minute and 7 days (10080 minutes).
        public var inProgressTimeoutInMinutes: Swift.Int

        public init (
            inProgressTimeoutInMinutes: Swift.Int = 0
        )
        {
            self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
        }
    }

}

extension GreengrassV2ClientTypes.LambdaContainerParams: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices
        case memorySizeInKB
        case mountROSysfs
        case volumes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for lambdadevicelist0 in devices {
                try devicesContainer.encode(lambdadevicelist0)
            }
        }
        if memorySizeInKB != 0 {
            try encodeContainer.encode(memorySizeInKB, forKey: .memorySizeInKB)
        }
        if mountROSysfs != false {
            try encodeContainer.encode(mountROSysfs, forKey: .mountROSysfs)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for lambdavolumelist0 in volumes {
                try volumesContainer.encode(lambdavolumelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memorySizeInKBDecoded = try containerValues.decode(Swift.Int.self, forKey: .memorySizeInKB)
        memorySizeInKB = memorySizeInKBDecoded
        let mountROSysfsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .mountROSysfs)
        mountROSysfs = mountROSysfsDecoded
        let volumesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.LambdaVolumeMount?].self, forKey: .volumes)
        var volumesDecoded0:[GreengrassV2ClientTypes.LambdaVolumeMount]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [GreengrassV2ClientTypes.LambdaVolumeMount]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
        let devicesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.LambdaDeviceMount?].self, forKey: .devices)
        var devicesDecoded0:[GreengrassV2ClientTypes.LambdaDeviceMount]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [GreengrassV2ClientTypes.LambdaDeviceMount]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
    }
}

extension GreengrassV2ClientTypes.LambdaContainerParams: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaContainerParams(devices: \(Swift.String(describing: devices)), memorySizeInKB: \(Swift.String(describing: memorySizeInKB)), mountROSysfs: \(Swift.String(describing: mountROSysfs)), volumes: \(Swift.String(describing: volumes)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a container in which Lambda functions run on Greengrass core
    ///       devices.
    public struct LambdaContainerParams: Swift.Equatable {
        /// The list of system devices that the container can access.
        public var devices: [GreengrassV2ClientTypes.LambdaDeviceMount]?
        /// The memory size of the container, expressed in kilobytes.
        ///          Default: 16384 (16 MB)
        public var memorySizeInKB: Swift.Int
        /// Whether or not the container can read information from the device's /sys
        ///       folder.
        ///          Default: false
        ///
        public var mountROSysfs: Swift.Bool
        /// The list of volumes that the container can access.
        public var volumes: [GreengrassV2ClientTypes.LambdaVolumeMount]?

        public init (
            devices: [GreengrassV2ClientTypes.LambdaDeviceMount]? = nil,
            memorySizeInKB: Swift.Int = 0,
            mountROSysfs: Swift.Bool = false,
            volumes: [GreengrassV2ClientTypes.LambdaVolumeMount]? = nil
        )
        {
            self.devices = devices
            self.memorySizeInKB = memorySizeInKB
            self.mountROSysfs = mountROSysfs
            self.volumes = volumes
        }
    }

}

extension GreengrassV2ClientTypes.LambdaDeviceMount: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addGroupOwner
        case path
        case permission
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGroupOwner != false {
            try encodeContainer.encode(addGroupOwner, forKey: .addGroupOwner)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaFilesystemPermission.self, forKey: .permission)
        permission = permissionDecoded
        let addGroupOwnerDecoded = try containerValues.decode(Swift.Bool.self, forKey: .addGroupOwner)
        addGroupOwner = addGroupOwnerDecoded
    }
}

extension GreengrassV2ClientTypes.LambdaDeviceMount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaDeviceMount(addGroupOwner: \(Swift.String(describing: addGroupOwner)), path: \(Swift.String(describing: path)), permission: \(Swift.String(describing: permission)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a device that Linux processes in a container can access.
    public struct LambdaDeviceMount: Swift.Equatable {
        /// Whether or not to add the component's system user as an owner of the device.
        ///          Default: false
        ///
        public var addGroupOwner: Swift.Bool
        /// The mount path for the device in the file system.
        /// This member is required.
        public var path: Swift.String?
        /// The permission to access the device: read/only (ro) or read/write
        ///       (rw).
        ///          Default: ro
        ///
        public var permission: GreengrassV2ClientTypes.LambdaFilesystemPermission?

        public init (
            addGroupOwner: Swift.Bool = false,
            path: Swift.String? = nil,
            permission: GreengrassV2ClientTypes.LambdaFilesystemPermission? = nil
        )
        {
            self.addGroupOwner = addGroupOwner
            self.path = path
            self.permission = permission
        }
    }

}

extension GreengrassV2ClientTypes.LambdaEventSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topic
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topic = topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let typeDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaEventSourceType.self, forKey: .type)
        type = typeDecoded
    }
}

extension GreengrassV2ClientTypes.LambdaEventSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaEventSource(topic: \(Swift.String(describing: topic)), type: \(Swift.String(describing: type)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about an event source for an Lambda function. The event source
    ///       defines the topics on which this Lambda function subscribes to receive messages that run the
    ///       function.
    public struct LambdaEventSource: Swift.Equatable {
        /// The topic to which to subscribe to receive event messages.
        /// This member is required.
        public var topic: Swift.String?
        /// The type of event source. Choose from the following options:
        ///
        ///
        ///
        ///                   PUB_SUB  Subscribe to local publish/subscribe messages. This event
        ///           source type doesn't support MQTT wildcards (+ and #) in the
        ///           event source topic.
        ///
        ///
        ///
        ///                   IOT_CORE  Subscribe to Amazon Web Services IoT Core MQTT messages. This event source
        ///           type supports MQTT wildcards (+ and #) in the event source
        ///           topic.
        ///
        ///
        /// This member is required.
        public var type: GreengrassV2ClientTypes.LambdaEventSourceType?

        public init (
            topic: Swift.String? = nil,
            type: GreengrassV2ClientTypes.LambdaEventSourceType? = nil
        )
        {
            self.topic = topic
            self.type = type
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum LambdaEventSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iotCore
        case pubSub
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaEventSourceType] {
            return [
                .iotCore,
                .pubSub,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iotCore: return "IOT_CORE"
            case .pubSub: return "PUB_SUB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LambdaEventSourceType(rawValue: rawValue) ?? LambdaEventSourceType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.LambdaExecutionParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentVariables
        case eventSources
        case execArgs
        case inputPayloadEncodingType
        case linuxProcessParams
        case maxIdleTimeInSeconds
        case maxInstancesCount
        case maxQueueSize
        case pinned
        case statusTimeoutInSeconds
        case timeoutInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .environmentVariables)
            for (dictKey0, lambdaenvironmentvariables0) in environmentVariables {
                try environmentVariablesContainer.encode(lambdaenvironmentvariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let eventSources = eventSources {
            var eventSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSources)
            for lambdaeventsourcelist0 in eventSources {
                try eventSourcesContainer.encode(lambdaeventsourcelist0)
            }
        }
        if let execArgs = execArgs {
            var execArgsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .execArgs)
            for lambdaexecargslist0 in execArgs {
                try execArgsContainer.encode(lambdaexecargslist0)
            }
        }
        if let inputPayloadEncodingType = inputPayloadEncodingType {
            try encodeContainer.encode(inputPayloadEncodingType.rawValue, forKey: .inputPayloadEncodingType)
        }
        if let linuxProcessParams = linuxProcessParams {
            try encodeContainer.encode(linuxProcessParams, forKey: .linuxProcessParams)
        }
        if maxIdleTimeInSeconds != 0 {
            try encodeContainer.encode(maxIdleTimeInSeconds, forKey: .maxIdleTimeInSeconds)
        }
        if maxInstancesCount != 0 {
            try encodeContainer.encode(maxInstancesCount, forKey: .maxInstancesCount)
        }
        if maxQueueSize != 0 {
            try encodeContainer.encode(maxQueueSize, forKey: .maxQueueSize)
        }
        if pinned != false {
            try encodeContainer.encode(pinned, forKey: .pinned)
        }
        if statusTimeoutInSeconds != 0 {
            try encodeContainer.encode(statusTimeoutInSeconds, forKey: .statusTimeoutInSeconds)
        }
        if timeoutInSeconds != 0 {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourcesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.LambdaEventSource?].self, forKey: .eventSources)
        var eventSourcesDecoded0:[GreengrassV2ClientTypes.LambdaEventSource]? = nil
        if let eventSourcesContainer = eventSourcesContainer {
            eventSourcesDecoded0 = [GreengrassV2ClientTypes.LambdaEventSource]()
            for structure0 in eventSourcesContainer {
                if let structure0 = structure0 {
                    eventSourcesDecoded0?.append(structure0)
                }
            }
        }
        eventSources = eventSourcesDecoded0
        let maxQueueSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxQueueSize)
        maxQueueSize = maxQueueSizeDecoded
        let maxInstancesCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxInstancesCount)
        maxInstancesCount = maxInstancesCountDecoded
        let maxIdleTimeInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxIdleTimeInSeconds)
        maxIdleTimeInSeconds = maxIdleTimeInSecondsDecoded
        let timeoutInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let statusTimeoutInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .statusTimeoutInSeconds)
        statusTimeoutInSeconds = statusTimeoutInSecondsDecoded
        let pinnedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .pinned)
        pinned = pinnedDecoded
        let inputPayloadEncodingTypeDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaInputPayloadEncodingType.self, forKey: .inputPayloadEncodingType)
        inputPayloadEncodingType = inputPayloadEncodingTypeDecoded
        let execArgsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .execArgs)
        var execArgsDecoded0:[Swift.String]? = nil
        if let execArgsContainer = execArgsContainer {
            execArgsDecoded0 = [Swift.String]()
            for string0 in execArgsContainer {
                if let string0 = string0 {
                    execArgsDecoded0?.append(string0)
                }
            }
        }
        execArgs = execArgsDecoded0
        let environmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in environmentVariablesContainer {
                if let string0 = string0 {
                    environmentVariablesDecoded0?[key0] = string0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let linuxProcessParamsDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaLinuxProcessParams.self, forKey: .linuxProcessParams)
        linuxProcessParams = linuxProcessParamsDecoded
    }
}

extension GreengrassV2ClientTypes.LambdaExecutionParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaExecutionParameters(environmentVariables: \(Swift.String(describing: environmentVariables)), eventSources: \(Swift.String(describing: eventSources)), execArgs: \(Swift.String(describing: execArgs)), inputPayloadEncodingType: \(Swift.String(describing: inputPayloadEncodingType)), linuxProcessParams: \(Swift.String(describing: linuxProcessParams)), maxIdleTimeInSeconds: \(Swift.String(describing: maxIdleTimeInSeconds)), maxInstancesCount: \(Swift.String(describing: maxInstancesCount)), maxQueueSize: \(Swift.String(describing: maxQueueSize)), pinned: \(Swift.String(describing: pinned)), statusTimeoutInSeconds: \(Swift.String(describing: statusTimeoutInSeconds)), timeoutInSeconds: \(Swift.String(describing: timeoutInSeconds)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains parameters for a Lambda function that runs on IoT Greengrass.
    public struct LambdaExecutionParameters: Swift.Equatable {
        /// The map of environment variables that are available to the Lambda function when it runs.
        public var environmentVariables: [Swift.String:Swift.String]?
        /// The list of event sources to which to subscribe to receive work messages. The Lambda
        ///       function runs when it receives a message from an event source. You can subscribe this function
        ///       to local publish/subscribe messages and Amazon Web Services IoT Core MQTT messages.
        public var eventSources: [GreengrassV2ClientTypes.LambdaEventSource]?
        /// The list of arguments to pass to the Lambda function when it runs.
        public var execArgs: [Swift.String]?
        /// The encoding type that the Lambda function supports.
        ///          Default: json
        ///
        public var inputPayloadEncodingType: GreengrassV2ClientTypes.LambdaInputPayloadEncodingType?
        /// The parameters for the Linux process that contains the Lambda function.
        public var linuxProcessParams: GreengrassV2ClientTypes.LambdaLinuxProcessParams?
        /// The maximum amount of time in seconds that a non-pinned Lambda function can idle before the
        ///       IoT Greengrass Core software stops its process.
        public var maxIdleTimeInSeconds: Swift.Int
        /// The maximum number of instances that a non-pinned Lambda function can run at the same
        ///       time.
        public var maxInstancesCount: Swift.Int
        /// The maximum size of the message queue for the Lambda function component. The IoT Greengrass core
        ///       stores messages in a FIFO (first-in-first-out) queue until it can run the Lambda function to
        ///       consume each message.
        public var maxQueueSize: Swift.Int
        /// Whether or not the Lambda function is pinned, or long-lived.
        ///
        ///
        ///                A pinned Lambda function starts
        ///           when IoT Greengrass starts and keeps running in its own container.
        ///
        ///
        ///                A non-pinned Lambda function starts only when it receives a work item and exists after
        ///           it idles for maxIdleTimeInSeconds. If the function has multiple work items,
        ///           the IoT Greengrass Core software creates multiple instances of the function.
        ///
        ///
        ///          Default: true
        ///
        public var pinned: Swift.Bool
        /// The interval in seconds at which a pinned (also known as long-lived) Lambda function
        ///       component sends status updates to the Lambda manager component.
        public var statusTimeoutInSeconds: Swift.Int
        /// The maximum amount of time in seconds that the Lambda function can process a work
        ///       item.
        public var timeoutInSeconds: Swift.Int

        public init (
            environmentVariables: [Swift.String:Swift.String]? = nil,
            eventSources: [GreengrassV2ClientTypes.LambdaEventSource]? = nil,
            execArgs: [Swift.String]? = nil,
            inputPayloadEncodingType: GreengrassV2ClientTypes.LambdaInputPayloadEncodingType? = nil,
            linuxProcessParams: GreengrassV2ClientTypes.LambdaLinuxProcessParams? = nil,
            maxIdleTimeInSeconds: Swift.Int = 0,
            maxInstancesCount: Swift.Int = 0,
            maxQueueSize: Swift.Int = 0,
            pinned: Swift.Bool = false,
            statusTimeoutInSeconds: Swift.Int = 0,
            timeoutInSeconds: Swift.Int = 0
        )
        {
            self.environmentVariables = environmentVariables
            self.eventSources = eventSources
            self.execArgs = execArgs
            self.inputPayloadEncodingType = inputPayloadEncodingType
            self.linuxProcessParams = linuxProcessParams
            self.maxIdleTimeInSeconds = maxIdleTimeInSeconds
            self.maxInstancesCount = maxInstancesCount
            self.maxQueueSize = maxQueueSize
            self.pinned = pinned
            self.statusTimeoutInSeconds = statusTimeoutInSeconds
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum LambdaFilesystemPermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ro
        case rw
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaFilesystemPermission] {
            return [
                .ro,
                .rw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ro: return "ro"
            case .rw: return "rw"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LambdaFilesystemPermission(rawValue: rawValue) ?? LambdaFilesystemPermission.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.LambdaFunctionRecipeSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentDependencies
        case componentLambdaParameters
        case componentName
        case componentPlatforms
        case componentVersion
        case lambdaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentDependencies = componentDependencies {
            var componentDependenciesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .componentDependencies)
            for (dictKey0, componentdependencymap0) in componentDependencies {
                try componentDependenciesContainer.encode(componentdependencymap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let componentLambdaParameters = componentLambdaParameters {
            try encodeContainer.encode(componentLambdaParameters, forKey: .componentLambdaParameters)
        }
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentPlatforms = componentPlatforms {
            var componentPlatformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .componentPlatforms)
            for componentplatformlist0 in componentPlatforms {
                try componentPlatformsContainer.encode(componentplatformlist0)
            }
        }
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let lambdaArn = lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let componentPlatformsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ComponentPlatform?].self, forKey: .componentPlatforms)
        var componentPlatformsDecoded0:[GreengrassV2ClientTypes.ComponentPlatform]? = nil
        if let componentPlatformsContainer = componentPlatformsContainer {
            componentPlatformsDecoded0 = [GreengrassV2ClientTypes.ComponentPlatform]()
            for structure0 in componentPlatformsContainer {
                if let structure0 = structure0 {
                    componentPlatformsDecoded0?.append(structure0)
                }
            }
        }
        componentPlatforms = componentPlatformsDecoded0
        let componentDependenciesContainer = try containerValues.decodeIfPresent([Swift.String: GreengrassV2ClientTypes.ComponentDependencyRequirement?].self, forKey: .componentDependencies)
        var componentDependenciesDecoded0: [Swift.String:GreengrassV2ClientTypes.ComponentDependencyRequirement]? = nil
        if let componentDependenciesContainer = componentDependenciesContainer {
            componentDependenciesDecoded0 = [Swift.String:GreengrassV2ClientTypes.ComponentDependencyRequirement]()
            for (key0, componentdependencyrequirement0) in componentDependenciesContainer {
                if let componentdependencyrequirement0 = componentdependencyrequirement0 {
                    componentDependenciesDecoded0?[key0] = componentdependencyrequirement0
                }
            }
        }
        componentDependencies = componentDependenciesDecoded0
        let componentLambdaParametersDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaExecutionParameters.self, forKey: .componentLambdaParameters)
        componentLambdaParameters = componentLambdaParametersDecoded
    }
}

extension GreengrassV2ClientTypes.LambdaFunctionRecipeSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionRecipeSource(componentDependencies: \(Swift.String(describing: componentDependencies)), componentLambdaParameters: \(Swift.String(describing: componentLambdaParameters)), componentName: \(Swift.String(describing: componentName)), componentPlatforms: \(Swift.String(describing: componentPlatforms)), componentVersion: \(Swift.String(describing: componentVersion)), lambdaArn: \(Swift.String(describing: lambdaArn)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about an Lambda function to import to create a component.
    public struct LambdaFunctionRecipeSource: Swift.Equatable {
        /// The component versions on which this Lambda function component depends.
        public var componentDependencies: [Swift.String:GreengrassV2ClientTypes.ComponentDependencyRequirement]?
        /// The system and runtime parameters for the Lambda function as it runs on the Greengrass core
        ///       device.
        public var componentLambdaParameters: GreengrassV2ClientTypes.LambdaExecutionParameters?
        /// The name of the component.
        ///          Defaults to the name of the Lambda function.
        public var componentName: Swift.String?
        /// The platforms that the component version supports.
        public var componentPlatforms: [GreengrassV2ClientTypes.ComponentPlatform]?
        /// The version of the component.
        ///          Defaults to the version of the Lambda function as a semantic version. For example, if your
        ///       function version is 3, the component version becomes 3.0.0.
        public var componentVersion: Swift.String?
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the Lambda function. The ARN must include the version of the function to
        ///       import. You can't use version aliases like $LATEST.
        /// This member is required.
        public var lambdaArn: Swift.String?

        public init (
            componentDependencies: [Swift.String:GreengrassV2ClientTypes.ComponentDependencyRequirement]? = nil,
            componentLambdaParameters: GreengrassV2ClientTypes.LambdaExecutionParameters? = nil,
            componentName: Swift.String? = nil,
            componentPlatforms: [GreengrassV2ClientTypes.ComponentPlatform]? = nil,
            componentVersion: Swift.String? = nil,
            lambdaArn: Swift.String? = nil
        )
        {
            self.componentDependencies = componentDependencies
            self.componentLambdaParameters = componentLambdaParameters
            self.componentName = componentName
            self.componentPlatforms = componentPlatforms
            self.componentVersion = componentVersion
            self.lambdaArn = lambdaArn
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum LambdaInputPayloadEncodingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binary
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaInputPayloadEncodingType] {
            return [
                .binary,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binary: return "binary"
            case .json: return "json"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LambdaInputPayloadEncodingType(rawValue: rawValue) ?? LambdaInputPayloadEncodingType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes {
    public enum LambdaIsolationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case greengrassContainer
        case noContainer
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaIsolationMode] {
            return [
                .greengrassContainer,
                .noContainer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .greengrassContainer: return "GreengrassContainer"
            case .noContainer: return "NoContainer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LambdaIsolationMode(rawValue: rawValue) ?? LambdaIsolationMode.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassV2ClientTypes.LambdaLinuxProcessParams: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerParams
        case isolationMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerParams = containerParams {
            try encodeContainer.encode(containerParams, forKey: .containerParams)
        }
        if let isolationMode = isolationMode {
            try encodeContainer.encode(isolationMode.rawValue, forKey: .isolationMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isolationModeDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaIsolationMode.self, forKey: .isolationMode)
        isolationMode = isolationModeDecoded
        let containerParamsDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaContainerParams.self, forKey: .containerParams)
        containerParams = containerParamsDecoded
    }
}

extension GreengrassV2ClientTypes.LambdaLinuxProcessParams: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaLinuxProcessParams(containerParams: \(Swift.String(describing: containerParams)), isolationMode: \(Swift.String(describing: isolationMode)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains parameters for a Linux process that contains an Lambda function.
    public struct LambdaLinuxProcessParams: Swift.Equatable {
        /// The parameters for the container in which the Lambda function runs.
        public var containerParams: GreengrassV2ClientTypes.LambdaContainerParams?
        /// The isolation mode for the process that contains the Lambda function. The process can run
        ///       in an isolated runtime environment inside the IoT Greengrass container, or as a regular process outside
        ///       any container.
        ///          Default: GreengrassContainer
        ///
        public var isolationMode: GreengrassV2ClientTypes.LambdaIsolationMode?

        public init (
            containerParams: GreengrassV2ClientTypes.LambdaContainerParams? = nil,
            isolationMode: GreengrassV2ClientTypes.LambdaIsolationMode? = nil
        )
        {
            self.containerParams = containerParams
            self.isolationMode = isolationMode
        }
    }

}

extension GreengrassV2ClientTypes.LambdaVolumeMount: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addGroupOwner
        case destinationPath
        case permission
        case sourcePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGroupOwner != false {
            try encodeContainer.encode(addGroupOwner, forKey: .addGroupOwner)
        }
        if let destinationPath = destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
        if let sourcePath = sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
        let destinationPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.LambdaFilesystemPermission.self, forKey: .permission)
        permission = permissionDecoded
        let addGroupOwnerDecoded = try containerValues.decode(Swift.Bool.self, forKey: .addGroupOwner)
        addGroupOwner = addGroupOwnerDecoded
    }
}

extension GreengrassV2ClientTypes.LambdaVolumeMount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaVolumeMount(addGroupOwner: \(Swift.String(describing: addGroupOwner)), destinationPath: \(Swift.String(describing: destinationPath)), permission: \(Swift.String(describing: permission)), sourcePath: \(Swift.String(describing: sourcePath)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a volume that Linux processes in a container can access. When
    ///       you define a volume, the IoT Greengrass Core software mounts the source files to the destination inside the
    ///       container.
    public struct LambdaVolumeMount: Swift.Equatable {
        /// Whether or not to add the IoT Greengrass user group as an owner of the volume.
        ///          Default: false
        ///
        public var addGroupOwner: Swift.Bool
        /// The path to the logical volume in the file system.
        /// This member is required.
        public var destinationPath: Swift.String?
        /// The permission to access the volume: read/only (ro) or read/write
        ///         (rw).
        ///          Default: ro
        ///
        public var permission: GreengrassV2ClientTypes.LambdaFilesystemPermission?
        /// The path to the physical volume in the file system.
        /// This member is required.
        public var sourcePath: Swift.String?

        public init (
            addGroupOwner: Swift.Bool = false,
            destinationPath: Swift.String? = nil,
            permission: GreengrassV2ClientTypes.LambdaFilesystemPermission? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.addGroupOwner = addGroupOwner
            self.destinationPath = destinationPath
            self.permission = permission
            self.sourcePath = sourcePath
        }
    }

}

extension ListClientDevicesAssociatedWithCoreDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListClientDevicesAssociatedWithCoreDeviceInput(coreDeviceThingName: \(Swift.String(describing: coreDeviceThingName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListClientDevicesAssociatedWithCoreDeviceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListClientDevicesAssociatedWithCoreDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClientDevicesAssociatedWithCoreDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClientDevicesAssociatedWithCoreDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClientDevicesAssociatedWithCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClientDevicesAssociatedWithCoreDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClientDevicesAssociatedWithCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClientDevicesAssociatedWithCoreDeviceOutputError>
}

public struct ListClientDevicesAssociatedWithCoreDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClientDevicesAssociatedWithCoreDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClientDevicesAssociatedWithCoreDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClientDevicesAssociatedWithCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClientDevicesAssociatedWithCoreDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClientDevicesAssociatedWithCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClientDevicesAssociatedWithCoreDeviceOutputError>
}

public struct ListClientDevicesAssociatedWithCoreDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClientDevicesAssociatedWithCoreDeviceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListClientDevicesAssociatedWithCoreDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClientDevicesAssociatedWithCoreDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreDeviceThingName = input.coreDeviceThingName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreDeviceThingName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/associatedClientDevices"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListClientDevicesAssociatedWithCoreDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListClientDevicesAssociatedWithCoreDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClientDevicesAssociatedWithCoreDeviceOutputError>
}

public struct ListClientDevicesAssociatedWithCoreDeviceInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        coreDeviceThingName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClientDevicesAssociatedWithCoreDeviceInputBody: Swift.Equatable {
}

extension ListClientDevicesAssociatedWithCoreDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListClientDevicesAssociatedWithCoreDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClientDevicesAssociatedWithCoreDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListClientDevicesAssociatedWithCoreDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClientDevicesAssociatedWithCoreDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListClientDevicesAssociatedWithCoreDeviceOutputResponse(associatedClientDevices: \(Swift.String(describing: associatedClientDevices)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListClientDevicesAssociatedWithCoreDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListClientDevicesAssociatedWithCoreDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associatedClientDevices = output.associatedClientDevices
            self.nextToken = output.nextToken
        } else {
            self.associatedClientDevices = nil
            self.nextToken = nil
        }
    }
}

public struct ListClientDevicesAssociatedWithCoreDeviceOutputResponse: Swift.Equatable {
    /// A list that describes the client devices that are associated with the core device.
    public var associatedClientDevices: [GreengrassV2ClientTypes.AssociatedClientDevice]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        associatedClientDevices: [GreengrassV2ClientTypes.AssociatedClientDevice]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associatedClientDevices = associatedClientDevices
        self.nextToken = nextToken
    }
}

struct ListClientDevicesAssociatedWithCoreDeviceOutputResponseBody: Swift.Equatable {
    public let associatedClientDevices: [GreengrassV2ClientTypes.AssociatedClientDevice]?
    public let nextToken: Swift.String?
}

extension ListClientDevicesAssociatedWithCoreDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedClientDevices
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedClientDevicesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.AssociatedClientDevice?].self, forKey: .associatedClientDevices)
        var associatedClientDevicesDecoded0:[GreengrassV2ClientTypes.AssociatedClientDevice]? = nil
        if let associatedClientDevicesContainer = associatedClientDevicesContainer {
            associatedClientDevicesDecoded0 = [GreengrassV2ClientTypes.AssociatedClientDevice]()
            for structure0 in associatedClientDevicesContainer {
                if let structure0 = structure0 {
                    associatedClientDevicesDecoded0?.append(structure0)
                }
            }
        }
        associatedClientDevices = associatedClientDevicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListComponentVersionsInput(arn: \(Swift.String(describing: arn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListComponentVersionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListComponentVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComponentVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComponentVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentVersionsOutputError>
}

public struct ListComponentVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComponentVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComponentVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentVersionsOutputError>
}

public struct ListComponentVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentVersionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListComponentVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let arn = input.arn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("arn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/components/\(arn.urlPercentEncoding())/versions"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListComponentVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentVersionsOutputError>
}

public struct ListComponentVersionsInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the component version.
    /// This member is required.
    public var arn: Swift.String?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComponentVersionsInputBody: Swift.Equatable {
}

extension ListComponentVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListComponentVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComponentVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListComponentVersionsOutputResponse(componentVersions: \(Swift.String(describing: componentVersions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListComponentVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComponentVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentVersions = output.componentVersions
            self.nextToken = output.nextToken
        } else {
            self.componentVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentVersionsOutputResponse: Swift.Equatable {
    /// A list of versions that exist for the component.
    public var componentVersions: [GreengrassV2ClientTypes.ComponentVersionListItem]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        componentVersions: [GreengrassV2ClientTypes.ComponentVersionListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentVersions = componentVersions
        self.nextToken = nextToken
    }
}

struct ListComponentVersionsOutputResponseBody: Swift.Equatable {
    public let componentVersions: [GreengrassV2ClientTypes.ComponentVersionListItem]?
    public let nextToken: Swift.String?
}

extension ListComponentVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentVersionsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ComponentVersionListItem?].self, forKey: .componentVersions)
        var componentVersionsDecoded0:[GreengrassV2ClientTypes.ComponentVersionListItem]? = nil
        if let componentVersionsContainer = componentVersionsContainer {
            componentVersionsDecoded0 = [GreengrassV2ClientTypes.ComponentVersionListItem]()
            for structure0 in componentVersionsContainer {
                if let structure0 = structure0 {
                    componentVersionsDecoded0?.append(structure0)
                }
            }
        }
        componentVersions = componentVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListComponentsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), scope: \(Swift.String(describing: scope)))"}
}

extension ListComponentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListComponentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComponentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentsOutputError>
}

public struct ListComponentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let scope = input.operationInput.scope {
            let scopeQueryItem = ClientRuntime.URLQueryItem(name: "scope".urlPercentEncoding(), value: Swift.String(scope.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(scopeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComponentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentsOutputError>
}

public struct ListComponentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListComponentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/components"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListComponentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentsOutputError>
}

public struct ListComponentsInput: Swift.Equatable {
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The scope of the components to list.
    ///          Default: PRIVATE
    ///
    public var scope: GreengrassV2ClientTypes.ComponentVisibilityScope?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        scope: GreengrassV2ClientTypes.ComponentVisibilityScope? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scope = scope
    }
}

struct ListComponentsInputBody: Swift.Equatable {
}

extension ListComponentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComponentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListComponentsOutputResponse(components: \(Swift.String(describing: components)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.components = output.components
            self.nextToken = output.nextToken
        } else {
            self.components = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutputResponse: Swift.Equatable {
    /// A list that summarizes each component.
    public var components: [GreengrassV2ClientTypes.Component]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        components: [GreengrassV2ClientTypes.Component]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.components = components
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputResponseBody: Swift.Equatable {
    public let components: [GreengrassV2ClientTypes.Component]?
    public let nextToken: Swift.String?
}

extension ListComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.Component?].self, forKey: .components)
        var componentsDecoded0:[GreengrassV2ClientTypes.Component]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [GreengrassV2ClientTypes.Component]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCoreDevicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCoreDevicesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), status: \(Swift.String(describing: status)), thingGroupArn: \(Swift.String(describing: thingGroupArn)))"}
}

extension ListCoreDevicesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCoreDevicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCoreDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCoreDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCoreDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCoreDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCoreDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCoreDevicesOutputError>
}

public struct ListCoreDevicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCoreDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCoreDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCoreDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let thingGroupArn = input.operationInput.thingGroupArn {
            let thingGroupArnQueryItem = ClientRuntime.URLQueryItem(name: "thingGroupArn".urlPercentEncoding(), value: Swift.String(thingGroupArn).urlPercentEncoding())
            input.builder.withQueryItem(thingGroupArnQueryItem)
        }
        if let status = input.operationInput.status {
            let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCoreDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCoreDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCoreDevicesOutputError>
}

public struct ListCoreDevicesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCoreDevicesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListCoreDevicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCoreDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/coreDevices"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCoreDevicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCoreDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCoreDevicesOutputError>
}

public struct ListCoreDevicesInput: Swift.Equatable {
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The core device status by which to filter. If you specify this parameter, the list
    ///       includes only core devices that have this status. Choose one of the following options:
    ///
    ///
    ///
    ///                   HEALTHY  The IoT Greengrass Core software and all components run on the core device without issue.
    ///
    ///
    ///
    ///                   UNHEALTHY  The IoT Greengrass Core software or a component is in a failed state
    ///           on the core device.
    ///
    ///
    public var status: GreengrassV2ClientTypes.CoreDeviceStatus?
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the IoT thing group by which to filter. If you specify this parameter, the
    ///       list includes only core devices that are members of this thing group.
    public var thingGroupArn: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        status: GreengrassV2ClientTypes.CoreDeviceStatus? = nil,
        thingGroupArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.thingGroupArn = thingGroupArn
    }
}

struct ListCoreDevicesInputBody: Swift.Equatable {
}

extension ListCoreDevicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCoreDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCoreDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCoreDevicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCoreDevicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCoreDevicesOutputResponse(coreDevices: \(Swift.String(describing: coreDevices)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCoreDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCoreDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coreDevices = output.coreDevices
            self.nextToken = output.nextToken
        } else {
            self.coreDevices = nil
            self.nextToken = nil
        }
    }
}

public struct ListCoreDevicesOutputResponse: Swift.Equatable {
    /// A list that summarizes each core device.
    public var coreDevices: [GreengrassV2ClientTypes.CoreDevice]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        coreDevices: [GreengrassV2ClientTypes.CoreDevice]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDevices = coreDevices
        self.nextToken = nextToken
    }
}

struct ListCoreDevicesOutputResponseBody: Swift.Equatable {
    public let coreDevices: [GreengrassV2ClientTypes.CoreDevice]?
    public let nextToken: Swift.String?
}

extension ListCoreDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreDevices
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreDevicesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.CoreDevice?].self, forKey: .coreDevices)
        var coreDevicesDecoded0:[GreengrassV2ClientTypes.CoreDevice]? = nil
        if let coreDevicesContainer = coreDevicesContainer {
            coreDevicesDecoded0 = [GreengrassV2ClientTypes.CoreDevice]()
            for structure0 in coreDevicesContainer {
                if let structure0 = structure0 {
                    coreDevicesDecoded0?.append(structure0)
                }
            }
        }
        coreDevices = coreDevicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeploymentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeploymentsInput(historyFilter: \(Swift.String(describing: historyFilter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), targetArn: \(Swift.String(describing: targetArn)))"}
}

extension ListDeploymentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDeploymentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeploymentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeploymentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeploymentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let historyFilter = input.operationInput.historyFilter {
            let historyFilterQueryItem = ClientRuntime.URLQueryItem(name: "historyFilter".urlPercentEncoding(), value: Swift.String(historyFilter.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(historyFilterQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let targetArn = input.operationInput.targetArn {
            let targetArnQueryItem = ClientRuntime.URLQueryItem(name: "targetArn".urlPercentEncoding(), value: Swift.String(targetArn).urlPercentEncoding())
            input.builder.withQueryItem(targetArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeploymentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeploymentsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDeploymentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/deployments"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDeploymentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInput: Swift.Equatable {
    /// The filter for the list of deployments. Choose one of the following options:
    ///
    ///
    ///
    ///                   ALL  The list includes all deployments.
    ///
    ///
    ///
    ///                   LATEST_ONLY  The list includes only the latest revision of each
    ///           deployment.
    ///
    ///
    ///          Default: LATEST_ONLY
    ///
    public var historyFilter: GreengrassV2ClientTypes.DeploymentHistoryFilter?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the target IoT thing or thing group.
    public var targetArn: Swift.String?

    public init (
        historyFilter: GreengrassV2ClientTypes.DeploymentHistoryFilter? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.historyFilter = historyFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetArn = targetArn
    }
}

struct ListDeploymentsInputBody: Swift.Equatable {
}

extension ListDeploymentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeploymentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeploymentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeploymentsOutputResponse(deployments: \(Swift.String(describing: deployments)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeploymentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
            self.nextToken = output.nextToken
        } else {
            self.deployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutputResponse: Swift.Equatable {
    /// A list that summarizes each deployment.
    public var deployments: [GreengrassV2ClientTypes.Deployment]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        deployments: [GreengrassV2ClientTypes.Deployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputResponseBody: Swift.Equatable {
    public let deployments: [GreengrassV2ClientTypes.Deployment]?
    public let nextToken: Swift.String?
}

extension ListDeploymentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployments
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.Deployment?].self, forKey: .deployments)
        var deploymentsDecoded0:[GreengrassV2ClientTypes.Deployment]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [GreengrassV2ClientTypes.Deployment]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEffectiveDeploymentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEffectiveDeploymentsInput(coreDeviceThingName: \(Swift.String(describing: coreDeviceThingName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEffectiveDeploymentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListEffectiveDeploymentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEffectiveDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEffectiveDeploymentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEffectiveDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEffectiveDeploymentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEffectiveDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEffectiveDeploymentsOutputError>
}

public struct ListEffectiveDeploymentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEffectiveDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEffectiveDeploymentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEffectiveDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEffectiveDeploymentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEffectiveDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEffectiveDeploymentsOutputError>
}

public struct ListEffectiveDeploymentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEffectiveDeploymentsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListEffectiveDeploymentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEffectiveDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreDeviceThingName = input.coreDeviceThingName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreDeviceThingName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/effectiveDeployments"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEffectiveDeploymentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEffectiveDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEffectiveDeploymentsOutputError>
}

public struct ListEffectiveDeploymentsInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        coreDeviceThingName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEffectiveDeploymentsInputBody: Swift.Equatable {
}

extension ListEffectiveDeploymentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEffectiveDeploymentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEffectiveDeploymentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEffectiveDeploymentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEffectiveDeploymentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEffectiveDeploymentsOutputResponse(effectiveDeployments: \(Swift.String(describing: effectiveDeployments)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEffectiveDeploymentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEffectiveDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.effectiveDeployments = output.effectiveDeployments
            self.nextToken = output.nextToken
        } else {
            self.effectiveDeployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListEffectiveDeploymentsOutputResponse: Swift.Equatable {
    /// A list that summarizes each deployment on the core device.
    public var effectiveDeployments: [GreengrassV2ClientTypes.EffectiveDeployment]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        effectiveDeployments: [GreengrassV2ClientTypes.EffectiveDeployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.effectiveDeployments = effectiveDeployments
        self.nextToken = nextToken
    }
}

struct ListEffectiveDeploymentsOutputResponseBody: Swift.Equatable {
    public let effectiveDeployments: [GreengrassV2ClientTypes.EffectiveDeployment]?
    public let nextToken: Swift.String?
}

extension ListEffectiveDeploymentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveDeployments
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectiveDeploymentsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.EffectiveDeployment?].self, forKey: .effectiveDeployments)
        var effectiveDeploymentsDecoded0:[GreengrassV2ClientTypes.EffectiveDeployment]? = nil
        if let effectiveDeploymentsContainer = effectiveDeploymentsContainer {
            effectiveDeploymentsDecoded0 = [GreengrassV2ClientTypes.EffectiveDeployment]()
            for structure0 in effectiveDeploymentsContainer {
                if let structure0 = structure0 {
                    effectiveDeploymentsDecoded0?.append(structure0)
                }
            }
        }
        effectiveDeployments = effectiveDeploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstalledComponentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInstalledComponentsInput(coreDeviceThingName: \(Swift.String(describing: coreDeviceThingName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListInstalledComponentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListInstalledComponentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstalledComponentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInstalledComponentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstalledComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInstalledComponentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstalledComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstalledComponentsOutputError>
}

public struct ListInstalledComponentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstalledComponentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInstalledComponentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstalledComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInstalledComponentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstalledComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstalledComponentsOutputError>
}

public struct ListInstalledComponentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInstalledComponentsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListInstalledComponentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInstalledComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let coreDeviceThingName = input.coreDeviceThingName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("coreDeviceThingName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/coreDevices/\(coreDeviceThingName.urlPercentEncoding())/installedComponents"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListInstalledComponentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListInstalledComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInstalledComponentsOutputError>
}

public struct ListInstalledComponentsInput: Swift.Equatable {
    /// The name of the core device. This is also the name of the IoT thing.
    /// This member is required.
    public var coreDeviceThingName: Swift.String?
    /// The maximum number of results to be returned per paginated request.
    public var maxResults: Swift.Int
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        coreDeviceThingName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDeviceThingName = coreDeviceThingName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstalledComponentsInputBody: Swift.Equatable {
}

extension ListInstalledComponentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInstalledComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstalledComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstalledComponentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstalledComponentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInstalledComponentsOutputResponse(installedComponents: \(Swift.String(describing: installedComponents)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListInstalledComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInstalledComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.installedComponents = output.installedComponents
            self.nextToken = output.nextToken
        } else {
            self.installedComponents = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstalledComponentsOutputResponse: Swift.Equatable {
    /// A list that summarizes each component on the core device.
    public var installedComponents: [GreengrassV2ClientTypes.InstalledComponent]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        installedComponents: [GreengrassV2ClientTypes.InstalledComponent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.installedComponents = installedComponents
        self.nextToken = nextToken
    }
}

struct ListInstalledComponentsOutputResponseBody: Swift.Equatable {
    public let installedComponents: [GreengrassV2ClientTypes.InstalledComponent]?
    public let nextToken: Swift.String?
}

extension ListInstalledComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case installedComponents
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let installedComponentsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.InstalledComponent?].self, forKey: .installedComponents)
        var installedComponentsDecoded0:[GreengrassV2ClientTypes.InstalledComponent]? = nil
        if let installedComponentsContainer = installedComponentsContainer {
            installedComponentsDecoded0 = [GreengrassV2ClientTypes.InstalledComponent]()
            for structure0 in installedComponentsContainer {
                if let structure0 = structure0 {
                    installedComponentsDecoded0?.append(structure0)
                }
            }
        }
        installedComponents = installedComponentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources in the IoT Greengrass V2 Developer Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GreengrassV2ClientTypes {
    public enum RecipeOutputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case yaml
        case sdkUnknown(Swift.String)

        public static var allCases: [RecipeOutputFormat] {
            return [
                .json,
                .yaml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .yaml: return "YAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecipeOutputFormat(rawValue: rawValue) ?? RecipeOutputFormat.sdkUnknown(rawValue)
        }
    }
}

extension RequestAlreadyInProgressException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestAlreadyInProgressException(message: \(Swift.String(describing: message)))"}
}

extension RequestAlreadyInProgressException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestAlreadyInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is already in progress. This exception occurs when you use a client token for
///       multiple requests while IoT Greengrass is still processing an earlier request that uses the same client
///       token.
public struct RequestAlreadyInProgressException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestAlreadyInProgressExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RequestAlreadyInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ResolveComponentCandidatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveComponentCandidatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResolveComponentCandidatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveComponentCandidatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResolveComponentCandidatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveComponentCandidatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveComponentCandidatesOutputError>
}

extension ResolveComponentCandidatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResolveComponentCandidatesInput(componentCandidates: \(Swift.String(describing: componentCandidates)), platform: \(Swift.String(describing: platform)))"}
}

extension ResolveComponentCandidatesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentCandidates
        case platform
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentCandidates = componentCandidates {
            var componentCandidatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .componentCandidates)
            for componentcandidatelist0 in componentCandidates {
                try componentCandidatesContainer.encode(componentcandidatelist0)
            }
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
    }
}

public struct ResolveComponentCandidatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveComponentCandidatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResolveComponentCandidatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveComponentCandidatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResolveComponentCandidatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveComponentCandidatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveComponentCandidatesOutputError>
}

public struct ResolveComponentCandidatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveComponentCandidatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResolveComponentCandidatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveComponentCandidatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResolveComponentCandidatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveComponentCandidatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveComponentCandidatesOutputError>
}

public struct ResolveComponentCandidatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveComponentCandidatesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ResolveComponentCandidatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveComponentCandidatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/greengrass/v2/resolveComponentCandidates"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResolveComponentCandidatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveComponentCandidatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveComponentCandidatesOutputError>
}

public struct ResolveComponentCandidatesInput: Swift.Equatable {
    /// The list of components to resolve.
    /// This member is required.
    public var componentCandidates: [GreengrassV2ClientTypes.ComponentCandidate]?
    /// The platform to use to resolve compatible components.
    /// This member is required.
    public var platform: GreengrassV2ClientTypes.ComponentPlatform?

    public init (
        componentCandidates: [GreengrassV2ClientTypes.ComponentCandidate]? = nil,
        platform: GreengrassV2ClientTypes.ComponentPlatform? = nil
    )
    {
        self.componentCandidates = componentCandidates
        self.platform = platform
    }
}

struct ResolveComponentCandidatesInputBody: Swift.Equatable {
    public let platform: GreengrassV2ClientTypes.ComponentPlatform?
    public let componentCandidates: [GreengrassV2ClientTypes.ComponentCandidate]?
}

extension ResolveComponentCandidatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentCandidates
        case platform
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.ComponentPlatform.self, forKey: .platform)
        platform = platformDecoded
        let componentCandidatesContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ComponentCandidate?].self, forKey: .componentCandidates)
        var componentCandidatesDecoded0:[GreengrassV2ClientTypes.ComponentCandidate]? = nil
        if let componentCandidatesContainer = componentCandidatesContainer {
            componentCandidatesDecoded0 = [GreengrassV2ClientTypes.ComponentCandidate]()
            for structure0 in componentCandidatesContainer {
                if let structure0 = structure0 {
                    componentCandidatesDecoded0?.append(structure0)
                }
            }
        }
        componentCandidates = componentCandidatesDecoded0
    }
}

extension ResolveComponentCandidatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResolveComponentCandidatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResolveComponentCandidatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResolveComponentCandidatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResolveComponentCandidatesOutputResponse(resolvedComponentVersions: \(Swift.String(describing: resolvedComponentVersions)))"}
}

extension ResolveComponentCandidatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResolveComponentCandidatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolvedComponentVersions = output.resolvedComponentVersions
        } else {
            self.resolvedComponentVersions = nil
        }
    }
}

public struct ResolveComponentCandidatesOutputResponse: Swift.Equatable {
    /// A list of components that meet the requirements that you specify in the request. This list
    ///       includes each component's recipe that you can use to install the component.
    public var resolvedComponentVersions: [GreengrassV2ClientTypes.ResolvedComponentVersion]?

    public init (
        resolvedComponentVersions: [GreengrassV2ClientTypes.ResolvedComponentVersion]? = nil
    )
    {
        self.resolvedComponentVersions = resolvedComponentVersions
    }
}

struct ResolveComponentCandidatesOutputResponseBody: Swift.Equatable {
    public let resolvedComponentVersions: [GreengrassV2ClientTypes.ResolvedComponentVersion]?
}

extension ResolveComponentCandidatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolvedComponentVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolvedComponentVersionsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ResolvedComponentVersion?].self, forKey: .resolvedComponentVersions)
        var resolvedComponentVersionsDecoded0:[GreengrassV2ClientTypes.ResolvedComponentVersion]? = nil
        if let resolvedComponentVersionsContainer = resolvedComponentVersionsContainer {
            resolvedComponentVersionsDecoded0 = [GreengrassV2ClientTypes.ResolvedComponentVersion]()
            for structure0 in resolvedComponentVersionsContainer {
                if let structure0 = structure0 {
                    resolvedComponentVersionsDecoded0?.append(structure0)
                }
            }
        }
        resolvedComponentVersions = resolvedComponentVersionsDecoded0
    }
}

extension GreengrassV2ClientTypes.ResolvedComponentVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentName
        case componentVersion
        case recipe
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentVersion = componentVersion {
            try encodeContainer.encode(componentVersion, forKey: .componentVersion)
        }
        if let recipe = recipe {
            try encodeContainer.encode(recipe.base64EncodedString(), forKey: .recipe)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersion)
        componentVersion = componentVersionDecoded
        let recipeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .recipe)
        recipe = recipeDecoded
    }
}

extension GreengrassV2ClientTypes.ResolvedComponentVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResolvedComponentVersion(arn: \(Swift.String(describing: arn)), componentName: \(Swift.String(describing: componentName)), componentVersion: \(Swift.String(describing: componentVersion)), recipe: \(Swift.String(describing: recipe)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a component version that is compatible to run on a Greengrass core
    ///       device.
    public struct ResolvedComponentVersion: Swift.Equatable {
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the component version.
        public var arn: Swift.String?
        /// The name of the component.
        public var componentName: Swift.String?
        /// The version of the component.
        public var componentVersion: Swift.String?
        /// The recipe of the component version.
        public var recipe: ClientRuntime.Data?

        public init (
            arn: Swift.String? = nil,
            componentName: Swift.String? = nil,
            componentVersion: Swift.String? = nil,
            recipe: ClientRuntime.Data? = nil
        )
        {
            self.arn = arn
            self.componentName = componentName
            self.componentVersion = componentVersion
            self.recipe = recipe
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource that isn't found.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource that isn't found.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request exceeds a service quota. For example, you might have the maximum number of
///       components that you can create.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The code for the quota in <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html">Service Quotas.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// The ID of the resource that exceeds the service quota.
    public var resourceId: Swift.String?
    /// The type of the resource that exceeds the service quota.
    public var resourceType: Swift.String?
    /// The code for the service in <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html">Service Quotas.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
    public let quotaCode: Swift.String?
    public let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension GreengrassV2ClientTypes.SystemResourceLimits: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case memory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cpus != 0.0 {
            try encodeContainer.encode(cpus, forKey: .cpus)
        }
        if memory != 0 {
            try encodeContainer.encode(memory, forKey: .memory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memoryDecoded = try containerValues.decode(Swift.Int.self, forKey: .memory)
        memory = memoryDecoded
        let cpusDecoded = try containerValues.decode(Swift.Double.self, forKey: .cpus)
        cpus = cpusDecoded
    }
}

extension GreengrassV2ClientTypes.SystemResourceLimits: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SystemResourceLimits(cpus: \(Swift.String(describing: cpus)), memory: \(Swift.String(describing: memory)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about system resource limits that the IoT Greengrass Core software applies to a
    ///       component's processes. For more information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/configure-greengrass-core-v2.html#configure-component-system-resource-limits">Configure system resource limits for components.
    public struct SystemResourceLimits: Swift.Equatable {
        /// The maximum amount of CPU time that a component's processes can use on the core device. A
        ///       core device's total CPU time is equivalent to the device's number of CPU cores. For example,
        ///       on a core device with 4 CPU cores, you can set this value to 2 to limit the
        ///       component's processes to 50 percent usage of each CPU core. On a device with 1 CPU core, you
        ///       can set this value to 0.25 to limit the component's processes to 25 percent usage
        ///       of the CPU. If you set this value to a number greater than the number of CPU cores, the IoT Greengrass Core
        ///       software doesn't limit the component's CPU usage.
        public var cpus: Swift.Double
        /// The maximum amount of RAM, expressed in kilobytes, that a component's processes can use on
        ///       the core device.
        public var memory: Swift.Int

        public init (
            cpus: Swift.Double = 0.0,
            memory: Swift.Int = 0
        )
        {
            self.cpus = cpus
            self.memory = memory
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the resource. For more
    ///       information, see <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html">Tag your
    ///         resources in the IoT Greengrass V2 Developer Guide.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request exceeded a request rate quota. For example, you might have exceeded the
///       amount of times that you can retrieve device or deployment status per second.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The code for the quota in <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html">Service Quotas.
    public var quotaCode: Swift.String?
    /// The amount of time to wait before you retry the request.
    public var retryAfterSeconds: Swift.Int
    /// The code for the service in <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html">Service Quotas.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let quotaCode: Swift.String?
    public let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the resource to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys for tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(fields: \(Swift.String(describing: fields)), message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request isn't valid. This can occur if your request contains malformed JSON or
///       unsupported characters.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The list of fields that failed to validate.
    public var fields: [GreengrassV2ClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason for the validation exception.
    public var reason: GreengrassV2ClientTypes.ValidationExceptionReason?

    public init (
        fields: [GreengrassV2ClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: GreengrassV2ClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: GreengrassV2ClientTypes.ValidationExceptionReason?
    public let fields: [GreengrassV2ClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(GreengrassV2ClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([GreengrassV2ClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[GreengrassV2ClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [GreengrassV2ClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension GreengrassV2ClientTypes.ValidationExceptionField: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassV2ClientTypes.ValidationExceptionField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationExceptionField(message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)))"}
}

extension GreengrassV2ClientTypes {
    /// Contains information about a validation exception field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message of the exception field.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the exception field.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension GreengrassV2ClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
