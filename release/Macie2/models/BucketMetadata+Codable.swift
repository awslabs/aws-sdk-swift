// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension BucketMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case allowsUnencryptedObjectUploads = "allowsUnencryptedObjectUploads"
        case bucketArn = "bucketArn"
        case bucketCreatedAt = "bucketCreatedAt"
        case bucketName = "bucketName"
        case classifiableObjectCount = "classifiableObjectCount"
        case classifiableSizeInBytes = "classifiableSizeInBytes"
        case jobDetails = "jobDetails"
        case lastUpdated = "lastUpdated"
        case objectCount = "objectCount"
        case objectCountByEncryptionType = "objectCountByEncryptionType"
        case publicAccess = "publicAccess"
        case region = "region"
        case replicationDetails = "replicationDetails"
        case serverSideEncryption = "serverSideEncryption"
        case sharedAccess = "sharedAccess"
        case sizeInBytes = "sizeInBytes"
        case sizeInBytesCompressed = "sizeInBytesCompressed"
        case tags = "tags"
        case unclassifiableObjectCount = "unclassifiableObjectCount"
        case unclassifiableObjectSizeInBytes = "unclassifiableObjectSizeInBytes"
        case versioning = "versioning"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploads {
            try encodeContainer.encode(allowsUnencryptedObjectUploads.rawValue, forKey: .allowsUnencryptedObjectUploads)
        }
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let bucketCreatedAt = bucketCreatedAt {
            try encodeContainer.encode(bucketCreatedAt.timeIntervalSince1970, forKey: .bucketCreatedAt)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if classifiableObjectCount != 0 {
            try encodeContainer.encode(classifiableObjectCount, forKey: .classifiableObjectCount)
        }
        if classifiableSizeInBytes != 0 {
            try encodeContainer.encode(classifiableSizeInBytes, forKey: .classifiableSizeInBytes)
        }
        if let jobDetails = jobDetails {
            try encodeContainer.encode(jobDetails, forKey: .jobDetails)
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if objectCount != 0 {
            try encodeContainer.encode(objectCount, forKey: .objectCount)
        }
        if let objectCountByEncryptionType = objectCountByEncryptionType {
            try encodeContainer.encode(objectCountByEncryptionType, forKey: .objectCountByEncryptionType)
        }
        if let publicAccess = publicAccess {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let replicationDetails = replicationDetails {
            try encodeContainer.encode(replicationDetails, forKey: .replicationDetails)
        }
        if let serverSideEncryption = serverSideEncryption {
            try encodeContainer.encode(serverSideEncryption, forKey: .serverSideEncryption)
        }
        if let sharedAccess = sharedAccess {
            try encodeContainer.encode(sharedAccess.rawValue, forKey: .sharedAccess)
        }
        if sizeInBytes != 0 {
            try encodeContainer.encode(sizeInBytes, forKey: .sizeInBytes)
        }
        if sizeInBytesCompressed != 0 {
            try encodeContainer.encode(sizeInBytesCompressed, forKey: .sizeInBytesCompressed)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for __listofkeyvaluepair0 in tags {
                try tagsContainer.encode(__listofkeyvaluepair0)
            }
        }
        if let unclassifiableObjectCount = unclassifiableObjectCount {
            try encodeContainer.encode(unclassifiableObjectCount, forKey: .unclassifiableObjectCount)
        }
        if let unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes {
            try encodeContainer.encode(unclassifiableObjectSizeInBytes, forKey: .unclassifiableObjectSizeInBytes)
        }
        if versioning != false {
            try encodeContainer.encode(versioning, forKey: .versioning)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let allowsUnencryptedObjectUploadsDecoded = try containerValues.decodeIfPresent(AllowsUnencryptedObjectUploads.self, forKey: .allowsUnencryptedObjectUploads)
        allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploadsDecoded
        let bucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let bucketCreatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .bucketCreatedAt)
        bucketCreatedAt = bucketCreatedAtDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let classifiableObjectCountDecoded = try containerValues.decode(Int.self, forKey: .classifiableObjectCount)
        classifiableObjectCount = classifiableObjectCountDecoded
        let classifiableSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .classifiableSizeInBytes)
        classifiableSizeInBytes = classifiableSizeInBytesDecoded
        let jobDetailsDecoded = try containerValues.decodeIfPresent(JobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let objectCountDecoded = try containerValues.decode(Int.self, forKey: .objectCount)
        objectCount = objectCountDecoded
        let objectCountByEncryptionTypeDecoded = try containerValues.decodeIfPresent(ObjectCountByEncryptionType.self, forKey: .objectCountByEncryptionType)
        objectCountByEncryptionType = objectCountByEncryptionTypeDecoded
        let publicAccessDecoded = try containerValues.decodeIfPresent(BucketPublicAccess.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let replicationDetailsDecoded = try containerValues.decodeIfPresent(ReplicationDetails.self, forKey: .replicationDetails)
        replicationDetails = replicationDetailsDecoded
        let serverSideEncryptionDecoded = try containerValues.decodeIfPresent(BucketServerSideEncryption.self, forKey: .serverSideEncryption)
        serverSideEncryption = serverSideEncryptionDecoded
        let sharedAccessDecoded = try containerValues.decodeIfPresent(SharedAccess.self, forKey: .sharedAccess)
        sharedAccess = sharedAccessDecoded
        let sizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let sizeInBytesCompressedDecoded = try containerValues.decode(Int.self, forKey: .sizeInBytesCompressed)
        sizeInBytesCompressed = sizeInBytesCompressedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyValuePair].self, forKey: .tags)
        var tagsDecoded0:[KeyValuePair]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyValuePair]()
            for structure0 in tagsContainer {
                tagsDecoded0?.append(structure0)
            }
        }
        tags = tagsDecoded0
        let unclassifiableObjectCountDecoded = try containerValues.decodeIfPresent(ObjectLevelStatistics.self, forKey: .unclassifiableObjectCount)
        unclassifiableObjectCount = unclassifiableObjectCountDecoded
        let unclassifiableObjectSizeInBytesDecoded = try containerValues.decodeIfPresent(ObjectLevelStatistics.self, forKey: .unclassifiableObjectSizeInBytes)
        unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytesDecoded
        let versioningDecoded = try containerValues.decode(Bool.self, forKey: .versioning)
        versioning = versioningDecoded
    }
}
