// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptInvitationInputBodyMiddleware: Middleware {
    public let id: String = "AcceptInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptInvitationOutputError>
}

extension AcceptInvitationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptInvitationInput(administratorAccountId: \(String(describing: administratorAccountId)), invitationId: \(String(describing: invitationId)), masterAccount: \(String(describing: masterAccount)))"}
}

extension AcceptInvitationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case administratorAccountId = "administratorAccountId"
        case invitationId = "invitationId"
        case masterAccount = "masterAccount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorAccountId = administratorAccountId {
            try encodeContainer.encode(administratorAccountId, forKey: .administratorAccountId)
        }
        if let invitationId = invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let masterAccount = masterAccount {
            try encodeContainer.encode(masterAccount, forKey: .masterAccount)
        }
    }
}

public struct AcceptInvitationInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptInvitationOutputError>
}

public struct AcceptInvitationInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptInvitationOutputError>
}

public struct AcceptInvitationInput: Equatable {
    /// <p>The AWS account ID for the account that sent the invitation.</p>
    public let administratorAccountId: String?
    /// <p>The unique identifier for the invitation to accept.</p>
    public let invitationId: String?
    /// <p>(Deprecated) The AWS account ID for the account that sent the invitation. This property has been replaced by the administratorAccountId property and is retained only for backward compatibility.</p>
    public let masterAccount: String?

    public init (
        administratorAccountId: String? = nil,
        invitationId: String? = nil,
        masterAccount: String? = nil
    )
    {
        self.administratorAccountId = administratorAccountId
        self.invitationId = invitationId
        self.masterAccount = masterAccount
    }
}

struct AcceptInvitationInputBody: Equatable {
    public let administratorAccountId: String?
    public let invitationId: String?
    public let masterAccount: String?
}

extension AcceptInvitationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case administratorAccountId = "administratorAccountId"
        case invitationId = "invitationId"
        case masterAccount = "masterAccount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .administratorAccountId)
        administratorAccountId = administratorAccountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let masterAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterAccount)
        masterAccount = masterAccountDecoded
    }
}

extension AcceptInvitationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptInvitationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptInvitationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptInvitationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptInvitationOutputResponse()"}
}

extension AcceptInvitationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AcceptInvitationOutputResponse: Equatable {

    public init() {}
}

struct AcceptInvitationOutputResponseBody: Equatable {
}

extension AcceptInvitationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AccessControlList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowsPublicReadAccess = "allowsPublicReadAccess"
        case allowsPublicWriteAccess = "allowsPublicWriteAccess"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsPublicReadAccess != false {
            try encodeContainer.encode(allowsPublicReadAccess, forKey: .allowsPublicReadAccess)
        }
        if allowsPublicWriteAccess != false {
            try encodeContainer.encode(allowsPublicWriteAccess, forKey: .allowsPublicWriteAccess)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsPublicReadAccessDecoded = try containerValues.decode(Bool.self, forKey: .allowsPublicReadAccess)
        allowsPublicReadAccess = allowsPublicReadAccessDecoded
        let allowsPublicWriteAccessDecoded = try containerValues.decode(Bool.self, forKey: .allowsPublicWriteAccess)
        allowsPublicWriteAccess = allowsPublicWriteAccessDecoded
    }
}

extension AccessControlList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessControlList(allowsPublicReadAccess: \(String(describing: allowsPublicReadAccess)), allowsPublicWriteAccess: \(String(describing: allowsPublicWriteAccess)))"}
}

/// <p>Provides information about the permissions settings of the bucket-level access control list (ACL) for an S3 bucket.</p>
public struct AccessControlList: Equatable {
    /// <p>Specifies whether the ACL grants the general public with read access permissions for the bucket.</p>
    public let allowsPublicReadAccess: Bool
    /// <p>Specifies whether the ACL grants the general public with write access permissions for the bucket.</p>
    public let allowsPublicWriteAccess: Bool

    public init (
        allowsPublicReadAccess: Bool = false,
        allowsPublicWriteAccess: Bool = false
    )
    {
        self.allowsPublicReadAccess = allowsPublicReadAccess
        self.allowsPublicWriteAccess = allowsPublicWriteAccess
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an error that occurred due to insufficient access to a specified resource.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The explanation of the error that occurred.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case email = "email"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
    }
}

extension AccountDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountDetail(accountId: \(String(describing: accountId)), email: \(String(describing: email)))"}
}

/// <p>Specifies details for an account to associate with an Amazon Macie administrator account.</p>
public struct AccountDetail: Equatable {
    /// <p>The AWS account ID for the account.</p>
    public let accountId: String?
    /// <p>The email address for the account.</p>
    public let email: String?

    public init (
        accountId: String? = nil,
        email: String? = nil
    )
    {
        self.accountId = accountId
        self.email = email
    }
}

extension AccountLevelPermissions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockPublicAccess = "blockPublicAccess"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockPublicAccess = blockPublicAccess {
            try encodeContainer.encode(blockPublicAccess, forKey: .blockPublicAccess)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAccessDecoded = try containerValues.decodeIfPresent(BlockPublicAccess.self, forKey: .blockPublicAccess)
        blockPublicAccess = blockPublicAccessDecoded
    }
}

extension AccountLevelPermissions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountLevelPermissions(blockPublicAccess: \(String(describing: blockPublicAccess)))"}
}

/// <p>Provides information about the account-level permissions settings that apply to an S3 bucket.</p>
public struct AccountLevelPermissions: Equatable {
    /// <p>The block public access settings for the AWS account that owns the bucket.</p>
    public let blockPublicAccess: BlockPublicAccess?

    public init (
        blockPublicAccess: BlockPublicAccess? = nil
    )
    {
        self.blockPublicAccess = blockPublicAccess
    }
}

extension AdminAccount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AdminStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AdminAccount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminAccount(accountId: \(String(describing: accountId)), status: \(String(describing: status)))"}
}

/// <p>Provides information about the delegated Amazon Macie administrator account for an AWS organization.</p>
public struct AdminAccount: Equatable {
    /// <p>The AWS account ID for the account.</p>
    public let accountId: String?
    /// <p>The current status of the account as the delegated administrator of Amazon Macie for the organization.</p>
    public let status: AdminStatus?

    public init (
        accountId: String? = nil,
        status: AdminStatus? = nil
    )
    {
        self.accountId = accountId
        self.status = status
    }
}

/// <p>The current status of an account as the delegated Amazon Macie administrator account for an AWS organization. Possible values are:</p>
public enum AdminStatus {
    case disablingInProgress
    case enabled
    case sdkUnknown(String)
}

extension AdminStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AdminStatus] {
        return [
            .disablingInProgress,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disablingInProgress: return "DISABLING_IN_PROGRESS"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AdminStatus(rawValue: rawValue) ?? AdminStatus.sdkUnknown(rawValue)
    }
}

public enum AllowsUnencryptedObjectUploads {
    case `false`
    case `true`
    case unknown
    case sdkUnknown(String)
}

extension AllowsUnencryptedObjectUploads : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AllowsUnencryptedObjectUploads] {
        return [
            .false,
            .true,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .false: return "FALSE"
        case .true: return "TRUE"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AllowsUnencryptedObjectUploads(rawValue: rawValue) ?? AllowsUnencryptedObjectUploads.sdkUnknown(rawValue)
    }
}

extension ApiCallDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case api = "api"
        case apiServiceName = "apiServiceName"
        case firstSeen = "firstSeen"
        case lastSeen = "lastSeen"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let api = api {
            try encodeContainer.encode(api, forKey: .api)
        }
        if let apiServiceName = apiServiceName {
            try encodeContainer.encode(apiServiceName, forKey: .apiServiceName)
        }
        if let firstSeen = firstSeen {
            try encodeContainer.encode(firstSeen.timeIntervalSince1970, forKey: .firstSeen)
        }
        if let lastSeen = lastSeen {
            try encodeContainer.encode(lastSeen.timeIntervalSince1970, forKey: .lastSeen)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDecoded = try containerValues.decodeIfPresent(String.self, forKey: .api)
        api = apiDecoded
        let apiServiceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiServiceName)
        apiServiceName = apiServiceNameDecoded
        let firstSeenDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .firstSeen)
        firstSeen = firstSeenDecoded
        let lastSeenDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSeen)
        lastSeen = lastSeenDecoded
    }
}

extension ApiCallDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApiCallDetails(api: \(String(describing: api)), apiServiceName: \(String(describing: apiServiceName)), firstSeen: \(String(describing: firstSeen)), lastSeen: \(String(describing: lastSeen)))"}
}

/// <p>Provides information about an API operation that an entity invoked for an affected resource.</p>
public struct ApiCallDetails: Equatable {
    /// <p>The name of the operation that was invoked most recently and produced the finding.</p>
    public let api: String?
    /// <p>The URL of the AWS service that provides the operation, for example: s3.amazonaws.com.</p>
    public let apiServiceName: String?
    /// <p>The first date and time, in UTC and extended ISO 8601 format, when any operation was invoked and produced the finding.</p>
    public let firstSeen: Date?
    /// <p>The most recent date and time, in UTC and extended ISO 8601 format, when the specified operation (api) was invoked and produced the finding.</p>
    public let lastSeen: Date?

    public init (
        api: String? = nil,
        apiServiceName: String? = nil,
        firstSeen: Date? = nil,
        lastSeen: Date? = nil
    )
    {
        self.api = api
        self.apiServiceName = apiServiceName
        self.firstSeen = firstSeen
        self.lastSeen = lastSeen
    }
}

extension AssumedRole: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId = "accessKeyId"
        case accountId = "accountId"
        case arn = "arn"
        case principalId = "principalId"
        case sessionContext = "sessionContext"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let sessionContext = sessionContext {
            try encodeContainer.encode(sessionContext, forKey: .sessionContext)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let sessionContextDecoded = try containerValues.decodeIfPresent(SessionContext.self, forKey: .sessionContext)
        sessionContext = sessionContextDecoded
    }
}

extension AssumedRole: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssumedRole(accessKeyId: \(String(describing: accessKeyId)), accountId: \(String(describing: accountId)), arn: \(String(describing: arn)), principalId: \(String(describing: principalId)), sessionContext: \(String(describing: sessionContext)))"}
}

/// <p>Provides information about an identity that performed an action on an affected resource by using temporary security credentials. The credentials were obtained using the AssumeRole operation of the AWS Security Token Service (AWS STS) API.</p>
public struct AssumedRole: Equatable {
    /// <p>The AWS access key ID that identifies the credentials.</p>
    public let accessKeyId: String?
    /// <p>The unique identifier for the AWS account that owns the entity that was used to get the credentials.</p>
    public let accountId: String?
    /// <p>The Amazon Resource Name (ARN) of the entity that was used to get the credentials.</p>
    public let arn: String?
    /// <p>The unique identifier for the entity that was used to get the credentials.</p>
    public let principalId: String?
    /// <p>The details of the session that was created for the credentials, including the entity that issued the session.</p>
    public let sessionContext: SessionContext?

    public init (
        accessKeyId: String? = nil,
        accountId: String? = nil,
        arn: String? = nil,
        principalId: String? = nil,
        sessionContext: SessionContext? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.accountId = accountId
        self.arn = arn
        self.principalId = principalId
        self.sessionContext = sessionContext
    }
}

extension AwsAccount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case principalId = "principalId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension AwsAccount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsAccount(accountId: \(String(describing: accountId)), principalId: \(String(describing: principalId)))"}
}

/// <p>Provides information about an AWS account and entity that performed an action on an affected resource. The action was performed using the credentials for an AWS account other than your own account.</p>
public struct AwsAccount: Equatable {
    /// <p>The unique identifier for the AWS account.</p>
    public let accountId: String?
    /// <p>The unique identifier for the entity that performed the action.</p>
    public let principalId: String?

    public init (
        accountId: String? = nil,
        principalId: String? = nil
    )
    {
        self.accountId = accountId
        self.principalId = principalId
    }
}

extension AwsService: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case invokedBy = "invokedBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invokedBy = invokedBy {
            try encodeContainer.encode(invokedBy, forKey: .invokedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invokedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invokedBy)
        invokedBy = invokedByDecoded
    }
}

extension AwsService: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsService(invokedBy: \(String(describing: invokedBy)))"}
}

/// <p>Provides information about an AWS service that performed an action on an affected resource.</p>
public struct AwsService: Equatable {
    /// <p>The name of the AWS service that performed the action.</p>
    public let invokedBy: String?

    public init (
        invokedBy: String? = nil
    )
    {
        self.invokedBy = invokedBy
    }
}

extension BatchGetCustomDataIdentifierSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case deleted = "deleted"
        case description = "description"
        case id = "id"
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if deleted != false {
            try encodeContainer.encode(deleted, forKey: .deleted)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deletedDecoded = try containerValues.decode(Bool.self, forKey: .deleted)
        deleted = deletedDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension BatchGetCustomDataIdentifierSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetCustomDataIdentifierSummary(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), deleted: \(String(describing: deleted)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Provides information about a custom data identifier.</p>
public struct BatchGetCustomDataIdentifierSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom data identifier.</p>
    public let arn: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the custom data identifier was created.</p>
    public let createdAt: Date?
    /// <p>Specifies whether the custom data identifier was deleted. If you delete a custom data identifier, Amazon Macie doesn't delete it permanently. Instead, it soft deletes the identifier.</p>
    public let deleted: Bool
    /// <p>The custom description of the custom data identifier.</p>
    public let description: String?
    /// <p>The unique identifier for the custom data identifier.</p>
    public let id: String?
    /// <p>The custom name of the custom data identifier.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        deleted: Bool = false,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deleted = deleted
        self.description = description
        self.id = id
        self.name = name
    }
}

public struct BatchGetCustomDataIdentifiersInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetCustomDataIdentifiersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetCustomDataIdentifiersInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetCustomDataIdentifiersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetCustomDataIdentifiersInput>
    public typealias MOutput = OperationOutput<BatchGetCustomDataIdentifiersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetCustomDataIdentifiersOutputError>
}

extension BatchGetCustomDataIdentifiersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetCustomDataIdentifiersInput(ids: \(String(describing: ids)))"}
}

extension BatchGetCustomDataIdentifiersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ids = "ids"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for __listof__string0 in ids {
                try idsContainer.encode(__listof__string0)
            }
        }
    }
}

public struct BatchGetCustomDataIdentifiersInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetCustomDataIdentifiersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetCustomDataIdentifiersInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetCustomDataIdentifiersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetCustomDataIdentifiersInput>
    public typealias MOutput = OperationOutput<BatchGetCustomDataIdentifiersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetCustomDataIdentifiersOutputError>
}

public struct BatchGetCustomDataIdentifiersInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetCustomDataIdentifiersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetCustomDataIdentifiersInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetCustomDataIdentifiersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetCustomDataIdentifiersInput>
    public typealias MOutput = OperationOutput<BatchGetCustomDataIdentifiersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetCustomDataIdentifiersOutputError>
}

public struct BatchGetCustomDataIdentifiersInput: Equatable {
    /// <p>An array of strings that lists the unique identifiers for the custom data identifiers to retrieve information about.</p>
    public let ids: [String]?

    public init (
        ids: [String]? = nil
    )
    {
        self.ids = ids
    }
}

struct BatchGetCustomDataIdentifiersInputBody: Equatable {
    public let ids: [String]?
}

extension BatchGetCustomDataIdentifiersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ids = "ids"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension BatchGetCustomDataIdentifiersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetCustomDataIdentifiersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetCustomDataIdentifiersOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetCustomDataIdentifiersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetCustomDataIdentifiersOutputResponse(customDataIdentifiers: \(String(describing: customDataIdentifiers)), notFoundIdentifierIds: \(String(describing: notFoundIdentifierIds)))"}
}

extension BatchGetCustomDataIdentifiersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetCustomDataIdentifiersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customDataIdentifiers = output.customDataIdentifiers
            self.notFoundIdentifierIds = output.notFoundIdentifierIds
        } else {
            self.customDataIdentifiers = nil
            self.notFoundIdentifierIds = nil
        }
    }
}

public struct BatchGetCustomDataIdentifiersOutputResponse: Equatable {
    /// <p>An array of objects, one for each custom data identifier that meets the criteria specified in the request.</p>
    public let customDataIdentifiers: [BatchGetCustomDataIdentifierSummary]?
    /// <p>An array of identifiers, one for each identifier that was specified in the request, but doesn't correlate to an existing custom data identifier.</p>
    public let notFoundIdentifierIds: [String]?

    public init (
        customDataIdentifiers: [BatchGetCustomDataIdentifierSummary]? = nil,
        notFoundIdentifierIds: [String]? = nil
    )
    {
        self.customDataIdentifiers = customDataIdentifiers
        self.notFoundIdentifierIds = notFoundIdentifierIds
    }
}

struct BatchGetCustomDataIdentifiersOutputResponseBody: Equatable {
    public let customDataIdentifiers: [BatchGetCustomDataIdentifierSummary]?
    public let notFoundIdentifierIds: [String]?
}

extension BatchGetCustomDataIdentifiersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customDataIdentifiers = "customDataIdentifiers"
        case notFoundIdentifierIds = "notFoundIdentifierIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDataIdentifiersContainer = try containerValues.decodeIfPresent([BatchGetCustomDataIdentifierSummary?].self, forKey: .customDataIdentifiers)
        var customDataIdentifiersDecoded0:[BatchGetCustomDataIdentifierSummary]? = nil
        if let customDataIdentifiersContainer = customDataIdentifiersContainer {
            customDataIdentifiersDecoded0 = [BatchGetCustomDataIdentifierSummary]()
            for structure0 in customDataIdentifiersContainer {
                if let structure0 = structure0 {
                    customDataIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        customDataIdentifiers = customDataIdentifiersDecoded0
        let notFoundIdentifierIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notFoundIdentifierIds)
        var notFoundIdentifierIdsDecoded0:[String]? = nil
        if let notFoundIdentifierIdsContainer = notFoundIdentifierIdsContainer {
            notFoundIdentifierIdsDecoded0 = [String]()
            for string0 in notFoundIdentifierIdsContainer {
                if let string0 = string0 {
                    notFoundIdentifierIdsDecoded0?.append(string0)
                }
            }
        }
        notFoundIdentifierIds = notFoundIdentifierIdsDecoded0
    }
}

extension BlockPublicAccess: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockPublicAcls = "blockPublicAcls"
        case blockPublicPolicy = "blockPublicPolicy"
        case ignorePublicAcls = "ignorePublicAcls"
        case restrictPublicBuckets = "restrictPublicBuckets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blockPublicAcls != false {
            try encodeContainer.encode(blockPublicAcls, forKey: .blockPublicAcls)
        }
        if blockPublicPolicy != false {
            try encodeContainer.encode(blockPublicPolicy, forKey: .blockPublicPolicy)
        }
        if ignorePublicAcls != false {
            try encodeContainer.encode(ignorePublicAcls, forKey: .ignorePublicAcls)
        }
        if restrictPublicBuckets != false {
            try encodeContainer.encode(restrictPublicBuckets, forKey: .restrictPublicBuckets)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAclsDecoded = try containerValues.decode(Bool.self, forKey: .blockPublicAcls)
        blockPublicAcls = blockPublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decode(Bool.self, forKey: .blockPublicPolicy)
        blockPublicPolicy = blockPublicPolicyDecoded
        let ignorePublicAclsDecoded = try containerValues.decode(Bool.self, forKey: .ignorePublicAcls)
        ignorePublicAcls = ignorePublicAclsDecoded
        let restrictPublicBucketsDecoded = try containerValues.decode(Bool.self, forKey: .restrictPublicBuckets)
        restrictPublicBuckets = restrictPublicBucketsDecoded
    }
}

extension BlockPublicAccess: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BlockPublicAccess(blockPublicAcls: \(String(describing: blockPublicAcls)), blockPublicPolicy: \(String(describing: blockPublicPolicy)), ignorePublicAcls: \(String(describing: ignorePublicAcls)), restrictPublicBuckets: \(String(describing: restrictPublicBuckets)))"}
}

/// <p>Provides information about the block public access settings for an S3 bucket. These settings can apply to a bucket at the account level or bucket level. For detailed information about each setting, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-control-block-public-access.html">Blocking public access to your Amazon S3 storage</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
public struct BlockPublicAccess: Equatable {
    /// <p>Specifies whether Amazon S3 blocks public access control lists (ACLs) for the bucket and objects in the bucket.</p>
    public let blockPublicAcls: Bool
    /// <p>Specifies whether Amazon S3 blocks public bucket policies for the bucket.</p>
    public let blockPublicPolicy: Bool
    /// <p>Specifies whether Amazon S3 ignores public ACLs for the bucket and objects in the bucket.</p>
    public let ignorePublicAcls: Bool
    /// <p>Specifies whether Amazon S3 restricts public bucket policies for the bucket.</p>
    public let restrictPublicBuckets: Bool

    public init (
        blockPublicAcls: Bool = false,
        blockPublicPolicy: Bool = false,
        ignorePublicAcls: Bool = false,
        restrictPublicBuckets: Bool = false
    )
    {
        self.blockPublicAcls = blockPublicAcls
        self.blockPublicPolicy = blockPublicPolicy
        self.ignorePublicAcls = ignorePublicAcls
        self.restrictPublicBuckets = restrictPublicBuckets
    }
}

extension BucketCountByEffectivePermission: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case publiclyAccessible = "publiclyAccessible"
        case publiclyReadable = "publiclyReadable"
        case publiclyWritable = "publiclyWritable"
        case unknown = "unknown"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if publiclyAccessible != 0 {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if publiclyReadable != 0 {
            try encodeContainer.encode(publiclyReadable, forKey: .publiclyReadable)
        }
        if publiclyWritable != 0 {
            try encodeContainer.encode(publiclyWritable, forKey: .publiclyWritable)
        }
        if unknown != 0 {
            try encodeContainer.encode(unknown, forKey: .unknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publiclyAccessibleDecoded = try containerValues.decode(Int.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let publiclyReadableDecoded = try containerValues.decode(Int.self, forKey: .publiclyReadable)
        publiclyReadable = publiclyReadableDecoded
        let publiclyWritableDecoded = try containerValues.decode(Int.self, forKey: .publiclyWritable)
        publiclyWritable = publiclyWritableDecoded
        let unknownDecoded = try containerValues.decode(Int.self, forKey: .unknown)
        unknown = unknownDecoded
    }
}

extension BucketCountByEffectivePermission: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketCountByEffectivePermission(publiclyAccessible: \(String(describing: publiclyAccessible)), publiclyReadable: \(String(describing: publiclyReadable)), publiclyWritable: \(String(describing: publiclyWritable)), unknown: \(String(describing: unknown)))"}
}

/// <p>Provides information about the number of S3 buckets that are publicly accessible based on a combination of permissions settings for each bucket.</p>
public struct BucketCountByEffectivePermission: Equatable {
    /// <p>The total number of buckets that allow the general public to have read or write access to the bucket.</p>
    public let publiclyAccessible: Int
    /// <p>The total number of buckets that allow the general public to have read access to the bucket.</p>
    public let publiclyReadable: Int
    /// <p>The total number of buckets that allow the general public to have write access to the bucket.</p>
    public let publiclyWritable: Int
    /// <p>The total number of buckets that Amazon Macie wasn't able to evaluate permissions settings for. Macie can't determine whether these buckets are publicly accessible.</p>
    public let unknown: Int

    public init (
        publiclyAccessible: Int = 0,
        publiclyReadable: Int = 0,
        publiclyWritable: Int = 0,
        unknown: Int = 0
    )
    {
        self.publiclyAccessible = publiclyAccessible
        self.publiclyReadable = publiclyReadable
        self.publiclyWritable = publiclyWritable
        self.unknown = unknown
    }
}

extension BucketCountByEncryptionType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsManaged = "kmsManaged"
        case s3Managed = "s3Managed"
        case unencrypted = "unencrypted"
        case unknown = "unknown"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if kmsManaged != 0 {
            try encodeContainer.encode(kmsManaged, forKey: .kmsManaged)
        }
        if s3Managed != 0 {
            try encodeContainer.encode(s3Managed, forKey: .s3Managed)
        }
        if unencrypted != 0 {
            try encodeContainer.encode(unencrypted, forKey: .unencrypted)
        }
        if unknown != 0 {
            try encodeContainer.encode(unknown, forKey: .unknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsManagedDecoded = try containerValues.decode(Int.self, forKey: .kmsManaged)
        kmsManaged = kmsManagedDecoded
        let s3ManagedDecoded = try containerValues.decode(Int.self, forKey: .s3Managed)
        s3Managed = s3ManagedDecoded
        let unencryptedDecoded = try containerValues.decode(Int.self, forKey: .unencrypted)
        unencrypted = unencryptedDecoded
        let unknownDecoded = try containerValues.decode(Int.self, forKey: .unknown)
        unknown = unknownDecoded
    }
}

extension BucketCountByEncryptionType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketCountByEncryptionType(kmsManaged: \(String(describing: kmsManaged)), s3Managed: \(String(describing: s3Managed)), unencrypted: \(String(describing: unencrypted)), unknown: \(String(describing: unknown)))"}
}

/// <p>Provides information about the number of S3 buckets that use certain types of server-side encryption by default or don't encrypt new objects by default. For detailed information about these settings, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucket-encryption.html">Setting default server-side encryption behavior for Amazon S3 buckets</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
public struct BucketCountByEncryptionType: Equatable {
    /// <p>The total number of buckets that use an AWS Key Management Service (AWS KMS) customer master key (CMK) to encrypt new objects by default. These buckets use AWS managed AWS KMS encryption (AWS-KMS) or customer managed AWS KMS encryption (SSE-KMS) by default.</p>
    public let kmsManaged: Int
    /// <p>The total number of buckets that use an Amazon S3 managed key to encrypt new objects by default. These buckets use Amazon S3 managed encryption (SSE-S3) by default.</p>
    public let s3Managed: Int
    /// <p>The total number of buckets that don't encrypt new objects by default. Default encryption is disabled for these buckets.</p>
    public let unencrypted: Int
    /// <p>The total number of buckets that Amazon Macie doesn't have current encryption metadata for. Macie can't provide current data about the default encryption settings for these buckets.</p>
    public let unknown: Int

    public init (
        kmsManaged: Int = 0,
        s3Managed: Int = 0,
        unencrypted: Int = 0,
        unknown: Int = 0
    )
    {
        self.kmsManaged = kmsManaged
        self.s3Managed = s3Managed
        self.unencrypted = unencrypted
        self.unknown = unknown
    }
}

extension BucketCountBySharedAccessType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case external = "external"
        case `internal` = "internal"
        case notShared = "notShared"
        case unknown = "unknown"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if external != 0 {
            try encodeContainer.encode(external, forKey: .external)
        }
        if `internal` != 0 {
            try encodeContainer.encode(`internal`, forKey: .`internal`)
        }
        if notShared != 0 {
            try encodeContainer.encode(notShared, forKey: .notShared)
        }
        if unknown != 0 {
            try encodeContainer.encode(unknown, forKey: .unknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalDecoded = try containerValues.decode(Int.self, forKey: .external)
        external = externalDecoded
        let internalDecoded = try containerValues.decode(Int.self, forKey: .internal)
        `internal` = internalDecoded
        let notSharedDecoded = try containerValues.decode(Int.self, forKey: .notShared)
        notShared = notSharedDecoded
        let unknownDecoded = try containerValues.decode(Int.self, forKey: .unknown)
        unknown = unknownDecoded
    }
}

extension BucketCountBySharedAccessType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketCountBySharedAccessType(external: \(String(describing: external)), internal: \(String(describing: `internal`)), notShared: \(String(describing: notShared)), unknown: \(String(describing: unknown)))"}
}

/// <p>Provides information about the number of S3 buckets that are or aren't shared with other AWS accounts.</p>
public struct BucketCountBySharedAccessType: Equatable {
    /// <p>The total number of buckets that are shared with an AWS account that's part of the same Amazon Macie organization.</p>
    public let `internal`: Int
    /// <p>The total number of buckets that are shared with an AWS account that isn't part of the same Amazon Macie organization.</p>
    public let external: Int
    /// <p>The total number of buckets that aren't shared with other AWS accounts.</p>
    public let notShared: Int
    /// <p>The total number of buckets that Amazon Macie wasn't able to evaluate shared access settings for. Macie can't determine whether these buckets are shared with other AWS accounts.</p>
    public let unknown: Int

    public init (
        `internal`: Int = 0,
        external: Int = 0,
        notShared: Int = 0,
        unknown: Int = 0
    )
    {
        self.`internal` = `internal`
        self.external = external
        self.notShared = notShared
        self.unknown = unknown
    }
}

extension BucketCountPolicyAllowsUnencryptedObjectUploads: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowsUnencryptedObjectUploads = "allowsUnencryptedObjectUploads"
        case deniesUnencryptedObjectUploads = "deniesUnencryptedObjectUploads"
        case unknown = "unknown"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsUnencryptedObjectUploads != 0 {
            try encodeContainer.encode(allowsUnencryptedObjectUploads, forKey: .allowsUnencryptedObjectUploads)
        }
        if deniesUnencryptedObjectUploads != 0 {
            try encodeContainer.encode(deniesUnencryptedObjectUploads, forKey: .deniesUnencryptedObjectUploads)
        }
        if unknown != 0 {
            try encodeContainer.encode(unknown, forKey: .unknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsUnencryptedObjectUploadsDecoded = try containerValues.decode(Int.self, forKey: .allowsUnencryptedObjectUploads)
        allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploadsDecoded
        let deniesUnencryptedObjectUploadsDecoded = try containerValues.decode(Int.self, forKey: .deniesUnencryptedObjectUploads)
        deniesUnencryptedObjectUploads = deniesUnencryptedObjectUploadsDecoded
        let unknownDecoded = try containerValues.decode(Int.self, forKey: .unknown)
        unknown = unknownDecoded
    }
}

extension BucketCountPolicyAllowsUnencryptedObjectUploads: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketCountPolicyAllowsUnencryptedObjectUploads(allowsUnencryptedObjectUploads: \(String(describing: allowsUnencryptedObjectUploads)), deniesUnencryptedObjectUploads: \(String(describing: deniesUnencryptedObjectUploads)), unknown: \(String(describing: unknown)))"}
}

/// <p>Provides information about the number of S3 buckets whose bucket policies do or don't require server-side encryption of objects when objects are uploaded to the buckets.</p>
public struct BucketCountPolicyAllowsUnencryptedObjectUploads: Equatable {
    /// <p>The total number of buckets that don't have a bucket policy or have a bucket policy that doesn't require server-side encryption of new objects. If a bucket policy exists, the policy doesn't require PutObject requests to include the x-amz-server-side-encryption header and it doesn't require the value for that header to be AES256 or aws:kms.</p>
    public let allowsUnencryptedObjectUploads: Int
    /// <p>The total number of buckets whose bucket policies require server-side encryption of new objects. PutObject requests for these buckets must include the x-amz-server-side-encryption header and the value for that header must be AES256 or aws:kms.</p>
    public let deniesUnencryptedObjectUploads: Int
    /// <p>The total number of buckets that Amazon Macie wasn't able to evaluate server-side encryption requirements for. Macie can't determine whether the bucket policies for these buckets require server-side encryption of new objects.</p>
    public let unknown: Int

    public init (
        allowsUnencryptedObjectUploads: Int = 0,
        deniesUnencryptedObjectUploads: Int = 0,
        unknown: Int = 0
    )
    {
        self.allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploads
        self.deniesUnencryptedObjectUploads = deniesUnencryptedObjectUploads
        self.unknown = unknown
    }
}

extension BucketCriteriaAdditionalProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eq = "eq"
        case gt = "gt"
        case gte = "gte"
        case lt = "lt"
        case lte = "lte"
        case neq = "neq"
        case prefix = "prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eq = eq {
            var eqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eq)
            for __listof__string0 in eq {
                try eqContainer.encode(__listof__string0)
            }
        }
        if gt != 0 {
            try encodeContainer.encode(gt, forKey: .gt)
        }
        if gte != 0 {
            try encodeContainer.encode(gte, forKey: .gte)
        }
        if lt != 0 {
            try encodeContainer.encode(lt, forKey: .lt)
        }
        if lte != 0 {
            try encodeContainer.encode(lte, forKey: .lte)
        }
        if let neq = neq {
            var neqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neq)
            for __listof__string0 in neq {
                try neqContainer.encode(__listof__string0)
            }
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eqContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eq)
        var eqDecoded0:[String]? = nil
        if let eqContainer = eqContainer {
            eqDecoded0 = [String]()
            for string0 in eqContainer {
                if let string0 = string0 {
                    eqDecoded0?.append(string0)
                }
            }
        }
        eq = eqDecoded0
        let gtDecoded = try containerValues.decode(Int.self, forKey: .gt)
        gt = gtDecoded
        let gteDecoded = try containerValues.decode(Int.self, forKey: .gte)
        gte = gteDecoded
        let ltDecoded = try containerValues.decode(Int.self, forKey: .lt)
        lt = ltDecoded
        let lteDecoded = try containerValues.decode(Int.self, forKey: .lte)
        lte = lteDecoded
        let neqContainer = try containerValues.decodeIfPresent([String?].self, forKey: .neq)
        var neqDecoded0:[String]? = nil
        if let neqContainer = neqContainer {
            neqDecoded0 = [String]()
            for string0 in neqContainer {
                if let string0 = string0 {
                    neqDecoded0?.append(string0)
                }
            }
        }
        neq = neqDecoded0
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension BucketCriteriaAdditionalProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketCriteriaAdditionalProperties(eq: \(String(describing: eq)), gt: \(String(describing: gt)), gte: \(String(describing: gte)), lt: \(String(describing: lt)), lte: \(String(describing: lte)), neq: \(String(describing: neq)), prefix: \(String(describing: prefix)))"}
}

/// <p>Specifies the operator to use in a property-based condition that filters the results of a query for information about S3 buckets.</p>
public struct BucketCriteriaAdditionalProperties: Equatable {
    /// <p>The value for the property matches (equals) the specified value. If you specify multiple values, Macie uses OR logic to join the values.</p>
    public let eq: [String]?
    /// <p>The value for the property is greater than the specified value.</p>
    public let gt: Int
    /// <p>The value for the property is greater than or equal to the specified value.</p>
    public let gte: Int
    /// <p>The value for the property is less than the specified value.</p>
    public let lt: Int
    /// <p>The value for the property is less than or equal to the specified value.</p>
    public let lte: Int
    /// <p>The value for the property doesn't match (doesn't equal) the specified value. If you specify multiple values, Amazon Macie uses OR logic to join the values.</p>
    public let neq: [String]?
    /// <p>The name of the bucket begins with the specified value.</p>
    public let prefix: String?

    public init (
        eq: [String]? = nil,
        gt: Int = 0,
        gte: Int = 0,
        lt: Int = 0,
        lte: Int = 0,
        neq: [String]? = nil,
        prefix: String? = nil
    )
    {
        self.eq = eq
        self.gt = gt
        self.gte = gte
        self.lt = lt
        self.lte = lte
        self.neq = neq
        self.prefix = prefix
    }
}

extension BucketLevelPermissions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlList = "accessControlList"
        case blockPublicAccess = "blockPublicAccess"
        case bucketPolicy = "bucketPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlList = accessControlList {
            try encodeContainer.encode(accessControlList, forKey: .accessControlList)
        }
        if let blockPublicAccess = blockPublicAccess {
            try encodeContainer.encode(blockPublicAccess, forKey: .blockPublicAccess)
        }
        if let bucketPolicy = bucketPolicy {
            try encodeContainer.encode(bucketPolicy, forKey: .bucketPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlListDecoded = try containerValues.decodeIfPresent(AccessControlList.self, forKey: .accessControlList)
        accessControlList = accessControlListDecoded
        let blockPublicAccessDecoded = try containerValues.decodeIfPresent(BlockPublicAccess.self, forKey: .blockPublicAccess)
        blockPublicAccess = blockPublicAccessDecoded
        let bucketPolicyDecoded = try containerValues.decodeIfPresent(BucketPolicy.self, forKey: .bucketPolicy)
        bucketPolicy = bucketPolicyDecoded
    }
}

extension BucketLevelPermissions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketLevelPermissions(accessControlList: \(String(describing: accessControlList)), blockPublicAccess: \(String(describing: blockPublicAccess)), bucketPolicy: \(String(describing: bucketPolicy)))"}
}

/// <p>Provides information about the bucket-level permissions settings for an S3 bucket.</p>
public struct BucketLevelPermissions: Equatable {
    /// <p>The permissions settings of the access control list (ACL) for the bucket. This value is null if an ACL hasn't been defined for the bucket.</p>
    public let accessControlList: AccessControlList?
    /// <p>The block public access settings for the bucket.</p>
    public let blockPublicAccess: BlockPublicAccess?
    /// <p>The permissions settings of the bucket policy for the bucket. This value is null if a bucket policy hasn't been defined for the bucket.</p>
    public let bucketPolicy: BucketPolicy?

    public init (
        accessControlList: AccessControlList? = nil,
        blockPublicAccess: BlockPublicAccess? = nil,
        bucketPolicy: BucketPolicy? = nil
    )
    {
        self.accessControlList = accessControlList
        self.blockPublicAccess = blockPublicAccess
        self.bucketPolicy = bucketPolicy
    }
}

extension BucketMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case allowsUnencryptedObjectUploads = "allowsUnencryptedObjectUploads"
        case bucketArn = "bucketArn"
        case bucketCreatedAt = "bucketCreatedAt"
        case bucketName = "bucketName"
        case classifiableObjectCount = "classifiableObjectCount"
        case classifiableSizeInBytes = "classifiableSizeInBytes"
        case jobDetails = "jobDetails"
        case lastUpdated = "lastUpdated"
        case objectCount = "objectCount"
        case objectCountByEncryptionType = "objectCountByEncryptionType"
        case publicAccess = "publicAccess"
        case region = "region"
        case replicationDetails = "replicationDetails"
        case serverSideEncryption = "serverSideEncryption"
        case sharedAccess = "sharedAccess"
        case sizeInBytes = "sizeInBytes"
        case sizeInBytesCompressed = "sizeInBytesCompressed"
        case tags = "tags"
        case unclassifiableObjectCount = "unclassifiableObjectCount"
        case unclassifiableObjectSizeInBytes = "unclassifiableObjectSizeInBytes"
        case versioning = "versioning"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploads {
            try encodeContainer.encode(allowsUnencryptedObjectUploads.rawValue, forKey: .allowsUnencryptedObjectUploads)
        }
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let bucketCreatedAt = bucketCreatedAt {
            try encodeContainer.encode(bucketCreatedAt.timeIntervalSince1970, forKey: .bucketCreatedAt)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if classifiableObjectCount != 0 {
            try encodeContainer.encode(classifiableObjectCount, forKey: .classifiableObjectCount)
        }
        if classifiableSizeInBytes != 0 {
            try encodeContainer.encode(classifiableSizeInBytes, forKey: .classifiableSizeInBytes)
        }
        if let jobDetails = jobDetails {
            try encodeContainer.encode(jobDetails, forKey: .jobDetails)
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if objectCount != 0 {
            try encodeContainer.encode(objectCount, forKey: .objectCount)
        }
        if let objectCountByEncryptionType = objectCountByEncryptionType {
            try encodeContainer.encode(objectCountByEncryptionType, forKey: .objectCountByEncryptionType)
        }
        if let publicAccess = publicAccess {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let replicationDetails = replicationDetails {
            try encodeContainer.encode(replicationDetails, forKey: .replicationDetails)
        }
        if let serverSideEncryption = serverSideEncryption {
            try encodeContainer.encode(serverSideEncryption, forKey: .serverSideEncryption)
        }
        if let sharedAccess = sharedAccess {
            try encodeContainer.encode(sharedAccess.rawValue, forKey: .sharedAccess)
        }
        if sizeInBytes != 0 {
            try encodeContainer.encode(sizeInBytes, forKey: .sizeInBytes)
        }
        if sizeInBytesCompressed != 0 {
            try encodeContainer.encode(sizeInBytesCompressed, forKey: .sizeInBytesCompressed)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for __listofkeyvaluepair0 in tags {
                try tagsContainer.encode(__listofkeyvaluepair0)
            }
        }
        if let unclassifiableObjectCount = unclassifiableObjectCount {
            try encodeContainer.encode(unclassifiableObjectCount, forKey: .unclassifiableObjectCount)
        }
        if let unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes {
            try encodeContainer.encode(unclassifiableObjectSizeInBytes, forKey: .unclassifiableObjectSizeInBytes)
        }
        if versioning != false {
            try encodeContainer.encode(versioning, forKey: .versioning)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let allowsUnencryptedObjectUploadsDecoded = try containerValues.decodeIfPresent(AllowsUnencryptedObjectUploads.self, forKey: .allowsUnencryptedObjectUploads)
        allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploadsDecoded
        let bucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let bucketCreatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .bucketCreatedAt)
        bucketCreatedAt = bucketCreatedAtDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let classifiableObjectCountDecoded = try containerValues.decode(Int.self, forKey: .classifiableObjectCount)
        classifiableObjectCount = classifiableObjectCountDecoded
        let classifiableSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .classifiableSizeInBytes)
        classifiableSizeInBytes = classifiableSizeInBytesDecoded
        let jobDetailsDecoded = try containerValues.decodeIfPresent(JobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let objectCountDecoded = try containerValues.decode(Int.self, forKey: .objectCount)
        objectCount = objectCountDecoded
        let objectCountByEncryptionTypeDecoded = try containerValues.decodeIfPresent(ObjectCountByEncryptionType.self, forKey: .objectCountByEncryptionType)
        objectCountByEncryptionType = objectCountByEncryptionTypeDecoded
        let publicAccessDecoded = try containerValues.decodeIfPresent(BucketPublicAccess.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let replicationDetailsDecoded = try containerValues.decodeIfPresent(ReplicationDetails.self, forKey: .replicationDetails)
        replicationDetails = replicationDetailsDecoded
        let serverSideEncryptionDecoded = try containerValues.decodeIfPresent(BucketServerSideEncryption.self, forKey: .serverSideEncryption)
        serverSideEncryption = serverSideEncryptionDecoded
        let sharedAccessDecoded = try containerValues.decodeIfPresent(SharedAccess.self, forKey: .sharedAccess)
        sharedAccess = sharedAccessDecoded
        let sizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let sizeInBytesCompressedDecoded = try containerValues.decode(Int.self, forKey: .sizeInBytesCompressed)
        sizeInBytesCompressed = sizeInBytesCompressedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyValuePair?].self, forKey: .tags)
        var tagsDecoded0:[KeyValuePair]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyValuePair]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let unclassifiableObjectCountDecoded = try containerValues.decodeIfPresent(ObjectLevelStatistics.self, forKey: .unclassifiableObjectCount)
        unclassifiableObjectCount = unclassifiableObjectCountDecoded
        let unclassifiableObjectSizeInBytesDecoded = try containerValues.decodeIfPresent(ObjectLevelStatistics.self, forKey: .unclassifiableObjectSizeInBytes)
        unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytesDecoded
        let versioningDecoded = try containerValues.decode(Bool.self, forKey: .versioning)
        versioning = versioningDecoded
    }
}

extension BucketMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketMetadata(accountId: \(String(describing: accountId)), allowsUnencryptedObjectUploads: \(String(describing: allowsUnencryptedObjectUploads)), bucketArn: \(String(describing: bucketArn)), bucketCreatedAt: \(String(describing: bucketCreatedAt)), bucketName: \(String(describing: bucketName)), classifiableObjectCount: \(String(describing: classifiableObjectCount)), classifiableSizeInBytes: \(String(describing: classifiableSizeInBytes)), jobDetails: \(String(describing: jobDetails)), lastUpdated: \(String(describing: lastUpdated)), objectCount: \(String(describing: objectCount)), objectCountByEncryptionType: \(String(describing: objectCountByEncryptionType)), publicAccess: \(String(describing: publicAccess)), region: \(String(describing: region)), replicationDetails: \(String(describing: replicationDetails)), serverSideEncryption: \(String(describing: serverSideEncryption)), sharedAccess: \(String(describing: sharedAccess)), sizeInBytes: \(String(describing: sizeInBytes)), sizeInBytesCompressed: \(String(describing: sizeInBytesCompressed)), tags: \(String(describing: tags)), unclassifiableObjectCount: \(String(describing: unclassifiableObjectCount)), unclassifiableObjectSizeInBytes: \(String(describing: unclassifiableObjectSizeInBytes)), versioning: \(String(describing: versioning)))"}
}

/// <p>Provides information about an S3 bucket that Amazon Macie monitors and analyzes.</p>
public struct BucketMetadata: Equatable {
    /// <p>The unique identifier for the AWS account that owns the bucket.</p>
    public let accountId: String?
    /// <p>Specifies whether the bucket policy for the bucket requires server-side encryption of objects when objects are uploaded to the bucket. Possible values are:</p> <ul><li><p>FALSE - The bucket policy requires server-side encryption of new objects. PutObject requests must include the x-amz-server-side-encryption header and the value for that header must be AES256 or aws:kms.</p></li> <li><p>TRUE - The bucket doesn't have a bucket policy or it has a bucket policy that doesn't require server-side encryption of new objects. If a bucket policy exists, it doesn't require PutObject requests to include the x-amz-server-side-encryption header and it doesn't require the value for that header to be AES256 or aws:kms.</p></li> <li><p>UNKNOWN - Amazon Macie can't determine whether the bucket policy requires server-side encryption of new objects.</p></li></ul>
    public let allowsUnencryptedObjectUploads: AllowsUnencryptedObjectUploads?
    /// <p>The Amazon Resource Name (ARN) of the bucket.</p>
    public let bucketArn: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the bucket was created.</p>
    public let bucketCreatedAt: Date?
    /// <p>The name of the bucket.</p>
    public let bucketName: String?
    /// <p>The total number of objects that Amazon Macie can analyze in the bucket. These objects use a supported storage class and have a file name extension for a supported file or storage format.</p>
    public let classifiableObjectCount: Int
    /// <p>The total storage size, in bytes, of the objects that Amazon Macie can analyze in the bucket. These objects use a supported storage class and have a file name extension for a supported file or storage format.</p> <p>If versioning is enabled for the bucket, Macie calculates this value based on the size of the latest version of each applicable object in the bucket. This value doesn't reflect the storage size of all versions of each applicable object in the bucket.</p>
    public let classifiableSizeInBytes: Int
    /// <p>Specifies whether any one-time or recurring classification jobs are configured to analyze data in the bucket, and, if so, the details of the job that ran most recently.</p>
    public let jobDetails: JobDetails?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when Amazon Macie most recently retrieved both bucket and object metadata from Amazon S3 for the bucket.</p>
    public let lastUpdated: Date?
    /// <p>The total number of objects in the bucket.</p>
    public let objectCount: Int
    /// <p>The total number of objects that are in the bucket, grouped by server-side encryption type. This includes a grouping that reports the total number of objects that aren't encrypted or use client-side encryption.</p>
    public let objectCountByEncryptionType: ObjectCountByEncryptionType?
    /// <p>Specifies whether the bucket is publicly accessible due to the combination of permissions settings that apply to the bucket, and provides information about those settings.</p>
    public let publicAccess: BucketPublicAccess?
    /// <p>The AWS Region that hosts the bucket.</p>
    public let region: String?
    /// <p>Specifies whether the bucket is configured to replicate one or more objects to buckets for other AWS accounts and, if so, which accounts.</p>
    public let replicationDetails: ReplicationDetails?
    /// <p>Specifies whether the bucket encrypts new objects by default and, if so, the type of server-side encryption that's used.</p>
    public let serverSideEncryption: BucketServerSideEncryption?
    /// <p>Specifies whether the bucket is shared with another AWS account. Possible values are:</p> <ul><li><p>EXTERNAL - The bucket is shared with an AWS account that isn't part of the same Amazon Macie organization.</p></li> <li><p>INTERNAL - The bucket is shared with an AWS account that's part of the same Amazon Macie organization.</p></li> <li><p>NOT_SHARED - The bucket isn't shared with other AWS accounts.</p></li> <li><p>UNKNOWN - Amazon Macie wasn't able to evaluate the shared access settings for the bucket.</p></li></ul>
    public let sharedAccess: SharedAccess?
    /// <p>The total storage size, in bytes, of the bucket.</p> <p>If versioning is enabled for the bucket, Amazon Macie calculates this value based on the size of the latest version of each object in the bucket. This value doesn't reflect the storage size of all versions of each object in the bucket.</p>
    public let sizeInBytes: Int
    /// <p>The total storage size, in bytes, of the objects that are compressed (.gz, .gzip, .zip) files in the bucket.</p> <p>If versioning is enabled for the bucket, Macie calculates this value based on the size of the latest version of each applicable object in the bucket. This value doesn't reflect the storage size of all versions of each applicable object in the bucket.</p>
    public let sizeInBytesCompressed: Int
    /// <p>An array that specifies the tags (keys and values) that are associated with the bucket.</p>
    public let tags: [KeyValuePair]?
    /// <p>The total number of objects that Amazon Macie can't analyze in the bucket. These objects don't use a supported storage class or don't have a file name extension for a supported file or storage format.</p>
    public let unclassifiableObjectCount: ObjectLevelStatistics?
    /// <p>The total storage size, in bytes, of the objects that Amazon Macie can't analyze in the bucket. These objects don't use a supported storage class or don't have a file name extension for a supported file or storage format.</p>
    public let unclassifiableObjectSizeInBytes: ObjectLevelStatistics?
    /// <p>Specifies whether versioning is enabled for the bucket.</p>
    public let versioning: Bool

    public init (
        accountId: String? = nil,
        allowsUnencryptedObjectUploads: AllowsUnencryptedObjectUploads? = nil,
        bucketArn: String? = nil,
        bucketCreatedAt: Date? = nil,
        bucketName: String? = nil,
        classifiableObjectCount: Int = 0,
        classifiableSizeInBytes: Int = 0,
        jobDetails: JobDetails? = nil,
        lastUpdated: Date? = nil,
        objectCount: Int = 0,
        objectCountByEncryptionType: ObjectCountByEncryptionType? = nil,
        publicAccess: BucketPublicAccess? = nil,
        region: String? = nil,
        replicationDetails: ReplicationDetails? = nil,
        serverSideEncryption: BucketServerSideEncryption? = nil,
        sharedAccess: SharedAccess? = nil,
        sizeInBytes: Int = 0,
        sizeInBytesCompressed: Int = 0,
        tags: [KeyValuePair]? = nil,
        unclassifiableObjectCount: ObjectLevelStatistics? = nil,
        unclassifiableObjectSizeInBytes: ObjectLevelStatistics? = nil,
        versioning: Bool = false
    )
    {
        self.accountId = accountId
        self.allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploads
        self.bucketArn = bucketArn
        self.bucketCreatedAt = bucketCreatedAt
        self.bucketName = bucketName
        self.classifiableObjectCount = classifiableObjectCount
        self.classifiableSizeInBytes = classifiableSizeInBytes
        self.jobDetails = jobDetails
        self.lastUpdated = lastUpdated
        self.objectCount = objectCount
        self.objectCountByEncryptionType = objectCountByEncryptionType
        self.publicAccess = publicAccess
        self.region = region
        self.replicationDetails = replicationDetails
        self.serverSideEncryption = serverSideEncryption
        self.sharedAccess = sharedAccess
        self.sizeInBytes = sizeInBytes
        self.sizeInBytesCompressed = sizeInBytesCompressed
        self.tags = tags
        self.unclassifiableObjectCount = unclassifiableObjectCount
        self.unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes
        self.versioning = versioning
    }
}

extension BucketPermissionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountLevelPermissions = "accountLevelPermissions"
        case bucketLevelPermissions = "bucketLevelPermissions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountLevelPermissions = accountLevelPermissions {
            try encodeContainer.encode(accountLevelPermissions, forKey: .accountLevelPermissions)
        }
        if let bucketLevelPermissions = bucketLevelPermissions {
            try encodeContainer.encode(bucketLevelPermissions, forKey: .bucketLevelPermissions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountLevelPermissionsDecoded = try containerValues.decodeIfPresent(AccountLevelPermissions.self, forKey: .accountLevelPermissions)
        accountLevelPermissions = accountLevelPermissionsDecoded
        let bucketLevelPermissionsDecoded = try containerValues.decodeIfPresent(BucketLevelPermissions.self, forKey: .bucketLevelPermissions)
        bucketLevelPermissions = bucketLevelPermissionsDecoded
    }
}

extension BucketPermissionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketPermissionConfiguration(accountLevelPermissions: \(String(describing: accountLevelPermissions)), bucketLevelPermissions: \(String(describing: bucketLevelPermissions)))"}
}

/// <p>Provides information about the account-level and bucket-level permissions settings for an S3 bucket.</p>
public struct BucketPermissionConfiguration: Equatable {
    /// <p>The account-level permissions settings that apply to the bucket.</p>
    public let accountLevelPermissions: AccountLevelPermissions?
    /// <p>The bucket-level permissions settings for the bucket.</p>
    public let bucketLevelPermissions: BucketLevelPermissions?

    public init (
        accountLevelPermissions: AccountLevelPermissions? = nil,
        bucketLevelPermissions: BucketLevelPermissions? = nil
    )
    {
        self.accountLevelPermissions = accountLevelPermissions
        self.bucketLevelPermissions = bucketLevelPermissions
    }
}

extension BucketPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowsPublicReadAccess = "allowsPublicReadAccess"
        case allowsPublicWriteAccess = "allowsPublicWriteAccess"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsPublicReadAccess != false {
            try encodeContainer.encode(allowsPublicReadAccess, forKey: .allowsPublicReadAccess)
        }
        if allowsPublicWriteAccess != false {
            try encodeContainer.encode(allowsPublicWriteAccess, forKey: .allowsPublicWriteAccess)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsPublicReadAccessDecoded = try containerValues.decode(Bool.self, forKey: .allowsPublicReadAccess)
        allowsPublicReadAccess = allowsPublicReadAccessDecoded
        let allowsPublicWriteAccessDecoded = try containerValues.decode(Bool.self, forKey: .allowsPublicWriteAccess)
        allowsPublicWriteAccess = allowsPublicWriteAccessDecoded
    }
}

extension BucketPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketPolicy(allowsPublicReadAccess: \(String(describing: allowsPublicReadAccess)), allowsPublicWriteAccess: \(String(describing: allowsPublicWriteAccess)))"}
}

/// <p>Provides information about the permissions settings of the bucket policy for an S3 bucket.</p>
public struct BucketPolicy: Equatable {
    /// <p>Specifies whether the bucket policy allows the general public to have read access to the bucket.</p>
    public let allowsPublicReadAccess: Bool
    /// <p>Specifies whether the bucket policy allows the general public to have write access to the bucket.</p>
    public let allowsPublicWriteAccess: Bool

    public init (
        allowsPublicReadAccess: Bool = false,
        allowsPublicWriteAccess: Bool = false
    )
    {
        self.allowsPublicReadAccess = allowsPublicReadAccess
        self.allowsPublicWriteAccess = allowsPublicWriteAccess
    }
}

extension BucketPublicAccess: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case effectivePermission = "effectivePermission"
        case permissionConfiguration = "permissionConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectivePermission = effectivePermission {
            try encodeContainer.encode(effectivePermission.rawValue, forKey: .effectivePermission)
        }
        if let permissionConfiguration = permissionConfiguration {
            try encodeContainer.encode(permissionConfiguration, forKey: .permissionConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectivePermissionDecoded = try containerValues.decodeIfPresent(EffectivePermission.self, forKey: .effectivePermission)
        effectivePermission = effectivePermissionDecoded
        let permissionConfigurationDecoded = try containerValues.decodeIfPresent(BucketPermissionConfiguration.self, forKey: .permissionConfiguration)
        permissionConfiguration = permissionConfigurationDecoded
    }
}

extension BucketPublicAccess: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketPublicAccess(effectivePermission: \(String(describing: effectivePermission)), permissionConfiguration: \(String(describing: permissionConfiguration)))"}
}

/// <p>Provides information about the permissions settings that determine whether an S3 bucket is publicly accessible.</p>
public struct BucketPublicAccess: Equatable {
    /// <p>Specifies whether the bucket is publicly accessible due to the combination of permissions settings that apply to the bucket. Possible values are:</p> <ul><li><p>NOT_PUBLIC - The bucket isn't publicly accessible.</p></li> <li><p>PUBLIC - The bucket is publicly accessible.</p></li> <li><p>UNKNOWN - Amazon Macie can't determine whether the bucket is publicly accessible.</p></li></ul>
    public let effectivePermission: EffectivePermission?
    /// <p>The account-level and bucket-level permissions settings for the bucket.</p>
    public let permissionConfiguration: BucketPermissionConfiguration?

    public init (
        effectivePermission: EffectivePermission? = nil,
        permissionConfiguration: BucketPermissionConfiguration? = nil
    )
    {
        self.effectivePermission = effectivePermission
        self.permissionConfiguration = permissionConfiguration
    }
}

extension BucketServerSideEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsMasterKeyId = "kmsMasterKeyId"
        case type = "type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsMasterKeyId = kmsMasterKeyId {
            try encodeContainer.encode(kmsMasterKeyId, forKey: .kmsMasterKeyId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsMasterKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsMasterKeyId)
        kmsMasterKeyId = kmsMasterKeyIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension BucketServerSideEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketServerSideEncryption(kmsMasterKeyId: \(String(describing: kmsMasterKeyId)), type: \(String(describing: type)))"}
}

/// <p>Provides information about the default server-side encryption settings for an S3 bucket. For detailed information about these settings, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucket-encryption.html">Setting default server-side encryption behavior for Amazon S3 buckets</a> in the <i>Amazon Simple Storage Service User Guide</i>.</p>
public struct BucketServerSideEncryption: Equatable {
    /// <p>The Amazon Resource Name (ARN) or unique identifier (key ID) for the AWS Key Management Service (AWS KMS) customer master key (CMK) that's used by default to encrypt objects that are added to the bucket. This value is null if the bucket uses an Amazon S3 managed key to encrypt new objects or the bucket doesn't encrypt new objects by default.</p>
    public let kmsMasterKeyId: String?
    /// <p>The type of server-side encryption that's used by default when storing new objects in the bucket. Possible values are:</p> <ul><li><p>AES256 - New objects are encrypted with an Amazon S3 managed key and use Amazon S3 managed encryption (SSE-S3).</p></li> <li><p>aws:kms - New objects are encrypted with an AWS KMS CMK, specified by the kmsMasterKeyId property, and use AWS managed AWS KMS encryption (AWS-KMS) or customer managed AWS KMS encryption (SSE-KMS).</p></li> <li><p>NONE - New objects aren't encrypted by default. Default encryption is disabled for the bucket.</p></li></ul>
    public let type: `Type`?

    public init (
        kmsMasterKeyId: String? = nil,
        type: `Type`? = nil
    )
    {
        self.kmsMasterKeyId = kmsMasterKeyId
        self.type = type
    }
}

extension BucketSortCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let orderBy = orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension BucketSortCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketSortCriteria(attributeName: \(String(describing: attributeName)), orderBy: \(String(describing: orderBy)))"}
}

/// <p>Specifies criteria for sorting the results of a query for information about S3 buckets.</p>
public struct BucketSortCriteria: Equatable {
    /// <p>The name of the bucket property to sort the results by. This value can be one of the following properties that Amazon Macie defines as bucket metadata: accountId, bucketName, classifiableObjectCount, classifiableSizeInBytes, objectCount, or sizeInBytes.</p>
    public let attributeName: String?
    /// <p>The sort order to apply to the results, based on the value specified by the attributeName property. Valid values are: ASC, sort the results in ascending order; and, DESC, sort the results in descending order.</p>
    public let orderBy: OrderBy?

    public init (
        attributeName: String? = nil,
        orderBy: OrderBy? = nil
    )
    {
        self.attributeName = attributeName
        self.orderBy = orderBy
    }
}

extension Cell: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cellReference = "cellReference"
        case column = "column"
        case columnName = "columnName"
        case row = "row"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellReference = cellReference {
            try encodeContainer.encode(cellReference, forKey: .cellReference)
        }
        if column != 0 {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if row != 0 {
            try encodeContainer.encode(row, forKey: .row)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cellReference)
        cellReference = cellReferenceDecoded
        let columnDecoded = try containerValues.decode(Int.self, forKey: .column)
        column = columnDecoded
        let columnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let rowDecoded = try containerValues.decode(Int.self, forKey: .row)
        row = rowDecoded
    }
}

extension Cell: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Cell(cellReference: \(String(describing: cellReference)), column: \(String(describing: column)), columnName: \(String(describing: columnName)), row: \(String(describing: row)))"}
}

/// <p>Specifies the location of an occurrence of sensitive data in a Microsoft Excel workbook, CSV file, or TSV file.</p>
public struct Cell: Equatable {
    /// <p>The location of the cell, as an absolute cell reference, that contains the data. For example, Sheet2!C5 for cell C5 on Sheet2 in a Microsoft Excel workbook. This value is null for CSV and TSV files.</p>
    public let cellReference: String?
    /// <p>The column number of the column that contains the data. For a Microsoft Excel workbook, this value correlates to the alphabetical character(s) for a column identifier. For example, 1 for column A, 2 for column B, and so on.</p>
    public let column: Int
    /// <p>The name of the column that contains the data, if available. This value is also null if Amazon Macie detects sensitive data in the name of any column in the file.</p>
    public let columnName: String?
    /// <p>The row number of the row that contains the data.</p>
    public let row: Int

    public init (
        cellReference: String? = nil,
        column: Int = 0,
        columnName: String? = nil,
        row: Int = 0
    )
    {
        self.cellReference = cellReference
        self.column = column
        self.columnName = columnName
        self.row = row
    }
}

extension ClassificationDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detailedResultsLocation = "detailedResultsLocation"
        case jobArn = "jobArn"
        case jobId = "jobId"
        case result = "result"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailedResultsLocation = detailedResultsLocation {
            try encodeContainer.encode(detailedResultsLocation, forKey: .detailedResultsLocation)
        }
        if let jobArn = jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let result = result {
            try encodeContainer.encode(result, forKey: .result)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedResultsLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detailedResultsLocation)
        detailedResultsLocation = detailedResultsLocationDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let resultDecoded = try containerValues.decodeIfPresent(ClassificationResult.self, forKey: .result)
        result = resultDecoded
    }
}

extension ClassificationDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClassificationDetails(detailedResultsLocation: \(String(describing: detailedResultsLocation)), jobArn: \(String(describing: jobArn)), jobId: \(String(describing: jobId)), result: \(String(describing: result)))"}
}

/// <p>Provides information about a sensitive data finding, including the classification job that produced the finding.</p>
public struct ClassificationDetails: Equatable {
    /// <p>The path to the folder or file (in Amazon S3) that contains the corresponding sensitive data discovery result for the finding. If a finding applies to a large archive or compressed file, this value is the path to a folder. Otherwise, this value is the path to a file.</p>
    public let detailedResultsLocation: String?
    /// <p>The Amazon Resource Name (ARN) of the classification job that produced the finding.</p>
    public let jobArn: String?
    /// <p>The unique identifier for the classification job that produced the finding.</p>
    public let jobId: String?
    /// <p>The status and other details for the finding.</p>
    public let result: ClassificationResult?

    public init (
        detailedResultsLocation: String? = nil,
        jobArn: String? = nil,
        jobId: String? = nil,
        result: ClassificationResult? = nil
    )
    {
        self.detailedResultsLocation = detailedResultsLocation
        self.jobArn = jobArn
        self.jobId = jobId
        self.result = result
    }
}

extension ClassificationExportConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Destination = "s3Destination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationDecoded = try containerValues.decodeIfPresent(S3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

extension ClassificationExportConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClassificationExportConfiguration(s3Destination: \(String(describing: s3Destination)))"}
}

/// <p>Specifies where to store data classification results, and the encryption settings to use when storing results in that location. Currently, you can store classification results only in an S3 bucket.</p>
public struct ClassificationExportConfiguration: Equatable {
    /// <p>The S3 bucket to store data classification results in, and the encryption settings to use when storing results in that bucket.</p>
    public let s3Destination: S3Destination?

    public init (
        s3Destination: S3Destination? = nil
    )
    {
        self.s3Destination = s3Destination
    }
}

extension ClassificationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalOccurrences = "additionalOccurrences"
        case customDataIdentifiers = "customDataIdentifiers"
        case mimeType = "mimeType"
        case sensitiveData = "sensitiveData"
        case sizeClassified = "sizeClassified"
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if additionalOccurrences != false {
            try encodeContainer.encode(additionalOccurrences, forKey: .additionalOccurrences)
        }
        if let customDataIdentifiers = customDataIdentifiers {
            try encodeContainer.encode(customDataIdentifiers, forKey: .customDataIdentifiers)
        }
        if let mimeType = mimeType {
            try encodeContainer.encode(mimeType, forKey: .mimeType)
        }
        if let sensitiveData = sensitiveData {
            var sensitiveDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sensitiveData)
            for sensitivedata0 in sensitiveData {
                try sensitiveDataContainer.encode(sensitivedata0)
            }
        }
        if sizeClassified != 0 {
            try encodeContainer.encode(sizeClassified, forKey: .sizeClassified)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalOccurrencesDecoded = try containerValues.decode(Bool.self, forKey: .additionalOccurrences)
        additionalOccurrences = additionalOccurrencesDecoded
        let customDataIdentifiersDecoded = try containerValues.decodeIfPresent(CustomDataIdentifiers.self, forKey: .customDataIdentifiers)
        customDataIdentifiers = customDataIdentifiersDecoded
        let mimeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mimeType)
        mimeType = mimeTypeDecoded
        let sensitiveDataContainer = try containerValues.decodeIfPresent([SensitiveDataItem?].self, forKey: .sensitiveData)
        var sensitiveDataDecoded0:[SensitiveDataItem]? = nil
        if let sensitiveDataContainer = sensitiveDataContainer {
            sensitiveDataDecoded0 = [SensitiveDataItem]()
            for structure0 in sensitiveDataContainer {
                if let structure0 = structure0 {
                    sensitiveDataDecoded0?.append(structure0)
                }
            }
        }
        sensitiveData = sensitiveDataDecoded0
        let sizeClassifiedDecoded = try containerValues.decode(Int.self, forKey: .sizeClassified)
        sizeClassified = sizeClassifiedDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ClassificationResultStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ClassificationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClassificationResult(additionalOccurrences: \(String(describing: additionalOccurrences)), customDataIdentifiers: \(String(describing: customDataIdentifiers)), mimeType: \(String(describing: mimeType)), sensitiveData: \(String(describing: sensitiveData)), sizeClassified: \(String(describing: sizeClassified)), status: \(String(describing: status)))"}
}

/// <p>Provides the details of a sensitive data finding, including the types, number of occurrences, and locations of the sensitive data that was detected.</p>
public struct ClassificationResult: Equatable {
    /// <p>Specifies whether Amazon Macie detected additional occurrences of sensitive data in the S3 object. A finding includes location data for a maximum of 15 occurrences of sensitive data.</p> <p>This value can help you determine whether to investigate additional occurrences of sensitive data in an object. You can do this by referring to the corresponding sensitive data discovery result for the finding (ClassificationDetails.detailedResultsLocation).</p>
    public let additionalOccurrences: Bool
    /// <p>The custom data identifiers that detected the sensitive data and the number of occurrences of the data that they detected.</p>
    public let customDataIdentifiers: CustomDataIdentifiers?
    /// <p>The type of content, as a MIME type, that the finding applies to. For example, application/gzip, for a GNU Gzip compressed archive file, or application/pdf, for an Adobe Portable Document Format file.</p>
    public let mimeType: String?
    /// <p>The category, types, and number of occurrences of the sensitive data that produced the finding.</p>
    public let sensitiveData: [SensitiveDataItem]?
    /// <p>The total size, in bytes, of the data that the finding applies to.</p>
    public let sizeClassified: Int
    /// <p>The status of the finding.</p>
    public let status: ClassificationResultStatus?

    public init (
        additionalOccurrences: Bool = false,
        customDataIdentifiers: CustomDataIdentifiers? = nil,
        mimeType: String? = nil,
        sensitiveData: [SensitiveDataItem]? = nil,
        sizeClassified: Int = 0,
        status: ClassificationResultStatus? = nil
    )
    {
        self.additionalOccurrences = additionalOccurrences
        self.customDataIdentifiers = customDataIdentifiers
        self.mimeType = mimeType
        self.sensitiveData = sensitiveData
        self.sizeClassified = sizeClassified
        self.status = status
    }
}

extension ClassificationResultStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "code"
        case reason = "reason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ClassificationResultStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClassificationResultStatus(code: \(String(describing: code)), reason: \(String(describing: reason)))"}
}

/// <p>Provides information about the status of a sensitive data finding.</p>
public struct ClassificationResultStatus: Equatable {
    /// <p>The status of the finding. Possible values are:</p> <ul><li><p>COMPLETE - Amazon Macie successfully completed its analysis of the object that the finding applies to.</p></li> <li><p>PARTIAL - Macie analyzed only a subset of the data in the object that the finding applies to. For example, the object is an archive file that contains files in an unsupported format.</p></li> <li><p>SKIPPED - Macie wasn't able to analyze the object that the finding applies to. For example, the object is a malformed file or a file that uses an unsupported format.</p></li></ul>
    public let code: String?
    /// <p>A brief description of the status of the finding. Amazon Macie uses this value to notify you of any errors, warnings, or considerations that might impact your analysis of the finding.</p>
    public let reason: String?

    public init (
        code: String? = nil,
        reason: String? = nil
    )
    {
        self.code = code
        self.reason = reason
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an error that occurred due to a versioning conflict for a specified resource.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The explanation of the error that occurred.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateClassificationJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateClassificationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClassificationJobInput>
    public typealias MOutput = OperationOutput<CreateClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClassificationJobOutputError>
}

extension CreateClassificationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClassificationJobInput(clientToken: \(String(describing: clientToken)), customDataIdentifierIds: \(String(describing: customDataIdentifierIds)), description: \(String(describing: description)), initialRun: \(String(describing: initialRun)), jobType: \(String(describing: jobType)), name: \(String(describing: name)), s3JobDefinition: \(String(describing: s3JobDefinition)), samplingPercentage: \(String(describing: samplingPercentage)), scheduleFrequency: \(String(describing: scheduleFrequency)), tags: \(String(describing: tags)))"}
}

extension CreateClassificationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case customDataIdentifierIds = "customDataIdentifierIds"
        case description = "description"
        case initialRun = "initialRun"
        case jobType = "jobType"
        case name = "name"
        case s3JobDefinition = "s3JobDefinition"
        case samplingPercentage = "samplingPercentage"
        case scheduleFrequency = "scheduleFrequency"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customDataIdentifierIds = customDataIdentifierIds {
            var customDataIdentifierIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customDataIdentifierIds)
            for __listof__string0 in customDataIdentifierIds {
                try customDataIdentifierIdsContainer.encode(__listof__string0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if initialRun != false {
            try encodeContainer.encode(initialRun, forKey: .initialRun)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3JobDefinition = s3JobDefinition {
            try encodeContainer.encode(s3JobDefinition, forKey: .s3JobDefinition)
        }
        if samplingPercentage != 0 {
            try encodeContainer.encode(samplingPercentage, forKey: .samplingPercentage)
        }
        if let scheduleFrequency = scheduleFrequency {
            try encodeContainer.encode(scheduleFrequency, forKey: .scheduleFrequency)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateClassificationJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateClassificationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClassificationJobInput>
    public typealias MOutput = OperationOutput<CreateClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClassificationJobOutputError>
}

public struct CreateClassificationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateClassificationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClassificationJobInput>
    public typealias MOutput = OperationOutput<CreateClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClassificationJobOutputError>
}

public struct CreateClassificationJobInput: Equatable {
    /// <p>A unique, case-sensitive token that you provide to ensure the idempotency of the request.</p>
    public var clientToken: String?
    /// <p>The custom data identifiers to use for data analysis and classification.</p>
    public let customDataIdentifierIds: [String]?
    /// <p>A custom description of the job. The description can contain as many as 200 characters.</p>
    public let description: String?
    /// <p>Specifies whether to analyze all existing, eligible objects immediately after the job is created.</p>
    public let initialRun: Bool
    /// <p>The schedule for running the job. Valid values are:</p> <ul><li><p>ONE_TIME - Run the job only once. If you specify this value, don't specify a value for the scheduleFrequency property.</p></li> <li><p>SCHEDULED - Run the job on a daily, weekly, or monthly basis. If you specify this value, use the scheduleFrequency property to define the recurrence pattern for the job.</p></li></ul>
    public let jobType: JobType?
    /// <p>A custom name for the job. The name can contain as many as 500 characters.</p>
    public let name: String?
    /// <p>The S3 buckets that contain the objects to analyze, and the scope of that analysis.</p>
    public let s3JobDefinition: S3JobDefinition?
    /// <p>The sampling depth, as a percentage, to apply when processing objects. This value determines the percentage of eligible objects that the job analyzes. If this value is less than 100, Amazon Macie selects the objects to analyze at random, up to the specified percentage, and analyzes all the data in those objects.</p>
    public let samplingPercentage: Int
    /// <p>The recurrence pattern for running the job. To run the job only once, don't specify a value for this property and set the value for the jobType property to ONE_TIME.</p>
    public let scheduleFrequency: JobScheduleFrequency?
    /// <p>A map of key-value pairs that specifies the tags to associate with the job.</p> <p>A job can have a maximum of 50 tags. Each tag consists of a tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        customDataIdentifierIds: [String]? = nil,
        description: String? = nil,
        initialRun: Bool = false,
        jobType: JobType? = nil,
        name: String? = nil,
        s3JobDefinition: S3JobDefinition? = nil,
        samplingPercentage: Int = 0,
        scheduleFrequency: JobScheduleFrequency? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.customDataIdentifierIds = customDataIdentifierIds
        self.description = description
        self.initialRun = initialRun
        self.jobType = jobType
        self.name = name
        self.s3JobDefinition = s3JobDefinition
        self.samplingPercentage = samplingPercentage
        self.scheduleFrequency = scheduleFrequency
        self.tags = tags
    }
}

struct CreateClassificationJobInputBody: Equatable {
    public let clientToken: String?
    public let customDataIdentifierIds: [String]?
    public let description: String?
    public let initialRun: Bool
    public let jobType: JobType?
    public let name: String?
    public let s3JobDefinition: S3JobDefinition?
    public let samplingPercentage: Int
    public let scheduleFrequency: JobScheduleFrequency?
    public let tags: [String:String]?
}

extension CreateClassificationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case customDataIdentifierIds = "customDataIdentifierIds"
        case description = "description"
        case initialRun = "initialRun"
        case jobType = "jobType"
        case name = "name"
        case s3JobDefinition = "s3JobDefinition"
        case samplingPercentage = "samplingPercentage"
        case scheduleFrequency = "scheduleFrequency"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let customDataIdentifierIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .customDataIdentifierIds)
        var customDataIdentifierIdsDecoded0:[String]? = nil
        if let customDataIdentifierIdsContainer = customDataIdentifierIdsContainer {
            customDataIdentifierIdsDecoded0 = [String]()
            for string0 in customDataIdentifierIdsContainer {
                if let string0 = string0 {
                    customDataIdentifierIdsDecoded0?.append(string0)
                }
            }
        }
        customDataIdentifierIds = customDataIdentifierIdsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let initialRunDecoded = try containerValues.decode(Bool.self, forKey: .initialRun)
        initialRun = initialRunDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let s3JobDefinitionDecoded = try containerValues.decodeIfPresent(S3JobDefinition.self, forKey: .s3JobDefinition)
        s3JobDefinition = s3JobDefinitionDecoded
        let samplingPercentageDecoded = try containerValues.decode(Int.self, forKey: .samplingPercentage)
        samplingPercentage = samplingPercentageDecoded
        let scheduleFrequencyDecoded = try containerValues.decodeIfPresent(JobScheduleFrequency.self, forKey: .scheduleFrequency)
        scheduleFrequency = scheduleFrequencyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateClassificationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClassificationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClassificationJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClassificationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClassificationJobOutputResponse(jobArn: \(String(describing: jobArn)), jobId: \(String(describing: jobId)))"}
}

extension CreateClassificationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateClassificationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobArn = output.jobArn
            self.jobId = output.jobId
        } else {
            self.jobArn = nil
            self.jobId = nil
        }
    }
}

public struct CreateClassificationJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the job.</p>
    public let jobArn: String?
    /// <p>The unique identifier for the job.</p>
    public let jobId: String?

    public init (
        jobArn: String? = nil,
        jobId: String? = nil
    )
    {
        self.jobArn = jobArn
        self.jobId = jobId
    }
}

struct CreateClassificationJobOutputResponseBody: Equatable {
    public let jobArn: String?
    public let jobId: String?
}

extension CreateClassificationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobArn = "jobArn"
        case jobId = "jobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct CreateCustomDataIdentifierInputBodyMiddleware: Middleware {
    public let id: String = "CreateCustomDataIdentifierInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomDataIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomDataIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomDataIdentifierInput>
    public typealias MOutput = OperationOutput<CreateCustomDataIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomDataIdentifierOutputError>
}

extension CreateCustomDataIdentifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomDataIdentifierInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), ignoreWords: \(String(describing: ignoreWords)), keywords: \(String(describing: keywords)), maximumMatchDistance: \(String(describing: maximumMatchDistance)), name: \(String(describing: name)), regex: \(String(describing: regex)), tags: \(String(describing: tags)))"}
}

extension CreateCustomDataIdentifierInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case description = "description"
        case ignoreWords = "ignoreWords"
        case keywords = "keywords"
        case maximumMatchDistance = "maximumMatchDistance"
        case name = "name"
        case regex = "regex"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ignoreWords = ignoreWords {
            var ignoreWordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ignoreWords)
            for __listof__string0 in ignoreWords {
                try ignoreWordsContainer.encode(__listof__string0)
            }
        }
        if let keywords = keywords {
            var keywordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keywords)
            for __listof__string0 in keywords {
                try keywordsContainer.encode(__listof__string0)
            }
        }
        if maximumMatchDistance != 0 {
            try encodeContainer.encode(maximumMatchDistance, forKey: .maximumMatchDistance)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regex = regex {
            try encodeContainer.encode(regex, forKey: .regex)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateCustomDataIdentifierInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCustomDataIdentifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomDataIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomDataIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomDataIdentifierInput>
    public typealias MOutput = OperationOutput<CreateCustomDataIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomDataIdentifierOutputError>
}

public struct CreateCustomDataIdentifierInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCustomDataIdentifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomDataIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomDataIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomDataIdentifierInput>
    public typealias MOutput = OperationOutput<CreateCustomDataIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomDataIdentifierOutputError>
}

public struct CreateCustomDataIdentifierInput: Equatable {
    /// <p>A unique, case-sensitive token that you provide to ensure the idempotency of the request.</p>
    public var clientToken: String?
    /// <p>A custom description of the custom data identifier. The description can contain as many as 512 characters.</p> <p>We strongly recommend that you avoid including any sensitive data in the description of a custom data identifier. Other users of your account might be able to see the identifier's description, depending on the actions that they're allowed to perform in Amazon Macie.</p>
    public let description: String?
    /// <p>An array that lists specific character sequences (ignore words) to exclude from the results. If the text matched by the regular expression is the same as any string in this array, Amazon Macie ignores it. The array can contain as many as 10 ignore words. Each ignore word can contain 4 - 90 characters. Ignore words are case sensitive.</p>
    public let ignoreWords: [String]?
    /// <p>An array that lists specific character sequences (keywords), one of which must be within proximity (maximumMatchDistance) of the regular expression to match. The array can contain as many as 50 keywords. Each keyword can contain 3 - 90 characters. Keywords aren't case sensitive.</p>
    public let keywords: [String]?
    /// <p>The maximum number of characters that can exist between text that matches the regex pattern and the character sequences specified by the keywords array. Macie includes or excludes a result based on the proximity of a keyword to text that matches the regex pattern. The distance can be 1 - 300 characters. The default value is 50.</p>
    public let maximumMatchDistance: Int
    /// <p>A custom name for the custom data identifier. The name can contain as many as 128 characters.</p> <p>We strongly recommend that you avoid including any sensitive data in the name of a custom data identifier. Other users of your account might be able to see the identifier's name, depending on the actions that they're allowed to perform in Amazon Macie.</p>
    public let name: String?
    /// <p>The regular expression (<i>regex</i>) that defines the pattern to match. The expression can contain as many as 512 characters.</p>
    public let regex: String?
    /// <p>A map of key-value pairs that specifies the tags to associate with the custom data identifier.</p> <p>A custom data identifier can have a maximum of 50 tags. Each tag consists of a tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        ignoreWords: [String]? = nil,
        keywords: [String]? = nil,
        maximumMatchDistance: Int = 0,
        name: String? = nil,
        regex: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.ignoreWords = ignoreWords
        self.keywords = keywords
        self.maximumMatchDistance = maximumMatchDistance
        self.name = name
        self.regex = regex
        self.tags = tags
    }
}

struct CreateCustomDataIdentifierInputBody: Equatable {
    public let clientToken: String?
    public let description: String?
    public let ignoreWords: [String]?
    public let keywords: [String]?
    public let maximumMatchDistance: Int
    public let name: String?
    public let regex: String?
    public let tags: [String:String]?
}

extension CreateCustomDataIdentifierInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case description = "description"
        case ignoreWords = "ignoreWords"
        case keywords = "keywords"
        case maximumMatchDistance = "maximumMatchDistance"
        case name = "name"
        case regex = "regex"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ignoreWordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ignoreWords)
        var ignoreWordsDecoded0:[String]? = nil
        if let ignoreWordsContainer = ignoreWordsContainer {
            ignoreWordsDecoded0 = [String]()
            for string0 in ignoreWordsContainer {
                if let string0 = string0 {
                    ignoreWordsDecoded0?.append(string0)
                }
            }
        }
        ignoreWords = ignoreWordsDecoded0
        let keywordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .keywords)
        var keywordsDecoded0:[String]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [String]()
            for string0 in keywordsContainer {
                if let string0 = string0 {
                    keywordsDecoded0?.append(string0)
                }
            }
        }
        keywords = keywordsDecoded0
        let maximumMatchDistanceDecoded = try containerValues.decode(Int.self, forKey: .maximumMatchDistance)
        maximumMatchDistance = maximumMatchDistanceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let regexDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regex)
        regex = regexDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCustomDataIdentifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomDataIdentifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomDataIdentifierOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomDataIdentifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomDataIdentifierOutputResponse(customDataIdentifierId: \(String(describing: customDataIdentifierId)))"}
}

extension CreateCustomDataIdentifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCustomDataIdentifierOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customDataIdentifierId = output.customDataIdentifierId
        } else {
            self.customDataIdentifierId = nil
        }
    }
}

public struct CreateCustomDataIdentifierOutputResponse: Equatable {
    /// <p>The unique identifier for the custom data identifier that was created.</p>
    public let customDataIdentifierId: String?

    public init (
        customDataIdentifierId: String? = nil
    )
    {
        self.customDataIdentifierId = customDataIdentifierId
    }
}

struct CreateCustomDataIdentifierOutputResponseBody: Equatable {
    public let customDataIdentifierId: String?
}

extension CreateCustomDataIdentifierOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customDataIdentifierId = "customDataIdentifierId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDataIdentifierIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customDataIdentifierId)
        customDataIdentifierId = customDataIdentifierIdDecoded
    }
}

public struct CreateFindingsFilterInputBodyMiddleware: Middleware {
    public let id: String = "CreateFindingsFilterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFindingsFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFindingsFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFindingsFilterInput>
    public typealias MOutput = OperationOutput<CreateFindingsFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFindingsFilterOutputError>
}

extension CreateFindingsFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFindingsFilterInput(action: \(String(describing: action)), clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), findingCriteria: \(String(describing: findingCriteria)), name: \(String(describing: name)), position: \(String(describing: position)), tags: \(String(describing: tags)))"}
}

extension CreateFindingsFilterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case position = "position"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingCriteria = findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if position != 0 {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateFindingsFilterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFindingsFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFindingsFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFindingsFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFindingsFilterInput>
    public typealias MOutput = OperationOutput<CreateFindingsFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFindingsFilterOutputError>
}

public struct CreateFindingsFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFindingsFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFindingsFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFindingsFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFindingsFilterInput>
    public typealias MOutput = OperationOutput<CreateFindingsFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFindingsFilterOutputError>
}

public struct CreateFindingsFilterInput: Equatable {
    /// <p>The action to perform on findings that meet the filter criteria (findingCriteria). Valid values are: ARCHIVE, suppress (automatically archive) the findings; and, NOOP, don't perform any action on the findings.</p>
    public let action: FindingsFilterAction?
    /// <p>A unique, case-sensitive token that you provide to ensure the idempotency of the request.</p>
    public var clientToken: String?
    /// <p>A custom description of the filter. The description can contain as many as 512 characters.</p> <p>We strongly recommend that you avoid including any sensitive data in the description of a filter. Other users of your account might be able to see the filter's description, depending on the actions that they're allowed to perform in Amazon Macie.</p>
    public let description: String?
    /// <p>The criteria to use to filter findings.</p>
    public let findingCriteria: FindingCriteria?
    /// <p>A custom name for the filter. The name must contain at least 3 characters and can contain as many as 64 characters.</p> <p>We strongly recommend that you avoid including any sensitive data in the name of a filter. Other users of your account might be able to see the filter's name, depending on the actions that they're allowed to perform in Amazon Macie.</p>
    public let name: String?
    /// <p>The position of the filter in the list of saved filters on the Amazon Macie console. This value also determines the order in which the filter is applied to findings, relative to other filters that are also applied to the findings.</p>
    public let position: Int
    /// <p>A map of key-value pairs that specifies the tags to associate with the filter.</p> <p>A findings filter can have a maximum of 50 tags. Each tag consists of a tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.</p>
    public let tags: [String:String]?

    public init (
        action: FindingsFilterAction? = nil,
        clientToken: String? = nil,
        description: String? = nil,
        findingCriteria: FindingCriteria? = nil,
        name: String? = nil,
        position: Int = 0,
        tags: [String:String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.description = description
        self.findingCriteria = findingCriteria
        self.name = name
        self.position = position
        self.tags = tags
    }
}

struct CreateFindingsFilterInputBody: Equatable {
    public let action: FindingsFilterAction?
    public let clientToken: String?
    public let description: String?
    public let findingCriteria: FindingCriteria?
    public let name: String?
    public let position: Int
    public let tags: [String:String]?
}

extension CreateFindingsFilterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case position = "position"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(FindingsFilterAction.self, forKey: .action)
        action = actionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let positionDecoded = try containerValues.decode(Int.self, forKey: .position)
        position = positionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFindingsFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFindingsFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFindingsFilterOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFindingsFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFindingsFilterOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)))"}
}

extension CreateFindingsFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFindingsFilterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateFindingsFilterOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the filter that was created.</p>
    public let arn: String?
    /// <p>The unique identifier for the filter that was created.</p>
    public let id: String?

    public init (
        arn: String? = nil,
        id: String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateFindingsFilterOutputResponseBody: Equatable {
    public let arn: String?
    public let id: String?
}

extension CreateFindingsFilterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case id = "id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateInvitationsInputBodyMiddleware: Middleware {
    public let id: String = "CreateInvitationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInvitationsInput>
    public typealias MOutput = OperationOutput<CreateInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInvitationsOutputError>
}

extension CreateInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInvitationsInput(accountIds: \(String(describing: accountIds)), disableEmailNotification: \(String(describing: disableEmailNotification)), message: \(String(describing: message)))"}
}

extension CreateInvitationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
        case disableEmailNotification = "disableEmailNotification"
        case message = "message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for __listof__string0 in accountIds {
                try accountIdsContainer.encode(__listof__string0)
            }
        }
        if disableEmailNotification != false {
            try encodeContainer.encode(disableEmailNotification, forKey: .disableEmailNotification)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }
}

public struct CreateInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInvitationsInput>
    public typealias MOutput = OperationOutput<CreateInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInvitationsOutputError>
}

public struct CreateInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInvitationsInput>
    public typealias MOutput = OperationOutput<CreateInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInvitationsOutputError>
}

public struct CreateInvitationsInput: Equatable {
    /// <p>An array that lists AWS account IDs, one for each account to send the invitation to.</p>
    public let accountIds: [String]?
    /// <p>Specifies whether to send an email notification to the root user of each account that the invitation will be sent to. This notification is in addition to an alert that the root user receives in AWS Personal Health Dashboard. To send an email notification to the root user of each account, set this value to true.</p>
    public let disableEmailNotification: Bool
    /// <p>A custom message to include in the invitation. Amazon Macie adds this message to the standard content that it sends for an invitation.</p>
    public let message: String?

    public init (
        accountIds: [String]? = nil,
        disableEmailNotification: Bool = false,
        message: String? = nil
    )
    {
        self.accountIds = accountIds
        self.disableEmailNotification = disableEmailNotification
        self.message = message
    }
}

struct CreateInvitationsInputBody: Equatable {
    public let accountIds: [String]?
    public let disableEmailNotification: Bool
    public let message: String?
}

extension CreateInvitationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
        case disableEmailNotification = "disableEmailNotification"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let disableEmailNotificationDecoded = try containerValues.decode(Bool.self, forKey: .disableEmailNotification)
        disableEmailNotification = disableEmailNotificationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInvitationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInvitationsOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension CreateInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct CreateInvitationsOutputResponse: Equatable {
    /// <p>An array of objects, one for each account whose invitation hasn't been processed. Each object identifies the account and explains why the invitation hasn't been processed for the account.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct CreateInvitationsOutputResponseBody: Equatable {
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension CreateInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public struct CreateMemberInputBodyMiddleware: Middleware {
    public let id: String = "CreateMemberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMemberInput>
    public typealias MOutput = OperationOutput<CreateMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMemberOutputError>
}

extension CreateMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMemberInput(account: \(String(describing: account)), tags: \(String(describing: tags)))"}
}

extension CreateMemberInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case account = "account"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateMemberInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMemberInput>
    public typealias MOutput = OperationOutput<CreateMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMemberOutputError>
}

public struct CreateMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMemberInput>
    public typealias MOutput = OperationOutput<CreateMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMemberOutputError>
}

public struct CreateMemberInput: Equatable {
    /// <p>The details for the account to associate with the administrator account.</p>
    public let account: AccountDetail?
    /// <p>A map of key-value pairs that specifies the tags to associate with the account in Amazon Macie.</p> <p>An account can have a maximum of 50 tags. Each tag consists of a tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.</p>
    public let tags: [String:String]?

    public init (
        account: AccountDetail? = nil,
        tags: [String:String]? = nil
    )
    {
        self.account = account
        self.tags = tags
    }
}

struct CreateMemberInputBody: Equatable {
    public let account: AccountDetail?
    public let tags: [String:String]?
}

extension CreateMemberInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case account = "account"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(AccountDetail.self, forKey: .account)
        account = accountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMemberOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMemberOutputResponse(arn: \(String(describing: arn)))"}
}

extension CreateMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMemberOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateMemberOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the account that was associated with the administrator account.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateMemberOutputResponseBody: Equatable {
    public let arn: String?
}

extension CreateMemberOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct CreateSampleFindingsInputBodyMiddleware: Middleware {
    public let id: String = "CreateSampleFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSampleFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSampleFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSampleFindingsInput>
    public typealias MOutput = OperationOutput<CreateSampleFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSampleFindingsOutputError>
}

extension CreateSampleFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSampleFindingsInput(findingTypes: \(String(describing: findingTypes)))"}
}

extension CreateSampleFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingTypes = "findingTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingTypes = findingTypes {
            var findingTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingTypes)
            for __listoffindingtype0 in findingTypes {
                try findingTypesContainer.encode(__listoffindingtype0.rawValue)
            }
        }
    }
}

public struct CreateSampleFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSampleFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSampleFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSampleFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSampleFindingsInput>
    public typealias MOutput = OperationOutput<CreateSampleFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSampleFindingsOutputError>
}

public struct CreateSampleFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSampleFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSampleFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSampleFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSampleFindingsInput>
    public typealias MOutput = OperationOutput<CreateSampleFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSampleFindingsOutputError>
}

public struct CreateSampleFindingsInput: Equatable {
    /// <p>An array that lists one or more types of findings to include in the set of sample findings. Currently, the only supported value is Policy:IAMUser/S3BucketEncryptionDisabled.</p>
    public let findingTypes: [FindingType]?

    public init (
        findingTypes: [FindingType]? = nil
    )
    {
        self.findingTypes = findingTypes
    }
}

struct CreateSampleFindingsInputBody: Equatable {
    public let findingTypes: [FindingType]?
}

extension CreateSampleFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingTypes = "findingTypes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingTypesContainer = try containerValues.decodeIfPresent([FindingType?].self, forKey: .findingTypes)
        var findingTypesDecoded0:[FindingType]? = nil
        if let findingTypesContainer = findingTypesContainer {
            findingTypesDecoded0 = [FindingType]()
            for string0 in findingTypesContainer {
                if let string0 = string0 {
                    findingTypesDecoded0?.append(string0)
                }
            }
        }
        findingTypes = findingTypesDecoded0
    }
}

extension CreateSampleFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSampleFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSampleFindingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSampleFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSampleFindingsOutputResponse()"}
}

extension CreateSampleFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateSampleFindingsOutputResponse: Equatable {

    public init() {}
}

struct CreateSampleFindingsOutputResponseBody: Equatable {
}

extension CreateSampleFindingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CriteriaBlockForJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case and = "and"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for __listofcriteriaforjob0 in and {
                try andContainer.encode(__listofcriteriaforjob0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let andContainer = try containerValues.decodeIfPresent([CriteriaForJob?].self, forKey: .and)
        var andDecoded0:[CriteriaForJob]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [CriteriaForJob]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
    }
}

extension CriteriaBlockForJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CriteriaBlockForJob(and: \(String(describing: and)))"}
}

/// <p>Specifies one or more property- and tag-based conditions that define criteria for including or excluding S3 buckets from a classification job.</p>
public struct CriteriaBlockForJob: Equatable {
    /// <p>An array of conditions, one for each condition that determines which buckets to include or exclude from the job. If you specify more than one condition, Amazon Macie uses AND logic to join the conditions.</p>
    public let and: [CriteriaForJob]?

    public init (
        and: [CriteriaForJob]? = nil
    )
    {
        self.and = and
    }
}

extension CriteriaForJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case simpleCriterion = "simpleCriterion"
        case tagCriterion = "tagCriterion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleCriterion = simpleCriterion {
            try encodeContainer.encode(simpleCriterion, forKey: .simpleCriterion)
        }
        if let tagCriterion = tagCriterion {
            try encodeContainer.encode(tagCriterion, forKey: .tagCriterion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleCriterionDecoded = try containerValues.decodeIfPresent(SimpleCriterionForJob.self, forKey: .simpleCriterion)
        simpleCriterion = simpleCriterionDecoded
        let tagCriterionDecoded = try containerValues.decodeIfPresent(TagCriterionForJob.self, forKey: .tagCriterion)
        tagCriterion = tagCriterionDecoded
    }
}

extension CriteriaForJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CriteriaForJob(simpleCriterion: \(String(describing: simpleCriterion)), tagCriterion: \(String(describing: tagCriterion)))"}
}

/// <p>Specifies a property- or tag-based condition that defines criteria for including or excluding S3 buckets from a classification job.</p>
public struct CriteriaForJob: Equatable {
    /// <p>A property-based condition that defines a property, operator, and one or more values for including or excluding buckets from the job.</p>
    public let simpleCriterion: SimpleCriterionForJob?
    /// <p>A tag-based condition that defines an operator and tag keys, tag values, or tag key and value pairs for including or excluding buckets from the job.</p>
    public let tagCriterion: TagCriterionForJob?

    public init (
        simpleCriterion: SimpleCriterionForJob? = nil,
        tagCriterion: TagCriterionForJob? = nil
    )
    {
        self.simpleCriterion = simpleCriterion
        self.tagCriterion = tagCriterion
    }
}

extension CriterionAdditionalProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eq = "eq"
        case eqExactMatch = "eqExactMatch"
        case gt = "gt"
        case gte = "gte"
        case lt = "lt"
        case lte = "lte"
        case neq = "neq"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eq = eq {
            var eqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eq)
            for __listof__string0 in eq {
                try eqContainer.encode(__listof__string0)
            }
        }
        if let eqExactMatch = eqExactMatch {
            var eqExactMatchContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eqExactMatch)
            for __listof__string0 in eqExactMatch {
                try eqExactMatchContainer.encode(__listof__string0)
            }
        }
        if gt != 0 {
            try encodeContainer.encode(gt, forKey: .gt)
        }
        if gte != 0 {
            try encodeContainer.encode(gte, forKey: .gte)
        }
        if lt != 0 {
            try encodeContainer.encode(lt, forKey: .lt)
        }
        if lte != 0 {
            try encodeContainer.encode(lte, forKey: .lte)
        }
        if let neq = neq {
            var neqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neq)
            for __listof__string0 in neq {
                try neqContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eqContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eq)
        var eqDecoded0:[String]? = nil
        if let eqContainer = eqContainer {
            eqDecoded0 = [String]()
            for string0 in eqContainer {
                if let string0 = string0 {
                    eqDecoded0?.append(string0)
                }
            }
        }
        eq = eqDecoded0
        let eqExactMatchContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eqExactMatch)
        var eqExactMatchDecoded0:[String]? = nil
        if let eqExactMatchContainer = eqExactMatchContainer {
            eqExactMatchDecoded0 = [String]()
            for string0 in eqExactMatchContainer {
                if let string0 = string0 {
                    eqExactMatchDecoded0?.append(string0)
                }
            }
        }
        eqExactMatch = eqExactMatchDecoded0
        let gtDecoded = try containerValues.decode(Int.self, forKey: .gt)
        gt = gtDecoded
        let gteDecoded = try containerValues.decode(Int.self, forKey: .gte)
        gte = gteDecoded
        let ltDecoded = try containerValues.decode(Int.self, forKey: .lt)
        lt = ltDecoded
        let lteDecoded = try containerValues.decode(Int.self, forKey: .lte)
        lte = lteDecoded
        let neqContainer = try containerValues.decodeIfPresent([String?].self, forKey: .neq)
        var neqDecoded0:[String]? = nil
        if let neqContainer = neqContainer {
            neqDecoded0 = [String]()
            for string0 in neqContainer {
                if let string0 = string0 {
                    neqDecoded0?.append(string0)
                }
            }
        }
        neq = neqDecoded0
    }
}

extension CriterionAdditionalProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CriterionAdditionalProperties(eq: \(String(describing: eq)), eqExactMatch: \(String(describing: eqExactMatch)), gt: \(String(describing: gt)), gte: \(String(describing: gte)), lt: \(String(describing: lt)), lte: \(String(describing: lte)), neq: \(String(describing: neq)))"}
}

/// <p>Specifies the operator to use in a property-based condition that filters the results of a query for findings. For detailed information and examples of each operator, see <a href="https://docs.aws.amazon.com/macie/latest/user/findings-filter-basics.html">Fundamentals of filtering findings</a> in the <i>Amazon Macie User Guide</i>.</p>
public struct CriterionAdditionalProperties: Equatable {
    /// <p>The value for the property matches (equals) the specified value. If you specify multiple values, Macie uses OR logic to join the values.</p>
    public let eq: [String]?
    /// <p>The value for the property exclusively matches (equals an exact match for) all the specified values. If you specify multiple values, Amazon Macie uses AND logic to join the values.</p> <p>You can use this operator with the following properties: customDataIdentifiers.detections.arn, customDataIdentifiers.detections.name, resourcesAffected.s3Bucket.tags.key, resourcesAffected.s3Bucket.tags.value, resourcesAffected.s3Object.tags.key, resourcesAffected.s3Object.tags.value, sensitiveData.category, and sensitiveData.detections.type.</p>
    public let eqExactMatch: [String]?
    /// <p>The value for the property is greater than the specified value.</p>
    public let gt: Int
    /// <p>The value for the property is greater than or equal to the specified value.</p>
    public let gte: Int
    /// <p>The value for the property is less than the specified value.</p>
    public let lt: Int
    /// <p>The value for the property is less than or equal to the specified value.</p>
    public let lte: Int
    /// <p>The value for the property doesn't match (doesn't equal) the specified value. If you specify multiple values, Macie uses OR logic to join the values.</p>
    public let neq: [String]?

    public init (
        eq: [String]? = nil,
        eqExactMatch: [String]? = nil,
        gt: Int = 0,
        gte: Int = 0,
        lt: Int = 0,
        lte: Int = 0,
        neq: [String]? = nil
    )
    {
        self.eq = eq
        self.eqExactMatch = eqExactMatch
        self.gt = gt
        self.gte = gte
        self.lt = lt
        self.lte = lte
        self.neq = neq
    }
}

/// <p>The type of currency that the data for an Amazon Macie usage metric is reported in. Possible values are:</p>
public enum Currency {
    case usd
    case sdkUnknown(String)
}

extension Currency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Currency] {
        return [
            .usd,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .usd: return "USD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Currency(rawValue: rawValue) ?? Currency.sdkUnknown(rawValue)
    }
}

extension CustomDataIdentifierSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case description = "description"
        case id = "id"
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CustomDataIdentifierSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomDataIdentifierSummary(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Provides information about a custom data identifier.</p>
public struct CustomDataIdentifierSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom data identifier.</p>
    public let arn: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the custom data identifier was created.</p>
    public let createdAt: Date?
    /// <p>The custom description of the custom data identifier.</p>
    public let description: String?
    /// <p>The unique identifier for the custom data identifier.</p>
    public let id: String?
    /// <p>The custom name of the custom data identifier.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
    }
}

extension CustomDataIdentifiers: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detections = "detections"
        case totalCount = "totalCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detections = detections {
            var detectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detections)
            for customdetections0 in detections {
                try detectionsContainer.encode(customdetections0)
            }
        }
        if totalCount != 0 {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectionsContainer = try containerValues.decodeIfPresent([CustomDetection?].self, forKey: .detections)
        var detectionsDecoded0:[CustomDetection]? = nil
        if let detectionsContainer = detectionsContainer {
            detectionsDecoded0 = [CustomDetection]()
            for structure0 in detectionsContainer {
                if let structure0 = structure0 {
                    detectionsDecoded0?.append(structure0)
                }
            }
        }
        detections = detectionsDecoded0
        let totalCountDecoded = try containerValues.decode(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension CustomDataIdentifiers: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomDataIdentifiers(detections: \(String(describing: detections)), totalCount: \(String(describing: totalCount)))"}
}

/// <p>Provides information about custom data identifiers that produced a sensitive data finding, and the number of occurrences of the data that they detected for the finding.</p>
public struct CustomDataIdentifiers: Equatable {
    /// <p>The custom data identifiers that detected the data, and the number of occurrences of the data that each identifier detected.</p>
    public let detections: [CustomDetection]?
    /// <p>The total number of occurrences of the data that was detected by the custom data identifiers and produced the finding.</p>
    public let totalCount: Int

    public init (
        detections: [CustomDetection]? = nil,
        totalCount: Int = 0
    )
    {
        self.detections = detections
        self.totalCount = totalCount
    }
}

extension CustomDetection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case count = "count"
        case name = "name"
        case occurrences = "occurrences"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let occurrences = occurrences {
            try encodeContainer.encode(occurrences, forKey: .occurrences)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let occurrencesDecoded = try containerValues.decodeIfPresent(Occurrences.self, forKey: .occurrences)
        occurrences = occurrencesDecoded
    }
}

extension CustomDetection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomDetection(arn: \(String(describing: arn)), count: \(String(describing: count)), name: \(String(describing: name)), occurrences: \(String(describing: occurrences)))"}
}

/// <p>Provides information about a custom data identifier that produced a sensitive data finding, and the sensitive data that it detected for the finding.</p>
public struct CustomDetection: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom data identifier.</p>
    public let arn: String?
    /// <p>The total number of occurrences of the sensitive data that the custom data identifier detected.</p>
    public let count: Int
    /// <p>The name of the custom data identifier.</p>
    public let name: String?
    /// <p>The location of 1-15 occurrences of the sensitive data that the custom data identifier detected. A finding includes location data for a maximum of 15 occurrences of sensitive data.</p>
    public let occurrences: Occurrences?

    public init (
        arn: String? = nil,
        count: Int = 0,
        name: String? = nil,
        occurrences: Occurrences? = nil
    )
    {
        self.arn = arn
        self.count = count
        self.name = name
        self.occurrences = occurrences
    }
}

extension DailySchedule: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension DailySchedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DailySchedule()"}
}

/// <p>Specifies that a classification job runs once a day, every day. This is an empty object.</p>
public struct DailySchedule: Equatable {

    public init() {}
}

public enum DayOfWeek {
    case friday
    case monday
    case saturday
    case sunday
    case thursday
    case tuesday
    case wednesday
    case sdkUnknown(String)
}

extension DayOfWeek : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DayOfWeek] {
        return [
            .friday,
            .monday,
            .saturday,
            .sunday,
            .thursday,
            .tuesday,
            .wednesday,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .friday: return "FRIDAY"
        case .monday: return "MONDAY"
        case .saturday: return "SATURDAY"
        case .sunday: return "SUNDAY"
        case .thursday: return "THURSDAY"
        case .tuesday: return "TUESDAY"
        case .wednesday: return "WEDNESDAY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DayOfWeek(rawValue: rawValue) ?? DayOfWeek.sdkUnknown(rawValue)
    }
}

public struct DeclineInvitationsInputBodyMiddleware: Middleware {
    public let id: String = "DeclineInvitationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeclineInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeclineInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeclineInvitationsInput>
    public typealias MOutput = OperationOutput<DeclineInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeclineInvitationsOutputError>
}

extension DeclineInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeclineInvitationsInput(accountIds: \(String(describing: accountIds)))"}
}

extension DeclineInvitationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for __listof__string0 in accountIds {
                try accountIdsContainer.encode(__listof__string0)
            }
        }
    }
}

public struct DeclineInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "DeclineInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeclineInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeclineInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeclineInvitationsInput>
    public typealias MOutput = OperationOutput<DeclineInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeclineInvitationsOutputError>
}

public struct DeclineInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeclineInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeclineInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeclineInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeclineInvitationsInput>
    public typealias MOutput = OperationOutput<DeclineInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeclineInvitationsOutputError>
}

public struct DeclineInvitationsInput: Equatable {
    /// <p>An array that lists AWS account IDs, one for each account that sent an invitation to decline.</p>
    public let accountIds: [String]?

    public init (
        accountIds: [String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeclineInvitationsInputBody: Equatable {
    public let accountIds: [String]?
}

extension DeclineInvitationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeclineInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeclineInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeclineInvitationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeclineInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeclineInvitationsOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension DeclineInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeclineInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeclineInvitationsOutputResponse: Equatable {
    /// <p>An array of objects, one for each account whose invitation hasn't been declined. Each object identifies the account and explains why the request hasn't been processed for that account.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeclineInvitationsOutputResponseBody: Equatable {
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension DeclineInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DefaultDetection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count = "count"
        case occurrences = "occurrences"
        case type = "type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let occurrences = occurrences {
            try encodeContainer.encode(occurrences, forKey: .occurrences)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let occurrencesDecoded = try containerValues.decodeIfPresent(Occurrences.self, forKey: .occurrences)
        occurrences = occurrencesDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension DefaultDetection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultDetection(count: \(String(describing: count)), occurrences: \(String(describing: occurrences)), type: \(String(describing: type)))"}
}

/// <p>Provides information about a type of sensitive data that was detected by managed data identifiers and produced a sensitive data finding.</p>
public struct DefaultDetection: Equatable {
    /// <p>The total number of occurrences of the type of sensitive data that was detected.</p>
    public let count: Int
    /// <p>The location of 1-15 occurrences of the sensitive data that was detected. A finding includes location data for a maximum of 15 occurrences of sensitive data.</p>
    public let occurrences: Occurrences?
    /// <p>The type of sensitive data that was detected. For example, AWS_CREDENTIALS, PHONE_NUMBER, or ADDRESS.</p>
    public let type: String?

    public init (
        count: Int = 0,
        occurrences: Occurrences? = nil,
        type: String? = nil
    )
    {
        self.count = count
        self.occurrences = occurrences
        self.type = type
    }
}

extension DeleteCustomDataIdentifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomDataIdentifierInput(id: \(String(describing: id)))"}
}

extension DeleteCustomDataIdentifierInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCustomDataIdentifierInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCustomDataIdentifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomDataIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomDataIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomDataIdentifierInput>
    public typealias MOutput = OperationOutput<DeleteCustomDataIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomDataIdentifierOutputError>
}

public struct DeleteCustomDataIdentifierInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCustomDataIdentifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomDataIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomDataIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomDataIdentifierInput>
    public typealias MOutput = OperationOutput<DeleteCustomDataIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomDataIdentifierOutputError>
}

public struct DeleteCustomDataIdentifierInput: Equatable {
    /// <p>The unique identifier for the Amazon Macie resource or account that the request applies to.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteCustomDataIdentifierInputBody: Equatable {
}

extension DeleteCustomDataIdentifierInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCustomDataIdentifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomDataIdentifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomDataIdentifierOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomDataIdentifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomDataIdentifierOutputResponse()"}
}

extension DeleteCustomDataIdentifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomDataIdentifierOutputResponse: Equatable {

    public init() {}
}

struct DeleteCustomDataIdentifierOutputResponseBody: Equatable {
}

extension DeleteCustomDataIdentifierOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFindingsFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFindingsFilterInput(id: \(String(describing: id)))"}
}

extension DeleteFindingsFilterInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFindingsFilterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFindingsFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFindingsFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFindingsFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFindingsFilterInput>
    public typealias MOutput = OperationOutput<DeleteFindingsFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFindingsFilterOutputError>
}

public struct DeleteFindingsFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFindingsFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFindingsFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFindingsFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFindingsFilterInput>
    public typealias MOutput = OperationOutput<DeleteFindingsFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFindingsFilterOutputError>
}

public struct DeleteFindingsFilterInput: Equatable {
    /// <p>The unique identifier for the Amazon Macie resource or account that the request applies to.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteFindingsFilterInputBody: Equatable {
}

extension DeleteFindingsFilterInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFindingsFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFindingsFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFindingsFilterOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFindingsFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFindingsFilterOutputResponse()"}
}

extension DeleteFindingsFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFindingsFilterOutputResponse: Equatable {

    public init() {}
}

struct DeleteFindingsFilterOutputResponseBody: Equatable {
}

extension DeleteFindingsFilterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteInvitationsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteInvitationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInvitationsInput>
    public typealias MOutput = OperationOutput<DeleteInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInvitationsOutputError>
}

extension DeleteInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInvitationsInput(accountIds: \(String(describing: accountIds)))"}
}

extension DeleteInvitationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for __listof__string0 in accountIds {
                try accountIdsContainer.encode(__listof__string0)
            }
        }
    }
}

public struct DeleteInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInvitationsInput>
    public typealias MOutput = OperationOutput<DeleteInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInvitationsOutputError>
}

public struct DeleteInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInvitationsInput>
    public typealias MOutput = OperationOutput<DeleteInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInvitationsOutputError>
}

public struct DeleteInvitationsInput: Equatable {
    /// <p>An array that lists AWS account IDs, one for each account that sent an invitation to delete.</p>
    public let accountIds: [String]?

    public init (
        accountIds: [String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeleteInvitationsInputBody: Equatable {
    public let accountIds: [String]?
}

extension DeleteInvitationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInvitationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInvitationsOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension DeleteInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteInvitationsOutputResponse: Equatable {
    /// <p>An array of objects, one for each account whose invitation hasn't been deleted. Each object identifies the account and explains why the request hasn't been processed for that account.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteInvitationsOutputResponseBody: Equatable {
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension DeleteInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DeleteMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMemberInput(id: \(String(describing: id)))"}
}

extension DeleteMemberInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteMemberInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMemberInput>
    public typealias MOutput = OperationOutput<DeleteMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMemberOutputError>
}

public struct DeleteMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMemberInput>
    public typealias MOutput = OperationOutput<DeleteMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMemberOutputError>
}

public struct DeleteMemberInput: Equatable {
    /// <p>The unique identifier for the Amazon Macie resource or account that the request applies to.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteMemberInputBody: Equatable {
}

extension DeleteMemberInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMemberOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMemberOutputResponse()"}
}

extension DeleteMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMemberOutputResponse: Equatable {

    public init() {}
}

struct DeleteMemberOutputResponseBody: Equatable {
}

extension DeleteMemberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeBucketsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBucketsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBucketsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBucketsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBucketsInput>
    public typealias MOutput = OperationOutput<DescribeBucketsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBucketsOutputError>
}

extension DescribeBucketsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBucketsInput(criteria: \(String(describing: criteria)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension DescribeBucketsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case criteria = "criteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criteria = criteria {
            var criteriaContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .criteria)
            for (dictKey0, bucketcriteria0) in criteria {
                try criteriaContainer.encode(bucketcriteria0, forKey: Key(stringValue: dictKey0))
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

public struct DescribeBucketsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBucketsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBucketsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBucketsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBucketsInput>
    public typealias MOutput = OperationOutput<DescribeBucketsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBucketsOutputError>
}

public struct DescribeBucketsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBucketsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBucketsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBucketsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBucketsInput>
    public typealias MOutput = OperationOutput<DescribeBucketsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBucketsOutputError>
}

public struct DescribeBucketsInput: Equatable {
    /// <p>The criteria to use to filter the query results.</p>
    public let criteria: [String:BucketCriteriaAdditionalProperties]?
    /// <p>The maximum number of items to include in each page of the response. The default value is 50.</p>
    public let maxResults: Int
    /// <p>The nextToken string that specifies which page of results to return in a paginated response.</p>
    public let nextToken: String?
    /// <p>The criteria to use to sort the query results.</p>
    public let sortCriteria: BucketSortCriteria?

    public init (
        criteria: [String:BucketCriteriaAdditionalProperties]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        sortCriteria: BucketSortCriteria? = nil
    )
    {
        self.criteria = criteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct DescribeBucketsInputBody: Equatable {
    public let criteria: [String:BucketCriteriaAdditionalProperties]?
    public let maxResults: Int
    public let nextToken: String?
    public let sortCriteria: BucketSortCriteria?
}

extension DescribeBucketsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case criteria = "criteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criteriaContainer = try containerValues.decodeIfPresent([String: BucketCriteriaAdditionalProperties?].self, forKey: .criteria)
        var criteriaDecoded0: [String:BucketCriteriaAdditionalProperties]? = nil
        if let criteriaContainer = criteriaContainer {
            criteriaDecoded0 = [String:BucketCriteriaAdditionalProperties]()
            for (key0, bucketcriteriaadditionalproperties0) in criteriaContainer {
                if let bucketcriteriaadditionalproperties0 = bucketcriteriaadditionalproperties0 {
                    criteriaDecoded0?[key0] = bucketcriteriaadditionalproperties0
                }
            }
        }
        criteria = criteriaDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(BucketSortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension DescribeBucketsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBucketsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBucketsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBucketsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBucketsOutputResponse(buckets: \(String(describing: buckets)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBucketsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBucketsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.buckets = output.buckets
            self.nextToken = output.nextToken
        } else {
            self.buckets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBucketsOutputResponse: Equatable {
    /// <p>An array of objects, one for each bucket that meets the filter criteria specified in the request.</p>
    public let buckets: [BucketMetadata]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        buckets: [BucketMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.buckets = buckets
        self.nextToken = nextToken
    }
}

struct DescribeBucketsOutputResponseBody: Equatable {
    public let buckets: [BucketMetadata]?
    public let nextToken: String?
}

extension DescribeBucketsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case buckets = "buckets"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketsContainer = try containerValues.decodeIfPresent([BucketMetadata?].self, forKey: .buckets)
        var bucketsDecoded0:[BucketMetadata]? = nil
        if let bucketsContainer = bucketsContainer {
            bucketsDecoded0 = [BucketMetadata]()
            for structure0 in bucketsContainer {
                if let structure0 = structure0 {
                    bucketsDecoded0?.append(structure0)
                }
            }
        }
        buckets = bucketsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeClassificationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClassificationJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeClassificationJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeClassificationJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClassificationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClassificationJobInput>
    public typealias MOutput = OperationOutput<DescribeClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClassificationJobOutputError>
}

public struct DescribeClassificationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClassificationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClassificationJobInput>
    public typealias MOutput = OperationOutput<DescribeClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClassificationJobOutputError>
}

public struct DescribeClassificationJobInput: Equatable {
    /// <p>The unique identifier for the classification job.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeClassificationJobInputBody: Equatable {
}

extension DescribeClassificationJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeClassificationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClassificationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClassificationJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClassificationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClassificationJobOutputResponse(clientToken: \(String(describing: clientToken)), createdAt: \(String(describing: createdAt)), customDataIdentifierIds: \(String(describing: customDataIdentifierIds)), description: \(String(describing: description)), initialRun: \(String(describing: initialRun)), jobArn: \(String(describing: jobArn)), jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)), jobType: \(String(describing: jobType)), lastRunErrorStatus: \(String(describing: lastRunErrorStatus)), lastRunTime: \(String(describing: lastRunTime)), name: \(String(describing: name)), s3JobDefinition: \(String(describing: s3JobDefinition)), samplingPercentage: \(String(describing: samplingPercentage)), scheduleFrequency: \(String(describing: scheduleFrequency)), statistics: \(String(describing: statistics)), tags: \(String(describing: tags)), userPausedDetails: \(String(describing: userPausedDetails)))"}
}

extension DescribeClassificationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClassificationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.createdAt = output.createdAt
            self.customDataIdentifierIds = output.customDataIdentifierIds
            self.description = output.description
            self.initialRun = output.initialRun
            self.jobArn = output.jobArn
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
            self.jobType = output.jobType
            self.lastRunErrorStatus = output.lastRunErrorStatus
            self.lastRunTime = output.lastRunTime
            self.name = output.name
            self.s3JobDefinition = output.s3JobDefinition
            self.samplingPercentage = output.samplingPercentage
            self.scheduleFrequency = output.scheduleFrequency
            self.statistics = output.statistics
            self.tags = output.tags
            self.userPausedDetails = output.userPausedDetails
        } else {
            self.clientToken = nil
            self.createdAt = nil
            self.customDataIdentifierIds = nil
            self.description = nil
            self.initialRun = false
            self.jobArn = nil
            self.jobId = nil
            self.jobStatus = nil
            self.jobType = nil
            self.lastRunErrorStatus = nil
            self.lastRunTime = nil
            self.name = nil
            self.s3JobDefinition = nil
            self.samplingPercentage = 0
            self.scheduleFrequency = nil
            self.statistics = nil
            self.tags = nil
            self.userPausedDetails = nil
        }
    }
}

public struct DescribeClassificationJobOutputResponse: Equatable {
    /// <p>The token that was provided to ensure the idempotency of the request to create the job.</p>
    public var clientToken: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the job was created.</p>
    public let createdAt: Date?
    /// <p>The custom data identifiers that the job uses to analyze data.</p>
    public let customDataIdentifierIds: [String]?
    /// <p>The custom description of the job.</p>
    public let description: String?
    /// <p>Specifies whether the job is configured to analyze all existing, eligible objects immediately after it's created.</p>
    public let initialRun: Bool
    /// <p>The Amazon Resource Name (ARN) of the job.</p>
    public let jobArn: String?
    /// <p>The unique identifier for the job.</p>
    public let jobId: String?
    /// <p>The current status of the job. Possible values are:</p> <ul><li><p>CANCELLED - You cancelled the job or, if it's a one-time job, you paused the job and didn't resume it within 30 days.</p></li> <li><p>COMPLETE - For a one-time job, Amazon Macie finished processing the data specified for the job. This value doesn't apply to recurring jobs.</p></li> <li><p>IDLE - For a recurring job, the previous scheduled run is complete and the next scheduled run is pending. This value doesn't apply to one-time jobs.</p></li> <li><p>PAUSED - Amazon Macie started running the job but additional processing would exceed the monthly sensitive data discovery quota for your account or one or more member accounts that the job analyzes data for.</p></li> <li><p>RUNNING - For a one-time job, the job is in progress. For a recurring job, a scheduled run is in progress.</p></li> <li><p>USER_PAUSED - You paused the job. If you paused the job while it had a status of RUNNING and you don't resume it within 30 days of pausing it, the job or job run will expire and be cancelled, depending on the job's type. To check the expiration date, refer to the UserPausedDetails.jobExpiresAt property.</p></li></ul>
    public let jobStatus: JobStatus?
    /// <p>The schedule for running the job. Possible values are:</p> <ul><li><p>ONE_TIME - The job runs only once.</p></li> <li><p>SCHEDULED - The job runs on a daily, weekly, or monthly basis. The scheduleFrequency property indicates the recurrence pattern for the job.</p></li></ul>
    public let jobType: JobType?
    /// <p>Specifies whether any account- or bucket-level access errors occurred when the job ran. For a recurring job, this value indicates the error status of the job's most recent run.</p>
    public let lastRunErrorStatus: LastRunErrorStatus?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the job started. If the job is a recurring job, this value indicates when the most recent run started.</p>
    public let lastRunTime: Date?
    /// <p>The custom name of the job.</p>
    public let name: String?
    /// <p>The S3 buckets that contain the objects to analyze, and the scope of that analysis.</p>
    public let s3JobDefinition: S3JobDefinition?
    /// <p>The sampling depth, as a percentage, that determines the percentage of eligible objects that the job analyzes.</p>
    public let samplingPercentage: Int
    /// <p>The recurrence pattern for running the job. If the job is configured to run only once, this value is null.</p>
    public let scheduleFrequency: JobScheduleFrequency?
    /// <p>The number of times that the job has run and processing statistics for the job's current run.</p>
    public let statistics: Statistics?
    /// <p>A map of key-value pairs that specifies which tags (keys and values) are associated with the classification job.</p>
    public let tags: [String:String]?
    /// <p>If the current status of the job is USER_PAUSED, specifies when the job was paused and when the job or job run will expire and be cancelled if it isn't resumed. This value is present only if the value for jobStatus is USER_PAUSED.</p>
    public let userPausedDetails: UserPausedDetails?

    public init (
        clientToken: String? = nil,
        createdAt: Date? = nil,
        customDataIdentifierIds: [String]? = nil,
        description: String? = nil,
        initialRun: Bool = false,
        jobArn: String? = nil,
        jobId: String? = nil,
        jobStatus: JobStatus? = nil,
        jobType: JobType? = nil,
        lastRunErrorStatus: LastRunErrorStatus? = nil,
        lastRunTime: Date? = nil,
        name: String? = nil,
        s3JobDefinition: S3JobDefinition? = nil,
        samplingPercentage: Int = 0,
        scheduleFrequency: JobScheduleFrequency? = nil,
        statistics: Statistics? = nil,
        tags: [String:String]? = nil,
        userPausedDetails: UserPausedDetails? = nil
    )
    {
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.customDataIdentifierIds = customDataIdentifierIds
        self.description = description
        self.initialRun = initialRun
        self.jobArn = jobArn
        self.jobId = jobId
        self.jobStatus = jobStatus
        self.jobType = jobType
        self.lastRunErrorStatus = lastRunErrorStatus
        self.lastRunTime = lastRunTime
        self.name = name
        self.s3JobDefinition = s3JobDefinition
        self.samplingPercentage = samplingPercentage
        self.scheduleFrequency = scheduleFrequency
        self.statistics = statistics
        self.tags = tags
        self.userPausedDetails = userPausedDetails
    }
}

struct DescribeClassificationJobOutputResponseBody: Equatable {
    public let clientToken: String?
    public let createdAt: Date?
    public let customDataIdentifierIds: [String]?
    public let description: String?
    public let initialRun: Bool
    public let jobArn: String?
    public let jobId: String?
    public let jobStatus: JobStatus?
    public let jobType: JobType?
    public let lastRunErrorStatus: LastRunErrorStatus?
    public let lastRunTime: Date?
    public let name: String?
    public let s3JobDefinition: S3JobDefinition?
    public let samplingPercentage: Int
    public let scheduleFrequency: JobScheduleFrequency?
    public let statistics: Statistics?
    public let tags: [String:String]?
    public let userPausedDetails: UserPausedDetails?
}

extension DescribeClassificationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case createdAt = "createdAt"
        case customDataIdentifierIds = "customDataIdentifierIds"
        case description = "description"
        case initialRun = "initialRun"
        case jobArn = "jobArn"
        case jobId = "jobId"
        case jobStatus = "jobStatus"
        case jobType = "jobType"
        case lastRunErrorStatus = "lastRunErrorStatus"
        case lastRunTime = "lastRunTime"
        case name = "name"
        case s3JobDefinition = "s3JobDefinition"
        case samplingPercentage = "samplingPercentage"
        case scheduleFrequency = "scheduleFrequency"
        case statistics = "statistics"
        case tags = "tags"
        case userPausedDetails = "userPausedDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let customDataIdentifierIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .customDataIdentifierIds)
        var customDataIdentifierIdsDecoded0:[String]? = nil
        if let customDataIdentifierIdsContainer = customDataIdentifierIdsContainer {
            customDataIdentifierIdsDecoded0 = [String]()
            for string0 in customDataIdentifierIdsContainer {
                if let string0 = string0 {
                    customDataIdentifierIdsDecoded0?.append(string0)
                }
            }
        }
        customDataIdentifierIds = customDataIdentifierIdsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let initialRunDecoded = try containerValues.decode(Bool.self, forKey: .initialRun)
        initialRun = initialRunDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let lastRunErrorStatusDecoded = try containerValues.decodeIfPresent(LastRunErrorStatus.self, forKey: .lastRunErrorStatus)
        lastRunErrorStatus = lastRunErrorStatusDecoded
        let lastRunTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastRunTime)
        lastRunTime = lastRunTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let s3JobDefinitionDecoded = try containerValues.decodeIfPresent(S3JobDefinition.self, forKey: .s3JobDefinition)
        s3JobDefinition = s3JobDefinitionDecoded
        let samplingPercentageDecoded = try containerValues.decode(Int.self, forKey: .samplingPercentage)
        samplingPercentage = samplingPercentageDecoded
        let scheduleFrequencyDecoded = try containerValues.decodeIfPresent(JobScheduleFrequency.self, forKey: .scheduleFrequency)
        scheduleFrequency = scheduleFrequencyDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(Statistics.self, forKey: .statistics)
        statistics = statisticsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let userPausedDetailsDecoded = try containerValues.decodeIfPresent(UserPausedDetails.self, forKey: .userPausedDetails)
        userPausedDetails = userPausedDetailsDecoded
    }
}

extension DescribeOrganizationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConfigurationInput()"}
}

extension DescribeOrganizationConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeOrganizationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConfigurationOutputError>
}

public struct DescribeOrganizationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConfigurationOutputError>
}

public struct DescribeOrganizationConfigurationInput: Equatable {

    public init() {}
}

struct DescribeOrganizationConfigurationInputBody: Equatable {
}

extension DescribeOrganizationConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeOrganizationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConfigurationOutputResponse(autoEnable: \(String(describing: autoEnable)), maxAccountLimitReached: \(String(describing: maxAccountLimitReached)))"}
}

extension DescribeOrganizationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOrganizationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.autoEnable = output.autoEnable
            self.maxAccountLimitReached = output.maxAccountLimitReached
        } else {
            self.autoEnable = false
            self.maxAccountLimitReached = false
        }
    }
}

public struct DescribeOrganizationConfigurationOutputResponse: Equatable {
    /// <p>Specifies whether Amazon Macie is enabled automatically for accounts that are added to the AWS organization.</p>
    public let autoEnable: Bool
    /// <p>Specifies whether the maximum number of Amazon Macie member accounts are part of the AWS organization.</p>
    public let maxAccountLimitReached: Bool

    public init (
        autoEnable: Bool = false,
        maxAccountLimitReached: Bool = false
    )
    {
        self.autoEnable = autoEnable
        self.maxAccountLimitReached = maxAccountLimitReached
    }
}

struct DescribeOrganizationConfigurationOutputResponseBody: Equatable {
    public let autoEnable: Bool
    public let maxAccountLimitReached: Bool
}

extension DescribeOrganizationConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoEnable = "autoEnable"
        case maxAccountLimitReached = "maxAccountLimitReached"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decode(Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let maxAccountLimitReachedDecoded = try containerValues.decode(Bool.self, forKey: .maxAccountLimitReached)
        maxAccountLimitReached = maxAccountLimitReachedDecoded
    }
}

extension DisableMacieInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableMacieInput()"}
}

extension DisableMacieInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisableMacieInputHeadersMiddleware: Middleware {
    public let id: String = "DisableMacieInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableMacieInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableMacieOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableMacieInput>
    public typealias MOutput = OperationOutput<DisableMacieOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableMacieOutputError>
}

public struct DisableMacieInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableMacieInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableMacieInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableMacieOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableMacieInput>
    public typealias MOutput = OperationOutput<DisableMacieOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableMacieOutputError>
}

public struct DisableMacieInput: Equatable {

    public init() {}
}

struct DisableMacieInputBody: Equatable {
}

extension DisableMacieInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisableMacieOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableMacieOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableMacieOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableMacieOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableMacieOutputResponse()"}
}

extension DisableMacieOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableMacieOutputResponse: Equatable {

    public init() {}
}

struct DisableMacieOutputResponseBody: Equatable {
}

extension DisableMacieOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisableOrganizationAdminAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableOrganizationAdminAccountInput(adminAccountId: \(String(describing: adminAccountId)))"}
}

extension DisableOrganizationAdminAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisableOrganizationAdminAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DisableOrganizationAdminAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<DisableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableOrganizationAdminAccountOutputError>
}

public struct DisableOrganizationAdminAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableOrganizationAdminAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let adminAccountId = input.operationInput.adminAccountId {
            let adminAccountIdQueryItem = URLQueryItem(name: "adminAccountId".urlPercentEncoding(), value: String(adminAccountId).urlPercentEncoding())
            input.builder.withQueryItem(adminAccountIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<DisableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableOrganizationAdminAccountOutputError>
}

public struct DisableOrganizationAdminAccountInput: Equatable {
    /// <p>The AWS account ID of the delegated Amazon Macie administrator account.</p>
    public let adminAccountId: String?

    public init (
        adminAccountId: String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct DisableOrganizationAdminAccountInputBody: Equatable {
}

extension DisableOrganizationAdminAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisableOrganizationAdminAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableOrganizationAdminAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableOrganizationAdminAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableOrganizationAdminAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableOrganizationAdminAccountOutputResponse()"}
}

extension DisableOrganizationAdminAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableOrganizationAdminAccountOutputResponse: Equatable {

    public init() {}
}

struct DisableOrganizationAdminAccountOutputResponseBody: Equatable {
}

extension DisableOrganizationAdminAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateFromAdministratorAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFromAdministratorAccountInput()"}
}

extension DisassociateFromAdministratorAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateFromAdministratorAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateFromAdministratorAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFromAdministratorAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFromAdministratorAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFromAdministratorAccountInput>
    public typealias MOutput = OperationOutput<DisassociateFromAdministratorAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFromAdministratorAccountOutputError>
}

public struct DisassociateFromAdministratorAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateFromAdministratorAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFromAdministratorAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFromAdministratorAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFromAdministratorAccountInput>
    public typealias MOutput = OperationOutput<DisassociateFromAdministratorAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFromAdministratorAccountOutputError>
}

public struct DisassociateFromAdministratorAccountInput: Equatable {

    public init() {}
}

struct DisassociateFromAdministratorAccountInputBody: Equatable {
}

extension DisassociateFromAdministratorAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateFromAdministratorAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFromAdministratorAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFromAdministratorAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFromAdministratorAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFromAdministratorAccountOutputResponse()"}
}

extension DisassociateFromAdministratorAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateFromAdministratorAccountOutputResponse: Equatable {

    public init() {}
}

struct DisassociateFromAdministratorAccountOutputResponseBody: Equatable {
}

extension DisassociateFromAdministratorAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateFromMasterAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFromMasterAccountInput()"}
}

extension DisassociateFromMasterAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateFromMasterAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateFromMasterAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFromMasterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFromMasterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFromMasterAccountInput>
    public typealias MOutput = OperationOutput<DisassociateFromMasterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFromMasterAccountOutputError>
}

public struct DisassociateFromMasterAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateFromMasterAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFromMasterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFromMasterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFromMasterAccountInput>
    public typealias MOutput = OperationOutput<DisassociateFromMasterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFromMasterAccountOutputError>
}

public struct DisassociateFromMasterAccountInput: Equatable {

    public init() {}
}

struct DisassociateFromMasterAccountInputBody: Equatable {
}

extension DisassociateFromMasterAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateFromMasterAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFromMasterAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFromMasterAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFromMasterAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFromMasterAccountOutputResponse()"}
}

extension DisassociateFromMasterAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateFromMasterAccountOutputResponse: Equatable {

    public init() {}
}

struct DisassociateFromMasterAccountOutputResponseBody: Equatable {
}

extension DisassociateFromMasterAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMemberInput(id: \(String(describing: id)))"}
}

extension DisassociateMemberInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateMemberInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMemberInput>
    public typealias MOutput = OperationOutput<DisassociateMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMemberOutputError>
}

public struct DisassociateMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMemberInput>
    public typealias MOutput = OperationOutput<DisassociateMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMemberOutputError>
}

public struct DisassociateMemberInput: Equatable {
    /// <p>The unique identifier for the Amazon Macie resource or account that the request applies to.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateMemberInputBody: Equatable {
}

extension DisassociateMemberInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMemberOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMemberOutputResponse()"}
}

extension DisassociateMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMemberOutputResponse: Equatable {

    public init() {}
}

struct DisassociateMemberOutputResponseBody: Equatable {
}

extension DisassociateMemberOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DomainDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "domainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DomainDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainDetails(domainName: \(String(describing: domainName)))"}
}

/// <p>Provides information about the domain name of the device that an entity used to perform an action on an affected resource.</p>
public struct DomainDetails: Equatable {
    /// <p>The name of the domain.</p>
    public let domainName: String?

    public init (
        domainName: String? = nil
    )
    {
        self.domainName = domainName
    }
}

public enum EffectivePermission {
    case notPublic
    case `public`
    case unknown
    case sdkUnknown(String)
}

extension EffectivePermission : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EffectivePermission] {
        return [
            .notPublic,
            .public,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notPublic: return "NOT_PUBLIC"
        case .public: return "PUBLIC"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EffectivePermission(rawValue: rawValue) ?? EffectivePermission.sdkUnknown(rawValue)
    }
}

public struct EnableMacieInputBodyMiddleware: Middleware {
    public let id: String = "EnableMacieInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableMacieInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableMacieOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableMacieInput>
    public typealias MOutput = OperationOutput<EnableMacieOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableMacieOutputError>
}

extension EnableMacieInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableMacieInput(clientToken: \(String(describing: clientToken)), findingPublishingFrequency: \(String(describing: findingPublishingFrequency)), status: \(String(describing: status)))"}
}

extension EnableMacieInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let findingPublishingFrequency = findingPublishingFrequency {
            try encodeContainer.encode(findingPublishingFrequency.rawValue, forKey: .findingPublishingFrequency)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct EnableMacieInputHeadersMiddleware: Middleware {
    public let id: String = "EnableMacieInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableMacieInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableMacieOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableMacieInput>
    public typealias MOutput = OperationOutput<EnableMacieOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableMacieOutputError>
}

public struct EnableMacieInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableMacieInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableMacieInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableMacieOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableMacieInput>
    public typealias MOutput = OperationOutput<EnableMacieOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableMacieOutputError>
}

public struct EnableMacieInput: Equatable {
    /// <p>A unique, case-sensitive token that you provide to ensure the idempotency of the request.</p>
    public var clientToken: String?
    /// Specifies how often to publish updates to policy findings for the account. This includes publishing updates to AWS Security Hub and Amazon EventBridge (formerly called Amazon CloudWatch Events).
    public let findingPublishingFrequency: FindingPublishingFrequency?
    /// <p>Specifies the new status for the account. To enable Amazon Macie and start all Macie activities for the account, set this value to ENABLED.</p>
    public let status: MacieStatus?

    public init (
        clientToken: String? = nil,
        findingPublishingFrequency: FindingPublishingFrequency? = nil,
        status: MacieStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.findingPublishingFrequency = findingPublishingFrequency
        self.status = status
    }
}

struct EnableMacieInputBody: Equatable {
    public let clientToken: String?
    public let findingPublishingFrequency: FindingPublishingFrequency?
    public let status: MacieStatus?
}

extension EnableMacieInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MacieStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension EnableMacieOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableMacieOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableMacieOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableMacieOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableMacieOutputResponse()"}
}

extension EnableMacieOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableMacieOutputResponse: Equatable {

    public init() {}
}

struct EnableMacieOutputResponseBody: Equatable {
}

extension EnableMacieOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct EnableOrganizationAdminAccountInputBodyMiddleware: Middleware {
    public let id: String = "EnableOrganizationAdminAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<EnableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableOrganizationAdminAccountOutputError>
}

extension EnableOrganizationAdminAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableOrganizationAdminAccountInput(adminAccountId: \(String(describing: adminAccountId)), clientToken: \(String(describing: clientToken)))"}
}

extension EnableOrganizationAdminAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminAccountId = "adminAccountId"
        case clientToken = "clientToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct EnableOrganizationAdminAccountInputHeadersMiddleware: Middleware {
    public let id: String = "EnableOrganizationAdminAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<EnableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableOrganizationAdminAccountOutputError>
}

public struct EnableOrganizationAdminAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableOrganizationAdminAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<EnableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableOrganizationAdminAccountOutputError>
}

public struct EnableOrganizationAdminAccountInput: Equatable {
    /// <p>The AWS account ID for the account to designate as the delegated Amazon Macie administrator account for the organization.</p>
    public let adminAccountId: String?
    /// <p>A unique, case-sensitive token that you provide to ensure the idempotency of the request.</p>
    public var clientToken: String?

    public init (
        adminAccountId: String? = nil,
        clientToken: String? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.clientToken = clientToken
    }
}

struct EnableOrganizationAdminAccountInputBody: Equatable {
    public let adminAccountId: String?
    public let clientToken: String?
}

extension EnableOrganizationAdminAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccountId = "adminAccountId"
        case clientToken = "clientToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableOrganizationAdminAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableOrganizationAdminAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableOrganizationAdminAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableOrganizationAdminAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableOrganizationAdminAccountOutputResponse()"}
}

extension EnableOrganizationAdminAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableOrganizationAdminAccountOutputResponse: Equatable {

    public init() {}
}

struct EnableOrganizationAdminAccountOutputResponseBody: Equatable {
}

extension EnableOrganizationAdminAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

/// <p>The type of server-side encryption that's used to encrypt an S3 object or objects in an S3 bucket. Valid values are:</p>
public enum EncryptionType {
    case aes256
    case `none`
    case unknown
    case awsKms
    case sdkUnknown(String)
}

extension EncryptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionType] {
        return [
            .aes256,
            .none,
            .unknown,
            .awsKms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aes256: return "AES256"
        case .none: return "NONE"
        case .unknown: return "UNKNOWN"
        case .awsKms: return "aws:kms"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
    }
}

/// <p>The source of an issue or delay. Possible values are:</p>
public enum ErrorCode {
    case clienterror
    case internalerror
    case sdkUnknown(String)
}

extension ErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ErrorCode] {
        return [
            .clienterror,
            .internalerror,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .clienterror: return "ClientError"
        case .internalerror: return "InternalError"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
    }
}

extension FederatedUser: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId = "accessKeyId"
        case accountId = "accountId"
        case arn = "arn"
        case principalId = "principalId"
        case sessionContext = "sessionContext"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let sessionContext = sessionContext {
            try encodeContainer.encode(sessionContext, forKey: .sessionContext)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let sessionContextDecoded = try containerValues.decodeIfPresent(SessionContext.self, forKey: .sessionContext)
        sessionContext = sessionContextDecoded
    }
}

extension FederatedUser: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FederatedUser(accessKeyId: \(String(describing: accessKeyId)), accountId: \(String(describing: accountId)), arn: \(String(describing: arn)), principalId: \(String(describing: principalId)), sessionContext: \(String(describing: sessionContext)))"}
}

/// <p>Provides information about an identity that performed an action on an affected resource by using temporary security credentials. The credentials were obtained using the GetFederationToken operation of the AWS Security Token Service (AWS STS) API.</p>
public struct FederatedUser: Equatable {
    /// <p>The AWS access key ID that identifies the credentials.</p>
    public let accessKeyId: String?
    /// <p>The unique identifier for the AWS account that owns the entity that was used to get the credentials.</p>
    public let accountId: String?
    /// <p>The Amazon Resource Name (ARN) of the entity that was used to get the credentials.</p>
    public let arn: String?
    /// <p>The unique identifier for the entity that was used to get the credentials.</p>
    public let principalId: String?
    /// <p>The details of the session that was created for the credentials, including the entity that issued the session.</p>
    public let sessionContext: SessionContext?

    public init (
        accessKeyId: String? = nil,
        accountId: String? = nil,
        arn: String? = nil,
        principalId: String? = nil,
        sessionContext: SessionContext? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.accountId = accountId
        self.arn = arn
        self.principalId = principalId
        self.sessionContext = sessionContext
    }
}

extension Finding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case archived = "archived"
        case category = "category"
        case classificationDetails = "classificationDetails"
        case count = "count"
        case createdAt = "createdAt"
        case description = "description"
        case id = "id"
        case partition = "partition"
        case policyDetails = "policyDetails"
        case region = "region"
        case resourcesAffected = "resourcesAffected"
        case sample = "sample"
        case schemaVersion = "schemaVersion"
        case severity = "severity"
        case title = "title"
        case type = "type"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if archived != false {
            try encodeContainer.encode(archived, forKey: .archived)
        }
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let classificationDetails = classificationDetails {
            try encodeContainer.encode(classificationDetails, forKey: .classificationDetails)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let partition = partition {
            try encodeContainer.encode(partition, forKey: .partition)
        }
        if let policyDetails = policyDetails {
            try encodeContainer.encode(policyDetails, forKey: .policyDetails)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourcesAffected = resourcesAffected {
            try encodeContainer.encode(resourcesAffected, forKey: .resourcesAffected)
        }
        if sample != false {
            try encodeContainer.encode(sample, forKey: .sample)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let archivedDecoded = try containerValues.decode(Bool.self, forKey: .archived)
        archived = archivedDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(FindingCategory.self, forKey: .category)
        category = categoryDecoded
        let classificationDetailsDecoded = try containerValues.decodeIfPresent(ClassificationDetails.self, forKey: .classificationDetails)
        classificationDetails = classificationDetailsDecoded
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partition)
        partition = partitionDecoded
        let policyDetailsDecoded = try containerValues.decodeIfPresent(PolicyDetails.self, forKey: .policyDetails)
        policyDetails = policyDetailsDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let resourcesAffectedDecoded = try containerValues.decodeIfPresent(ResourcesAffected.self, forKey: .resourcesAffected)
        resourcesAffected = resourcesAffectedDecoded
        let sampleDecoded = try containerValues.decode(Bool.self, forKey: .sample)
        sample = sampleDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Severity.self, forKey: .severity)
        severity = severityDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FindingType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Finding: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Finding(accountId: \(String(describing: accountId)), archived: \(String(describing: archived)), category: \(String(describing: category)), classificationDetails: \(String(describing: classificationDetails)), count: \(String(describing: count)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), id: \(String(describing: id)), partition: \(String(describing: partition)), policyDetails: \(String(describing: policyDetails)), region: \(String(describing: region)), resourcesAffected: \(String(describing: resourcesAffected)), sample: \(String(describing: sample)), schemaVersion: \(String(describing: schemaVersion)), severity: \(String(describing: severity)), title: \(String(describing: title)), type: \(String(describing: type)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Provides the details of a finding.</p>
public struct Finding: Equatable {
    /// <p>The unique identifier for the AWS account that the finding applies to. This is typically the account that owns the affected resource.</p>
    public let accountId: String?
    /// <p>Specifies whether the finding is archived.</p>
    public let archived: Bool
    /// <p>The category of the finding. Possible values are: CLASSIFICATION, for a sensitive data finding; and, POLICY, for a policy finding.</p>
    public let category: FindingCategory?
    /// <p>The details of a sensitive data finding. This value is null for a policy finding.</p>
    public let classificationDetails: ClassificationDetails?
    /// <p>The total number of occurrences of the finding. For sensitive data findings, this value is always 1. All sensitive data findings are considered new (unique) because they derive from individual classification jobs.</p>
    public let count: Int
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the finding was created.</p>
    public let createdAt: Date?
    /// <p>The description of the finding.</p>
    public let description: String?
    /// <p>The unique identifier for the finding. This is a random string that Amazon Macie generates and assigns to a finding when it creates the finding.</p>
    public let id: String?
    /// <p>The AWS partition that Amazon Macie created the finding in.</p>
    public let partition: String?
    /// <p>The details of a policy finding. This value is null for a sensitive data finding.</p>
    public let policyDetails: PolicyDetails?
    /// <p>The AWS Region that Amazon Macie created the finding in.</p>
    public let region: String?
    /// <p>The resources that the finding applies to.</p>
    public let resourcesAffected: ResourcesAffected?
    /// <p>Specifies whether the finding is a sample finding. A <i>sample finding</i> is a finding that uses example data to demonstrate what a finding might contain.</p>
    public let sample: Bool
    /// <p>The version of the schema that was used to define the data structures in the finding.</p>
    public let schemaVersion: String?
    /// <p>The severity level and score for the finding.</p>
    public let severity: Severity?
    /// <p>The brief description of the finding.</p>
    public let title: String?
    /// <p>The type of the finding.</p>
    public let type: FindingType?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the finding was last updated. For sensitive data findings, this value is the same as the value for the createdAt property. All sensitive data findings are considered new (unique) because they derive from individual classification jobs.</p>
    public let updatedAt: Date?

    public init (
        accountId: String? = nil,
        archived: Bool = false,
        category: FindingCategory? = nil,
        classificationDetails: ClassificationDetails? = nil,
        count: Int = 0,
        createdAt: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        partition: String? = nil,
        policyDetails: PolicyDetails? = nil,
        region: String? = nil,
        resourcesAffected: ResourcesAffected? = nil,
        sample: Bool = false,
        schemaVersion: String? = nil,
        severity: Severity? = nil,
        title: String? = nil,
        type: FindingType? = nil,
        updatedAt: Date? = nil
    )
    {
        self.accountId = accountId
        self.archived = archived
        self.category = category
        self.classificationDetails = classificationDetails
        self.count = count
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.partition = partition
        self.policyDetails = policyDetails
        self.region = region
        self.resourcesAffected = resourcesAffected
        self.sample = sample
        self.schemaVersion = schemaVersion
        self.severity = severity
        self.title = title
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension FindingAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionType = "actionType"
        case apiCallDetails = "apiCallDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let apiCallDetails = apiCallDetails {
            try encodeContainer.encode(apiCallDetails, forKey: .apiCallDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(FindingActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let apiCallDetailsDecoded = try containerValues.decodeIfPresent(ApiCallDetails.self, forKey: .apiCallDetails)
        apiCallDetails = apiCallDetailsDecoded
    }
}

extension FindingAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingAction(actionType: \(String(describing: actionType)), apiCallDetails: \(String(describing: apiCallDetails)))"}
}

/// <p>Provides information about an action that occurred for a resource and produced a policy finding.</p>
public struct FindingAction: Equatable {
    /// <p>The type of action that occurred for the affected resource. This value is typically AWS_API_CALL, which indicates that an entity invoked an API operation for the resource.</p>
    public let actionType: FindingActionType?
    /// <p>The invocation details of the API operation that an entity invoked for the affected resource, if the value for the actionType property is AWS_API_CALL.</p>
    public let apiCallDetails: ApiCallDetails?

    public init (
        actionType: FindingActionType? = nil,
        apiCallDetails: ApiCallDetails? = nil
    )
    {
        self.actionType = actionType
        self.apiCallDetails = apiCallDetails
    }
}

/// <p>The type of action that occurred for the resource and produced the policy finding:</p>
public enum FindingActionType {
    case awsApiCall
    case sdkUnknown(String)
}

extension FindingActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingActionType] {
        return [
            .awsApiCall,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsApiCall: return "AWS_API_CALL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingActionType(rawValue: rawValue) ?? FindingActionType.sdkUnknown(rawValue)
    }
}

extension FindingActor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainDetails = "domainDetails"
        case ipAddressDetails = "ipAddressDetails"
        case userIdentity = "userIdentity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainDetails = domainDetails {
            try encodeContainer.encode(domainDetails, forKey: .domainDetails)
        }
        if let ipAddressDetails = ipAddressDetails {
            try encodeContainer.encode(ipAddressDetails, forKey: .ipAddressDetails)
        }
        if let userIdentity = userIdentity {
            try encodeContainer.encode(userIdentity, forKey: .userIdentity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDetailsDecoded = try containerValues.decodeIfPresent(DomainDetails.self, forKey: .domainDetails)
        domainDetails = domainDetailsDecoded
        let ipAddressDetailsDecoded = try containerValues.decodeIfPresent(IpAddressDetails.self, forKey: .ipAddressDetails)
        ipAddressDetails = ipAddressDetailsDecoded
        let userIdentityDecoded = try containerValues.decodeIfPresent(UserIdentity.self, forKey: .userIdentity)
        userIdentity = userIdentityDecoded
    }
}

extension FindingActor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingActor(domainDetails: \(String(describing: domainDetails)), ipAddressDetails: \(String(describing: ipAddressDetails)), userIdentity: \(String(describing: userIdentity)))"}
}

/// <p>Provides information about an entity that performed an action that produced a policy finding for a resource.</p>
public struct FindingActor: Equatable {
    /// <p>The domain name of the device that the entity used to perform the action on the affected resource.</p>
    public let domainDetails: DomainDetails?
    /// <p>The IP address of the device that the entity used to perform the action on the affected resource. This object also provides information such as the owner and geographic location for the IP address.</p>
    public let ipAddressDetails: IpAddressDetails?
    /// <p>The type and other characteristics of the entity that performed the action on the affected resource.</p>
    public let userIdentity: UserIdentity?

    public init (
        domainDetails: DomainDetails? = nil,
        ipAddressDetails: IpAddressDetails? = nil,
        userIdentity: UserIdentity? = nil
    )
    {
        self.domainDetails = domainDetails
        self.ipAddressDetails = ipAddressDetails
        self.userIdentity = userIdentity
    }
}

/// <p>The category of the finding. Valid values are:</p>
public enum FindingCategory {
    case classification
    case policy
    case sdkUnknown(String)
}

extension FindingCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingCategory] {
        return [
            .classification,
            .policy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .classification: return "CLASSIFICATION"
        case .policy: return "POLICY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingCategory(rawValue: rawValue) ?? FindingCategory.sdkUnknown(rawValue)
    }
}

extension FindingCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case criterion = "criterion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criterion = criterion {
            var criterionContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .criterion)
            for (dictKey0, criterion0) in criterion {
                try criterionContainer.encode(criterion0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criterionContainer = try containerValues.decodeIfPresent([String: CriterionAdditionalProperties?].self, forKey: .criterion)
        var criterionDecoded0: [String:CriterionAdditionalProperties]? = nil
        if let criterionContainer = criterionContainer {
            criterionDecoded0 = [String:CriterionAdditionalProperties]()
            for (key0, criterionadditionalproperties0) in criterionContainer {
                if let criterionadditionalproperties0 = criterionadditionalproperties0 {
                    criterionDecoded0?[key0] = criterionadditionalproperties0
                }
            }
        }
        criterion = criterionDecoded0
    }
}

extension FindingCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingCriteria(criterion: \(String(describing: criterion)))"}
}

/// <p>Specifies, as a map, one or more property-based conditions that filter the results of a query for findings.</p>
public struct FindingCriteria: Equatable {
    /// <p>A condition that specifies the property, operator, and one or more values to use to filter the results.</p>
    public let criterion: [String:CriterionAdditionalProperties]?

    public init (
        criterion: [String:CriterionAdditionalProperties]? = nil
    )
    {
        self.criterion = criterion
    }
}

/// <p>The frequency with which Amazon Macie publishes updates to policy findings for an account. This includes publishing updates to AWS Security Hub and Amazon EventBridge (formerly called Amazon CloudWatch Events). For more information, see <a href="https://docs.aws.amazon.com/macie/latest/user/findings-monitor.html">Monitoring and processing findings</a> in the <i>Amazon Macie User Guide</i>. Valid values are:</p>
public enum FindingPublishingFrequency {
    case fifteenMinutes
    case oneHour
    case sixHours
    case sdkUnknown(String)
}

extension FindingPublishingFrequency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingPublishingFrequency] {
        return [
            .fifteenMinutes,
            .oneHour,
            .sixHours,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fifteenMinutes: return "FIFTEEN_MINUTES"
        case .oneHour: return "ONE_HOUR"
        case .sixHours: return "SIX_HOURS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingPublishingFrequency(rawValue: rawValue) ?? FindingPublishingFrequency.sdkUnknown(rawValue)
    }
}

/// <p>The grouping to sort the results by. Valid values are:</p>
public enum FindingStatisticsSortAttributeName {
    case count
    case groupkey
    case sdkUnknown(String)
}

extension FindingStatisticsSortAttributeName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingStatisticsSortAttributeName] {
        return [
            .count,
            .groupkey,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .count: return "count"
        case .groupkey: return "groupKey"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingStatisticsSortAttributeName(rawValue: rawValue) ?? FindingStatisticsSortAttributeName.sdkUnknown(rawValue)
    }
}

extension FindingStatisticsSortCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName.rawValue, forKey: .attributeName)
        }
        if let orderBy = orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(FindingStatisticsSortAttributeName.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension FindingStatisticsSortCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingStatisticsSortCriteria(attributeName: \(String(describing: attributeName)), orderBy: \(String(describing: orderBy)))"}
}

/// <p>Specifies criteria for sorting the results of a query that retrieves aggregated statistical data about findings.</p>
public struct FindingStatisticsSortCriteria: Equatable {
    /// <p>The grouping to sort the results by. Valid values are: count, sort the results by the number of findings in each group of results; and, groupKey, sort the results by the name of each group of results.</p>
    public let attributeName: FindingStatisticsSortAttributeName?
    /// <p>The sort order to apply to the results, based on the value for the property specified by the attributeName property. Valid values are: ASC, sort the results in ascending order; and, DESC, sort the results in descending order.</p>
    public let orderBy: OrderBy?

    public init (
        attributeName: FindingStatisticsSortAttributeName? = nil,
        orderBy: OrderBy? = nil
    )
    {
        self.attributeName = attributeName
        self.orderBy = orderBy
    }
}

/// <p>The type of finding. For details about each type, see <a href="https://docs.aws.amazon.com/macie/latest/user/findings-types.html">Types of Amazon Macie findings</a> in the <i>Amazon Macie User Guide</i>. Valid values are:</p>
public enum FindingType {
    case policyIamuserS3blockpublicaccessdisabled
    case policyIamuserS3bucketencryptiondisabled
    case policyIamuserS3bucketpublic
    case policyIamuserS3bucketreplicatedexternally
    case policyIamuserS3bucketsharedexternally
    case sensitivedataS3objectCredentials
    case sensitivedataS3objectCustomidentifier
    case sensitivedataS3objectFinancial
    case sensitivedataS3objectMultiple
    case sensitivedataS3objectPersonal
    case sdkUnknown(String)
}

extension FindingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingType] {
        return [
            .policyIamuserS3blockpublicaccessdisabled,
            .policyIamuserS3bucketencryptiondisabled,
            .policyIamuserS3bucketpublic,
            .policyIamuserS3bucketreplicatedexternally,
            .policyIamuserS3bucketsharedexternally,
            .sensitivedataS3objectCredentials,
            .sensitivedataS3objectCustomidentifier,
            .sensitivedataS3objectFinancial,
            .sensitivedataS3objectMultiple,
            .sensitivedataS3objectPersonal,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .policyIamuserS3blockpublicaccessdisabled: return "Policy:IAMUser/S3BlockPublicAccessDisabled"
        case .policyIamuserS3bucketencryptiondisabled: return "Policy:IAMUser/S3BucketEncryptionDisabled"
        case .policyIamuserS3bucketpublic: return "Policy:IAMUser/S3BucketPublic"
        case .policyIamuserS3bucketreplicatedexternally: return "Policy:IAMUser/S3BucketReplicatedExternally"
        case .policyIamuserS3bucketsharedexternally: return "Policy:IAMUser/S3BucketSharedExternally"
        case .sensitivedataS3objectCredentials: return "SensitiveData:S3Object/Credentials"
        case .sensitivedataS3objectCustomidentifier: return "SensitiveData:S3Object/CustomIdentifier"
        case .sensitivedataS3objectFinancial: return "SensitiveData:S3Object/Financial"
        case .sensitivedataS3objectMultiple: return "SensitiveData:S3Object/Multiple"
        case .sensitivedataS3objectPersonal: return "SensitiveData:S3Object/Personal"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingType(rawValue: rawValue) ?? FindingType.sdkUnknown(rawValue)
    }
}

/// <p>The action to perform on findings that meet the filter criteria. To suppress (automatically archive) findings that meet the criteria, set this value to ARCHIVE. Valid values are:</p>
public enum FindingsFilterAction {
    case archive
    case noop
    case sdkUnknown(String)
}

extension FindingsFilterAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingsFilterAction] {
        return [
            .archive,
            .noop,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .archive: return "ARCHIVE"
        case .noop: return "NOOP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingsFilterAction(rawValue: rawValue) ?? FindingsFilterAction.sdkUnknown(rawValue)
    }
}

extension FindingsFilterListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case arn = "arn"
        case id = "id"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(FindingsFilterAction.self, forKey: .action)
        action = actionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FindingsFilterListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingsFilterListItem(action: \(String(describing: action)), arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

/// <p>Provides information about a findings filter.</p>
public struct FindingsFilterListItem: Equatable {
    /// <p>The action that's performed on findings that meet the filter criteria. Possible values are: ARCHIVE, suppress (automatically archive) the findings; and, NOOP, don't perform any action on the findings.</p>
    public let action: FindingsFilterAction?
    /// <p>The Amazon Resource Name (ARN) of the filter.</p>
    public let arn: String?
    /// <p>The unique identifier for the filter.</p>
    public let id: String?
    /// <p>The custom name of the filter.</p>
    public let name: String?
    /// <p>A map of key-value pairs that identifies the tags (keys and values) that are associated with the filter.</p>
    public let tags: [String:String]?

    public init (
        action: FindingsFilterAction? = nil,
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.id = id
        self.name = name
        self.tags = tags
    }
}

extension GetAdministratorAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAdministratorAccountInput()"}
}

extension GetAdministratorAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAdministratorAccountInputHeadersMiddleware: Middleware {
    public let id: String = "GetAdministratorAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAdministratorAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAdministratorAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAdministratorAccountInput>
    public typealias MOutput = OperationOutput<GetAdministratorAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAdministratorAccountOutputError>
}

public struct GetAdministratorAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAdministratorAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAdministratorAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAdministratorAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAdministratorAccountInput>
    public typealias MOutput = OperationOutput<GetAdministratorAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAdministratorAccountOutputError>
}

public struct GetAdministratorAccountInput: Equatable {

    public init() {}
}

struct GetAdministratorAccountInputBody: Equatable {
}

extension GetAdministratorAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAdministratorAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAdministratorAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAdministratorAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAdministratorAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAdministratorAccountOutputResponse(administrator: \(String(describing: administrator)))"}
}

extension GetAdministratorAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAdministratorAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.administrator = output.administrator
        } else {
            self.administrator = nil
        }
    }
}

public struct GetAdministratorAccountOutputResponse: Equatable {
    /// <p>The AWS account ID for the administrator account. If the accounts are associated by a Macie membership invitation, this object also provides details about the invitation that was sent to establish the relationship between the accounts.</p>
    public let administrator: Invitation?

    public init (
        administrator: Invitation? = nil
    )
    {
        self.administrator = administrator
    }
}

struct GetAdministratorAccountOutputResponseBody: Equatable {
    public let administrator: Invitation?
}

extension GetAdministratorAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case administrator = "administrator"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorDecoded = try containerValues.decodeIfPresent(Invitation.self, forKey: .administrator)
        administrator = administratorDecoded
    }
}

public struct GetBucketStatisticsInputBodyMiddleware: Middleware {
    public let id: String = "GetBucketStatisticsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketStatisticsInput>
    public typealias MOutput = OperationOutput<GetBucketStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketStatisticsOutputError>
}

extension GetBucketStatisticsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketStatisticsInput(accountId: \(String(describing: accountId)))"}
}

extension GetBucketStatisticsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }
}

public struct GetBucketStatisticsInputHeadersMiddleware: Middleware {
    public let id: String = "GetBucketStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketStatisticsInput>
    public typealias MOutput = OperationOutput<GetBucketStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketStatisticsOutputError>
}

public struct GetBucketStatisticsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBucketStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBucketStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBucketStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBucketStatisticsInput>
    public typealias MOutput = OperationOutput<GetBucketStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBucketStatisticsOutputError>
}

public struct GetBucketStatisticsInput: Equatable {
    /// <p>The unique identifier for the AWS account.</p>
    public let accountId: String?

    public init (
        accountId: String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetBucketStatisticsInputBody: Equatable {
    public let accountId: String?
}

extension GetBucketStatisticsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension GetBucketStatisticsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBucketStatisticsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBucketStatisticsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBucketStatisticsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBucketStatisticsOutputResponse(bucketCount: \(String(describing: bucketCount)), bucketCountByEffectivePermission: \(String(describing: bucketCountByEffectivePermission)), bucketCountByEncryptionType: \(String(describing: bucketCountByEncryptionType)), bucketCountByObjectEncryptionRequirement: \(String(describing: bucketCountByObjectEncryptionRequirement)), bucketCountBySharedAccessType: \(String(describing: bucketCountBySharedAccessType)), classifiableObjectCount: \(String(describing: classifiableObjectCount)), classifiableSizeInBytes: \(String(describing: classifiableSizeInBytes)), lastUpdated: \(String(describing: lastUpdated)), objectCount: \(String(describing: objectCount)), sizeInBytes: \(String(describing: sizeInBytes)), sizeInBytesCompressed: \(String(describing: sizeInBytesCompressed)), unclassifiableObjectCount: \(String(describing: unclassifiableObjectCount)), unclassifiableObjectSizeInBytes: \(String(describing: unclassifiableObjectSizeInBytes)))"}
}

extension GetBucketStatisticsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBucketStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucketCount = output.bucketCount
            self.bucketCountByEffectivePermission = output.bucketCountByEffectivePermission
            self.bucketCountByEncryptionType = output.bucketCountByEncryptionType
            self.bucketCountByObjectEncryptionRequirement = output.bucketCountByObjectEncryptionRequirement
            self.bucketCountBySharedAccessType = output.bucketCountBySharedAccessType
            self.classifiableObjectCount = output.classifiableObjectCount
            self.classifiableSizeInBytes = output.classifiableSizeInBytes
            self.lastUpdated = output.lastUpdated
            self.objectCount = output.objectCount
            self.sizeInBytes = output.sizeInBytes
            self.sizeInBytesCompressed = output.sizeInBytesCompressed
            self.unclassifiableObjectCount = output.unclassifiableObjectCount
            self.unclassifiableObjectSizeInBytes = output.unclassifiableObjectSizeInBytes
        } else {
            self.bucketCount = 0
            self.bucketCountByEffectivePermission = nil
            self.bucketCountByEncryptionType = nil
            self.bucketCountByObjectEncryptionRequirement = nil
            self.bucketCountBySharedAccessType = nil
            self.classifiableObjectCount = 0
            self.classifiableSizeInBytes = 0
            self.lastUpdated = nil
            self.objectCount = 0
            self.sizeInBytes = 0
            self.sizeInBytesCompressed = 0
            self.unclassifiableObjectCount = nil
            self.unclassifiableObjectSizeInBytes = nil
        }
    }
}

public struct GetBucketStatisticsOutputResponse: Equatable {
    /// <p>The total number of buckets.</p>
    public let bucketCount: Int
    /// <p>The total number of buckets that are publicly accessible based on a combination of permissions settings for each bucket.</p>
    public let bucketCountByEffectivePermission: BucketCountByEffectivePermission?
    /// <p>The total number of buckets that use certain types of server-side encryption to encrypt new objects by default. This object also reports the total number of buckets that don't encrypt new objects by default.</p>
    public let bucketCountByEncryptionType: BucketCountByEncryptionType?
    /// <p>The total number of buckets whose bucket policies do or don't require server-side encryption of objects when objects are uploaded to the buckets.</p>
    public let bucketCountByObjectEncryptionRequirement: BucketCountPolicyAllowsUnencryptedObjectUploads?
    /// <p>The total number of buckets that are or aren't shared with another AWS account.</p>
    public let bucketCountBySharedAccessType: BucketCountBySharedAccessType?
    /// <p>The total number of objects that Amazon Macie can analyze in the buckets. These objects use a supported storage class and have a file name extension for a supported file or storage format.</p>
    public let classifiableObjectCount: Int
    /// <p>The total storage size, in bytes, of all the objects that Amazon Macie can analyze in the buckets. These objects use a supported storage class and have a file name extension for a supported file or storage format.</p> <p>If versioning is enabled for any of the buckets, Macie calculates this value based on the size of the latest version of each applicable object in those buckets. This value doesn't reflect the storage size of all versions of all applicable objects in the buckets.</p>
    public let classifiableSizeInBytes: Int
    /// <p>The date and time, in UTC and extended ISO 8601 format, when Amazon Macie most recently retrieved both bucket and object metadata from Amazon S3 for the buckets.</p>
    public let lastUpdated: Date?
    /// <p>The total number of objects in the buckets.</p>
    public let objectCount: Int
    /// <p>The total storage size, in bytes, of the buckets.</p> <p>If versioning is enabled for any of the buckets, Macie calculates this value based on the size of the latest version of each object in those buckets. This value doesn't reflect the storage size of all versions of the objects in the buckets.</p>
    public let sizeInBytes: Int
    /// <p>The total storage size, in bytes, of the objects that are compressed (.gz, .gzip, .zip) files in the buckets.</p> <p>If versioning is enabled for any of the buckets, Macie calculates this value based on the size of the latest version of each applicable object in those buckets. This value doesn't reflect the storage size of all versions of the applicable objects in the buckets.</p>
    public let sizeInBytesCompressed: Int
    /// <p>The total number of objects that Amazon Macie can't analyze in the buckets. These objects don't use a supported storage class or don't have a file name extension for a supported file or storage format.</p>
    public let unclassifiableObjectCount: ObjectLevelStatistics?
    /// <p>The total storage size, in bytes, of the objects that Amazon Macie can't analyze in the buckets. These objects don't use a supported storage class or don't have a file name extension for a supported file or storage format.</p>
    public let unclassifiableObjectSizeInBytes: ObjectLevelStatistics?

    public init (
        bucketCount: Int = 0,
        bucketCountByEffectivePermission: BucketCountByEffectivePermission? = nil,
        bucketCountByEncryptionType: BucketCountByEncryptionType? = nil,
        bucketCountByObjectEncryptionRequirement: BucketCountPolicyAllowsUnencryptedObjectUploads? = nil,
        bucketCountBySharedAccessType: BucketCountBySharedAccessType? = nil,
        classifiableObjectCount: Int = 0,
        classifiableSizeInBytes: Int = 0,
        lastUpdated: Date? = nil,
        objectCount: Int = 0,
        sizeInBytes: Int = 0,
        sizeInBytesCompressed: Int = 0,
        unclassifiableObjectCount: ObjectLevelStatistics? = nil,
        unclassifiableObjectSizeInBytes: ObjectLevelStatistics? = nil
    )
    {
        self.bucketCount = bucketCount
        self.bucketCountByEffectivePermission = bucketCountByEffectivePermission
        self.bucketCountByEncryptionType = bucketCountByEncryptionType
        self.bucketCountByObjectEncryptionRequirement = bucketCountByObjectEncryptionRequirement
        self.bucketCountBySharedAccessType = bucketCountBySharedAccessType
        self.classifiableObjectCount = classifiableObjectCount
        self.classifiableSizeInBytes = classifiableSizeInBytes
        self.lastUpdated = lastUpdated
        self.objectCount = objectCount
        self.sizeInBytes = sizeInBytes
        self.sizeInBytesCompressed = sizeInBytesCompressed
        self.unclassifiableObjectCount = unclassifiableObjectCount
        self.unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes
    }
}

struct GetBucketStatisticsOutputResponseBody: Equatable {
    public let bucketCount: Int
    public let bucketCountByEffectivePermission: BucketCountByEffectivePermission?
    public let bucketCountByEncryptionType: BucketCountByEncryptionType?
    public let bucketCountByObjectEncryptionRequirement: BucketCountPolicyAllowsUnencryptedObjectUploads?
    public let bucketCountBySharedAccessType: BucketCountBySharedAccessType?
    public let classifiableObjectCount: Int
    public let classifiableSizeInBytes: Int
    public let lastUpdated: Date?
    public let objectCount: Int
    public let sizeInBytes: Int
    public let sizeInBytesCompressed: Int
    public let unclassifiableObjectCount: ObjectLevelStatistics?
    public let unclassifiableObjectSizeInBytes: ObjectLevelStatistics?
}

extension GetBucketStatisticsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucketCount = "bucketCount"
        case bucketCountByEffectivePermission = "bucketCountByEffectivePermission"
        case bucketCountByEncryptionType = "bucketCountByEncryptionType"
        case bucketCountByObjectEncryptionRequirement = "bucketCountByObjectEncryptionRequirement"
        case bucketCountBySharedAccessType = "bucketCountBySharedAccessType"
        case classifiableObjectCount = "classifiableObjectCount"
        case classifiableSizeInBytes = "classifiableSizeInBytes"
        case lastUpdated = "lastUpdated"
        case objectCount = "objectCount"
        case sizeInBytes = "sizeInBytes"
        case sizeInBytesCompressed = "sizeInBytesCompressed"
        case unclassifiableObjectCount = "unclassifiableObjectCount"
        case unclassifiableObjectSizeInBytes = "unclassifiableObjectSizeInBytes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketCountDecoded = try containerValues.decode(Int.self, forKey: .bucketCount)
        bucketCount = bucketCountDecoded
        let bucketCountByEffectivePermissionDecoded = try containerValues.decodeIfPresent(BucketCountByEffectivePermission.self, forKey: .bucketCountByEffectivePermission)
        bucketCountByEffectivePermission = bucketCountByEffectivePermissionDecoded
        let bucketCountByEncryptionTypeDecoded = try containerValues.decodeIfPresent(BucketCountByEncryptionType.self, forKey: .bucketCountByEncryptionType)
        bucketCountByEncryptionType = bucketCountByEncryptionTypeDecoded
        let bucketCountByObjectEncryptionRequirementDecoded = try containerValues.decodeIfPresent(BucketCountPolicyAllowsUnencryptedObjectUploads.self, forKey: .bucketCountByObjectEncryptionRequirement)
        bucketCountByObjectEncryptionRequirement = bucketCountByObjectEncryptionRequirementDecoded
        let bucketCountBySharedAccessTypeDecoded = try containerValues.decodeIfPresent(BucketCountBySharedAccessType.self, forKey: .bucketCountBySharedAccessType)
        bucketCountBySharedAccessType = bucketCountBySharedAccessTypeDecoded
        let classifiableObjectCountDecoded = try containerValues.decode(Int.self, forKey: .classifiableObjectCount)
        classifiableObjectCount = classifiableObjectCountDecoded
        let classifiableSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .classifiableSizeInBytes)
        classifiableSizeInBytes = classifiableSizeInBytesDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let objectCountDecoded = try containerValues.decode(Int.self, forKey: .objectCount)
        objectCount = objectCountDecoded
        let sizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let sizeInBytesCompressedDecoded = try containerValues.decode(Int.self, forKey: .sizeInBytesCompressed)
        sizeInBytesCompressed = sizeInBytesCompressedDecoded
        let unclassifiableObjectCountDecoded = try containerValues.decodeIfPresent(ObjectLevelStatistics.self, forKey: .unclassifiableObjectCount)
        unclassifiableObjectCount = unclassifiableObjectCountDecoded
        let unclassifiableObjectSizeInBytesDecoded = try containerValues.decodeIfPresent(ObjectLevelStatistics.self, forKey: .unclassifiableObjectSizeInBytes)
        unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytesDecoded
    }
}

extension GetClassificationExportConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClassificationExportConfigurationInput()"}
}

extension GetClassificationExportConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetClassificationExportConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetClassificationExportConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClassificationExportConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClassificationExportConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClassificationExportConfigurationInput>
    public typealias MOutput = OperationOutput<GetClassificationExportConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClassificationExportConfigurationOutputError>
}

public struct GetClassificationExportConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetClassificationExportConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetClassificationExportConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetClassificationExportConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetClassificationExportConfigurationInput>
    public typealias MOutput = OperationOutput<GetClassificationExportConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetClassificationExportConfigurationOutputError>
}

public struct GetClassificationExportConfigurationInput: Equatable {

    public init() {}
}

struct GetClassificationExportConfigurationInputBody: Equatable {
}

extension GetClassificationExportConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetClassificationExportConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetClassificationExportConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetClassificationExportConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetClassificationExportConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetClassificationExportConfigurationOutputResponse(configuration: \(String(describing: configuration)))"}
}

extension GetClassificationExportConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetClassificationExportConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configuration = output.configuration
        } else {
            self.configuration = nil
        }
    }
}

public struct GetClassificationExportConfigurationOutputResponse: Equatable {
    /// <p>The location where data classification results are stored, and the encryption settings that are used when storing results in that location.</p>
    public let configuration: ClassificationExportConfiguration?

    public init (
        configuration: ClassificationExportConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct GetClassificationExportConfigurationOutputResponseBody: Equatable {
    public let configuration: ClassificationExportConfiguration?
}

extension GetClassificationExportConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "configuration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(ClassificationExportConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension GetCustomDataIdentifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCustomDataIdentifierInput(id: \(String(describing: id)))"}
}

extension GetCustomDataIdentifierInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCustomDataIdentifierInputHeadersMiddleware: Middleware {
    public let id: String = "GetCustomDataIdentifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCustomDataIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCustomDataIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCustomDataIdentifierInput>
    public typealias MOutput = OperationOutput<GetCustomDataIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCustomDataIdentifierOutputError>
}

public struct GetCustomDataIdentifierInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCustomDataIdentifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCustomDataIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCustomDataIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCustomDataIdentifierInput>
    public typealias MOutput = OperationOutput<GetCustomDataIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCustomDataIdentifierOutputError>
}

public struct GetCustomDataIdentifierInput: Equatable {
    /// <p>The unique identifier for the Amazon Macie resource or account that the request applies to.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetCustomDataIdentifierInputBody: Equatable {
}

extension GetCustomDataIdentifierInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCustomDataIdentifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCustomDataIdentifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCustomDataIdentifierOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCustomDataIdentifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCustomDataIdentifierOutputResponse(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), deleted: \(String(describing: deleted)), description: \(String(describing: description)), id: \(String(describing: id)), ignoreWords: \(String(describing: ignoreWords)), keywords: \(String(describing: keywords)), maximumMatchDistance: \(String(describing: maximumMatchDistance)), name: \(String(describing: name)), regex: \(String(describing: regex)), tags: \(String(describing: tags)))"}
}

extension GetCustomDataIdentifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCustomDataIdentifierOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.deleted = output.deleted
            self.description = output.description
            self.id = output.id
            self.ignoreWords = output.ignoreWords
            self.keywords = output.keywords
            self.maximumMatchDistance = output.maximumMatchDistance
            self.name = output.name
            self.regex = output.regex
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.deleted = false
            self.description = nil
            self.id = nil
            self.ignoreWords = nil
            self.keywords = nil
            self.maximumMatchDistance = 0
            self.name = nil
            self.regex = nil
            self.tags = nil
        }
    }
}

public struct GetCustomDataIdentifierOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the custom data identifier.</p>
    public let arn: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the custom data identifier was created.</p>
    public let createdAt: Date?
    /// <p>Specifies whether the custom data identifier was deleted. If you delete a custom data identifier, Amazon Macie doesn't delete it permanently. Instead, it soft deletes the identifier.</p>
    public let deleted: Bool
    /// <p>The custom description of the custom data identifier.</p>
    public let description: String?
    /// <p>The unique identifier for the custom data identifier.</p>
    public let id: String?
    /// <p>An array that lists specific character sequences (ignore words) to exclude from the results. If the text matched by the regular expression is the same as any string in this array, Amazon Macie ignores it. Ignore words are case sensitive.</p>
    public let ignoreWords: [String]?
    /// <p>An array that lists specific character sequences (keywords), one of which must be within proximity (maximumMatchDistance) of the regular expression to match. Keywords aren't case sensitive.</p>
    public let keywords: [String]?
    /// <p>The maximum number of characters that can exist between text that matches the regex pattern and the character sequences specified by the keywords array. Macie includes or excludes a result based on the proximity of a keyword to text that matches the regex pattern.</p>
    public let maximumMatchDistance: Int
    /// <p>The custom name of the custom data identifier.</p>
    public let name: String?
    /// <p>The regular expression (<i>regex</i>) that defines the pattern to match.</p>
    public let regex: String?
    /// <p>A map of key-value pairs that identifies the tags (keys and values) that are associated with the custom data identifier.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        deleted: Bool = false,
        description: String? = nil,
        id: String? = nil,
        ignoreWords: [String]? = nil,
        keywords: [String]? = nil,
        maximumMatchDistance: Int = 0,
        name: String? = nil,
        regex: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.deleted = deleted
        self.description = description
        self.id = id
        self.ignoreWords = ignoreWords
        self.keywords = keywords
        self.maximumMatchDistance = maximumMatchDistance
        self.name = name
        self.regex = regex
        self.tags = tags
    }
}

struct GetCustomDataIdentifierOutputResponseBody: Equatable {
    public let arn: String?
    public let createdAt: Date?
    public let deleted: Bool
    public let description: String?
    public let id: String?
    public let ignoreWords: [String]?
    public let keywords: [String]?
    public let maximumMatchDistance: Int
    public let name: String?
    public let regex: String?
    public let tags: [String:String]?
}

extension GetCustomDataIdentifierOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case deleted = "deleted"
        case description = "description"
        case id = "id"
        case ignoreWords = "ignoreWords"
        case keywords = "keywords"
        case maximumMatchDistance = "maximumMatchDistance"
        case name = "name"
        case regex = "regex"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deletedDecoded = try containerValues.decode(Bool.self, forKey: .deleted)
        deleted = deletedDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let ignoreWordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ignoreWords)
        var ignoreWordsDecoded0:[String]? = nil
        if let ignoreWordsContainer = ignoreWordsContainer {
            ignoreWordsDecoded0 = [String]()
            for string0 in ignoreWordsContainer {
                if let string0 = string0 {
                    ignoreWordsDecoded0?.append(string0)
                }
            }
        }
        ignoreWords = ignoreWordsDecoded0
        let keywordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .keywords)
        var keywordsDecoded0:[String]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [String]()
            for string0 in keywordsContainer {
                if let string0 = string0 {
                    keywordsDecoded0?.append(string0)
                }
            }
        }
        keywords = keywordsDecoded0
        let maximumMatchDistanceDecoded = try containerValues.decode(Int.self, forKey: .maximumMatchDistance)
        maximumMatchDistance = maximumMatchDistanceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let regexDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regex)
        regex = regexDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct GetFindingStatisticsInputBodyMiddleware: Middleware {
    public let id: String = "GetFindingStatisticsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingStatisticsInput>
    public typealias MOutput = OperationOutput<GetFindingStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingStatisticsOutputError>
}

extension GetFindingStatisticsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingStatisticsInput(findingCriteria: \(String(describing: findingCriteria)), groupBy: \(String(describing: groupBy)), size: \(String(describing: size)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension GetFindingStatisticsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingCriteria = "findingCriteria"
        case groupBy = "groupBy"
        case size = "size"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingCriteria = findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let groupBy = groupBy {
            try encodeContainer.encode(groupBy.rawValue, forKey: .groupBy)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let sortCriteria = sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

public struct GetFindingStatisticsInputHeadersMiddleware: Middleware {
    public let id: String = "GetFindingStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingStatisticsInput>
    public typealias MOutput = OperationOutput<GetFindingStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingStatisticsOutputError>
}

public struct GetFindingStatisticsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFindingStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingStatisticsInput>
    public typealias MOutput = OperationOutput<GetFindingStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingStatisticsOutputError>
}

public struct GetFindingStatisticsInput: Equatable {
    /// <p>The criteria to use to filter the query results.</p>
    public let findingCriteria: FindingCriteria?
    /// <p>The finding property to use to group the query results. Valid values are:</p> <ul><li><p>classificationDetails.jobId - The unique identifier for the classification job that produced the finding.</p></li> <li><p>resourcesAffected.s3Bucket.name - The name of the S3 bucket that the finding applies to.</p></li> <li><p>severity.description - The severity level of the finding, such as High or Medium.</p></li> <li><p>type - The type of finding, such as Policy:IAMUser/S3BucketPublic and SensitiveData:S3Object/Personal.</p></li></ul>
    public let groupBy: GroupBy?
    /// <p>The maximum number of items to include in each page of the response.</p>
    public let size: Int
    /// <p>The criteria to use to sort the query results.</p>
    public let sortCriteria: FindingStatisticsSortCriteria?

    public init (
        findingCriteria: FindingCriteria? = nil,
        groupBy: GroupBy? = nil,
        size: Int = 0,
        sortCriteria: FindingStatisticsSortCriteria? = nil
    )
    {
        self.findingCriteria = findingCriteria
        self.groupBy = groupBy
        self.size = size
        self.sortCriteria = sortCriteria
    }
}

struct GetFindingStatisticsInputBody: Equatable {
    public let findingCriteria: FindingCriteria?
    public let groupBy: GroupBy?
    public let size: Int
    public let sortCriteria: FindingStatisticsSortCriteria?
}

extension GetFindingStatisticsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingCriteria = "findingCriteria"
        case groupBy = "groupBy"
        case size = "size"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(GroupBy.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(FindingStatisticsSortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension GetFindingStatisticsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingStatisticsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingStatisticsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingStatisticsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingStatisticsOutputResponse(countsByGroup: \(String(describing: countsByGroup)))"}
}

extension GetFindingStatisticsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFindingStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.countsByGroup = output.countsByGroup
        } else {
            self.countsByGroup = nil
        }
    }
}

public struct GetFindingStatisticsOutputResponse: Equatable {
    /// <p>An array of objects, one for each group of findings that meet the filter criteria specified in the request.</p>
    public let countsByGroup: [GroupCount]?

    public init (
        countsByGroup: [GroupCount]? = nil
    )
    {
        self.countsByGroup = countsByGroup
    }
}

struct GetFindingStatisticsOutputResponseBody: Equatable {
    public let countsByGroup: [GroupCount]?
}

extension GetFindingStatisticsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case countsByGroup = "countsByGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countsByGroupContainer = try containerValues.decodeIfPresent([GroupCount?].self, forKey: .countsByGroup)
        var countsByGroupDecoded0:[GroupCount]? = nil
        if let countsByGroupContainer = countsByGroupContainer {
            countsByGroupDecoded0 = [GroupCount]()
            for structure0 in countsByGroupContainer {
                if let structure0 = structure0 {
                    countsByGroupDecoded0?.append(structure0)
                }
            }
        }
        countsByGroup = countsByGroupDecoded0
    }
}

extension GetFindingsFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsFilterInput(id: \(String(describing: id)))"}
}

extension GetFindingsFilterInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFindingsFilterInputHeadersMiddleware: Middleware {
    public let id: String = "GetFindingsFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsFilterInput>
    public typealias MOutput = OperationOutput<GetFindingsFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsFilterOutputError>
}

public struct GetFindingsFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFindingsFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsFilterInput>
    public typealias MOutput = OperationOutput<GetFindingsFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsFilterOutputError>
}

public struct GetFindingsFilterInput: Equatable {
    /// <p>The unique identifier for the Amazon Macie resource or account that the request applies to.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetFindingsFilterInputBody: Equatable {
}

extension GetFindingsFilterInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFindingsFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingsFilterOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsFilterOutputResponse(action: \(String(describing: action)), arn: \(String(describing: arn)), description: \(String(describing: description)), findingCriteria: \(String(describing: findingCriteria)), id: \(String(describing: id)), name: \(String(describing: name)), position: \(String(describing: position)), tags: \(String(describing: tags)))"}
}

extension GetFindingsFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFindingsFilterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.action = output.action
            self.arn = output.arn
            self.description = output.description
            self.findingCriteria = output.findingCriteria
            self.id = output.id
            self.name = output.name
            self.position = output.position
            self.tags = output.tags
        } else {
            self.action = nil
            self.arn = nil
            self.description = nil
            self.findingCriteria = nil
            self.id = nil
            self.name = nil
            self.position = 0
            self.tags = nil
        }
    }
}

public struct GetFindingsFilterOutputResponse: Equatable {
    /// <p>The action that's performed on findings that meet the filter criteria (findingCriteria). Possible values are: ARCHIVE, suppress (automatically archive) the findings; and, NOOP, don't perform any action on the findings.</p>
    public let action: FindingsFilterAction?
    /// <p>The Amazon Resource Name (ARN) of the filter.</p>
    public let arn: String?
    /// <p>The custom description of the filter.</p>
    public let description: String?
    /// <p>The criteria that's used to filter findings.</p>
    public let findingCriteria: FindingCriteria?
    /// <p>The unique identifier for the filter.</p>
    public let id: String?
    /// <p>The custom name of the filter.</p>
    public let name: String?
    /// <p>The position of the filter in the list of saved filters on the Amazon Macie console. This value also determines the order in which the filter is applied to findings, relative to other filters that are also applied to the findings.</p>
    public let position: Int
    /// <p>A map of key-value pairs that identifies the tags (keys and values) that are associated with the filter.</p>
    public let tags: [String:String]?

    public init (
        action: FindingsFilterAction? = nil,
        arn: String? = nil,
        description: String? = nil,
        findingCriteria: FindingCriteria? = nil,
        id: String? = nil,
        name: String? = nil,
        position: Int = 0,
        tags: [String:String]? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.description = description
        self.findingCriteria = findingCriteria
        self.id = id
        self.name = name
        self.position = position
        self.tags = tags
    }
}

struct GetFindingsFilterOutputResponseBody: Equatable {
    public let action: FindingsFilterAction?
    public let arn: String?
    public let description: String?
    public let findingCriteria: FindingCriteria?
    public let id: String?
    public let name: String?
    public let position: Int
    public let tags: [String:String]?
}

extension GetFindingsFilterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case arn = "arn"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case id = "id"
        case name = "name"
        case position = "position"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(FindingsFilterAction.self, forKey: .action)
        action = actionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let positionDecoded = try containerValues.decode(Int.self, forKey: .position)
        position = positionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct GetFindingsInputBodyMiddleware: Middleware {
    public let id: String = "GetFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsInput>
    public typealias MOutput = OperationOutput<GetFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsOutputError>
}

extension GetFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsInput(findingIds: \(String(describing: findingIds)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension GetFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingIds = "findingIds"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for __listof__string0 in findingIds {
                try findingIdsContainer.encode(__listof__string0)
            }
        }
        if let sortCriteria = sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

public struct GetFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsInput>
    public typealias MOutput = OperationOutput<GetFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsOutputError>
}

public struct GetFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsInput>
    public typealias MOutput = OperationOutput<GetFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsOutputError>
}

public struct GetFindingsInput: Equatable {
    /// <p>An array of strings that lists the unique identifiers for the findings to retrieve.</p>
    public let findingIds: [String]?
    /// <p>The criteria for sorting the results of the request.</p>
    public let sortCriteria: SortCriteria?

    public init (
        findingIds: [String]? = nil,
        sortCriteria: SortCriteria? = nil
    )
    {
        self.findingIds = findingIds
        self.sortCriteria = sortCriteria
    }
}

struct GetFindingsInputBody: Equatable {
    public let findingIds: [String]?
    public let sortCriteria: SortCriteria?
}

extension GetFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingIds = "findingIds"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension GetFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsOutputResponse(findings: \(String(describing: findings)))"}
}

extension GetFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.findings = output.findings
        } else {
            self.findings = nil
        }
    }
}

public struct GetFindingsOutputResponse: Equatable {
    /// <p>An array of objects, one for each finding that meets the criteria specified in the request.</p>
    public let findings: [Finding]?

    public init (
        findings: [Finding]? = nil
    )
    {
        self.findings = findings
    }
}

struct GetFindingsOutputResponseBody: Equatable {
    public let findings: [Finding]?
}

extension GetFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findings = "findings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([Finding?].self, forKey: .findings)
        var findingsDecoded0:[Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
    }
}

extension GetFindingsPublicationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsPublicationConfigurationInput()"}
}

extension GetFindingsPublicationConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFindingsPublicationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetFindingsPublicationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsPublicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsPublicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsPublicationConfigurationInput>
    public typealias MOutput = OperationOutput<GetFindingsPublicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsPublicationConfigurationOutputError>
}

public struct GetFindingsPublicationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFindingsPublicationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsPublicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsPublicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsPublicationConfigurationInput>
    public typealias MOutput = OperationOutput<GetFindingsPublicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsPublicationConfigurationOutputError>
}

public struct GetFindingsPublicationConfigurationInput: Equatable {

    public init() {}
}

struct GetFindingsPublicationConfigurationInputBody: Equatable {
}

extension GetFindingsPublicationConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFindingsPublicationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsPublicationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingsPublicationConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsPublicationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsPublicationConfigurationOutputResponse(securityHubConfiguration: \(String(describing: securityHubConfiguration)))"}
}

extension GetFindingsPublicationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFindingsPublicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.securityHubConfiguration = output.securityHubConfiguration
        } else {
            self.securityHubConfiguration = nil
        }
    }
}

public struct GetFindingsPublicationConfigurationOutputResponse: Equatable {
    /// <p>The configuration settings that determine which findings are published to AWS Security Hub.</p>
    public let securityHubConfiguration: SecurityHubConfiguration?

    public init (
        securityHubConfiguration: SecurityHubConfiguration? = nil
    )
    {
        self.securityHubConfiguration = securityHubConfiguration
    }
}

struct GetFindingsPublicationConfigurationOutputResponseBody: Equatable {
    public let securityHubConfiguration: SecurityHubConfiguration?
}

extension GetFindingsPublicationConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case securityHubConfiguration = "securityHubConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityHubConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubConfiguration.self, forKey: .securityHubConfiguration)
        securityHubConfiguration = securityHubConfigurationDecoded
    }
}

extension GetInvitationsCountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInvitationsCountInput()"}
}

extension GetInvitationsCountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetInvitationsCountInputHeadersMiddleware: Middleware {
    public let id: String = "GetInvitationsCountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInvitationsCountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInvitationsCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInvitationsCountInput>
    public typealias MOutput = OperationOutput<GetInvitationsCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInvitationsCountOutputError>
}

public struct GetInvitationsCountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInvitationsCountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInvitationsCountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInvitationsCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInvitationsCountInput>
    public typealias MOutput = OperationOutput<GetInvitationsCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInvitationsCountOutputError>
}

public struct GetInvitationsCountInput: Equatable {

    public init() {}
}

struct GetInvitationsCountInputBody: Equatable {
}

extension GetInvitationsCountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetInvitationsCountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInvitationsCountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInvitationsCountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInvitationsCountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInvitationsCountOutputResponse(invitationsCount: \(String(describing: invitationsCount)))"}
}

extension GetInvitationsCountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInvitationsCountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invitationsCount = output.invitationsCount
        } else {
            self.invitationsCount = 0
        }
    }
}

public struct GetInvitationsCountOutputResponse: Equatable {
    /// <p>The total number of invitations that were received by the account, not including the currently accepted invitation.</p>
    public let invitationsCount: Int

    public init (
        invitationsCount: Int = 0
    )
    {
        self.invitationsCount = invitationsCount
    }
}

struct GetInvitationsCountOutputResponseBody: Equatable {
    public let invitationsCount: Int
}

extension GetInvitationsCountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invitationsCount = "invitationsCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsCountDecoded = try containerValues.decode(Int.self, forKey: .invitationsCount)
        invitationsCount = invitationsCountDecoded
    }
}

extension GetMacieSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMacieSessionInput()"}
}

extension GetMacieSessionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetMacieSessionInputHeadersMiddleware: Middleware {
    public let id: String = "GetMacieSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMacieSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMacieSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMacieSessionInput>
    public typealias MOutput = OperationOutput<GetMacieSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMacieSessionOutputError>
}

public struct GetMacieSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMacieSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMacieSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMacieSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMacieSessionInput>
    public typealias MOutput = OperationOutput<GetMacieSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMacieSessionOutputError>
}

public struct GetMacieSessionInput: Equatable {

    public init() {}
}

struct GetMacieSessionInputBody: Equatable {
}

extension GetMacieSessionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetMacieSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMacieSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMacieSessionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMacieSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMacieSessionOutputResponse(createdAt: \(String(describing: createdAt)), findingPublishingFrequency: \(String(describing: findingPublishingFrequency)), serviceRole: \(String(describing: serviceRole)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

extension GetMacieSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMacieSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.findingPublishingFrequency = output.findingPublishingFrequency
            self.serviceRole = output.serviceRole
            self.status = output.status
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.findingPublishingFrequency = nil
            self.serviceRole = nil
            self.status = nil
            self.updatedAt = nil
        }
    }
}

public struct GetMacieSessionOutputResponse: Equatable {
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the Amazon Macie account was created.</p>
    public let createdAt: Date?
    /// <p>The frequency with which Macie publishes updates to policy findings for the account. This includes publishing updates to AWS Security Hub and Amazon EventBridge (formerly called Amazon CloudWatch Events).</p>
    public let findingPublishingFrequency: FindingPublishingFrequency?
    /// <p>The Amazon Resource Name (ARN) of the service-linked role that allows Macie to monitor and analyze data in AWS resources for the account.</p>
    public let serviceRole: String?
    /// <p>The current status of the Macie account. Possible values are: PAUSED, the account is enabled but all Macie activities are suspended (paused) for the account; and, ENABLED, the account is enabled and all Macie activities are enabled for the account.</p>
    public let status: MacieStatus?
    /// <p>The date and time, in UTC and extended ISO 8601 format, of the most recent change to the status of the Macie account.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        findingPublishingFrequency: FindingPublishingFrequency? = nil,
        serviceRole: String? = nil,
        status: MacieStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.findingPublishingFrequency = findingPublishingFrequency
        self.serviceRole = serviceRole
        self.status = status
        self.updatedAt = updatedAt
    }
}

struct GetMacieSessionOutputResponseBody: Equatable {
    public let createdAt: Date?
    public let findingPublishingFrequency: FindingPublishingFrequency?
    public let serviceRole: String?
    public let status: MacieStatus?
    public let updatedAt: Date?
}

extension GetMacieSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "createdAt"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case serviceRole = "serviceRole"
        case status = "status"
        case updatedAt = "updatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MacieStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GetMasterAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMasterAccountInput()"}
}

extension GetMasterAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetMasterAccountInputHeadersMiddleware: Middleware {
    public let id: String = "GetMasterAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMasterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMasterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMasterAccountInput>
    public typealias MOutput = OperationOutput<GetMasterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMasterAccountOutputError>
}

public struct GetMasterAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMasterAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMasterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMasterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMasterAccountInput>
    public typealias MOutput = OperationOutput<GetMasterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMasterAccountOutputError>
}

public struct GetMasterAccountInput: Equatable {

    public init() {}
}

struct GetMasterAccountInputBody: Equatable {
}

extension GetMasterAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetMasterAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMasterAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMasterAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMasterAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMasterAccountOutputResponse(master: \(String(describing: master)))"}
}

extension GetMasterAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMasterAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.master = output.master
        } else {
            self.master = nil
        }
    }
}

public struct GetMasterAccountOutputResponse: Equatable {
    /// <p>(Deprecated) The AWS account ID for the administrator account. If the accounts are associated by a Macie membership invitation, this object also provides details about the invitation that was sent to establish the relationship between the accounts.</p>
    public let master: Invitation?

    public init (
        master: Invitation? = nil
    )
    {
        self.master = master
    }
}

struct GetMasterAccountOutputResponseBody: Equatable {
    public let master: Invitation?
}

extension GetMasterAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case master = "master"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterDecoded = try containerValues.decodeIfPresent(Invitation.self, forKey: .master)
        master = masterDecoded
    }
}

extension GetMemberInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMemberInput(id: \(String(describing: id)))"}
}

extension GetMemberInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetMemberInputHeadersMiddleware: Middleware {
    public let id: String = "GetMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMemberInput>
    public typealias MOutput = OperationOutput<GetMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMemberOutputError>
}

public struct GetMemberInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMemberInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMemberInput>
    public typealias MOutput = OperationOutput<GetMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMemberOutputError>
}

public struct GetMemberInput: Equatable {
    /// <p>The unique identifier for the Amazon Macie resource or account that the request applies to.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetMemberInputBody: Equatable {
}

extension GetMemberInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetMemberOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMemberOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMemberOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMemberOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMemberOutputResponse(accountId: \(String(describing: accountId)), administratorAccountId: \(String(describing: administratorAccountId)), arn: \(String(describing: arn)), email: \(String(describing: email)), invitedAt: \(String(describing: invitedAt)), masterAccountId: \(String(describing: masterAccountId)), relationshipStatus: \(String(describing: relationshipStatus)), tags: \(String(describing: tags)), updatedAt: \(String(describing: updatedAt)))"}
}

extension GetMemberOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMemberOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountId = output.accountId
            self.administratorAccountId = output.administratorAccountId
            self.arn = output.arn
            self.email = output.email
            self.invitedAt = output.invitedAt
            self.masterAccountId = output.masterAccountId
            self.relationshipStatus = output.relationshipStatus
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.accountId = nil
            self.administratorAccountId = nil
            self.arn = nil
            self.email = nil
            self.invitedAt = nil
            self.masterAccountId = nil
            self.relationshipStatus = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetMemberOutputResponse: Equatable {
    /// <p>The AWS account ID for the account.</p>
    public let accountId: String?
    /// <p>The AWS account ID for the administrator account.</p>
    public let administratorAccountId: String?
    /// <p>The Amazon Resource Name (ARN) of the account.</p>
    public let arn: String?
    /// <p>The email address for the account.</p>
    public let email: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when an Amazon Macie membership invitation was last sent to the account. This value is null if a Macie invitation hasn't been sent to the account.</p>
    public let invitedAt: Date?
    /// <p>(Deprecated) The AWS account ID for the administrator account. This property has been replaced by the administratorAccountId property and is retained only for backward compatibility.</p>
    public let masterAccountId: String?
    /// <p>The current status of the relationship between the account and the administrator account.</p>
    public let relationshipStatus: RelationshipStatus?
    /// <p>A map of key-value pairs that identifies the tags (keys and values) that are associated with the member account in Amazon Macie.</p>
    public let tags: [String:String]?
    /// <p>The date and time, in UTC and extended ISO 8601 format, of the most recent change to the status of the relationship between the account and the administrator account.</p>
    public let updatedAt: Date?

    public init (
        accountId: String? = nil,
        administratorAccountId: String? = nil,
        arn: String? = nil,
        email: String? = nil,
        invitedAt: Date? = nil,
        masterAccountId: String? = nil,
        relationshipStatus: RelationshipStatus? = nil,
        tags: [String:String]? = nil,
        updatedAt: Date? = nil
    )
    {
        self.accountId = accountId
        self.administratorAccountId = administratorAccountId
        self.arn = arn
        self.email = email
        self.invitedAt = invitedAt
        self.masterAccountId = masterAccountId
        self.relationshipStatus = relationshipStatus
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetMemberOutputResponseBody: Equatable {
    public let accountId: String?
    public let administratorAccountId: String?
    public let arn: String?
    public let email: String?
    public let invitedAt: Date?
    public let masterAccountId: String?
    public let relationshipStatus: RelationshipStatus?
    public let tags: [String:String]?
    public let updatedAt: Date?
}

extension GetMemberOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case administratorAccountId = "administratorAccountId"
        case arn = "arn"
        case email = "email"
        case invitedAt = "invitedAt"
        case masterAccountId = "masterAccountId"
        case relationshipStatus = "relationshipStatus"
        case tags = "tags"
        case updatedAt = "updatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let administratorAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .administratorAccountId)
        administratorAccountId = administratorAccountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let masterAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterAccountId)
        masterAccountId = masterAccountIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(RelationshipStatus.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

public struct GetUsageStatisticsInputBodyMiddleware: Middleware {
    public let id: String = "GetUsageStatisticsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageStatisticsInput>
    public typealias MOutput = OperationOutput<GetUsageStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageStatisticsOutputError>
}

extension GetUsageStatisticsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsageStatisticsInput(filterBy: \(String(describing: filterBy)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)), timeRange: \(String(describing: timeRange)))"}
}

extension GetUsageStatisticsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterBy = "filterBy"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortBy = "sortBy"
        case timeRange = "timeRange"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterBy = filterBy {
            var filterByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterBy)
            for __listofusagestatisticsfilter0 in filterBy {
                try filterByContainer.encode(__listofusagestatisticsfilter0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timeRange = timeRange {
            try encodeContainer.encode(timeRange.rawValue, forKey: .timeRange)
        }
    }
}

public struct GetUsageStatisticsInputHeadersMiddleware: Middleware {
    public let id: String = "GetUsageStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageStatisticsInput>
    public typealias MOutput = OperationOutput<GetUsageStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageStatisticsOutputError>
}

public struct GetUsageStatisticsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUsageStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageStatisticsInput>
    public typealias MOutput = OperationOutput<GetUsageStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageStatisticsOutputError>
}

public struct GetUsageStatisticsInput: Equatable {
    /// <p>An array of objects, one for each condition to use to filter the query results. If you specify more than one condition, Amazon Macie uses an AND operator to join the conditions.</p>
    public let filterBy: [UsageStatisticsFilter]?
    /// <p>The maximum number of items to include in each page of the response.</p>
    public let maxResults: Int
    /// <p>The nextToken string that specifies which page of results to return in a paginated response.</p>
    public let nextToken: String?
    /// <p>The criteria to use to sort the query results.</p>
    public let sortBy: UsageStatisticsSortBy?
    /// <p>The inclusive time period to query usage data for. Valid values are: MONTH_TO_DATE, for the current calendar month to date; and, PAST_30_DAYS, for the preceding 30 days. If you don't specify a value, Amazon Macie provides usage data for the preceding 30 days.</p>
    public let timeRange: TimeRange?

    public init (
        filterBy: [UsageStatisticsFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        sortBy: UsageStatisticsSortBy? = nil,
        timeRange: TimeRange? = nil
    )
    {
        self.filterBy = filterBy
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.timeRange = timeRange
    }
}

struct GetUsageStatisticsInputBody: Equatable {
    public let filterBy: [UsageStatisticsFilter]?
    public let maxResults: Int
    public let nextToken: String?
    public let sortBy: UsageStatisticsSortBy?
    public let timeRange: TimeRange?
}

extension GetUsageStatisticsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filterBy = "filterBy"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortBy = "sortBy"
        case timeRange = "timeRange"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterByContainer = try containerValues.decodeIfPresent([UsageStatisticsFilter?].self, forKey: .filterBy)
        var filterByDecoded0:[UsageStatisticsFilter]? = nil
        if let filterByContainer = filterByContainer {
            filterByDecoded0 = [UsageStatisticsFilter]()
            for structure0 in filterByContainer {
                if let structure0 = structure0 {
                    filterByDecoded0?.append(structure0)
                }
            }
        }
        filterBy = filterByDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(UsageStatisticsSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let timeRangeDecoded = try containerValues.decodeIfPresent(TimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
    }
}

extension GetUsageStatisticsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsageStatisticsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsageStatisticsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsageStatisticsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsageStatisticsOutputResponse(nextToken: \(String(describing: nextToken)), records: \(String(describing: records)), timeRange: \(String(describing: timeRange)))"}
}

extension GetUsageStatisticsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUsageStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.records = output.records
            self.timeRange = output.timeRange
        } else {
            self.nextToken = nil
            self.records = nil
            self.timeRange = nil
        }
    }
}

public struct GetUsageStatisticsOutputResponse: Equatable {
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?
    /// <p>An array of objects that contains the results of the query. Each object contains the data for an account that meets the filter criteria specified in the request.</p>
    public let records: [UsageRecord]?
    /// <p>The inclusive time period that the usage data applies to. Possible values are: MONTH_TO_DATE, for the current calendar month to date; and, PAST_30_DAYS, for the preceding 30 days.</p>
    public let timeRange: TimeRange?

    public init (
        nextToken: String? = nil,
        records: [UsageRecord]? = nil,
        timeRange: TimeRange? = nil
    )
    {
        self.nextToken = nextToken
        self.records = records
        self.timeRange = timeRange
    }
}

struct GetUsageStatisticsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let records: [UsageRecord]?
    public let timeRange: TimeRange?
}

extension GetUsageStatisticsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case records = "records"
        case timeRange = "timeRange"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recordsContainer = try containerValues.decodeIfPresent([UsageRecord?].self, forKey: .records)
        var recordsDecoded0:[UsageRecord]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [UsageRecord]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let timeRangeDecoded = try containerValues.decodeIfPresent(TimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
    }
}

extension GetUsageTotalsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsageTotalsInput(timeRange: \(String(describing: timeRange)))"}
}

extension GetUsageTotalsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetUsageTotalsInputHeadersMiddleware: Middleware {
    public let id: String = "GetUsageTotalsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageTotalsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageTotalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageTotalsInput>
    public typealias MOutput = OperationOutput<GetUsageTotalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageTotalsOutputError>
}

public struct GetUsageTotalsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUsageTotalsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageTotalsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageTotalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let timeRange = input.operationInput.timeRange {
            let timeRangeQueryItem = URLQueryItem(name: "timeRange".urlPercentEncoding(), value: String(timeRange).urlPercentEncoding())
            input.builder.withQueryItem(timeRangeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageTotalsInput>
    public typealias MOutput = OperationOutput<GetUsageTotalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageTotalsOutputError>
}

public struct GetUsageTotalsInput: Equatable {
    /// <p>The inclusive time period to retrieve the data for. Valid values are: MONTH_TO_DATE, for the current calendar month to date; and, PAST_30_DAYS, for the preceding 30 days. If you don't specify a value for this parameter, Amazon Macie provides aggregated usage data for the preceding 30 days.</p>
    public let timeRange: String?

    public init (
        timeRange: String? = nil
    )
    {
        self.timeRange = timeRange
    }
}

struct GetUsageTotalsInputBody: Equatable {
}

extension GetUsageTotalsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetUsageTotalsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsageTotalsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsageTotalsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsageTotalsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsageTotalsOutputResponse(timeRange: \(String(describing: timeRange)), usageTotals: \(String(describing: usageTotals)))"}
}

extension GetUsageTotalsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUsageTotalsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.timeRange = output.timeRange
            self.usageTotals = output.usageTotals
        } else {
            self.timeRange = nil
            self.usageTotals = nil
        }
    }
}

public struct GetUsageTotalsOutputResponse: Equatable {
    /// <p>The inclusive time period that the usage data applies to. Possible values are: MONTH_TO_DATE, for the current calendar month to date; and, PAST_30_DAYS, for the preceding 30 days.</p>
    public let timeRange: TimeRange?
    /// <p>An array of objects that contains the results of the query. Each object contains the data for a specific usage metric.</p>
    public let usageTotals: [UsageTotal]?

    public init (
        timeRange: TimeRange? = nil,
        usageTotals: [UsageTotal]? = nil
    )
    {
        self.timeRange = timeRange
        self.usageTotals = usageTotals
    }
}

struct GetUsageTotalsOutputResponseBody: Equatable {
    public let timeRange: TimeRange?
    public let usageTotals: [UsageTotal]?
}

extension GetUsageTotalsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case timeRange = "timeRange"
        case usageTotals = "usageTotals"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeRangeDecoded = try containerValues.decodeIfPresent(TimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
        let usageTotalsContainer = try containerValues.decodeIfPresent([UsageTotal?].self, forKey: .usageTotals)
        var usageTotalsDecoded0:[UsageTotal]? = nil
        if let usageTotalsContainer = usageTotalsContainer {
            usageTotalsDecoded0 = [UsageTotal]()
            for structure0 in usageTotalsContainer {
                if let structure0 = structure0 {
                    usageTotalsDecoded0?.append(structure0)
                }
            }
        }
        usageTotals = usageTotalsDecoded0
    }
}

public enum GroupBy {
    case classificationdetailsJobid
    case resourcesaffectedS3bucketName
    case severityDescription
    case type
    case sdkUnknown(String)
}

extension GroupBy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GroupBy] {
        return [
            .classificationdetailsJobid,
            .resourcesaffectedS3bucketName,
            .severityDescription,
            .type,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .classificationdetailsJobid: return "classificationDetails.jobId"
        case .resourcesaffectedS3bucketName: return "resourcesAffected.s3Bucket.name"
        case .severityDescription: return "severity.description"
        case .type: return "type"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GroupBy(rawValue: rawValue) ?? GroupBy.sdkUnknown(rawValue)
    }
}

extension GroupCount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count = "count"
        case groupKey = "groupKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let groupKey = groupKey {
            try encodeContainer.encode(groupKey, forKey: .groupKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let groupKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupKey)
        groupKey = groupKeyDecoded
    }
}

extension GroupCount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupCount(count: \(String(describing: count)), groupKey: \(String(describing: groupKey)))"}
}

/// <p>Provides a group of results for a query that retrieved aggregated statistical data about findings.</p>
public struct GroupCount: Equatable {
    /// <p>The total number of findings in the group of query results.</p>
    public let count: Int
    /// <p>The name of the property that defines the group in the query results, as specified by the groupBy property in the query request.</p>
    public let groupKey: String?

    public init (
        count: Int = 0,
        groupKey: String? = nil
    )
    {
        self.count = count
        self.groupKey = groupKey
    }
}

extension IamUser: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case arn = "arn"
        case principalId = "principalId"
        case userName = "userName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension IamUser: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IamUser(accountId: \(String(describing: accountId)), arn: \(String(describing: arn)), principalId: \(String(describing: principalId)), userName: \(String(describing: userName)))"}
}

/// <p>Provides information about an AWS Identity and Access Management (IAM) user who performed an action on an affected resource.</p>
public struct IamUser: Equatable {
    /// <p>The unique identifier for the AWS account that's associated with the IAM user who performed the action.</p>
    public let accountId: String?
    /// <p>The Amazon Resource Name (ARN) of the principal that performed the action. The last section of the ARN contains the name of the user who performed the action.</p>
    public let arn: String?
    /// <p>The unique identifier for the IAM user who performed the action.</p>
    public let principalId: String?
    /// <p>The user name of the IAM user who performed the action.</p>
    public let userName: String?

    public init (
        accountId: String? = nil,
        arn: String? = nil,
        principalId: String? = nil,
        userName: String? = nil
    )
    {
        self.accountId = accountId
        self.arn = arn
        self.principalId = principalId
        self.userName = userName
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an error that occurred due to an unknown internal server error, exception, or failure.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The explanation of the error that occurred.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Invitation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case invitationId = "invitationId"
        case invitedAt = "invitedAt"
        case relationshipStatus = "relationshipStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = invitedAt {
            try encodeContainer.encode(invitedAt.timeIntervalSince1970, forKey: .invitedAt)
        }
        if let relationshipStatus = relationshipStatus {
            try encodeContainer.encode(relationshipStatus.rawValue, forKey: .relationshipStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(RelationshipStatus.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
    }
}

extension Invitation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Invitation(accountId: \(String(describing: accountId)), invitationId: \(String(describing: invitationId)), invitedAt: \(String(describing: invitedAt)), relationshipStatus: \(String(describing: relationshipStatus)))"}
}

/// <p>Provides information about an Amazon Macie membership invitation that was received by an account.</p>
public struct Invitation: Equatable {
    /// <p>The AWS account ID for the account that sent the invitation.</p>
    public let accountId: String?
    /// <p>The unique identifier for the invitation. Amazon Macie uses this identifier to validate the inviter account with the invitee account.</p>
    public let invitationId: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the invitation was sent.</p>
    public let invitedAt: Date?
    /// <p>The status of the relationship between the account that sent the invitation (<i>inviter account</i>) and the account that received the invitation (<i>invitee account</i>).</p>
    public let relationshipStatus: RelationshipStatus?

    public init (
        accountId: String? = nil,
        invitationId: String? = nil,
        invitedAt: Date? = nil,
        relationshipStatus: RelationshipStatus? = nil
    )
    {
        self.accountId = accountId
        self.invitationId = invitationId
        self.invitedAt = invitedAt
        self.relationshipStatus = relationshipStatus
    }
}

extension IpAddressDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipAddressV4 = "ipAddressV4"
        case ipCity = "ipCity"
        case ipCountry = "ipCountry"
        case ipGeoLocation = "ipGeoLocation"
        case ipOwner = "ipOwner"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddressV4 = ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
        if let ipCity = ipCity {
            try encodeContainer.encode(ipCity, forKey: .ipCity)
        }
        if let ipCountry = ipCountry {
            try encodeContainer.encode(ipCountry, forKey: .ipCountry)
        }
        if let ipGeoLocation = ipGeoLocation {
            try encodeContainer.encode(ipGeoLocation, forKey: .ipGeoLocation)
        }
        if let ipOwner = ipOwner {
            try encodeContainer.encode(ipOwner, forKey: .ipOwner)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
        let ipCityDecoded = try containerValues.decodeIfPresent(IpCity.self, forKey: .ipCity)
        ipCity = ipCityDecoded
        let ipCountryDecoded = try containerValues.decodeIfPresent(IpCountry.self, forKey: .ipCountry)
        ipCountry = ipCountryDecoded
        let ipGeoLocationDecoded = try containerValues.decodeIfPresent(IpGeoLocation.self, forKey: .ipGeoLocation)
        ipGeoLocation = ipGeoLocationDecoded
        let ipOwnerDecoded = try containerValues.decodeIfPresent(IpOwner.self, forKey: .ipOwner)
        ipOwner = ipOwnerDecoded
    }
}

extension IpAddressDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpAddressDetails(ipAddressV4: \(String(describing: ipAddressV4)), ipCity: \(String(describing: ipCity)), ipCountry: \(String(describing: ipCountry)), ipGeoLocation: \(String(describing: ipGeoLocation)), ipOwner: \(String(describing: ipOwner)))"}
}

/// <p>Provides information about the IP address of the device that an entity used to perform an action on an affected resource.</p>
public struct IpAddressDetails: Equatable {
    /// <p>The Internet Protocol version 4 (IPv4) address of the device.</p>
    public let ipAddressV4: String?
    /// <p>The city that the IP address originated from.</p>
    public let ipCity: IpCity?
    /// <p>The country that the IP address originated from.</p>
    public let ipCountry: IpCountry?
    /// <p>The geographic coordinates of the location that the IP address originated from.</p>
    public let ipGeoLocation: IpGeoLocation?
    /// <p>The registered owner of the IP address.</p>
    public let ipOwner: IpOwner?

    public init (
        ipAddressV4: String? = nil,
        ipCity: IpCity? = nil,
        ipCountry: IpCountry? = nil,
        ipGeoLocation: IpGeoLocation? = nil,
        ipOwner: IpOwner? = nil
    )
    {
        self.ipAddressV4 = ipAddressV4
        self.ipCity = ipCity
        self.ipCountry = ipCountry
        self.ipGeoLocation = ipGeoLocation
        self.ipOwner = ipOwner
    }
}

extension IpCity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IpCity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpCity(name: \(String(describing: name)))"}
}

/// <p>Provides information about the city that an IP address originated from.</p>
public struct IpCity: Equatable {
    /// <p>The name of the city.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension IpCountry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "code"
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IpCountry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpCountry(code: \(String(describing: code)), name: \(String(describing: name)))"}
}

/// <p>Provides information about the country that an IP address originated from.</p>
public struct IpCountry: Equatable {
    /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country that the IP address originated from. For example, US for the United States.</p>
    public let code: String?
    /// <p>The name of the country that the IP address originated from.</p>
    public let name: String?

    public init (
        code: String? = nil,
        name: String? = nil
    )
    {
        self.code = code
        self.name = name
    }
}

extension IpGeoLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lat = "lat"
        case lon = "lon"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if lat != 0.0 {
            try encodeContainer.encode(lat, forKey: .lat)
        }
        if lon != 0.0 {
            try encodeContainer.encode(lon, forKey: .lon)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latDecoded = try containerValues.decode(Double.self, forKey: .lat)
        lat = latDecoded
        let lonDecoded = try containerValues.decode(Double.self, forKey: .lon)
        lon = lonDecoded
    }
}

extension IpGeoLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpGeoLocation(lat: \(String(describing: lat)), lon: \(String(describing: lon)))"}
}

/// <p>Provides geographic coordinates that indicate where a specified IP address originated from.</p>
public struct IpGeoLocation: Equatable {
    /// <p>The latitude coordinate of the location, rounded to four decimal places.</p>
    public let lat: Double
    /// <p>The longitude coordinate of the location, rounded to four decimal places.</p>
    public let lon: Double

    public init (
        lat: Double = 0.0,
        lon: Double = 0.0
    )
    {
        self.lat = lat
        self.lon = lon
    }
}

extension IpOwner: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case asn = "asn"
        case asnOrg = "asnOrg"
        case isp = "isp"
        case org = "org"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asn = asn {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let asnOrg = asnOrg {
            try encodeContainer.encode(asnOrg, forKey: .asnOrg)
        }
        if let isp = isp {
            try encodeContainer.encode(isp, forKey: .isp)
        }
        if let org = org {
            try encodeContainer.encode(org, forKey: .org)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .asn)
        asn = asnDecoded
        let asnOrgDecoded = try containerValues.decodeIfPresent(String.self, forKey: .asnOrg)
        asnOrg = asnOrgDecoded
        let ispDecoded = try containerValues.decodeIfPresent(String.self, forKey: .isp)
        isp = ispDecoded
        let orgDecoded = try containerValues.decodeIfPresent(String.self, forKey: .org)
        org = orgDecoded
    }
}

extension IpOwner: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IpOwner(asn: \(String(describing: asn)), asnOrg: \(String(describing: asnOrg)), isp: \(String(describing: isp)), org: \(String(describing: org)))"}
}

/// <p>Provides information about the registered owner of an IP address.</p>
public struct IpOwner: Equatable {
    /// <p>The autonomous system number (ASN) for the autonomous system that included the IP address.</p>
    public let asn: String?
    /// <p>The organization identifier that's associated with the autonomous system number (ASN) for the autonomous system that included the IP address.</p>
    public let asnOrg: String?
    /// <p>The name of the internet service provider (ISP) that owned the IP address.</p>
    public let isp: String?
    /// <p>The name of the organization that owned the IP address.</p>
    public let org: String?

    public init (
        asn: String? = nil,
        asnOrg: String? = nil,
        isp: String? = nil,
        org: String? = nil
    )
    {
        self.asn = asn
        self.asnOrg = asnOrg
        self.isp = isp
        self.org = org
    }
}

public enum IsDefinedInJob {
    case `false`
    case `true`
    case unknown
    case sdkUnknown(String)
}

extension IsDefinedInJob : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IsDefinedInJob] {
        return [
            .false,
            .true,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .false: return "FALSE"
        case .true: return "TRUE"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IsDefinedInJob(rawValue: rawValue) ?? IsDefinedInJob.sdkUnknown(rawValue)
    }
}

public enum IsMonitoredByJob {
    case `false`
    case `true`
    case unknown
    case sdkUnknown(String)
}

extension IsMonitoredByJob : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IsMonitoredByJob] {
        return [
            .false,
            .true,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .false: return "FALSE"
        case .true: return "TRUE"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IsMonitoredByJob(rawValue: rawValue) ?? IsMonitoredByJob.sdkUnknown(rawValue)
    }
}

/// <p>The operator to use in a condition. Valid values are:</p>
public enum JobComparator {
    case contains
    case eq
    case gt
    case gte
    case lt
    case lte
    case ne
    case startsWith
    case sdkUnknown(String)
}

extension JobComparator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobComparator] {
        return [
            .contains,
            .eq,
            .gt,
            .gte,
            .lt,
            .lte,
            .ne,
            .startsWith,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "CONTAINS"
        case .eq: return "EQ"
        case .gt: return "GT"
        case .gte: return "GTE"
        case .lt: return "LT"
        case .lte: return "LTE"
        case .ne: return "NE"
        case .startsWith: return "STARTS_WITH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobComparator(rawValue: rawValue) ?? JobComparator.sdkUnknown(rawValue)
    }
}

extension JobDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isDefinedInJob = "isDefinedInJob"
        case isMonitoredByJob = "isMonitoredByJob"
        case lastJobId = "lastJobId"
        case lastJobRunTime = "lastJobRunTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isDefinedInJob = isDefinedInJob {
            try encodeContainer.encode(isDefinedInJob.rawValue, forKey: .isDefinedInJob)
        }
        if let isMonitoredByJob = isMonitoredByJob {
            try encodeContainer.encode(isMonitoredByJob.rawValue, forKey: .isMonitoredByJob)
        }
        if let lastJobId = lastJobId {
            try encodeContainer.encode(lastJobId, forKey: .lastJobId)
        }
        if let lastJobRunTime = lastJobRunTime {
            try encodeContainer.encode(lastJobRunTime.timeIntervalSince1970, forKey: .lastJobRunTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isDefinedInJobDecoded = try containerValues.decodeIfPresent(IsDefinedInJob.self, forKey: .isDefinedInJob)
        isDefinedInJob = isDefinedInJobDecoded
        let isMonitoredByJobDecoded = try containerValues.decodeIfPresent(IsMonitoredByJob.self, forKey: .isMonitoredByJob)
        isMonitoredByJob = isMonitoredByJobDecoded
        let lastJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastJobId)
        lastJobId = lastJobIdDecoded
        let lastJobRunTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastJobRunTime)
        lastJobRunTime = lastJobRunTimeDecoded
    }
}

extension JobDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobDetails(isDefinedInJob: \(String(describing: isDefinedInJob)), isMonitoredByJob: \(String(describing: isMonitoredByJob)), lastJobId: \(String(describing: lastJobId)), lastJobRunTime: \(String(describing: lastJobRunTime)))"}
}

/// <p>Specifies whether any one-time or recurring classification jobs are configured to analyze data in an S3 bucket, and, if so, the details of the job that ran most recently.</p>
public struct JobDetails: Equatable {
    /// <p>Specifies whether any one-time or recurring jobs are configured to analyze data in the bucket. Possible values are:</p> <ul><li><p>TRUE - The bucket is explicitly included in the bucket definition (S3BucketDefinitionForJob) for one or more jobs and at least one of those jobs has a status other than CANCELLED. Or the bucket matched the bucket criteria (S3BucketCriteriaForJob) for at least one job that previously ran.</p></li> <li><p>FALSE - The bucket isn't explicitly included in the bucket definition (S3BucketDefinitionForJob) for any jobs, all the jobs that explicitly include the bucket in their bucket definitions have a status of CANCELLED, or the bucket didn't match the bucket criteria (S3BucketCriteriaForJob) for any jobs that previously ran.</p></li> <li><p>UNKNOWN - An exception occurred when Amazon Macie attempted to retrieve job data for the bucket.</p></li></ul> <p></p>
    public let isDefinedInJob: IsDefinedInJob?
    /// <p>Specifies whether any recurring jobs are configured to analyze data in the bucket. Possible values are:</p> <ul><li><p>TRUE - The bucket is explicitly included in the bucket definition (S3BucketDefinitionForJob) for one or more recurring jobs or the bucket matches the bucket criteria (S3BucketCriteriaForJob) for one or more recurring jobs. At least one of those jobs has a status other than CANCELLED.</p></li> <li><p>FALSE - The bucket isn't explicitly included in the bucket definition (S3BucketDefinitionForJob) for any recurring jobs, the bucket doesn't match the bucket criteria (S3BucketCriteriaForJob) for any recurring jobs, or all the recurring jobs that are configured to analyze data in the bucket have a status of CANCELLED.</p></li> <li><p>UNKNOWN - An exception occurred when Amazon Macie attempted to retrieve job data for the bucket.</p></li></ul>
    public let isMonitoredByJob: IsMonitoredByJob?
    /// <p>The unique identifier for the job that ran most recently and is configured to analyze data in the bucket, either the latest run of a recurring job or the only run of a one-time job.</p> <p>This value is typically null if the value for the isDefinedInJob property is FALSE or UNKNOWN.</p>
    public let lastJobId: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the job (lastJobId) started. If the job is a recurring job, this value indicates when the most recent run started.</p> <p>This value is typically null if the value for the isDefinedInJob property is FALSE or UNKNOWN.</p>
    public let lastJobRunTime: Date?

    public init (
        isDefinedInJob: IsDefinedInJob? = nil,
        isMonitoredByJob: IsMonitoredByJob? = nil,
        lastJobId: String? = nil,
        lastJobRunTime: Date? = nil
    )
    {
        self.isDefinedInJob = isDefinedInJob
        self.isMonitoredByJob = isMonitoredByJob
        self.lastJobId = lastJobId
        self.lastJobRunTime = lastJobRunTime
    }
}

extension JobScheduleFrequency: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dailySchedule = "dailySchedule"
        case monthlySchedule = "monthlySchedule"
        case weeklySchedule = "weeklySchedule"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dailySchedule = dailySchedule {
            try encodeContainer.encode(dailySchedule, forKey: .dailySchedule)
        }
        if let monthlySchedule = monthlySchedule {
            try encodeContainer.encode(monthlySchedule, forKey: .monthlySchedule)
        }
        if let weeklySchedule = weeklySchedule {
            try encodeContainer.encode(weeklySchedule, forKey: .weeklySchedule)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dailyScheduleDecoded = try containerValues.decodeIfPresent(DailySchedule.self, forKey: .dailySchedule)
        dailySchedule = dailyScheduleDecoded
        let monthlyScheduleDecoded = try containerValues.decodeIfPresent(MonthlySchedule.self, forKey: .monthlySchedule)
        monthlySchedule = monthlyScheduleDecoded
        let weeklyScheduleDecoded = try containerValues.decodeIfPresent(WeeklySchedule.self, forKey: .weeklySchedule)
        weeklySchedule = weeklyScheduleDecoded
    }
}

extension JobScheduleFrequency: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobScheduleFrequency(dailySchedule: \(String(describing: dailySchedule)), monthlySchedule: \(String(describing: monthlySchedule)), weeklySchedule: \(String(describing: weeklySchedule)))"}
}

/// <p>Specifies the recurrence pattern for running a classification job.</p>
public struct JobScheduleFrequency: Equatable {
    /// <p>Specifies a daily recurrence pattern for running the job.</p>
    public let dailySchedule: DailySchedule?
    /// <p>Specifies a monthly recurrence pattern for running the job.</p>
    public let monthlySchedule: MonthlySchedule?
    /// <p>Specifies a weekly recurrence pattern for running the job.</p>
    public let weeklySchedule: WeeklySchedule?

    public init (
        dailySchedule: DailySchedule? = nil,
        monthlySchedule: MonthlySchedule? = nil,
        weeklySchedule: WeeklySchedule? = nil
    )
    {
        self.dailySchedule = dailySchedule
        self.monthlySchedule = monthlySchedule
        self.weeklySchedule = weeklySchedule
    }
}

extension JobScopeTerm: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case simpleScopeTerm = "simpleScopeTerm"
        case tagScopeTerm = "tagScopeTerm"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleScopeTerm = simpleScopeTerm {
            try encodeContainer.encode(simpleScopeTerm, forKey: .simpleScopeTerm)
        }
        if let tagScopeTerm = tagScopeTerm {
            try encodeContainer.encode(tagScopeTerm, forKey: .tagScopeTerm)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleScopeTermDecoded = try containerValues.decodeIfPresent(SimpleScopeTerm.self, forKey: .simpleScopeTerm)
        simpleScopeTerm = simpleScopeTermDecoded
        let tagScopeTermDecoded = try containerValues.decodeIfPresent(TagScopeTerm.self, forKey: .tagScopeTerm)
        tagScopeTerm = tagScopeTermDecoded
    }
}

extension JobScopeTerm: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobScopeTerm(simpleScopeTerm: \(String(describing: simpleScopeTerm)), tagScopeTerm: \(String(describing: tagScopeTerm)))"}
}

/// <p>Specifies a property- or tag-based condition that defines criteria for including or excluding S3 objects from a classification job.</p>
public struct JobScopeTerm: Equatable {
    /// <p>A property-based condition that defines a property, operator, and one or more values for including or excluding objects from the job.</p>
    public let simpleScopeTerm: SimpleScopeTerm?
    /// <p>A tag-based condition that defines the operator and tag keys or tag key and value pairs for including or excluding objects from the job.</p>
    public let tagScopeTerm: TagScopeTerm?

    public init (
        simpleScopeTerm: SimpleScopeTerm? = nil,
        tagScopeTerm: TagScopeTerm? = nil
    )
    {
        self.simpleScopeTerm = simpleScopeTerm
        self.tagScopeTerm = tagScopeTerm
    }
}

extension JobScopingBlock: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case and = "and"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for __listofjobscopeterm0 in and {
                try andContainer.encode(__listofjobscopeterm0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let andContainer = try containerValues.decodeIfPresent([JobScopeTerm?].self, forKey: .and)
        var andDecoded0:[JobScopeTerm]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [JobScopeTerm]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
    }
}

extension JobScopingBlock: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobScopingBlock(and: \(String(describing: and)))"}
}

/// <p>Specifies one or more property- and tag-based conditions that define criteria for including or excluding S3 objects from a classification job.</p>
public struct JobScopingBlock: Equatable {
    /// <p>An array of conditions, one for each condition that determines which objects to include or exclude from the job. If you specify more than one condition, Amazon Macie uses AND logic to join the conditions.</p>
    public let and: [JobScopeTerm]?

    public init (
        and: [JobScopeTerm]? = nil
    )
    {
        self.and = and
    }
}

/// <p>The status of a classification job. Possible values are:</p>
public enum JobStatus {
    case cancelled
    case complete
    case idle
    case paused
    case running
    case userPaused
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .cancelled,
            .complete,
            .idle,
            .paused,
            .running,
            .userPaused,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .complete: return "COMPLETE"
        case .idle: return "IDLE"
        case .paused: return "PAUSED"
        case .running: return "RUNNING"
        case .userPaused: return "USER_PAUSED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

extension JobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketCriteria = "bucketCriteria"
        case bucketDefinitions = "bucketDefinitions"
        case createdAt = "createdAt"
        case jobId = "jobId"
        case jobStatus = "jobStatus"
        case jobType = "jobType"
        case lastRunErrorStatus = "lastRunErrorStatus"
        case name = "name"
        case userPausedDetails = "userPausedDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketCriteria = bucketCriteria {
            try encodeContainer.encode(bucketCriteria, forKey: .bucketCriteria)
        }
        if let bucketDefinitions = bucketDefinitions {
            var bucketDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bucketDefinitions)
            for __listofs3bucketdefinitionforjob0 in bucketDefinitions {
                try bucketDefinitionsContainer.encode(__listofs3bucketdefinitionforjob0)
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let lastRunErrorStatus = lastRunErrorStatus {
            try encodeContainer.encode(lastRunErrorStatus, forKey: .lastRunErrorStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let userPausedDetails = userPausedDetails {
            try encodeContainer.encode(userPausedDetails, forKey: .userPausedDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDefinitionsContainer = try containerValues.decodeIfPresent([S3BucketDefinitionForJob?].self, forKey: .bucketDefinitions)
        var bucketDefinitionsDecoded0:[S3BucketDefinitionForJob]? = nil
        if let bucketDefinitionsContainer = bucketDefinitionsContainer {
            bucketDefinitionsDecoded0 = [S3BucketDefinitionForJob]()
            for structure0 in bucketDefinitionsContainer {
                if let structure0 = structure0 {
                    bucketDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        bucketDefinitions = bucketDefinitionsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let lastRunErrorStatusDecoded = try containerValues.decodeIfPresent(LastRunErrorStatus.self, forKey: .lastRunErrorStatus)
        lastRunErrorStatus = lastRunErrorStatusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let userPausedDetailsDecoded = try containerValues.decodeIfPresent(UserPausedDetails.self, forKey: .userPausedDetails)
        userPausedDetails = userPausedDetailsDecoded
        let bucketCriteriaDecoded = try containerValues.decodeIfPresent(S3BucketCriteriaForJob.self, forKey: .bucketCriteria)
        bucketCriteria = bucketCriteriaDecoded
    }
}

extension JobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobSummary(bucketCriteria: \(String(describing: bucketCriteria)), bucketDefinitions: \(String(describing: bucketDefinitions)), createdAt: \(String(describing: createdAt)), jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)), jobType: \(String(describing: jobType)), lastRunErrorStatus: \(String(describing: lastRunErrorStatus)), name: \(String(describing: name)), userPausedDetails: \(String(describing: userPausedDetails)))"}
}

/// <p>Provides information about a classification job, including the current status of the job.</p>
public struct JobSummary: Equatable {
    /// <p>The property- and tag-based conditions that determine which S3 buckets are included or excluded from the job's analysis. Each time the job runs, the job uses these criteria to determine which buckets to analyze. A job's definition can contain a bucketCriteria object or a bucketDefinitions array, not both.</p>
    public let bucketCriteria: S3BucketCriteriaForJob?
    /// <p>An array of objects, one for each AWS account that owns specific S3 buckets for the job to analyze. Each object specifies the account ID for an account and one or more buckets to analyze for that account. A job's definition can contain a bucketDefinitions array or a bucketCriteria object, not both.</p>
    public let bucketDefinitions: [S3BucketDefinitionForJob]?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the job was created.</p>
    public let createdAt: Date?
    /// <p>The unique identifier for the job.</p>
    public let jobId: String?
    /// <p>The current status of the job. Possible values are:</p> <ul><li><p>CANCELLED - You cancelled the job or, if it's a one-time job, you paused the job and didn't resume it within 30 days.</p></li> <li><p>COMPLETE - For a one-time job, Amazon Macie finished processing the data specified for the job. This value doesn't apply to recurring jobs.</p></li> <li><p>IDLE - For a recurring job, the previous scheduled run is complete and the next scheduled run is pending. This value doesn't apply to one-time jobs.</p></li> <li><p>PAUSED - Amazon Macie started running the job but additional processing would exceed the monthly sensitive data discovery quota for your account or one or more member accounts that the job analyzes data for.</p></li> <li><p>RUNNING - For a one-time job, the job is in progress. For a recurring job, a scheduled run is in progress.</p></li> <li><p>USER_PAUSED - You paused the job. If you paused the job while it had a status of RUNNING and you don't resume it within 30 days of pausing it, the job or job run will expire and be cancelled, depending on the job's type. To check the expiration date, refer to the UserPausedDetails.jobExpiresAt property.</p></li></ul>
    public let jobStatus: JobStatus?
    /// <p>The schedule for running the job. Possible values are:</p> <ul><li><p>ONE_TIME - The job runs only once.</p></li> <li><p>SCHEDULED - The job runs on a daily, weekly, or monthly basis.</p></li></ul>
    public let jobType: JobType?
    /// <p>Specifies whether any account- or bucket-level access errors occurred when the job ran. For a recurring job, this value indicates the error status of the job's most recent run.</p>
    public let lastRunErrorStatus: LastRunErrorStatus?
    /// <p>The custom name of the job.</p>
    public let name: String?
    /// <p>If the current status of the job is USER_PAUSED, specifies when the job was paused and when the job or job run will expire and be cancelled if it isn't resumed. This value is present only if the value for jobStatus is USER_PAUSED.</p>
    public let userPausedDetails: UserPausedDetails?

    public init (
        bucketCriteria: S3BucketCriteriaForJob? = nil,
        bucketDefinitions: [S3BucketDefinitionForJob]? = nil,
        createdAt: Date? = nil,
        jobId: String? = nil,
        jobStatus: JobStatus? = nil,
        jobType: JobType? = nil,
        lastRunErrorStatus: LastRunErrorStatus? = nil,
        name: String? = nil,
        userPausedDetails: UserPausedDetails? = nil
    )
    {
        self.bucketCriteria = bucketCriteria
        self.bucketDefinitions = bucketDefinitions
        self.createdAt = createdAt
        self.jobId = jobId
        self.jobStatus = jobStatus
        self.jobType = jobType
        self.lastRunErrorStatus = lastRunErrorStatus
        self.name = name
        self.userPausedDetails = userPausedDetails
    }
}

/// <p>The schedule for running a classification job. Valid values are:</p>
public enum JobType {
    case oneTime
    case scheduled
    case sdkUnknown(String)
}

extension JobType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobType] {
        return [
            .oneTime,
            .scheduled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .oneTime: return "ONE_TIME"
        case .scheduled: return "SCHEDULED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
    }
}

extension KeyValuePair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension KeyValuePair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyValuePair(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Provides information about the tags that are associated with an S3 bucket or object. Each tag consists of a required tag key and an associated tag value.</p>
public struct KeyValuePair: Equatable {
    /// <p>One part of a key-value pair that comprises a tag. A tag key is a general label that acts as a category for more specific tag values.</p>
    public let key: String?
    /// <p>One part of a key-value pair that comprises a tag. A tag value acts as a descriptor for a tag key. A tag value can be an empty string.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension LastRunErrorStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "code"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(LastRunErrorStatusCode.self, forKey: .code)
        code = codeDecoded
    }
}

extension LastRunErrorStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LastRunErrorStatus(code: \(String(describing: code)))"}
}

/// <p>Specifies whether any account- or bucket-level access errors occurred when a classification job ran. For information about using logging data to investigate these errors, see <a href="https://docs.aws.amazon.com/macie/latest/user/discovery-jobs-monitor-cw-logs.html">Monitoring sensitive data discovery jobs</a> in the <i>Amazon Macie User Guide</i>.</p>
public struct LastRunErrorStatus: Equatable {
    /// <p>Specifies whether any account- or bucket-level access errors occurred when the job ran. For a recurring job, this value indicates the error status of the job's most recent run. Possible values are:</p> <ul><li><p>ERROR - One or more errors occurred. Amazon Macie didn't process all the data specified for the job.</p></li> <li><p>NONE - No errors occurred. Macie processed all the data specified for the job.</p></li></ul>
    public let code: LastRunErrorStatusCode?

    public init (
        code: LastRunErrorStatusCode? = nil
    )
    {
        self.code = code
    }
}

/// <p>Specifies whether any account- or bucket-level access errors occurred during the run of a one-time classification job or the most recent run of a recurring classification job. Possible values are:</p>
public enum LastRunErrorStatusCode {
    case error
    case `none`
    case sdkUnknown(String)
}

extension LastRunErrorStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LastRunErrorStatusCode] {
        return [
            .error,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "ERROR"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LastRunErrorStatusCode(rawValue: rawValue) ?? LastRunErrorStatusCode.sdkUnknown(rawValue)
    }
}

public struct ListClassificationJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListClassificationJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClassificationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClassificationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClassificationJobsInput>
    public typealias MOutput = OperationOutput<ListClassificationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClassificationJobsOutputError>
}

extension ListClassificationJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListClassificationJobsInput(filterCriteria: \(String(describing: filterCriteria)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension ListClassificationJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterCriteria = "filterCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

public struct ListClassificationJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListClassificationJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClassificationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClassificationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClassificationJobsInput>
    public typealias MOutput = OperationOutput<ListClassificationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClassificationJobsOutputError>
}

public struct ListClassificationJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListClassificationJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClassificationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClassificationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClassificationJobsInput>
    public typealias MOutput = OperationOutput<ListClassificationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClassificationJobsOutputError>
}

public struct ListClassificationJobsInput: Equatable {
    /// <p>The criteria to use to filter the results.</p>
    public let filterCriteria: ListJobsFilterCriteria?
    /// <p>The maximum number of items to include in each page of the response.</p>
    public let maxResults: Int
    /// <p>The nextToken string that specifies which page of results to return in a paginated response.</p>
    public let nextToken: String?
    /// <p>The criteria to use to sort the results.</p>
    public let sortCriteria: ListJobsSortCriteria?

    public init (
        filterCriteria: ListJobsFilterCriteria? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        sortCriteria: ListJobsSortCriteria? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct ListClassificationJobsInputBody: Equatable {
    public let filterCriteria: ListJobsFilterCriteria?
    public let maxResults: Int
    public let nextToken: String?
    public let sortCriteria: ListJobsSortCriteria?
}

extension ListClassificationJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filterCriteria = "filterCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(ListJobsFilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(ListJobsSortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension ListClassificationJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClassificationJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListClassificationJobsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClassificationJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListClassificationJobsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListClassificationJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListClassificationJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListClassificationJobsOutputResponse: Equatable {
    /// <p>An array of objects, one for each job that meets the filter criteria specified in the request.</p>
    public let items: [JobSummary]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        items: [JobSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListClassificationJobsOutputResponseBody: Equatable {
    public let items: [JobSummary]?
    public let nextToken: String?
}

extension ListClassificationJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([JobSummary?].self, forKey: .items)
        var itemsDecoded0:[JobSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [JobSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCustomDataIdentifiersInputBodyMiddleware: Middleware {
    public let id: String = "ListCustomDataIdentifiersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomDataIdentifiersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomDataIdentifiersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomDataIdentifiersInput>
    public typealias MOutput = OperationOutput<ListCustomDataIdentifiersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomDataIdentifiersOutputError>
}

extension ListCustomDataIdentifiersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomDataIdentifiersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomDataIdentifiersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCustomDataIdentifiersInputHeadersMiddleware: Middleware {
    public let id: String = "ListCustomDataIdentifiersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomDataIdentifiersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomDataIdentifiersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomDataIdentifiersInput>
    public typealias MOutput = OperationOutput<ListCustomDataIdentifiersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomDataIdentifiersOutputError>
}

public struct ListCustomDataIdentifiersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCustomDataIdentifiersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomDataIdentifiersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomDataIdentifiersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomDataIdentifiersInput>
    public typealias MOutput = OperationOutput<ListCustomDataIdentifiersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomDataIdentifiersOutputError>
}

public struct ListCustomDataIdentifiersInput: Equatable {
    /// <p>The maximum number of items to include in each page of the response.</p>
    public let maxResults: Int
    /// <p>The nextToken string that specifies which page of results to return in a paginated response.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomDataIdentifiersInputBody: Equatable {
    public let maxResults: Int
    public let nextToken: String?
}

extension ListCustomDataIdentifiersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomDataIdentifiersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomDataIdentifiersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomDataIdentifiersOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomDataIdentifiersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomDataIdentifiersOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomDataIdentifiersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCustomDataIdentifiersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomDataIdentifiersOutputResponse: Equatable {
    /// <p>An array of objects, one for each custom data identifier.</p>
    public let items: [CustomDataIdentifierSummary]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        items: [CustomDataIdentifierSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListCustomDataIdentifiersOutputResponseBody: Equatable {
    public let items: [CustomDataIdentifierSummary]?
    public let nextToken: String?
}

extension ListCustomDataIdentifiersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CustomDataIdentifierSummary?].self, forKey: .items)
        var itemsDecoded0:[CustomDataIdentifierSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CustomDataIdentifierSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFindingsFiltersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFindingsFiltersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFindingsFiltersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFindingsFiltersInputHeadersMiddleware: Middleware {
    public let id: String = "ListFindingsFiltersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsFiltersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsFiltersInput>
    public typealias MOutput = OperationOutput<ListFindingsFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsFiltersOutputError>
}

public struct ListFindingsFiltersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFindingsFiltersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsFiltersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsFiltersInput>
    public typealias MOutput = OperationOutput<ListFindingsFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsFiltersOutputError>
}

public struct ListFindingsFiltersInput: Equatable {
    /// <p>The maximum number of items to include in each page of a paginated response.</p>
    public let maxResults: Int
    /// <p>The nextToken string that specifies which page of results to return in a paginated response.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFindingsFiltersInputBody: Equatable {
}

extension ListFindingsFiltersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFindingsFiltersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsFiltersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFindingsFiltersOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsFiltersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFindingsFiltersOutputResponse(findingsFilterListItems: \(String(describing: findingsFilterListItems)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFindingsFiltersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFindingsFiltersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.findingsFilterListItems = output.findingsFilterListItems
            self.nextToken = output.nextToken
        } else {
            self.findingsFilterListItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsFiltersOutputResponse: Equatable {
    /// <p>An array of objects, one for each filter that's associated with the account.</p>
    public let findingsFilterListItems: [FindingsFilterListItem]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        findingsFilterListItems: [FindingsFilterListItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.findingsFilterListItems = findingsFilterListItems
        self.nextToken = nextToken
    }
}

struct ListFindingsFiltersOutputResponseBody: Equatable {
    public let findingsFilterListItems: [FindingsFilterListItem]?
    public let nextToken: String?
}

extension ListFindingsFiltersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingsFilterListItems = "findingsFilterListItems"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsFilterListItemsContainer = try containerValues.decodeIfPresent([FindingsFilterListItem?].self, forKey: .findingsFilterListItems)
        var findingsFilterListItemsDecoded0:[FindingsFilterListItem]? = nil
        if let findingsFilterListItemsContainer = findingsFilterListItemsContainer {
            findingsFilterListItemsDecoded0 = [FindingsFilterListItem]()
            for structure0 in findingsFilterListItemsContainer {
                if let structure0 = structure0 {
                    findingsFilterListItemsDecoded0?.append(structure0)
                }
            }
        }
        findingsFilterListItems = findingsFilterListItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFindingsInputBodyMiddleware: Middleware {
    public let id: String = "ListFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsInput>
    public typealias MOutput = OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsOutputError>
}

extension ListFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFindingsInput(findingCriteria: \(String(describing: findingCriteria)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension ListFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingCriteria = "findingCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingCriteria = findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

public struct ListFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsInput>
    public typealias MOutput = OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsOutputError>
}

public struct ListFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsInput>
    public typealias MOutput = OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsOutputError>
}

public struct ListFindingsInput: Equatable {
    /// <p>The criteria to use to filter the results.</p>
    public let findingCriteria: FindingCriteria?
    /// <p>The maximum number of items to include in each page of the response.</p>
    public let maxResults: Int
    /// <p>The nextToken string that specifies which page of results to return in a paginated response.</p>
    public let nextToken: String?
    /// <p>The criteria to use to sort the results.</p>
    public let sortCriteria: SortCriteria?

    public init (
        findingCriteria: FindingCriteria? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        sortCriteria: SortCriteria? = nil
    )
    {
        self.findingCriteria = findingCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct ListFindingsInputBody: Equatable {
    public let findingCriteria: FindingCriteria?
    public let maxResults: Int
    public let nextToken: String?
    public let sortCriteria: SortCriteria?
}

extension ListFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingCriteria = "findingCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension ListFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFindingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFindingsOutputResponse(findingIds: \(String(describing: findingIds)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.findingIds = output.findingIds
            self.nextToken = output.nextToken
        } else {
            self.findingIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsOutputResponse: Equatable {
    /// <p>An array of strings, where each string is the unique identifier for a finding that meets the filter criteria specified in the request.</p>
    public let findingIds: [String]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        findingIds: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.findingIds = findingIds
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputResponseBody: Equatable {
    public let findingIds: [String]?
    public let nextToken: String?
}

extension ListFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingIds = "findingIds"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInvitationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInvitationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInvitationsInput>
    public typealias MOutput = OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInvitationsOutputError>
}

public struct ListInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInvitationsInput>
    public typealias MOutput = OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInvitationsOutputError>
}

public struct ListInvitationsInput: Equatable {
    /// <p>The maximum number of items to include in each page of a paginated response.</p>
    public let maxResults: Int
    /// <p>The nextToken string that specifies which page of results to return in a paginated response.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInvitationsInputBody: Equatable {
}

extension ListInvitationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInvitationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInvitationsOutputResponse(invitations: \(String(describing: invitations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invitations = output.invitations
            self.nextToken = output.nextToken
        } else {
            self.invitations = nil
            self.nextToken = nil
        }
    }
}

public struct ListInvitationsOutputResponse: Equatable {
    /// <p>An array of objects, one for each invitation that was received by the account.</p>
    public let invitations: [Invitation]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        invitations: [Invitation]? = nil,
        nextToken: String? = nil
    )
    {
        self.invitations = invitations
        self.nextToken = nextToken
    }
}

struct ListInvitationsOutputResponseBody: Equatable {
    public let invitations: [Invitation]?
    public let nextToken: String?
}

extension ListInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invitations = "invitations"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsContainer = try containerValues.decodeIfPresent([Invitation?].self, forKey: .invitations)
        var invitationsDecoded0:[Invitation]? = nil
        if let invitationsContainer = invitationsContainer {
            invitationsDecoded0 = [Invitation]()
            for structure0 in invitationsContainer {
                if let structure0 = structure0 {
                    invitationsDecoded0?.append(structure0)
                }
            }
        }
        invitations = invitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsFilterCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludes = "excludes"
        case includes = "includes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludes = excludes {
            var excludesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludes)
            for __listoflistjobsfilterterm0 in excludes {
                try excludesContainer.encode(__listoflistjobsfilterterm0)
            }
        }
        if let includes = includes {
            var includesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includes)
            for __listoflistjobsfilterterm0 in includes {
                try includesContainer.encode(__listoflistjobsfilterterm0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludesContainer = try containerValues.decodeIfPresent([ListJobsFilterTerm?].self, forKey: .excludes)
        var excludesDecoded0:[ListJobsFilterTerm]? = nil
        if let excludesContainer = excludesContainer {
            excludesDecoded0 = [ListJobsFilterTerm]()
            for structure0 in excludesContainer {
                if let structure0 = structure0 {
                    excludesDecoded0?.append(structure0)
                }
            }
        }
        excludes = excludesDecoded0
        let includesContainer = try containerValues.decodeIfPresent([ListJobsFilterTerm?].self, forKey: .includes)
        var includesDecoded0:[ListJobsFilterTerm]? = nil
        if let includesContainer = includesContainer {
            includesDecoded0 = [ListJobsFilterTerm]()
            for structure0 in includesContainer {
                if let structure0 = structure0 {
                    includesDecoded0?.append(structure0)
                }
            }
        }
        includes = includesDecoded0
    }
}

extension ListJobsFilterCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsFilterCriteria(excludes: \(String(describing: excludes)), includes: \(String(describing: includes)))"}
}

/// <p>Specifies criteria for filtering the results of a request for information about classification jobs.</p>
public struct ListJobsFilterCriteria: Equatable {
    /// <p>An array of objects, one for each condition that determines which jobs to exclude from the results.</p>
    public let excludes: [ListJobsFilterTerm]?
    /// <p>An array of objects, one for each condition that determines which jobs to include in the results.</p>
    public let includes: [ListJobsFilterTerm]?

    public init (
        excludes: [ListJobsFilterTerm]? = nil,
        includes: [ListJobsFilterTerm]? = nil
    )
    {
        self.excludes = excludes
        self.includes = includes
    }
}

/// <p>The property to use to filter the results. Valid values are:</p>
public enum ListJobsFilterKey {
    case createdat
    case jobstatus
    case jobtype
    case name
    case sdkUnknown(String)
}

extension ListJobsFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ListJobsFilterKey] {
        return [
            .createdat,
            .jobstatus,
            .jobtype,
            .name,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createdat: return "createdAt"
        case .jobstatus: return "jobStatus"
        case .jobtype: return "jobType"
        case .name: return "name"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ListJobsFilterKey(rawValue: rawValue) ?? ListJobsFilterKey.sdkUnknown(rawValue)
    }
}

extension ListJobsFilterTerm: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparator = "comparator"
        case key = "key"
        case values = "values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for __listof__string0 in values {
                try valuesContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(JobComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let keyDecoded = try containerValues.decodeIfPresent(ListJobsFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ListJobsFilterTerm: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsFilterTerm(comparator: \(String(describing: comparator)), key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>Specifies a condition that filters the results of a request for information about classification jobs. Each condition consists of a property, an operator, and one or more values.</p>
public struct ListJobsFilterTerm: Equatable {
    /// <p>The operator to use to filter the results.</p>
    public let comparator: JobComparator?
    /// <p>The property to use to filter the results.</p>
    public let key: ListJobsFilterKey?
    /// <p>An array that lists one or more values to use to filter the results.</p>
    public let values: [String]?

    public init (
        comparator: JobComparator? = nil,
        key: ListJobsFilterKey? = nil,
        values: [String]? = nil
    )
    {
        self.comparator = comparator
        self.key = key
        self.values = values
    }
}

/// <p>The property to sort the results by. Valid values are:</p>
public enum ListJobsSortAttributeName {
    case createdat
    case jobstatus
    case jobtype
    case name
    case sdkUnknown(String)
}

extension ListJobsSortAttributeName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ListJobsSortAttributeName] {
        return [
            .createdat,
            .jobstatus,
            .jobtype,
            .name,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createdat: return "createdAt"
        case .jobstatus: return "jobStatus"
        case .jobtype: return "jobType"
        case .name: return "name"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ListJobsSortAttributeName(rawValue: rawValue) ?? ListJobsSortAttributeName.sdkUnknown(rawValue)
    }
}

extension ListJobsSortCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName.rawValue, forKey: .attributeName)
        }
        if let orderBy = orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(ListJobsSortAttributeName.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension ListJobsSortCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsSortCriteria(attributeName: \(String(describing: attributeName)), orderBy: \(String(describing: orderBy)))"}
}

/// <p>Specifies criteria for sorting the results of a request for information about classification jobs.</p>
public struct ListJobsSortCriteria: Equatable {
    /// <p>The property to sort the results by.</p>
    public let attributeName: ListJobsSortAttributeName?
    /// <p>The sort order to apply to the results, based on the value for the property specified by the attributeName property. Valid values are: ASC, sort the results in ascending order; and, DESC, sort the results in descending order.</p>
    public let orderBy: OrderBy?

    public init (
        attributeName: ListJobsSortAttributeName? = nil,
        orderBy: OrderBy? = nil
    )
    {
        self.attributeName = attributeName
        self.orderBy = orderBy
    }
}

extension ListMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMembersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), onlyAssociated: \(String(describing: onlyAssociated)))"}
}

extension ListMembersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListMembersInputHeadersMiddleware: Middleware {
    public let id: String = "ListMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMembersInput>
    public typealias MOutput = OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMembersOutputError>
}

public struct ListMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let onlyAssociated = input.operationInput.onlyAssociated {
            let onlyAssociatedQueryItem = URLQueryItem(name: "onlyAssociated".urlPercentEncoding(), value: String(onlyAssociated).urlPercentEncoding())
            input.builder.withQueryItem(onlyAssociatedQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMembersInput>
    public typealias MOutput = OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMembersOutputError>
}

public struct ListMembersInput: Equatable {
    /// <p>The maximum number of items to include in each page of a paginated response.</p>
    public let maxResults: Int
    /// <p>The nextToken string that specifies which page of results to return in a paginated response.</p>
    public let nextToken: String?
    /// <p>Specifies which accounts to include in the response, based on the status of an account's relationship with the administrator account. By default, the response includes only current member accounts. To include all accounts, set this value to false.</p>
    public let onlyAssociated: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        onlyAssociated: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.onlyAssociated = onlyAssociated
    }
}

struct ListMembersInputBody: Equatable {
}

extension ListMembersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMembersOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMembersOutputResponse(members: \(String(describing: members)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMembersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutputResponse: Equatable {
    /// <p>An array of objects, one for each account that's associated with the administrator account and meets the criteria specified by the onlyAssociated request parameter.</p>
    public let members: [Member]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        members: [Member]? = nil,
        nextToken: String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListMembersOutputResponseBody: Equatable {
    public let members: [Member]?
    public let nextToken: String?
}

extension ListMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case members = "members"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([Member?].self, forKey: .members)
        var membersDecoded0:[Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrganizationAdminAccountsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOrganizationAdminAccountsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOrganizationAdminAccountsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListOrganizationAdminAccountsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOrganizationAdminAccountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOrganizationAdminAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOrganizationAdminAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOrganizationAdminAccountsInput>
    public typealias MOutput = OperationOutput<ListOrganizationAdminAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOrganizationAdminAccountsOutputError>
}

public struct ListOrganizationAdminAccountsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOrganizationAdminAccountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOrganizationAdminAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOrganizationAdminAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOrganizationAdminAccountsInput>
    public typealias MOutput = OperationOutput<ListOrganizationAdminAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOrganizationAdminAccountsOutputError>
}

public struct ListOrganizationAdminAccountsInput: Equatable {
    /// <p>The maximum number of items to include in each page of a paginated response.</p>
    public let maxResults: Int
    /// <p>The nextToken string that specifies which page of results to return in a paginated response.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsInputBody: Equatable {
}

extension ListOrganizationAdminAccountsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListOrganizationAdminAccountsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationAdminAccountsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOrganizationAdminAccountsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationAdminAccountsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOrganizationAdminAccountsOutputResponse(adminAccounts: \(String(describing: adminAccounts)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOrganizationAdminAccountsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOrganizationAdminAccountsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.adminAccounts = output.adminAccounts
            self.nextToken = output.nextToken
        } else {
            self.adminAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListOrganizationAdminAccountsOutputResponse: Equatable {
    /// <p>An array of objects, one for each delegated Amazon Macie administrator account for the organization. Only one of these accounts can have a status of ENABLED.</p>
    public let adminAccounts: [AdminAccount]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        adminAccounts: [AdminAccount]? = nil,
        nextToken: String? = nil
    )
    {
        self.adminAccounts = adminAccounts
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsOutputResponseBody: Equatable {
    public let adminAccounts: [AdminAccount]?
    public let nextToken: String?
}

extension ListOrganizationAdminAccountsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccounts = "adminAccounts"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountsContainer = try containerValues.decodeIfPresent([AdminAccount?].self, forKey: .adminAccounts)
        var adminAccountsDecoded0:[AdminAccount]? = nil
        if let adminAccountsContainer = adminAccountsContainer {
            adminAccountsDecoded0 = [AdminAccount]()
            for structure0 in adminAccountsContainer {
                if let structure0 = structure0 {
                    adminAccountsDecoded0?.append(structure0)
                }
            }
        }
        adminAccounts = adminAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the classification job, custom data identifier, findings filter, or member account.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A map of key-value pairs that identifies the tags (keys and values) that are associated with the resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

/// <p>The status of an Amazon Macie account. Valid values are:</p>
public enum MacieStatus {
    case enabled
    case paused
    case sdkUnknown(String)
}

extension MacieStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MacieStatus] {
        return [
            .enabled,
            .paused,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enabled: return "ENABLED"
        case .paused: return "PAUSED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MacieStatus(rawValue: rawValue) ?? MacieStatus.sdkUnknown(rawValue)
    }
}

extension MatchingBucket: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case bucketName = "bucketName"
        case classifiableObjectCount = "classifiableObjectCount"
        case classifiableSizeInBytes = "classifiableSizeInBytes"
        case jobDetails = "jobDetails"
        case objectCount = "objectCount"
        case objectCountByEncryptionType = "objectCountByEncryptionType"
        case sizeInBytes = "sizeInBytes"
        case sizeInBytesCompressed = "sizeInBytesCompressed"
        case unclassifiableObjectCount = "unclassifiableObjectCount"
        case unclassifiableObjectSizeInBytes = "unclassifiableObjectSizeInBytes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if classifiableObjectCount != 0 {
            try encodeContainer.encode(classifiableObjectCount, forKey: .classifiableObjectCount)
        }
        if classifiableSizeInBytes != 0 {
            try encodeContainer.encode(classifiableSizeInBytes, forKey: .classifiableSizeInBytes)
        }
        if let jobDetails = jobDetails {
            try encodeContainer.encode(jobDetails, forKey: .jobDetails)
        }
        if objectCount != 0 {
            try encodeContainer.encode(objectCount, forKey: .objectCount)
        }
        if let objectCountByEncryptionType = objectCountByEncryptionType {
            try encodeContainer.encode(objectCountByEncryptionType, forKey: .objectCountByEncryptionType)
        }
        if sizeInBytes != 0 {
            try encodeContainer.encode(sizeInBytes, forKey: .sizeInBytes)
        }
        if sizeInBytesCompressed != 0 {
            try encodeContainer.encode(sizeInBytesCompressed, forKey: .sizeInBytesCompressed)
        }
        if let unclassifiableObjectCount = unclassifiableObjectCount {
            try encodeContainer.encode(unclassifiableObjectCount, forKey: .unclassifiableObjectCount)
        }
        if let unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes {
            try encodeContainer.encode(unclassifiableObjectSizeInBytes, forKey: .unclassifiableObjectSizeInBytes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let classifiableObjectCountDecoded = try containerValues.decode(Int.self, forKey: .classifiableObjectCount)
        classifiableObjectCount = classifiableObjectCountDecoded
        let classifiableSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .classifiableSizeInBytes)
        classifiableSizeInBytes = classifiableSizeInBytesDecoded
        let jobDetailsDecoded = try containerValues.decodeIfPresent(JobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
        let objectCountDecoded = try containerValues.decode(Int.self, forKey: .objectCount)
        objectCount = objectCountDecoded
        let objectCountByEncryptionTypeDecoded = try containerValues.decodeIfPresent(ObjectCountByEncryptionType.self, forKey: .objectCountByEncryptionType)
        objectCountByEncryptionType = objectCountByEncryptionTypeDecoded
        let sizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let sizeInBytesCompressedDecoded = try containerValues.decode(Int.self, forKey: .sizeInBytesCompressed)
        sizeInBytesCompressed = sizeInBytesCompressedDecoded
        let unclassifiableObjectCountDecoded = try containerValues.decodeIfPresent(ObjectLevelStatistics.self, forKey: .unclassifiableObjectCount)
        unclassifiableObjectCount = unclassifiableObjectCountDecoded
        let unclassifiableObjectSizeInBytesDecoded = try containerValues.decodeIfPresent(ObjectLevelStatistics.self, forKey: .unclassifiableObjectSizeInBytes)
        unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytesDecoded
    }
}

extension MatchingBucket: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MatchingBucket(accountId: \(String(describing: accountId)), bucketName: \(String(describing: bucketName)), classifiableObjectCount: \(String(describing: classifiableObjectCount)), classifiableSizeInBytes: \(String(describing: classifiableSizeInBytes)), jobDetails: \(String(describing: jobDetails)), objectCount: \(String(describing: objectCount)), objectCountByEncryptionType: \(String(describing: objectCountByEncryptionType)), sizeInBytes: \(String(describing: sizeInBytes)), sizeInBytesCompressed: \(String(describing: sizeInBytesCompressed)), unclassifiableObjectCount: \(String(describing: unclassifiableObjectCount)), unclassifiableObjectSizeInBytes: \(String(describing: unclassifiableObjectSizeInBytes)))"}
}

/// <p>Provides statistical data and other information about an S3 bucket that Amazon Macie monitors and analyzes.</p>
public struct MatchingBucket: Equatable {
    /// <p>The unique identifier for the AWS account that owns the bucket.</p>
    public let accountId: String?
    /// <p>The name of the bucket.</p>
    public let bucketName: String?
    /// <p>The total number of objects that Amazon Macie can analyze in the bucket. These objects use a supported storage class and have a file name extension for a supported file or storage format.</p>
    public let classifiableObjectCount: Int
    /// <p>The total storage size, in bytes, of the objects that Amazon Macie can analyze in the bucket. These objects use a supported storage class and have a file name extension for a supported file or storage format.</p><p>If versioning is enabled for the bucket, Macie calculates this value based on the size of the latest version of each applicable object in the bucket. This value doesn't reflect the storage size of all versions of each applicable object in the bucket.</p>
    public let classifiableSizeInBytes: Int
    /// <p>Specifies whether any one-time or recurring classification jobs are configured to analyze objects in the bucket, and, if so, the details of the job that ran most recently.</p>
    public let jobDetails: JobDetails?
    /// <p>The total number of objects in the bucket.</p>
    public let objectCount: Int
    /// <p>The total number of objects that are in the bucket, grouped by server-side encryption type. This includes a grouping that reports the total number of objects that aren't encrypted or use client-side encryption.</p>
    public let objectCountByEncryptionType: ObjectCountByEncryptionType?
    /// <p>The total storage size, in bytes, of the bucket.</p><p>If versioning is enabled for the bucket, Amazon Macie calculates this value based on the size of the latest version of each object in the bucket. This value doesn't reflect the storage size of all versions of each object in the bucket.</p>
    public let sizeInBytes: Int
    /// <p>The total storage size, in bytes, of the objects that are compressed (.gz, .gzip, .zip) files in the bucket.</p><p>If versioning is enabled for the bucket, Macie calculates this value based on the size of the latest version of each applicable object in the bucket. This value doesn't reflect the storage size of all versions of each applicable object in the bucket.</p>
    public let sizeInBytesCompressed: Int
    /// <p>The total number of objects that Amazon Macie can't analyze in the bucket. These objects don't use a supported storage class or don't have a file name extension for a supported file or storage format.</p>
    public let unclassifiableObjectCount: ObjectLevelStatistics?
    /// <p>The total storage size, in bytes, of the objects that Amazon Macie can't analyze in the bucket. These objects don't use a supported storage class or don't have a file name extension for a supported file or storage format.</p>
    public let unclassifiableObjectSizeInBytes: ObjectLevelStatistics?

    public init (
        accountId: String? = nil,
        bucketName: String? = nil,
        classifiableObjectCount: Int = 0,
        classifiableSizeInBytes: Int = 0,
        jobDetails: JobDetails? = nil,
        objectCount: Int = 0,
        objectCountByEncryptionType: ObjectCountByEncryptionType? = nil,
        sizeInBytes: Int = 0,
        sizeInBytesCompressed: Int = 0,
        unclassifiableObjectCount: ObjectLevelStatistics? = nil,
        unclassifiableObjectSizeInBytes: ObjectLevelStatistics? = nil
    )
    {
        self.accountId = accountId
        self.bucketName = bucketName
        self.classifiableObjectCount = classifiableObjectCount
        self.classifiableSizeInBytes = classifiableSizeInBytes
        self.jobDetails = jobDetails
        self.objectCount = objectCount
        self.objectCountByEncryptionType = objectCountByEncryptionType
        self.sizeInBytes = sizeInBytes
        self.sizeInBytesCompressed = sizeInBytesCompressed
        self.unclassifiableObjectCount = unclassifiableObjectCount
        self.unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes
    }
}

extension MatchingResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case matchingBucket = "matchingBucket"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchingBucket = matchingBucket {
            try encodeContainer.encode(matchingBucket, forKey: .matchingBucket)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchingBucketDecoded = try containerValues.decodeIfPresent(MatchingBucket.self, forKey: .matchingBucket)
        matchingBucket = matchingBucketDecoded
    }
}

extension MatchingResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MatchingResource(matchingBucket: \(String(describing: matchingBucket)))"}
}

/// <p>Provides statistical data and other information about an AWS resource that Amazon Macie monitors and analyzes.</p>
public struct MatchingResource: Equatable {
    /// <p>The details of an S3 bucket that Amazon Macie monitors and analyzes.</p>
    public let matchingBucket: MatchingBucket?

    public init (
        matchingBucket: MatchingBucket? = nil
    )
    {
        self.matchingBucket = matchingBucket
    }
}

extension Member: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case administratorAccountId = "administratorAccountId"
        case arn = "arn"
        case email = "email"
        case invitedAt = "invitedAt"
        case masterAccountId = "masterAccountId"
        case relationshipStatus = "relationshipStatus"
        case tags = "tags"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let administratorAccountId = administratorAccountId {
            try encodeContainer.encode(administratorAccountId, forKey: .administratorAccountId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let invitedAt = invitedAt {
            try encodeContainer.encode(invitedAt.timeIntervalSince1970, forKey: .invitedAt)
        }
        if let masterAccountId = masterAccountId {
            try encodeContainer.encode(masterAccountId, forKey: .masterAccountId)
        }
        if let relationshipStatus = relationshipStatus {
            try encodeContainer.encode(relationshipStatus.rawValue, forKey: .relationshipStatus)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let administratorAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .administratorAccountId)
        administratorAccountId = administratorAccountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let masterAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterAccountId)
        masterAccountId = masterAccountIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(RelationshipStatus.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Member: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Member(accountId: \(String(describing: accountId)), administratorAccountId: \(String(describing: administratorAccountId)), arn: \(String(describing: arn)), email: \(String(describing: email)), invitedAt: \(String(describing: invitedAt)), masterAccountId: \(String(describing: masterAccountId)), relationshipStatus: \(String(describing: relationshipStatus)), tags: \(String(describing: tags)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Provides information about an account that's associated with an Amazon Macie administrator account.</p>
public struct Member: Equatable {
    /// <p>The AWS account ID for the account.</p>
    public let accountId: String?
    /// <p>The AWS account ID for the administrator account.</p>
    public let administratorAccountId: String?
    /// <p>The Amazon Resource Name (ARN) of the account.</p>
    public let arn: String?
    /// <p>The email address for the account.</p>
    public let email: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when an Amazon Macie membership invitation was last sent to the account. This value is null if a Macie invitation hasn't been sent to the account.</p>
    public let invitedAt: Date?
    /// <p>(Deprecated) The AWS account ID for the administrator account. This property has been replaced by the administratorAccountId property and is retained only for backward compatibility.</p>
    public let masterAccountId: String?
    /// <p>The current status of the relationship between the account and the administrator account.</p>
    public let relationshipStatus: RelationshipStatus?
    /// <p>A map of key-value pairs that identifies the tags (keys and values) that are associated with the account in Amazon Macie.</p>
    public let tags: [String:String]?
    /// <p>The date and time, in UTC and extended ISO 8601 format, of the most recent change to the status of the relationship between the account and the administrator account.</p>
    public let updatedAt: Date?

    public init (
        accountId: String? = nil,
        administratorAccountId: String? = nil,
        arn: String? = nil,
        email: String? = nil,
        invitedAt: Date? = nil,
        masterAccountId: String? = nil,
        relationshipStatus: RelationshipStatus? = nil,
        tags: [String:String]? = nil,
        updatedAt: Date? = nil
    )
    {
        self.accountId = accountId
        self.administratorAccountId = administratorAccountId
        self.arn = arn
        self.email = email
        self.invitedAt = invitedAt
        self.masterAccountId = masterAccountId
        self.relationshipStatus = relationshipStatus
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

extension MonthlySchedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dayOfMonth = "dayOfMonth"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dayOfMonth != 0 {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfMonthDecoded = try containerValues.decode(Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
    }
}

extension MonthlySchedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MonthlySchedule(dayOfMonth: \(String(describing: dayOfMonth)))"}
}

/// <p>Specifies a monthly recurrence pattern for running a classification job.</p>
public struct MonthlySchedule: Equatable {
    /// <p>The numeric day of the month when Amazon Macie runs the job. This value can be an integer from 1 through 31.</p> <p>If this value exceeds the number of days in a certain month, Macie doesn't run the job that month. Macie runs the job only during months that have the specified day. For example, if this value is 31 and a month has only 30 days, Macie doesn't run the job that month. To run the job every month, specify a value that's less than 29.</p>
    public let dayOfMonth: Int

    public init (
        dayOfMonth: Int = 0
    )
    {
        self.dayOfMonth = dayOfMonth
    }
}

extension ObjectCountByEncryptionType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerManaged = "customerManaged"
        case kmsManaged = "kmsManaged"
        case s3Managed = "s3Managed"
        case unencrypted = "unencrypted"
        case unknown = "unknown"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if customerManaged != 0 {
            try encodeContainer.encode(customerManaged, forKey: .customerManaged)
        }
        if kmsManaged != 0 {
            try encodeContainer.encode(kmsManaged, forKey: .kmsManaged)
        }
        if s3Managed != 0 {
            try encodeContainer.encode(s3Managed, forKey: .s3Managed)
        }
        if unencrypted != 0 {
            try encodeContainer.encode(unencrypted, forKey: .unencrypted)
        }
        if unknown != 0 {
            try encodeContainer.encode(unknown, forKey: .unknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerManagedDecoded = try containerValues.decode(Int.self, forKey: .customerManaged)
        customerManaged = customerManagedDecoded
        let kmsManagedDecoded = try containerValues.decode(Int.self, forKey: .kmsManaged)
        kmsManaged = kmsManagedDecoded
        let s3ManagedDecoded = try containerValues.decode(Int.self, forKey: .s3Managed)
        s3Managed = s3ManagedDecoded
        let unencryptedDecoded = try containerValues.decode(Int.self, forKey: .unencrypted)
        unencrypted = unencryptedDecoded
        let unknownDecoded = try containerValues.decode(Int.self, forKey: .unknown)
        unknown = unknownDecoded
    }
}

extension ObjectCountByEncryptionType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectCountByEncryptionType(customerManaged: \(String(describing: customerManaged)), kmsManaged: \(String(describing: kmsManaged)), s3Managed: \(String(describing: s3Managed)), unencrypted: \(String(describing: unencrypted)), unknown: \(String(describing: unknown)))"}
}

/// <p>Provides information about the number of objects that are in an S3 bucket and use certain types of server-side encryption, use client-side encryption, or aren't encrypted.</p>
public struct ObjectCountByEncryptionType: Equatable {
    /// <p>The total number of objects that are encrypted with a customer-managed key. The objects use customer-provided server-side encryption (SSE-C).</p>
    public let customerManaged: Int
    /// <p>The total number of objects that are encrypted with an AWS Key Management Service (AWS KMS) customer master key (CMK). The objects use AWS managed AWS KMS encryption (AWS-KMS) or customer managed AWS KMS encryption (SSE-KMS).</p>
    public let kmsManaged: Int
    /// <p>The total number of objects that are encrypted with an Amazon S3 managed key. The objects use Amazon S3 managed encryption (SSE-S3).</p>
    public let s3Managed: Int
    /// <p>The total number of objects that aren't encrypted or use client-side encryption.</p>
    public let unencrypted: Int
    /// <p>The total number of objects that Amazon Macie doesn't have current encryption metadata for. Macie can't provide current data about the encryption settings for these objects.</p>
    public let unknown: Int

    public init (
        customerManaged: Int = 0,
        kmsManaged: Int = 0,
        s3Managed: Int = 0,
        unencrypted: Int = 0,
        unknown: Int = 0
    )
    {
        self.customerManaged = customerManaged
        self.kmsManaged = kmsManaged
        self.s3Managed = s3Managed
        self.unencrypted = unencrypted
        self.unknown = unknown
    }
}

extension ObjectLevelStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileType = "fileType"
        case storageClass = "storageClass"
        case total = "total"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if fileType != 0 {
            try encodeContainer.encode(fileType, forKey: .fileType)
        }
        if storageClass != 0 {
            try encodeContainer.encode(storageClass, forKey: .storageClass)
        }
        if total != 0 {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileTypeDecoded = try containerValues.decode(Int.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let storageClassDecoded = try containerValues.decode(Int.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let totalDecoded = try containerValues.decode(Int.self, forKey: .total)
        total = totalDecoded
    }
}

extension ObjectLevelStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectLevelStatistics(fileType: \(String(describing: fileType)), storageClass: \(String(describing: storageClass)), total: \(String(describing: total)))"}
}

/// <p>Provides information about the total storage size (in bytes) or number of objects that Amazon Macie can't analyze in one or more S3 buckets. In a BucketMetadata or MatchingBucket object, this data is for a specific bucket. In a GetBucketStatisticsResponse object, this data is aggregated for all the buckets in the query results. If versioning is enabled for a bucket, total storage size values are based on the size of the latest version of each applicable object in the bucket.</p>
public struct ObjectLevelStatistics: Equatable {
    /// <p>The total storage size (in bytes) or number of objects that Amazon Macie can't analyze because the objects don't have a file name extension for a supported file or storage format.</p>
    public let fileType: Int
    /// <p>The total storage size (in bytes) or number of objects that Amazon Macie can't analyze because the objects use an unsupported storage class.</p>
    public let storageClass: Int
    /// <p>The total storage size (in bytes) or number of objects that Amazon Macie can't analyze because the objects use an unsupported storage class or don't have a file name extension for a supported file or storage format.</p>
    public let total: Int

    public init (
        fileType: Int = 0,
        storageClass: Int = 0,
        total: Int = 0
    )
    {
        self.fileType = fileType
        self.storageClass = storageClass
        self.total = total
    }
}

extension Occurrences: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cells = "cells"
        case lineRanges = "lineRanges"
        case offsetRanges = "offsetRanges"
        case pages = "pages"
        case records = "records"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for cells0 in cells {
                try cellsContainer.encode(cells0)
            }
        }
        if let lineRanges = lineRanges {
            var lineRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineRanges)
            for ranges0 in lineRanges {
                try lineRangesContainer.encode(ranges0)
            }
        }
        if let offsetRanges = offsetRanges {
            var offsetRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .offsetRanges)
            for ranges0 in offsetRanges {
                try offsetRangesContainer.encode(ranges0)
            }
        }
        if let pages = pages {
            var pagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pages)
            for pages0 in pages {
                try pagesContainer.encode(pages0)
            }
        }
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for records0 in records {
                try recordsContainer.encode(records0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Cell?].self, forKey: .cells)
        var cellsDecoded0:[Cell]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Cell]()
            for structure0 in cellsContainer {
                if let structure0 = structure0 {
                    cellsDecoded0?.append(structure0)
                }
            }
        }
        cells = cellsDecoded0
        let lineRangesContainer = try containerValues.decodeIfPresent([Range?].self, forKey: .lineRanges)
        var lineRangesDecoded0:[Range]? = nil
        if let lineRangesContainer = lineRangesContainer {
            lineRangesDecoded0 = [Range]()
            for structure0 in lineRangesContainer {
                if let structure0 = structure0 {
                    lineRangesDecoded0?.append(structure0)
                }
            }
        }
        lineRanges = lineRangesDecoded0
        let offsetRangesContainer = try containerValues.decodeIfPresent([Range?].self, forKey: .offsetRanges)
        var offsetRangesDecoded0:[Range]? = nil
        if let offsetRangesContainer = offsetRangesContainer {
            offsetRangesDecoded0 = [Range]()
            for structure0 in offsetRangesContainer {
                if let structure0 = structure0 {
                    offsetRangesDecoded0?.append(structure0)
                }
            }
        }
        offsetRanges = offsetRangesDecoded0
        let pagesContainer = try containerValues.decodeIfPresent([Page?].self, forKey: .pages)
        var pagesDecoded0:[Page]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [Page]()
            for structure0 in pagesContainer {
                if let structure0 = structure0 {
                    pagesDecoded0?.append(structure0)
                }
            }
        }
        pages = pagesDecoded0
        let recordsContainer = try containerValues.decodeIfPresent([Record?].self, forKey: .records)
        var recordsDecoded0:[Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
    }
}

extension Occurrences: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Occurrences(cells: \(String(describing: cells)), lineRanges: \(String(describing: lineRanges)), offsetRanges: \(String(describing: offsetRanges)), pages: \(String(describing: pages)), records: \(String(describing: records)))"}
}

/// <p>Provides the location of 1-15 occurrences of sensitive data that was detected by managed data identifiers or a custom data identifier and produced a sensitive data finding.</p>
public struct Occurrences: Equatable {
    /// <p>An array of objects, one for each occurrence of sensitive data in a Microsoft Excel workbook, CSV file, or TSV file. Each object specifies the cell or field that contains the data. This value is null for all other types of files.</p>
    public let cells: [Cell]?
    /// <p>An array of objects, one for each occurrence of sensitive data in a Microsoft Word document or non-binary text file, such as an HTML, JSON, TXT, or XML file. Each object specifies the line that contains the data, and the position of the data on that line.</p> <p>This value is often null for file types that are supported by Cell, Page, or Record objects. Exceptions are the locations of data in: unstructured sections of an otherwise structured file, such as a comment in a file; a malformed file that Amazon Macie analyzes as plain text; and, a CSV or TSV file that has any column names that contain sensitive data.</p>
    public let lineRanges: [Range]?
    /// <p>An array of objects, one for each occurrence of sensitive data in a binary text file. Each object specifies the position of the data relative to the beginning of the file.</p> <p>This value is typically null. For binary text files, Amazon Macie adds location data to a lineRanges.Range or Page object, depending on the file type.</p>
    public let offsetRanges: [Range]?
    /// <p>An array of objects, one for each occurrence of sensitive data in an Adobe Portable Document Format file. Each object specifies the page that contains the data, and the position of the data on that page. This value is null for all other types of files.</p>
    public let pages: [Page]?
    /// <p>An array of objects, one for each occurrence of sensitive data in an Apache Avro object container or Apache Parquet file. Each object specifies the record index and the path to the field in the record that contains the data. This value is null for all other types of files.</p>
    public let records: [Record]?

    public init (
        cells: [Cell]? = nil,
        lineRanges: [Range]? = nil,
        offsetRanges: [Range]? = nil,
        pages: [Page]? = nil,
        records: [Record]? = nil
    )
    {
        self.cells = cells
        self.lineRanges = lineRanges
        self.offsetRanges = offsetRanges
        self.pages = pages
        self.records = records
    }
}

public enum OrderBy {
    case asc
    case desc
    case sdkUnknown(String)
}

extension OrderBy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrderBy] {
        return [
            .asc,
            .desc,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .asc: return "ASC"
        case .desc: return "DESC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrderBy(rawValue: rawValue) ?? OrderBy.sdkUnknown(rawValue)
    }
}

extension Page: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lineRange = "lineRange"
        case offsetRange = "offsetRange"
        case pageNumber = "pageNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineRange = lineRange {
            try encodeContainer.encode(lineRange, forKey: .lineRange)
        }
        if let offsetRange = offsetRange {
            try encodeContainer.encode(offsetRange, forKey: .offsetRange)
        }
        if pageNumber != 0 {
            try encodeContainer.encode(pageNumber, forKey: .pageNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineRangeDecoded = try containerValues.decodeIfPresent(Range.self, forKey: .lineRange)
        lineRange = lineRangeDecoded
        let offsetRangeDecoded = try containerValues.decodeIfPresent(Range.self, forKey: .offsetRange)
        offsetRange = offsetRangeDecoded
        let pageNumberDecoded = try containerValues.decode(Int.self, forKey: .pageNumber)
        pageNumber = pageNumberDecoded
    }
}

extension Page: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Page(lineRange: \(String(describing: lineRange)), offsetRange: \(String(describing: offsetRange)), pageNumber: \(String(describing: pageNumber)))"}
}

/// <p>Specifies the location of an occurrence of sensitive data in an Adobe Portable Document Format file.</p>
public struct Page: Equatable {
    /// <p>The line that contains the data, and the position of the data on that line.</p>
    public let lineRange: Range?
    /// <p>The position of the data on the page, relative to the beginning of the page.</p>
    public let offsetRange: Range?
    /// <p>The page number of the page that contains the data.</p>
    public let pageNumber: Int

    public init (
        lineRange: Range? = nil,
        offsetRange: Range? = nil,
        pageNumber: Int = 0
    )
    {
        self.lineRange = lineRange
        self.offsetRange = offsetRange
        self.pageNumber = pageNumber
    }
}

extension PolicyDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case actor = "actor"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let actor = actor {
            try encodeContainer.encode(actor, forKey: .actor)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(FindingAction.self, forKey: .action)
        action = actionDecoded
        let actorDecoded = try containerValues.decodeIfPresent(FindingActor.self, forKey: .actor)
        actor = actorDecoded
    }
}

extension PolicyDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyDetails(action: \(String(describing: action)), actor: \(String(describing: actor)))"}
}

/// <p>Provides the details of a policy finding.</p>
public struct PolicyDetails: Equatable {
    /// <p>The action that produced the finding.</p>
    public let action: FindingAction?
    /// <p>The entity that performed the action that produced the finding.</p>
    public let actor: FindingActor?

    public init (
        action: FindingAction? = nil,
        actor: FindingActor? = nil
    )
    {
        self.action = action
        self.actor = actor
    }
}

public struct PutClassificationExportConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutClassificationExportConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutClassificationExportConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutClassificationExportConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutClassificationExportConfigurationInput>
    public typealias MOutput = OperationOutput<PutClassificationExportConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutClassificationExportConfigurationOutputError>
}

extension PutClassificationExportConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutClassificationExportConfigurationInput(configuration: \(String(describing: configuration)))"}
}

extension PutClassificationExportConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "configuration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
    }
}

public struct PutClassificationExportConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutClassificationExportConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutClassificationExportConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutClassificationExportConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutClassificationExportConfigurationInput>
    public typealias MOutput = OperationOutput<PutClassificationExportConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutClassificationExportConfigurationOutputError>
}

public struct PutClassificationExportConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutClassificationExportConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutClassificationExportConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutClassificationExportConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutClassificationExportConfigurationInput>
    public typealias MOutput = OperationOutput<PutClassificationExportConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutClassificationExportConfigurationOutputError>
}

public struct PutClassificationExportConfigurationInput: Equatable {
    /// <p>The location to store data classification results in, and the encryption settings to use when storing results in that location.</p>
    public let configuration: ClassificationExportConfiguration?

    public init (
        configuration: ClassificationExportConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct PutClassificationExportConfigurationInputBody: Equatable {
    public let configuration: ClassificationExportConfiguration?
}

extension PutClassificationExportConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "configuration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(ClassificationExportConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension PutClassificationExportConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutClassificationExportConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutClassificationExportConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutClassificationExportConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutClassificationExportConfigurationOutputResponse(configuration: \(String(describing: configuration)))"}
}

extension PutClassificationExportConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutClassificationExportConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configuration = output.configuration
        } else {
            self.configuration = nil
        }
    }
}

public struct PutClassificationExportConfigurationOutputResponse: Equatable {
    /// <p>The location where the data classification results are stored, and the encryption settings that are used when storing results in that location.</p>
    public let configuration: ClassificationExportConfiguration?

    public init (
        configuration: ClassificationExportConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct PutClassificationExportConfigurationOutputResponseBody: Equatable {
    public let configuration: ClassificationExportConfiguration?
}

extension PutClassificationExportConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "configuration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(ClassificationExportConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

public struct PutFindingsPublicationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutFindingsPublicationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFindingsPublicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFindingsPublicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFindingsPublicationConfigurationInput>
    public typealias MOutput = OperationOutput<PutFindingsPublicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFindingsPublicationConfigurationOutputError>
}

extension PutFindingsPublicationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFindingsPublicationConfigurationInput(clientToken: \(String(describing: clientToken)), securityHubConfiguration: \(String(describing: securityHubConfiguration)))"}
}

extension PutFindingsPublicationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case securityHubConfiguration = "securityHubConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let securityHubConfiguration = securityHubConfiguration {
            try encodeContainer.encode(securityHubConfiguration, forKey: .securityHubConfiguration)
        }
    }
}

public struct PutFindingsPublicationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutFindingsPublicationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFindingsPublicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFindingsPublicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFindingsPublicationConfigurationInput>
    public typealias MOutput = OperationOutput<PutFindingsPublicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFindingsPublicationConfigurationOutputError>
}

public struct PutFindingsPublicationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutFindingsPublicationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFindingsPublicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFindingsPublicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFindingsPublicationConfigurationInput>
    public typealias MOutput = OperationOutput<PutFindingsPublicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFindingsPublicationConfigurationOutputError>
}

public struct PutFindingsPublicationConfigurationInput: Equatable {
    /// <p>A unique, case-sensitive token that you provide to ensure the idempotency of the request.</p>
    public var clientToken: String?
    /// <p>The configuration settings that determine which findings to publish to AWS Security Hub.</p>
    public let securityHubConfiguration: SecurityHubConfiguration?

    public init (
        clientToken: String? = nil,
        securityHubConfiguration: SecurityHubConfiguration? = nil
    )
    {
        self.clientToken = clientToken
        self.securityHubConfiguration = securityHubConfiguration
    }
}

struct PutFindingsPublicationConfigurationInputBody: Equatable {
    public let clientToken: String?
    public let securityHubConfiguration: SecurityHubConfiguration?
}

extension PutFindingsPublicationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case securityHubConfiguration = "securityHubConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let securityHubConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubConfiguration.self, forKey: .securityHubConfiguration)
        securityHubConfiguration = securityHubConfigurationDecoded
    }
}

extension PutFindingsPublicationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFindingsPublicationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFindingsPublicationConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFindingsPublicationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFindingsPublicationConfigurationOutputResponse()"}
}

extension PutFindingsPublicationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutFindingsPublicationConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutFindingsPublicationConfigurationOutputResponseBody: Equatable {
}

extension PutFindingsPublicationConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Range: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case end = "end"
        case start = "start"
        case startColumn = "startColumn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if end != 0 {
            try encodeContainer.encode(end, forKey: .end)
        }
        if start != 0 {
            try encodeContainer.encode(start, forKey: .start)
        }
        if startColumn != 0 {
            try encodeContainer.encode(startColumn, forKey: .startColumn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endDecoded = try containerValues.decode(Int.self, forKey: .end)
        end = endDecoded
        let startDecoded = try containerValues.decode(Int.self, forKey: .start)
        start = startDecoded
        let startColumnDecoded = try containerValues.decode(Int.self, forKey: .startColumn)
        startColumn = startColumnDecoded
    }
}

extension Range: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Range(end: \(String(describing: end)), start: \(String(describing: start)), startColumn: \(String(describing: startColumn)))"}
}

/// <p>Provides details about the location of an occurrence of sensitive data in an Adobe Portable Document Format file, Microsoft Word document, or non-binary text file.</p>
public struct Range: Equatable {
    /// <p>Possible values are:</p> <ul><li><p>In an Occurrences.lineRanges array, the number of lines from the beginning of the file to the end of the sensitive data.</p></li> <li><p>In an Occurrences.offsetRanges array, the number of characters from the beginning of the file to the end of the sensitive data.</p></li> <li><p>In a Page object, the number of lines (lineRange) or characters (offsetRange) from the beginning of the page to the end of the sensitive data.</p></li></ul>
    public let end: Int
    /// <p>Possible values are:</p> <ul><li><p>In an Occurrences.lineRanges array, the number of lines from the beginning of the file to the beginning of the sensitive data.</p></li> <li><p>In an Occurrences.offsetRanges array, the number of characters from the beginning of the file to the beginning of the sensitive data.</p></li> <li><p>In a Page object, the number of lines (lineRange) or characters (offsetRange) from the beginning of the page to the beginning of the sensitive data.</p></li></ul>
    public let start: Int
    /// <p>The column number for the column that contains the data, if the file contains structured data.</p>
    public let startColumn: Int

    public init (
        end: Int = 0,
        start: Int = 0,
        startColumn: Int = 0
    )
    {
        self.end = end
        self.start = start
        self.startColumn = startColumn
    }
}

extension Record: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jsonPath = "jsonPath"
        case recordIndex = "recordIndex"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonPath = jsonPath {
            try encodeContainer.encode(jsonPath, forKey: .jsonPath)
        }
        if recordIndex != 0 {
            try encodeContainer.encode(recordIndex, forKey: .recordIndex)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jsonPath)
        jsonPath = jsonPathDecoded
        let recordIndexDecoded = try containerValues.decode(Int.self, forKey: .recordIndex)
        recordIndex = recordIndexDecoded
    }
}

extension Record: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Record(jsonPath: \(String(describing: jsonPath)), recordIndex: \(String(describing: recordIndex)))"}
}

/// <p>Specifies the location of an occurrence of sensitive data in an Apache Avro object container or Apache Parquet file.</p>
public struct Record: Equatable {
    /// <p>The path, as a JSONPath expression, to the field in the record that contains the data. If Amazon Macie detects sensitive data in the name of any element in the path, Macie omits this field.</p> <p>If the name of an element exceeds 20 characters, Macie truncates the name by removing characters from the beginning of the name. If the resulting full path exceeds 250 characters, Macie also truncates the path, starting with the first element in the path, until the path contains 250 or fewer characters.</p>
    public let jsonPath: String?
    /// <p>The record index, starting from 0, for the record that contains the data.</p>
    public let recordIndex: Int

    public init (
        jsonPath: String? = nil,
        recordIndex: Int = 0
    )
    {
        self.jsonPath = jsonPath
        self.recordIndex = recordIndex
    }
}

/// <p>The current status of the relationship between an account and an associated Amazon Macie administrator account (<i>inviter account</i>). Possible values are:</p>
public enum RelationshipStatus {
    case accountsuspended
    case created
    case emailverificationfailed
    case emailverificationinprogress
    case enabled
    case invited
    case paused
    case regiondisabled
    case removed
    case resigned
    case sdkUnknown(String)
}

extension RelationshipStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RelationshipStatus] {
        return [
            .accountsuspended,
            .created,
            .emailverificationfailed,
            .emailverificationinprogress,
            .enabled,
            .invited,
            .paused,
            .regiondisabled,
            .removed,
            .resigned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountsuspended: return "AccountSuspended"
        case .created: return "Created"
        case .emailverificationfailed: return "EmailVerificationFailed"
        case .emailverificationinprogress: return "EmailVerificationInProgress"
        case .enabled: return "Enabled"
        case .invited: return "Invited"
        case .paused: return "Paused"
        case .regiondisabled: return "RegionDisabled"
        case .removed: return "Removed"
        case .resigned: return "Resigned"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RelationshipStatus(rawValue: rawValue) ?? RelationshipStatus.sdkUnknown(rawValue)
    }
}

extension ReplicationDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicated = "replicated"
        case replicatedExternally = "replicatedExternally"
        case replicationAccounts = "replicationAccounts"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if replicated != false {
            try encodeContainer.encode(replicated, forKey: .replicated)
        }
        if replicatedExternally != false {
            try encodeContainer.encode(replicatedExternally, forKey: .replicatedExternally)
        }
        if let replicationAccounts = replicationAccounts {
            var replicationAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationAccounts)
            for __listof__string0 in replicationAccounts {
                try replicationAccountsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicatedDecoded = try containerValues.decode(Bool.self, forKey: .replicated)
        replicated = replicatedDecoded
        let replicatedExternallyDecoded = try containerValues.decode(Bool.self, forKey: .replicatedExternally)
        replicatedExternally = replicatedExternallyDecoded
        let replicationAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationAccounts)
        var replicationAccountsDecoded0:[String]? = nil
        if let replicationAccountsContainer = replicationAccountsContainer {
            replicationAccountsDecoded0 = [String]()
            for string0 in replicationAccountsContainer {
                if let string0 = string0 {
                    replicationAccountsDecoded0?.append(string0)
                }
            }
        }
        replicationAccounts = replicationAccountsDecoded0
    }
}

extension ReplicationDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationDetails(replicated: \(String(describing: replicated)), replicatedExternally: \(String(describing: replicatedExternally)), replicationAccounts: \(String(describing: replicationAccounts)))"}
}

/// <p>Provides information about settings that define whether one or more objects in an S3 bucket are replicated to S3 buckets for other AWS accounts and, if so, which accounts.</p>
public struct ReplicationDetails: Equatable {
    /// <p>Specifies whether the bucket is configured to replicate one or more objects to any destination.</p>
    public let replicated: Bool
    /// <p>Specifies whether the bucket is configured to replicate one or more objects to an AWS account that isn't part of the same Amazon Macie organization.</p>
    public let replicatedExternally: Bool
    /// <p>An array of AWS account IDs, one for each AWS account that the bucket is configured to replicate one or more objects to.</p>
    public let replicationAccounts: [String]?

    public init (
        replicated: Bool = false,
        replicatedExternally: Bool = false,
        replicationAccounts: [String]? = nil
    )
    {
        self.replicated = replicated
        self.replicatedExternally = replicatedExternally
        self.replicationAccounts = replicationAccounts
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an error that occurred because a specified resource wasn't found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The explanation of the error that occurred.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourcesAffected: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Bucket = "s3Bucket"
        case s3Object = "s3Object"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Object = s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(S3Bucket.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3ObjectDecoded = try containerValues.decodeIfPresent(S3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
    }
}

extension ResourcesAffected: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourcesAffected(s3Bucket: \(String(describing: s3Bucket)), s3Object: \(String(describing: s3Object)))"}
}

/// <p>Provides information about the resources that a finding applies to.</p>
public struct ResourcesAffected: Equatable {
    /// <p>An array of objects, one for each S3 bucket that the finding applies to. Each object provides a set of metadata about an affected S3 bucket.</p>
    public let s3Bucket: S3Bucket?
    /// <p>An array of objects, one for each S3 object that the finding applies to. Each object provides a set of metadata about an affected S3 object.</p>
    public let s3Object: S3Object?

    public init (
        s3Bucket: S3Bucket? = nil,
        s3Object: S3Object? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Object = s3Object
    }
}

extension S3Bucket: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowsUnencryptedObjectUploads = "allowsUnencryptedObjectUploads"
        case arn = "arn"
        case createdAt = "createdAt"
        case defaultServerSideEncryption = "defaultServerSideEncryption"
        case name = "name"
        case owner = "owner"
        case publicAccess = "publicAccess"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploads {
            try encodeContainer.encode(allowsUnencryptedObjectUploads.rawValue, forKey: .allowsUnencryptedObjectUploads)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let defaultServerSideEncryption = defaultServerSideEncryption {
            try encodeContainer.encode(defaultServerSideEncryption, forKey: .defaultServerSideEncryption)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let publicAccess = publicAccess {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for keyvaluepairlist0 in tags {
                try tagsContainer.encode(keyvaluepairlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsUnencryptedObjectUploadsDecoded = try containerValues.decodeIfPresent(AllowsUnencryptedObjectUploads.self, forKey: .allowsUnencryptedObjectUploads)
        allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploadsDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let defaultServerSideEncryptionDecoded = try containerValues.decodeIfPresent(ServerSideEncryption.self, forKey: .defaultServerSideEncryption)
        defaultServerSideEncryption = defaultServerSideEncryptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(S3BucketOwner.self, forKey: .owner)
        owner = ownerDecoded
        let publicAccessDecoded = try containerValues.decodeIfPresent(BucketPublicAccess.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyValuePair?].self, forKey: .tags)
        var tagsDecoded0:[KeyValuePair]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyValuePair]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension S3Bucket: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Bucket(allowsUnencryptedObjectUploads: \(String(describing: allowsUnencryptedObjectUploads)), arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), defaultServerSideEncryption: \(String(describing: defaultServerSideEncryption)), name: \(String(describing: name)), owner: \(String(describing: owner)), publicAccess: \(String(describing: publicAccess)), tags: \(String(describing: tags)))"}
}

/// <p>Provides information about an S3 bucket that a finding applies to.</p>
public struct S3Bucket: Equatable {
    /// <p>Specifies whether the bucket policy for the bucket requires server-side encryption of objects when objects are uploaded to the bucket. Possible values are:</p> <ul><li><p>FALSE - The bucket policy requires server-side encryption of new objects. PutObject requests must include the x-amz-server-side-encryption header and the value for that header must be AES256 or aws:kms.</p></li> <li><p>TRUE - The bucket doesn't have a bucket policy or it has a bucket policy that doesn't require server-side encryption of new objects. If a bucket policy exists, it doesn't require PutObject requests to include the x-amz-server-side-encryption header and it doesn't require the value for that header to be AES256 or aws:kms.</p></li> <li><p>UNKNOWN - Amazon Macie can't determine whether the bucket policy requires server-side encryption of objects.</p></li></ul>
    public let allowsUnencryptedObjectUploads: AllowsUnencryptedObjectUploads?
    /// <p>The Amazon Resource Name (ARN) of the bucket.</p>
    public let arn: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the bucket was created.</p>
    public let createdAt: Date?
    /// <p>The type of server-side encryption that's used by default to encrypt objects in the bucket.</p>
    public let defaultServerSideEncryption: ServerSideEncryption?
    /// <p>The name of the bucket.</p>
    public let name: String?
    /// <p>The display name and AWS account ID for the user who owns the bucket.</p>
    public let owner: S3BucketOwner?
    /// <p>The permissions settings that determine whether the bucket is publicly accessible.</p>
    public let publicAccess: BucketPublicAccess?
    /// <p>The tags that are associated with the bucket.</p>
    public let tags: [KeyValuePair]?

    public init (
        allowsUnencryptedObjectUploads: AllowsUnencryptedObjectUploads? = nil,
        arn: String? = nil,
        createdAt: Date? = nil,
        defaultServerSideEncryption: ServerSideEncryption? = nil,
        name: String? = nil,
        owner: S3BucketOwner? = nil,
        publicAccess: BucketPublicAccess? = nil,
        tags: [KeyValuePair]? = nil
    )
    {
        self.allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploads
        self.arn = arn
        self.createdAt = createdAt
        self.defaultServerSideEncryption = defaultServerSideEncryption
        self.name = name
        self.owner = owner
        self.publicAccess = publicAccess
        self.tags = tags
    }
}

extension S3BucketCriteriaForJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludes = "excludes"
        case includes = "includes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludes = excludes {
            try encodeContainer.encode(excludes, forKey: .excludes)
        }
        if let includes = includes {
            try encodeContainer.encode(includes, forKey: .includes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludesDecoded = try containerValues.decodeIfPresent(CriteriaBlockForJob.self, forKey: .excludes)
        excludes = excludesDecoded
        let includesDecoded = try containerValues.decodeIfPresent(CriteriaBlockForJob.self, forKey: .includes)
        includes = includesDecoded
    }
}

extension S3BucketCriteriaForJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3BucketCriteriaForJob(excludes: \(String(describing: excludes)), includes: \(String(describing: includes)))"}
}

/// <p>Specifies property- and tag-based conditions that define criteria for including or excluding S3 buckets from a classification job. Exclude conditions take precedence over include conditions.</p>
public struct S3BucketCriteriaForJob: Equatable {
    /// <p>The property- and tag-based conditions that determine which buckets to exclude from the job.</p>
    public let excludes: CriteriaBlockForJob?
    /// <p>The property- and tag-based conditions that determine which buckets to include in the job.</p>
    public let includes: CriteriaBlockForJob?

    public init (
        excludes: CriteriaBlockForJob? = nil,
        includes: CriteriaBlockForJob? = nil
    )
    {
        self.excludes = excludes
        self.includes = includes
    }
}

extension S3BucketDefinitionForJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case buckets = "buckets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let buckets = buckets {
            var bucketsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .buckets)
            for __listof__string0 in buckets {
                try bucketsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let bucketsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .buckets)
        var bucketsDecoded0:[String]? = nil
        if let bucketsContainer = bucketsContainer {
            bucketsDecoded0 = [String]()
            for string0 in bucketsContainer {
                if let string0 = string0 {
                    bucketsDecoded0?.append(string0)
                }
            }
        }
        buckets = bucketsDecoded0
    }
}

extension S3BucketDefinitionForJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3BucketDefinitionForJob(accountId: \(String(describing: accountId)), buckets: \(String(describing: buckets)))"}
}

/// <p>Specifies an AWS account that owns S3 buckets for a classification job to analyze, and one or more specific buckets to analyze for that account.</p>
public struct S3BucketDefinitionForJob: Equatable {
    /// <p>The unique identifier for the AWS account that owns the buckets.</p>
    public let accountId: String?
    /// <p>An array that lists the names of the buckets.</p>
    public let buckets: [String]?

    public init (
        accountId: String? = nil,
        buckets: [String]? = nil
    )
    {
        self.accountId = accountId
        self.buckets = buckets
    }
}

extension S3BucketOwner: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "displayName"
        case id = "id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension S3BucketOwner: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3BucketOwner(displayName: \(String(describing: displayName)), id: \(String(describing: id)))"}
}

/// <p>Provides information about the user who owns an S3 bucket.</p>
public struct S3BucketOwner: Equatable {
    /// <p>The display name of the user who owns the bucket.</p>
    public let displayName: String?
    /// <p>The AWS account ID for the user who owns the bucket.</p>
    public let id: String?

    public init (
        displayName: String? = nil,
        id: String? = nil
    )
    {
        self.displayName = displayName
        self.id = id
    }
}

extension S3Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName = "bucketName"
        case keyPrefix = "keyPrefix"
        case kmsKeyArn = "kmsKeyArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension S3Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Destination(bucketName: \(String(describing: bucketName)), keyPrefix: \(String(describing: keyPrefix)), kmsKeyArn: \(String(describing: kmsKeyArn)))"}
}

/// <p>Specifies an S3 bucket to store data classification results in, and the encryption settings to use when storing results in that bucket.</p>
public struct S3Destination: Equatable {
    /// <p>The name of the bucket.</p>
    public let bucketName: String?
    /// <p>The path prefix to use in the path to the location in the bucket. This prefix specifies where to store classification results in the bucket.</p>
    public let keyPrefix: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use for encryption of the results. This must be the ARN of an existing CMK that's in the same AWS Region as the bucket.</p>
    public let kmsKeyArn: String?

    public init (
        bucketName: String? = nil,
        keyPrefix: String? = nil,
        kmsKeyArn: String? = nil
    )
    {
        self.bucketName = bucketName
        self.keyPrefix = keyPrefix
        self.kmsKeyArn = kmsKeyArn
    }
}

extension S3JobDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketCriteria = "bucketCriteria"
        case bucketDefinitions = "bucketDefinitions"
        case scoping = "scoping"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketCriteria = bucketCriteria {
            try encodeContainer.encode(bucketCriteria, forKey: .bucketCriteria)
        }
        if let bucketDefinitions = bucketDefinitions {
            var bucketDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bucketDefinitions)
            for __listofs3bucketdefinitionforjob0 in bucketDefinitions {
                try bucketDefinitionsContainer.encode(__listofs3bucketdefinitionforjob0)
            }
        }
        if let scoping = scoping {
            try encodeContainer.encode(scoping, forKey: .scoping)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDefinitionsContainer = try containerValues.decodeIfPresent([S3BucketDefinitionForJob?].self, forKey: .bucketDefinitions)
        var bucketDefinitionsDecoded0:[S3BucketDefinitionForJob]? = nil
        if let bucketDefinitionsContainer = bucketDefinitionsContainer {
            bucketDefinitionsDecoded0 = [S3BucketDefinitionForJob]()
            for structure0 in bucketDefinitionsContainer {
                if let structure0 = structure0 {
                    bucketDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        bucketDefinitions = bucketDefinitionsDecoded0
        let scopingDecoded = try containerValues.decodeIfPresent(Scoping.self, forKey: .scoping)
        scoping = scopingDecoded
        let bucketCriteriaDecoded = try containerValues.decodeIfPresent(S3BucketCriteriaForJob.self, forKey: .bucketCriteria)
        bucketCriteria = bucketCriteriaDecoded
    }
}

extension S3JobDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3JobDefinition(bucketCriteria: \(String(describing: bucketCriteria)), bucketDefinitions: \(String(describing: bucketDefinitions)), scoping: \(String(describing: scoping)))"}
}

/// <p>Specifies which S3 buckets contain the objects that a classification job analyzes, and the scope of that analysis. The bucket specification can be static (bucketDefinitions) or dynamic (bucketCriteria). If it's static, the job analyzes objects in the same predefined set of buckets each time the job runs. If it's dynamic, the job analyzes objects in any buckets that match the specified criteria each time the job starts to run.</p>
public struct S3JobDefinition: Equatable {
    /// <p>The property- and tag-based conditions that determine which S3 buckets to include or exclude from the analysis. Each time the job runs, the job uses these criteria to determine which buckets contain objects to analyze. A job's definition can contain a bucketCriteria object or a bucketDefinitions array, not both.</p>
    public let bucketCriteria: S3BucketCriteriaForJob?
    /// <p>An array of objects, one for each AWS account that owns specific S3 buckets to analyze. Each object specifies the account ID for an account and one or more buckets to analyze for that account. A job's definition can contain a bucketDefinitions array or a bucketCriteria object, not both.</p>
    public let bucketDefinitions: [S3BucketDefinitionForJob]?
    /// <p>The property- and tag-based conditions that determine which S3 objects to include or exclude from the analysis. Each time the job runs, the job uses these criteria to determine which objects to analyze.</p>
    public let scoping: Scoping?

    public init (
        bucketCriteria: S3BucketCriteriaForJob? = nil,
        bucketDefinitions: [S3BucketDefinitionForJob]? = nil,
        scoping: Scoping? = nil
    )
    {
        self.bucketCriteria = bucketCriteria
        self.bucketDefinitions = bucketDefinitions
        self.scoping = scoping
    }
}

extension S3Object: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketArn = "bucketArn"
        case eTag = "eTag"
        case `extension` = "extension"
        case key = "key"
        case lastModified = "lastModified"
        case path = "path"
        case publicAccess = "publicAccess"
        case serverSideEncryption = "serverSideEncryption"
        case size = "size"
        case storageClass = "storageClass"
        case tags = "tags"
        case versionId = "versionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let eTag = eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if let `extension` = `extension` {
            try encodeContainer.encode(`extension`, forKey: .`extension`)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if publicAccess != false {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
        if let serverSideEncryption = serverSideEncryption {
            try encodeContainer.encode(serverSideEncryption, forKey: .serverSideEncryption)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let storageClass = storageClass {
            try encodeContainer.encode(storageClass.rawValue, forKey: .storageClass)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for keyvaluepairlist0 in tags {
                try tagsContainer.encode(keyvaluepairlist0)
            }
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eTag)
        eTag = eTagDecoded
        let extensionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .extension)
        `extension` = extensionDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let publicAccessDecoded = try containerValues.decode(Bool.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
        let serverSideEncryptionDecoded = try containerValues.decodeIfPresent(ServerSideEncryption.self, forKey: .serverSideEncryption)
        serverSideEncryption = serverSideEncryptionDecoded
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyValuePair?].self, forKey: .tags)
        var tagsDecoded0:[KeyValuePair]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyValuePair]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension S3Object: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Object(bucketArn: \(String(describing: bucketArn)), eTag: \(String(describing: eTag)), extension: \(String(describing: `extension`)), key: \(String(describing: key)), lastModified: \(String(describing: lastModified)), path: \(String(describing: path)), publicAccess: \(String(describing: publicAccess)), serverSideEncryption: \(String(describing: serverSideEncryption)), size: \(String(describing: size)), storageClass: \(String(describing: storageClass)), tags: \(String(describing: tags)), versionId: \(String(describing: versionId)))"}
}

/// <p>Provides information about an S3 object that a finding applies to.</p>
public struct S3Object: Equatable {
    /// <p>The file name extension of the object. If the object doesn't have a file name extension, this value is "".</p>
    public let `extension`: String?
    /// <p>The Amazon Resource Name (ARN) of the bucket that contains the object.</p>
    public let bucketArn: String?
    /// <p>The entity tag (ETag) that identifies the affected version of the object. If the object was overwritten or changed after Amazon Macie produced the finding, this value might be different from the current ETag for the object.</p>
    public let eTag: String?
    /// <p>The full key (name) that's assigned to the object.</p>
    public let key: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the object was last modified.</p>
    public let lastModified: Date?
    /// <p>The path to the object, including the full key (name).</p>
    public let path: String?
    /// <p>Specifies whether the object is publicly accessible due to the combination of permissions settings that apply to the object.</p>
    public let publicAccess: Bool
    /// <p>The type of server-side encryption that's used to encrypt the object.</p>
    public let serverSideEncryption: ServerSideEncryption?
    /// <p>The total storage size, in bytes, of the object.</p>
    public let size: Int
    /// <p>The storage class of the object.</p>
    public let storageClass: StorageClass?
    /// <p>The tags that are associated with the object.</p>
    public let tags: [KeyValuePair]?
    /// <p>The identifier for the affected version of the object.</p>
    public let versionId: String?

    public init (
        `extension`: String? = nil,
        bucketArn: String? = nil,
        eTag: String? = nil,
        key: String? = nil,
        lastModified: Date? = nil,
        path: String? = nil,
        publicAccess: Bool = false,
        serverSideEncryption: ServerSideEncryption? = nil,
        size: Int = 0,
        storageClass: StorageClass? = nil,
        tags: [KeyValuePair]? = nil,
        versionId: String? = nil
    )
    {
        self.`extension` = `extension`
        self.bucketArn = bucketArn
        self.eTag = eTag
        self.key = key
        self.lastModified = lastModified
        self.path = path
        self.publicAccess = publicAccess
        self.serverSideEncryption = serverSideEncryption
        self.size = size
        self.storageClass = storageClass
        self.tags = tags
        self.versionId = versionId
    }
}

/// <p>The property to use in a condition that determines whether an S3 object is included or excluded from a classification job. Valid values are:</p>
public enum ScopeFilterKey {
    case bucketCreationDate
    case objectExtension
    case objectKey
    case objectLastModifiedDate
    case objectSize
    case tag
    case sdkUnknown(String)
}

extension ScopeFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScopeFilterKey] {
        return [
            .bucketCreationDate,
            .objectExtension,
            .objectKey,
            .objectLastModifiedDate,
            .objectSize,
            .tag,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bucketCreationDate: return "BUCKET_CREATION_DATE"
        case .objectExtension: return "OBJECT_EXTENSION"
        case .objectKey: return "OBJECT_KEY"
        case .objectLastModifiedDate: return "OBJECT_LAST_MODIFIED_DATE"
        case .objectSize: return "OBJECT_SIZE"
        case .tag: return "TAG"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScopeFilterKey(rawValue: rawValue) ?? ScopeFilterKey.sdkUnknown(rawValue)
    }
}

extension Scoping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludes = "excludes"
        case includes = "includes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludes = excludes {
            try encodeContainer.encode(excludes, forKey: .excludes)
        }
        if let includes = includes {
            try encodeContainer.encode(includes, forKey: .includes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludesDecoded = try containerValues.decodeIfPresent(JobScopingBlock.self, forKey: .excludes)
        excludes = excludesDecoded
        let includesDecoded = try containerValues.decodeIfPresent(JobScopingBlock.self, forKey: .includes)
        includes = includesDecoded
    }
}

extension Scoping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Scoping(excludes: \(String(describing: excludes)), includes: \(String(describing: includes)))"}
}

/// <p>Specifies one or more property- and tag-based conditions that define criteria for including or excluding S3 objects from a classification job. Exclude conditions take precedence over include conditions.</p>
public struct Scoping: Equatable {
    /// <p>The property- or tag-based conditions that determine which objects to exclude from the analysis.</p>
    public let excludes: JobScopingBlock?
    /// <p>The property- or tag-based conditions that determine which objects to include in the analysis.</p>
    public let includes: JobScopingBlock?

    public init (
        excludes: JobScopingBlock? = nil,
        includes: JobScopingBlock? = nil
    )
    {
        self.excludes = excludes
        self.includes = includes
    }
}

extension SearchResourcesBucketCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludes = "excludes"
        case includes = "includes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludes = excludes {
            try encodeContainer.encode(excludes, forKey: .excludes)
        }
        if let includes = includes {
            try encodeContainer.encode(includes, forKey: .includes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludesDecoded = try containerValues.decodeIfPresent(SearchResourcesCriteriaBlock.self, forKey: .excludes)
        excludes = excludesDecoded
        let includesDecoded = try containerValues.decodeIfPresent(SearchResourcesCriteriaBlock.self, forKey: .includes)
        includes = includesDecoded
    }
}

extension SearchResourcesBucketCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchResourcesBucketCriteria(excludes: \(String(describing: excludes)), includes: \(String(describing: includes)))"}
}

/// <p>Specifies property- and tag-based conditions that define filter criteria for including or excluding S3 buckets from the query results. Exclude conditions take precedence over include conditions.</p>
public struct SearchResourcesBucketCriteria: Equatable {
    /// <p>The property- and tag-based conditions that determine which buckets to exclude from the results.</p>
    public let excludes: SearchResourcesCriteriaBlock?
    /// <p>The property- and tag-based conditions that determine which buckets to include in the results.</p>
    public let includes: SearchResourcesCriteriaBlock?

    public init (
        excludes: SearchResourcesCriteriaBlock? = nil,
        includes: SearchResourcesCriteriaBlock? = nil
    )
    {
        self.excludes = excludes
        self.includes = includes
    }
}

/// <p>The operator to use in a condition that filters the results of a query. Valid values are:</p>
public enum SearchResourcesComparator {
    case eq
    case ne
    case sdkUnknown(String)
}

extension SearchResourcesComparator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SearchResourcesComparator] {
        return [
            .eq,
            .ne,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .eq: return "EQ"
        case .ne: return "NE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SearchResourcesComparator(rawValue: rawValue) ?? SearchResourcesComparator.sdkUnknown(rawValue)
    }
}

extension SearchResourcesCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case simpleCriterion = "simpleCriterion"
        case tagCriterion = "tagCriterion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleCriterion = simpleCriterion {
            try encodeContainer.encode(simpleCriterion, forKey: .simpleCriterion)
        }
        if let tagCriterion = tagCriterion {
            try encodeContainer.encode(tagCriterion, forKey: .tagCriterion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleCriterionDecoded = try containerValues.decodeIfPresent(SearchResourcesSimpleCriterion.self, forKey: .simpleCriterion)
        simpleCriterion = simpleCriterionDecoded
        let tagCriterionDecoded = try containerValues.decodeIfPresent(SearchResourcesTagCriterion.self, forKey: .tagCriterion)
        tagCriterion = tagCriterionDecoded
    }
}

extension SearchResourcesCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchResourcesCriteria(simpleCriterion: \(String(describing: simpleCriterion)), tagCriterion: \(String(describing: tagCriterion)))"}
}

/// <p>Specifies a property- or tag-based filter condition for including or excluding AWS resources from the query results.</p>
public struct SearchResourcesCriteria: Equatable {
    /// <p>A property-based condition that defines a property, operator, and one or more values for including or excluding resources from the results.</p>
    public let simpleCriterion: SearchResourcesSimpleCriterion?
    /// <p>A tag-based condition that defines an operator and tag keys, tag values, or tag key and value pairs for including or excluding resources from the results.</p>
    public let tagCriterion: SearchResourcesTagCriterion?

    public init (
        simpleCriterion: SearchResourcesSimpleCriterion? = nil,
        tagCriterion: SearchResourcesTagCriterion? = nil
    )
    {
        self.simpleCriterion = simpleCriterion
        self.tagCriterion = tagCriterion
    }
}

extension SearchResourcesCriteriaBlock: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case and = "and"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for __listofsearchresourcescriteria0 in and {
                try andContainer.encode(__listofsearchresourcescriteria0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let andContainer = try containerValues.decodeIfPresent([SearchResourcesCriteria?].self, forKey: .and)
        var andDecoded0:[SearchResourcesCriteria]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [SearchResourcesCriteria]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
    }
}

extension SearchResourcesCriteriaBlock: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchResourcesCriteriaBlock(and: \(String(describing: and)))"}
}

/// <p>Specifies property- and tag-based conditions that define filter criteria for including or excluding AWS resources from the query results.</p>
public struct SearchResourcesCriteriaBlock: Equatable {
    /// <p>An array of objects, one for each property- or tag-based condition that includes or excludes resources from the query results. If you specify more than one condition, Amazon Macie uses AND logic to join the conditions.</p>
    public let and: [SearchResourcesCriteria]?

    public init (
        and: [SearchResourcesCriteria]? = nil
    )
    {
        self.and = and
    }
}

public struct SearchResourcesInputBodyMiddleware: Middleware {
    public let id: String = "SearchResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchResourcesInput>
    public typealias MOutput = OperationOutput<SearchResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchResourcesOutputError>
}

extension SearchResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchResourcesInput(bucketCriteria: \(String(describing: bucketCriteria)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension SearchResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketCriteria = "bucketCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketCriteria = bucketCriteria {
            try encodeContainer.encode(bucketCriteria, forKey: .bucketCriteria)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

public struct SearchResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "SearchResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchResourcesInput>
    public typealias MOutput = OperationOutput<SearchResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchResourcesOutputError>
}

public struct SearchResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "SearchResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SearchResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<SearchResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SearchResourcesInput>
    public typealias MOutput = OperationOutput<SearchResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SearchResourcesOutputError>
}

public struct SearchResourcesInput: Equatable {
    /// <p>The filter conditions that determine which S3 buckets to include or exclude from the query results.</p>
    public let bucketCriteria: SearchResourcesBucketCriteria?
    /// <p>The maximum number of items to include in each page of the response. The default value is 50.</p>
    public let maxResults: Int
    /// <p>The nextToken string that specifies which page of results to return in a paginated response.</p>
    public let nextToken: String?
    /// <p>The criteria to use to sort the results.</p>
    public let sortCriteria: SearchResourcesSortCriteria?

    public init (
        bucketCriteria: SearchResourcesBucketCriteria? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        sortCriteria: SearchResourcesSortCriteria? = nil
    )
    {
        self.bucketCriteria = bucketCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchResourcesInputBody: Equatable {
    public let bucketCriteria: SearchResourcesBucketCriteria?
    public let maxResults: Int
    public let nextToken: String?
    public let sortCriteria: SearchResourcesSortCriteria?
}

extension SearchResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucketCriteria = "bucketCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketCriteriaDecoded = try containerValues.decodeIfPresent(SearchResourcesBucketCriteria.self, forKey: .bucketCriteria)
        bucketCriteria = bucketCriteriaDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(SearchResourcesSortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension SearchResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchResourcesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchResourcesOutputResponse(matchingResources: \(String(describing: matchingResources)), nextToken: \(String(describing: nextToken)))"}
}

extension SearchResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SearchResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.matchingResources = output.matchingResources
            self.nextToken = output.nextToken
        } else {
            self.matchingResources = nil
            self.nextToken = nil
        }
    }
}

public struct SearchResourcesOutputResponse: Equatable {
    /// <p>An array of objects, one for each resource that meets the filter criteria specified in the request.</p>
    public let matchingResources: [MatchingResource]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        matchingResources: [MatchingResource]? = nil,
        nextToken: String? = nil
    )
    {
        self.matchingResources = matchingResources
        self.nextToken = nextToken
    }
}

struct SearchResourcesOutputResponseBody: Equatable {
    public let matchingResources: [MatchingResource]?
    public let nextToken: String?
}

extension SearchResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case matchingResources = "matchingResources"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchingResourcesContainer = try containerValues.decodeIfPresent([MatchingResource?].self, forKey: .matchingResources)
        var matchingResourcesDecoded0:[MatchingResource]? = nil
        if let matchingResourcesContainer = matchingResourcesContainer {
            matchingResourcesDecoded0 = [MatchingResource]()
            for structure0 in matchingResourcesContainer {
                if let structure0 = structure0 {
                    matchingResourcesDecoded0?.append(structure0)
                }
            }
        }
        matchingResources = matchingResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SearchResourcesSimpleCriterion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparator = "comparator"
        case key = "key"
        case values = "values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for __listof__string0 in values {
                try valuesContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(SearchResourcesComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let keyDecoded = try containerValues.decodeIfPresent(SearchResourcesSimpleCriterionKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SearchResourcesSimpleCriterion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchResourcesSimpleCriterion(comparator: \(String(describing: comparator)), key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>Specifies a property-based filter condition that determines which AWS resources are included or excluded from the query results.</p>
public struct SearchResourcesSimpleCriterion: Equatable {
    /// <p>The operator to use in the condition. Valid values are EQ (equals) and NE (not equals).</p>
    public let comparator: SearchResourcesComparator?
    /// <p>The property to use in the condition.</p>
    public let key: SearchResourcesSimpleCriterionKey?
    /// <p>An array that lists one or more values to use in the condition. If you specify multiple values, Amazon Macie uses OR logic to join the values. Valid values for each supported property (key) are:</p> <ul><li><p>ACCOUNT_ID - A string that represents the unique identifier for the AWS account that owns the resource.</p></li> <li><p>S3_BUCKET_EFFECTIVE_PERMISSION - A string that represents an enumerated value that Macie defines for the <a href="https://docs.aws.amazon.com/macie/latest/APIReference/datasources-s3.html#datasources-s3-prop-bucketpublicaccess-effectivepermission">BucketPublicAccess.effectivePermission</a> property of an S3 bucket.</p></li> <li><p>S3_BUCKET_NAME - A string that represents the name of an S3 bucket.</p></li> <li><p>S3_BUCKET_SHARED_ACCESS - A string that represents an enumerated value that Macie defines for the <a href="https://docs.aws.amazon.com/macie/latest/APIReference/datasources-s3.html#datasources-s3-prop-bucketmetadata-sharedaccess">BucketMetadata.sharedAccess</a> property of an S3 bucket.</p></li></ul> <p>Values are case sensitive. Also, Macie doesn't support use of partial values or wildcard characters in values.</p>
    public let values: [String]?

    public init (
        comparator: SearchResourcesComparator? = nil,
        key: SearchResourcesSimpleCriterionKey? = nil,
        values: [String]? = nil
    )
    {
        self.comparator = comparator
        self.key = key
        self.values = values
    }
}

/// <p>The property to use in a condition that filters the query results. Valid values are:</p>
public enum SearchResourcesSimpleCriterionKey {
    case accountId
    case s3BucketEffectivePermission
    case s3BucketName
    case s3BucketSharedAccess
    case sdkUnknown(String)
}

extension SearchResourcesSimpleCriterionKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SearchResourcesSimpleCriterionKey] {
        return [
            .accountId,
            .s3BucketEffectivePermission,
            .s3BucketName,
            .s3BucketSharedAccess,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountId: return "ACCOUNT_ID"
        case .s3BucketEffectivePermission: return "S3_BUCKET_EFFECTIVE_PERMISSION"
        case .s3BucketName: return "S3_BUCKET_NAME"
        case .s3BucketSharedAccess: return "S3_BUCKET_SHARED_ACCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SearchResourcesSimpleCriterionKey(rawValue: rawValue) ?? SearchResourcesSimpleCriterionKey.sdkUnknown(rawValue)
    }
}

/// <p>The property to sort the query results by. Valid values are:</p>
public enum SearchResourcesSortAttributeName {
    case accountId
    case resourceName
    case s3ClassifiableObjectCount
    case s3ClassifiableSizeInBytes
    case sdkUnknown(String)
}

extension SearchResourcesSortAttributeName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SearchResourcesSortAttributeName] {
        return [
            .accountId,
            .resourceName,
            .s3ClassifiableObjectCount,
            .s3ClassifiableSizeInBytes,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountId: return "ACCOUNT_ID"
        case .resourceName: return "RESOURCE_NAME"
        case .s3ClassifiableObjectCount: return "S3_CLASSIFIABLE_OBJECT_COUNT"
        case .s3ClassifiableSizeInBytes: return "S3_CLASSIFIABLE_SIZE_IN_BYTES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SearchResourcesSortAttributeName(rawValue: rawValue) ?? SearchResourcesSortAttributeName.sdkUnknown(rawValue)
    }
}

extension SearchResourcesSortCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName.rawValue, forKey: .attributeName)
        }
        if let orderBy = orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(SearchResourcesSortAttributeName.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension SearchResourcesSortCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchResourcesSortCriteria(attributeName: \(String(describing: attributeName)), orderBy: \(String(describing: orderBy)))"}
}

/// <p>Specifies criteria for sorting the results of a query for information about AWS resources that Amazon Macie monitors and analyzes.</p>
public struct SearchResourcesSortCriteria: Equatable {
    /// <p>The property to sort the results by.</p>
    public let attributeName: SearchResourcesSortAttributeName?
    /// <p>The sort order to apply to the results, based on the value for the property specified by the attributeName property. Valid values are: ASC, sort the results in ascending order; and, DESC, sort the results in descending order.</p>
    public let orderBy: OrderBy?

    public init (
        attributeName: SearchResourcesSortAttributeName? = nil,
        orderBy: OrderBy? = nil
    )
    {
        self.attributeName = attributeName
        self.orderBy = orderBy
    }
}

extension SearchResourcesTagCriterion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparator = "comparator"
        case tagValues = "tagValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for __listofsearchresourcestagcriterionpair0 in tagValues {
                try tagValuesContainer.encode(__listofsearchresourcestagcriterionpair0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(SearchResourcesComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([SearchResourcesTagCriterionPair?].self, forKey: .tagValues)
        var tagValuesDecoded0:[SearchResourcesTagCriterionPair]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [SearchResourcesTagCriterionPair]()
            for structure0 in tagValuesContainer {
                if let structure0 = structure0 {
                    tagValuesDecoded0?.append(structure0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension SearchResourcesTagCriterion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchResourcesTagCriterion(comparator: \(String(describing: comparator)), tagValues: \(String(describing: tagValues)))"}
}

/// <p>Specifies a tag-based filter condition that determines which AWS resources are included or excluded from the query results.</p>
public struct SearchResourcesTagCriterion: Equatable {
    /// <p>The operator to use in the condition. Valid values are EQ (equals) and NE (not equals).</p>
    public let comparator: SearchResourcesComparator?
    /// <p>The tag keys, tag values, or tag key and value pairs to use in the condition.</p>
    public let tagValues: [SearchResourcesTagCriterionPair]?

    public init (
        comparator: SearchResourcesComparator? = nil,
        tagValues: [SearchResourcesTagCriterionPair]? = nil
    )
    {
        self.comparator = comparator
        self.tagValues = tagValues
    }
}

extension SearchResourcesTagCriterionPair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SearchResourcesTagCriterionPair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SearchResourcesTagCriterionPair(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Specifies a tag key, a tag value, or a tag key and value (as a pair) to use in a tag-based filter condition for a query. Tag keys and values are case sensitive. Also, Amazon Macie doesn't support use of partial values or wildcard characters in tag-based filter conditions.</p>
public struct SearchResourcesTagCriterionPair: Equatable {
    /// <p>The value for the tag key to use in the condition.</p>
    public let key: String?
    /// <p>The tag value to use in the condition.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension SecurityHubConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case publishClassificationFindings = "publishClassificationFindings"
        case publishPolicyFindings = "publishPolicyFindings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if publishClassificationFindings != false {
            try encodeContainer.encode(publishClassificationFindings, forKey: .publishClassificationFindings)
        }
        if publishPolicyFindings != false {
            try encodeContainer.encode(publishPolicyFindings, forKey: .publishPolicyFindings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishClassificationFindingsDecoded = try containerValues.decode(Bool.self, forKey: .publishClassificationFindings)
        publishClassificationFindings = publishClassificationFindingsDecoded
        let publishPolicyFindingsDecoded = try containerValues.decode(Bool.self, forKey: .publishPolicyFindings)
        publishPolicyFindings = publishPolicyFindingsDecoded
    }
}

extension SecurityHubConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityHubConfiguration(publishClassificationFindings: \(String(describing: publishClassificationFindings)), publishPolicyFindings: \(String(describing: publishPolicyFindings)))"}
}

/// <p>Specifies configuration settings that determine which findings are published to AWS Security Hub automatically. For information about how Macie publishes findings to Security Hub, see <a href="https://docs.aws.amazon.com/macie/latest/user/securityhub-integration.html">Amazon Macie integration with Security Hub</a> in the <i>Amazon Macie User Guide</i>.</p>
public struct SecurityHubConfiguration: Equatable {
    /// <p>Specifies whether to publish sensitive data findings to AWS Security Hub. If you set this value to true, Amazon Macie automatically publishes all sensitive data findings that weren't suppressed by a findings filter. The default value is false.</p>
    public let publishClassificationFindings: Bool
    /// <p>Specifies whether to publish policy findings to AWS Security Hub. If you set this value to true, Amazon Macie automatically publishes all new and updated policy findings that weren't suppressed by a findings filter. The default value is true.</p>
    public let publishPolicyFindings: Bool

    public init (
        publishClassificationFindings: Bool = false,
        publishPolicyFindings: Bool = false
    )
    {
        self.publishClassificationFindings = publishClassificationFindings
        self.publishPolicyFindings = publishPolicyFindings
    }
}

extension SensitiveDataItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category = "category"
        case detections = "detections"
        case totalCount = "totalCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let detections = detections {
            var detectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detections)
            for defaultdetections0 in detections {
                try detectionsContainer.encode(defaultdetections0)
            }
        }
        if totalCount != 0 {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(SensitiveDataItemCategory.self, forKey: .category)
        category = categoryDecoded
        let detectionsContainer = try containerValues.decodeIfPresent([DefaultDetection?].self, forKey: .detections)
        var detectionsDecoded0:[DefaultDetection]? = nil
        if let detectionsContainer = detectionsContainer {
            detectionsDecoded0 = [DefaultDetection]()
            for structure0 in detectionsContainer {
                if let structure0 = structure0 {
                    detectionsDecoded0?.append(structure0)
                }
            }
        }
        detections = detectionsDecoded0
        let totalCountDecoded = try containerValues.decode(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension SensitiveDataItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SensitiveDataItem(category: \(String(describing: category)), detections: \(String(describing: detections)), totalCount: \(String(describing: totalCount)))"}
}

/// <p>Provides information about the category, types, and occurrences of sensitive data that produced a sensitive data finding.</p>
public struct SensitiveDataItem: Equatable {
    /// <p>The category of sensitive data that was detected. For example: CREDENTIALS, for credentials data such as private keys or AWS secret keys; FINANCIAL_INFORMATION, for financial data such as credit card numbers; or, PERSONAL_INFORMATION, for personal health information, such as health insurance identification numbers, or personally identifiable information, such as driver's license identification numbers.</p>
    public let category: SensitiveDataItemCategory?
    /// <p>An array of objects, one for each type of sensitive data that was detected. Each object reports the number of occurrences of a specific type of sensitive data that was detected, and the location of up to 15 of those occurrences.</p>
    public let detections: [DefaultDetection]?
    /// <p>The total number of occurrences of the sensitive data that was detected.</p>
    public let totalCount: Int

    public init (
        category: SensitiveDataItemCategory? = nil,
        detections: [DefaultDetection]? = nil,
        totalCount: Int = 0
    )
    {
        self.category = category
        self.detections = detections
        self.totalCount = totalCount
    }
}

/// <p>The category of sensitive data that was detected and produced the finding. Possible values are:</p>
public enum SensitiveDataItemCategory {
    case credentials
    case customIdentifier
    case financialInformation
    case personalInformation
    case sdkUnknown(String)
}

extension SensitiveDataItemCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SensitiveDataItemCategory] {
        return [
            .credentials,
            .customIdentifier,
            .financialInformation,
            .personalInformation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .credentials: return "CREDENTIALS"
        case .customIdentifier: return "CUSTOM_IDENTIFIER"
        case .financialInformation: return "FINANCIAL_INFORMATION"
        case .personalInformation: return "PERSONAL_INFORMATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SensitiveDataItemCategory(rawValue: rawValue) ?? SensitiveDataItemCategory.sdkUnknown(rawValue)
    }
}

extension ServerSideEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionType = "encryptionType"
        case kmsMasterKeyId = "kmsMasterKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kmsMasterKeyId = kmsMasterKeyId {
            try encodeContainer.encode(kmsMasterKeyId, forKey: .kmsMasterKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsMasterKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsMasterKeyId)
        kmsMasterKeyId = kmsMasterKeyIdDecoded
    }
}

extension ServerSideEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerSideEncryption(encryptionType: \(String(describing: encryptionType)), kmsMasterKeyId: \(String(describing: kmsMasterKeyId)))"}
}

/// <p>Provides information about the server-side encryption settings for an S3 bucket or S3 object.</p>
public struct ServerSideEncryption: Equatable {
    /// <p>The server-side encryption algorithm that's used when storing data in the bucket or object. If default encryption is disabled for the bucket or the object isn't encrypted using server-side encryption, this value is NONE.</p>
    public let encryptionType: EncryptionType?
    /// <p>The Amazon Resource Name (ARN) or unique identifier (key ID) for the AWS Key Management Service (AWS KMS) customer master key (CMK) that's used to encrypt data in the bucket or the object. If an AWS KMS CMK isn't used, this value is null.</p>
    public let kmsMasterKeyId: String?

    public init (
        encryptionType: EncryptionType? = nil,
        kmsMasterKeyId: String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.kmsMasterKeyId = kmsMasterKeyId
    }
}

extension ServiceLimit: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isServiceLimited = "isServiceLimited"
        case unit = "unit"
        case value = "value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isServiceLimited != false {
            try encodeContainer.encode(isServiceLimited, forKey: .isServiceLimited)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isServiceLimitedDecoded = try containerValues.decode(Bool.self, forKey: .isServiceLimited)
        isServiceLimited = isServiceLimitedDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Unit.self, forKey: .unit)
        unit = unitDecoded
        let valueDecoded = try containerValues.decode(Int.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceLimit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceLimit(isServiceLimited: \(String(describing: isServiceLimited)), unit: \(String(describing: unit)), value: \(String(describing: value)))"}
}

/// <p>Specifies a current quota for an Amazon Macie account.</p>
public struct ServiceLimit: Equatable {
    /// <p>Specifies whether the account has met the quota that corresponds to the metric specified by the UsageByAccount.type field in the response.</p>
    public let isServiceLimited: Bool
    /// <p>The unit of measurement for the value specified by the value field.</p>
    public let unit: Unit?
    /// <p>The value for the metric specified by the UsageByAccount.type field in the response.</p>
    public let value: Int

    public init (
        isServiceLimited: Bool = false,
        unit: Unit? = nil,
        value: Int = 0
    )
    {
        self.isServiceLimited = isServiceLimited
        self.unit = unit
        self.value = value
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an error that occurred due to one or more service quotas for an account.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The explanation of the error that occurred.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SessionContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "attributes"
        case sessionIssuer = "sessionIssuer"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let sessionIssuer = sessionIssuer {
            try encodeContainer.encode(sessionIssuer, forKey: .sessionIssuer)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(SessionContextAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
        let sessionIssuerDecoded = try containerValues.decodeIfPresent(SessionIssuer.self, forKey: .sessionIssuer)
        sessionIssuer = sessionIssuerDecoded
    }
}

extension SessionContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SessionContext(attributes: \(String(describing: attributes)), sessionIssuer: \(String(describing: sessionIssuer)))"}
}

/// <p>Provides information about a session that was created for an entity that performed an action by using temporary security credentials.</p>
public struct SessionContext: Equatable {
    /// <p>The date and time when the credentials were issued, and whether the credentials were authenticated with a multi-factor authentication (MFA) device.</p>
    public let attributes: SessionContextAttributes?
    /// <p>The source and type of credentials that were issued to the entity.</p>
    public let sessionIssuer: SessionIssuer?

    public init (
        attributes: SessionContextAttributes? = nil,
        sessionIssuer: SessionIssuer? = nil
    )
    {
        self.attributes = attributes
        self.sessionIssuer = sessionIssuer
    }
}

extension SessionContextAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "creationDate"
        case mfaAuthenticated = "mfaAuthenticated"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if mfaAuthenticated != false {
            try encodeContainer.encode(mfaAuthenticated, forKey: .mfaAuthenticated)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let mfaAuthenticatedDecoded = try containerValues.decode(Bool.self, forKey: .mfaAuthenticated)
        mfaAuthenticated = mfaAuthenticatedDecoded
    }
}

extension SessionContextAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SessionContextAttributes(creationDate: \(String(describing: creationDate)), mfaAuthenticated: \(String(describing: mfaAuthenticated)))"}
}

/// <p>Provides information about the context in which temporary security credentials were issued to an entity.</p>
public struct SessionContextAttributes: Equatable {
    /// <p>The date and time, in UTC and ISO 8601 format, when the credentials were issued.</p>
    public let creationDate: Date?
    /// <p>Specifies whether the credentials were authenticated with a multi-factor authentication (MFA) device.</p>
    public let mfaAuthenticated: Bool

    public init (
        creationDate: Date? = nil,
        mfaAuthenticated: Bool = false
    )
    {
        self.creationDate = creationDate
        self.mfaAuthenticated = mfaAuthenticated
    }
}

extension SessionIssuer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case arn = "arn"
        case principalId = "principalId"
        case type = "type"
        case userName = "userName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension SessionIssuer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SessionIssuer(accountId: \(String(describing: accountId)), arn: \(String(describing: arn)), principalId: \(String(describing: principalId)), type: \(String(describing: type)), userName: \(String(describing: userName)))"}
}

/// <p>Provides information about the source and type of temporary security credentials that were issued to an entity.</p>
public struct SessionIssuer: Equatable {
    /// <p>The unique identifier for the AWS account that owns the entity that was used to get the credentials.</p>
    public let accountId: String?
    /// <p>The Amazon Resource Name (ARN) of the source account, IAM user, or role that was used to get the credentials.</p>
    public let arn: String?
    /// <p>The unique identifier for the entity that was used to get the credentials.</p>
    public let principalId: String?
    /// <p>The source of the temporary security credentials, such as Root, IAMUser, or Role.</p>
    public let type: String?
    /// <p>The name or alias of the user or role that issued the session. This value is null if the credentials were obtained from a root account that doesn't have an alias.</p>
    public let userName: String?

    public init (
        accountId: String? = nil,
        arn: String? = nil,
        principalId: String? = nil,
        type: String? = nil,
        userName: String? = nil
    )
    {
        self.accountId = accountId
        self.arn = arn
        self.principalId = principalId
        self.type = type
        self.userName = userName
    }
}

extension Severity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "description"
        case score = "score"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description.rawValue, forKey: .description)
        }
        if score != 0 {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(SeverityDescription.self, forKey: .description)
        description = descriptionDecoded
        let scoreDecoded = try containerValues.decode(Int.self, forKey: .score)
        score = scoreDecoded
    }
}

extension Severity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Severity(description: \(String(describing: description)), score: \(String(describing: score)))"}
}

/// <p>Provides the numerical and qualitative representations of a finding's severity.</p>
public struct Severity: Equatable {
    /// <p>The qualitative representation of the finding's severity, ranging from Low (least severe) to High (most severe).</p>
    public let description: SeverityDescription?
    /// <p>The numerical representation of the finding's severity, ranging from 1 (least severe) to 3 (most severe).</p>
    public let score: Int

    public init (
        description: SeverityDescription? = nil,
        score: Int = 0
    )
    {
        self.description = description
        self.score = score
    }
}

/// <p>The qualitative representation of the finding's severity. Possible values are:</p>
public enum SeverityDescription {
    case high
    case low
    case medium
    case sdkUnknown(String)
}

extension SeverityDescription : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SeverityDescription] {
        return [
            .high,
            .low,
            .medium,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "High"
        case .low: return "Low"
        case .medium: return "Medium"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SeverityDescription(rawValue: rawValue) ?? SeverityDescription.sdkUnknown(rawValue)
    }
}

public enum SharedAccess {
    case external
    case `internal`
    case notShared
    case unknown
    case sdkUnknown(String)
}

extension SharedAccess : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SharedAccess] {
        return [
            .external,
            .internal,
            .notShared,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .external: return "EXTERNAL"
        case .internal: return "INTERNAL"
        case .notShared: return "NOT_SHARED"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SharedAccess(rawValue: rawValue) ?? SharedAccess.sdkUnknown(rawValue)
    }
}

extension SimpleCriterionForJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparator = "comparator"
        case key = "key"
        case values = "values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for __listof__string0 in values {
                try valuesContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(JobComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let keyDecoded = try containerValues.decodeIfPresent(SimpleCriterionKeyForJob.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SimpleCriterionForJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimpleCriterionForJob(comparator: \(String(describing: comparator)), key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>Specifies a property-based condition that determines whether an S3 bucket is included or excluded from a classification job.</p>
public struct SimpleCriterionForJob: Equatable {
    /// <p>The operator to use in the condition. Valid values are EQ (equals) and NE (not equals).</p>
    public let comparator: JobComparator?
    /// <p>The property to use in the condition.</p>
    public let key: SimpleCriterionKeyForJob?
    /// <p>An array that lists one or more values to use in the condition. If you specify multiple values, Amazon Macie uses OR logic to join the values. Valid values for each supported property (key) are:</p> <ul><li><p>ACCOUNT_ID - A string that represents the unique identifier for the AWS account that owns the bucket.</p></li> <li><p>S3_BUCKET_EFFECTIVE_PERMISSION - A string that represents an enumerated value that Macie defines for the <a href="https://docs.aws.amazon.com/macie/latest/APIReference/datasources-s3.html#datasources-s3-prop-bucketpublicaccess-effectivepermission">BucketPublicAccess.effectivePermission</a> property of a bucket.</p></li> <li><p>S3_BUCKET_NAME - A string that represents the name of a bucket.</p></li> <li><p>S3_BUCKET_SHARED_ACCESS - A string that represents an enumerated value that Macie defines for the <a href="https://docs.aws.amazon.com/macie/latest/APIReference/datasources-s3.html#datasources-s3-prop-bucketmetadata-sharedaccess">BucketMetadata.sharedAccess</a> property of a bucket.</p></li></ul> <p>Values are case sensitive. Also, Macie doesn't support use of partial values or wildcard characters in these values.</p>
    public let values: [String]?

    public init (
        comparator: JobComparator? = nil,
        key: SimpleCriterionKeyForJob? = nil,
        values: [String]? = nil
    )
    {
        self.comparator = comparator
        self.key = key
        self.values = values
    }
}

/// <p>The property to use in a condition that determines whether an S3 bucket is included or excluded from a classification job. Valid values are:</p>
public enum SimpleCriterionKeyForJob {
    case accountId
    case s3BucketEffectivePermission
    case s3BucketName
    case s3BucketSharedAccess
    case sdkUnknown(String)
}

extension SimpleCriterionKeyForJob : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SimpleCriterionKeyForJob] {
        return [
            .accountId,
            .s3BucketEffectivePermission,
            .s3BucketName,
            .s3BucketSharedAccess,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountId: return "ACCOUNT_ID"
        case .s3BucketEffectivePermission: return "S3_BUCKET_EFFECTIVE_PERMISSION"
        case .s3BucketName: return "S3_BUCKET_NAME"
        case .s3BucketSharedAccess: return "S3_BUCKET_SHARED_ACCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SimpleCriterionKeyForJob(rawValue: rawValue) ?? SimpleCriterionKeyForJob.sdkUnknown(rawValue)
    }
}

extension SimpleScopeTerm: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparator = "comparator"
        case key = "key"
        case values = "values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for __listof__string0 in values {
                try valuesContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(JobComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let keyDecoded = try containerValues.decodeIfPresent(ScopeFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SimpleScopeTerm: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimpleScopeTerm(comparator: \(String(describing: comparator)), key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>Specifies a property-based condition that determines whether an S3 object is included or excluded from a classification job.</p>
public struct SimpleScopeTerm: Equatable {
    /// <p>The operator to use in the condition. Valid operators for each supported property (key) are:</p> <ul><li><p>OBJECT_EXTENSION - EQ (equals) or NE (not equals)</p></li> <li><p>OBJECT_KEY - STARTS_WITH</p></li> <li><p>OBJECT_LAST_MODIFIED_DATE - Any operator except CONTAINS</p></li> <li><p>OBJECT_SIZE - Any operator except CONTAINS</p></li> <li><p>TAG - EQ (equals) or NE (not equals)</p></li></ul>
    public let comparator: JobComparator?
    /// <p>The object property to use in the condition.</p>
    public let key: ScopeFilterKey?
    /// <p>An array that lists the values to use in the condition. If the value for the key property is OBJECT_EXTENSION or OBJECT_KEY, this array can specify multiple values and Amazon Macie uses an OR operator to join the values. Otherwise, this array can specify only one value.</p> <p>Valid values for each supported property (key) are:</p> <ul><li><p>OBJECT_EXTENSION - A string that represents the file name extension of an object. For example: docx or pdf</p></li> <li><p>OBJECT_KEY - A string that represents the key prefix (folder name or path) of an object. For example: logs or awslogs/eventlogs. This value applies a condition to objects whose keys (names) begin with the specified value.</p></li> <li><p>OBJECT_LAST_MODIFIED_DATE - The date and time (in UTC and extended ISO 8601 format) when an object was created or last changed, whichever is latest. For example: 2020-09-28T14:31:13Z</p></li> <li><p>OBJECT_SIZE - An integer that represents the storage size (in bytes) of an object.</p></li> <li><p>TAG - A string that represents a tag key for an object. For advanced options, use a TagScopeTerm object instead of a SimpleScopeTerm object to define a tag-based condition for the job.</p></li></ul> <p>Macie doesn't support use of wildcard characters in these values. Also, string values are case sensitive.</p>
    public let values: [String]?

    public init (
        comparator: JobComparator? = nil,
        key: ScopeFilterKey? = nil,
        values: [String]? = nil
    )
    {
        self.comparator = comparator
        self.key = key
        self.values = values
    }
}

extension SortCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let orderBy = orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension SortCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SortCriteria(attributeName: \(String(describing: attributeName)), orderBy: \(String(describing: orderBy)))"}
}

/// <p>Specifies criteria for sorting the results of a request for findings.</p>
public struct SortCriteria: Equatable {
    /// <p>The name of the property to sort the results by. This value can be the name of any property that Amazon Macie defines for a finding.</p>
    public let attributeName: String?
    /// <p>The sort order to apply to the results, based on the value for the property specified by the attributeName property. Valid values are: ASC, sort the results in ascending order; and, DESC, sort the results in descending order.</p>
    public let orderBy: OrderBy?

    public init (
        attributeName: String? = nil,
        orderBy: OrderBy? = nil
    )
    {
        self.attributeName = attributeName
        self.orderBy = orderBy
    }
}

extension Statistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approximateNumberOfObjectsToProcess = "approximateNumberOfObjectsToProcess"
        case numberOfRuns = "numberOfRuns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if approximateNumberOfObjectsToProcess != 0.0 {
            try encodeContainer.encode(approximateNumberOfObjectsToProcess, forKey: .approximateNumberOfObjectsToProcess)
        }
        if numberOfRuns != 0.0 {
            try encodeContainer.encode(numberOfRuns, forKey: .numberOfRuns)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateNumberOfObjectsToProcessDecoded = try containerValues.decode(Double.self, forKey: .approximateNumberOfObjectsToProcess)
        approximateNumberOfObjectsToProcess = approximateNumberOfObjectsToProcessDecoded
        let numberOfRunsDecoded = try containerValues.decode(Double.self, forKey: .numberOfRuns)
        numberOfRuns = numberOfRunsDecoded
    }
}

extension Statistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Statistics(approximateNumberOfObjectsToProcess: \(String(describing: approximateNumberOfObjectsToProcess)), numberOfRuns: \(String(describing: numberOfRuns)))"}
}

/// <p>Provides processing statistics for a classification job.</p>
public struct Statistics: Equatable {
    /// <p>The approximate number of objects that the job has yet to process during its current run.</p>
    public let approximateNumberOfObjectsToProcess: Double
    /// <p>The number of times that the job has run.</p>
    public let numberOfRuns: Double

    public init (
        approximateNumberOfObjectsToProcess: Double = 0.0,
        numberOfRuns: Double = 0.0
    )
    {
        self.approximateNumberOfObjectsToProcess = approximateNumberOfObjectsToProcess
        self.numberOfRuns = numberOfRuns
    }
}

/// <p>The storage class of the S3 object. Possible values are:</p>
public enum StorageClass {
    case deepArchive
    case glacier
    case intelligentTiering
    case onezoneIa
    case reducedRedundancy
    case standard
    case standardIa
    case sdkUnknown(String)
}

extension StorageClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StorageClass] {
        return [
            .deepArchive,
            .glacier,
            .intelligentTiering,
            .onezoneIa,
            .reducedRedundancy,
            .standard,
            .standardIa,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deepArchive: return "DEEP_ARCHIVE"
        case .glacier: return "GLACIER"
        case .intelligentTiering: return "INTELLIGENT_TIERING"
        case .onezoneIa: return "ONEZONE_IA"
        case .reducedRedundancy: return "REDUCED_REDUNDANCY"
        case .standard: return "STANDARD"
        case .standardIa: return "STANDARD_IA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
    }
}

extension TagCriterionForJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparator = "comparator"
        case tagValues = "tagValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for __listoftagcriterionpairforjob0 in tagValues {
                try tagValuesContainer.encode(__listoftagcriterionpairforjob0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(JobComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([TagCriterionPairForJob?].self, forKey: .tagValues)
        var tagValuesDecoded0:[TagCriterionPairForJob]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [TagCriterionPairForJob]()
            for structure0 in tagValuesContainer {
                if let structure0 = structure0 {
                    tagValuesDecoded0?.append(structure0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension TagCriterionForJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagCriterionForJob(comparator: \(String(describing: comparator)), tagValues: \(String(describing: tagValues)))"}
}

/// <p>Specifies a tag-based condition that determines whether an S3 bucket is included or excluded from a classification job.</p>
public struct TagCriterionForJob: Equatable {
    /// <p>The operator to use in the condition. Valid values are EQ (equals) and NE (not equals).</p>
    public let comparator: JobComparator?
    /// <p>The tag keys, tag values, or tag key and value pairs to use in the condition.</p>
    public let tagValues: [TagCriterionPairForJob]?

    public init (
        comparator: JobComparator? = nil,
        tagValues: [TagCriterionPairForJob]? = nil
    )
    {
        self.comparator = comparator
        self.tagValues = tagValues
    }
}

extension TagCriterionPairForJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TagCriterionPairForJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagCriterionPairForJob(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Specifies a tag key, a tag value, or a tag key and value (as a pair) to use in a tag-based condition that determines whether an S3 bucket is included or excluded from a classification job. Tag keys and values are case sensitive. Also, Amazon Macie doesn't support use of partial values or wildcard characters in tag-based conditions.</p>
public struct TagCriterionPairForJob: Equatable {
    /// <p>The value for the tag key to use in the condition.</p>
    public let key: String?
    /// <p>The tag value to use in the condition.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the classification job, custom data identifier, findings filter, or member account.</p>
    public let resourceArn: String?
    /// <p>A map of key-value pairs that specifies the tags to associate with the resource.</p> <p>A resource can have a maximum of 50 tags. Each tag consists of a tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TagScopeTerm: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparator = "comparator"
        case key = "key"
        case tagValues = "tagValues"
        case target = "target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for __listoftagvaluepair0 in tagValues {
                try tagValuesContainer.encode(__listoftagvaluepair0)
            }
        }
        if let target = target {
            try encodeContainer.encode(target.rawValue, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(JobComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([TagValuePair?].self, forKey: .tagValues)
        var tagValuesDecoded0:[TagValuePair]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [TagValuePair]()
            for structure0 in tagValuesContainer {
                if let structure0 = structure0 {
                    tagValuesDecoded0?.append(structure0)
                }
            }
        }
        tagValues = tagValuesDecoded0
        let targetDecoded = try containerValues.decodeIfPresent(TagTarget.self, forKey: .target)
        target = targetDecoded
    }
}

extension TagScopeTerm: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagScopeTerm(comparator: \(String(describing: comparator)), key: \(String(describing: key)), tagValues: \(String(describing: tagValues)), target: \(String(describing: target)))"}
}

/// <p>Specifies a tag-based condition that determines whether an S3 object is included or excluded from a classification job. Tag keys and values are case sensitive. Also, Amazon Macie doesn't support use of partial values or wildcard characters in tag-based conditions.</p>
public struct TagScopeTerm: Equatable {
    /// <p>The operator to use in the condition. Valid operators are EQ (equals) or NE (not equals).</p>
    public let comparator: JobComparator?
    /// <p>The tag key to use in the condition.</p>
    public let key: String?
    /// <p>The tag keys or tag key and value pairs to use in the condition.</p>
    public let tagValues: [TagValuePair]?
    /// <p>The type of object to apply the condition to.</p>
    public let target: TagTarget?

    public init (
        comparator: JobComparator? = nil,
        key: String? = nil,
        tagValues: [TagValuePair]? = nil,
        target: TagTarget? = nil
    )
    {
        self.comparator = comparator
        self.key = key
        self.tagValues = tagValues
        self.target = target
    }
}

/// <p>The type of object to apply a tag-based condition to. Valid values are:</p>
public enum TagTarget {
    case s3Object
    case sdkUnknown(String)
}

extension TagTarget : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TagTarget] {
        return [
            .s3Object,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .s3Object: return "S3_OBJECT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TagTarget(rawValue: rawValue) ?? TagTarget.sdkUnknown(rawValue)
    }
}

extension TagValuePair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TagValuePair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagValuePair(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Specifies a tag key or tag key and value pair to use in a tag-based condition that determines whether an S3 object is included or excluded from a classification job. Tag keys and values are case sensitive. Also, Amazon Macie doesn't support use of partial values or wildcard characters in tag-based conditions.</p>
public struct TagValuePair: Equatable {
    /// <p>The value for the tag key to use in the condition.</p>
    public let key: String?
    /// <p>The tag value, associated with the specified tag key (key), to use in the condition. To specify only a tag key for a condition, specify the tag key for the key property and set this value to an empty string.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TestCustomDataIdentifierInputBodyMiddleware: Middleware {
    public let id: String = "TestCustomDataIdentifierInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestCustomDataIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<TestCustomDataIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestCustomDataIdentifierInput>
    public typealias MOutput = OperationOutput<TestCustomDataIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestCustomDataIdentifierOutputError>
}

extension TestCustomDataIdentifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestCustomDataIdentifierInput(ignoreWords: \(String(describing: ignoreWords)), keywords: \(String(describing: keywords)), maximumMatchDistance: \(String(describing: maximumMatchDistance)), regex: \(String(describing: regex)), sampleText: \(String(describing: sampleText)))"}
}

extension TestCustomDataIdentifierInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ignoreWords = "ignoreWords"
        case keywords = "keywords"
        case maximumMatchDistance = "maximumMatchDistance"
        case regex = "regex"
        case sampleText = "sampleText"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ignoreWords = ignoreWords {
            var ignoreWordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ignoreWords)
            for __listof__string0 in ignoreWords {
                try ignoreWordsContainer.encode(__listof__string0)
            }
        }
        if let keywords = keywords {
            var keywordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keywords)
            for __listof__string0 in keywords {
                try keywordsContainer.encode(__listof__string0)
            }
        }
        if maximumMatchDistance != 0 {
            try encodeContainer.encode(maximumMatchDistance, forKey: .maximumMatchDistance)
        }
        if let regex = regex {
            try encodeContainer.encode(regex, forKey: .regex)
        }
        if let sampleText = sampleText {
            try encodeContainer.encode(sampleText, forKey: .sampleText)
        }
    }
}

public struct TestCustomDataIdentifierInputHeadersMiddleware: Middleware {
    public let id: String = "TestCustomDataIdentifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestCustomDataIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<TestCustomDataIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestCustomDataIdentifierInput>
    public typealias MOutput = OperationOutput<TestCustomDataIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestCustomDataIdentifierOutputError>
}

public struct TestCustomDataIdentifierInputQueryItemMiddleware: Middleware {
    public let id: String = "TestCustomDataIdentifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestCustomDataIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<TestCustomDataIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestCustomDataIdentifierInput>
    public typealias MOutput = OperationOutput<TestCustomDataIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestCustomDataIdentifierOutputError>
}

public struct TestCustomDataIdentifierInput: Equatable {
    /// <p>An array that lists specific character sequences (ignore words) to exclude from the results. If the text matched by the regular expression is the same as any string in this array, Amazon Macie ignores it. The array can contain as many as 10 ignore words. Each ignore word can contain 4 - 90 characters. Ignore words are case sensitive.</p>
    public let ignoreWords: [String]?
    /// <p>An array that lists specific character sequences (keywords), one of which must be within proximity (maximumMatchDistance) of the regular expression to match. The array can contain as many as 50 keywords. Each keyword can contain 3 - 90 characters. Keywords aren't case sensitive.</p>
    public let keywords: [String]?
    /// <p>The maximum number of characters that can exist between text that matches the regex pattern and the character sequences specified by the keywords array. Macie includes or excludes a result based on the proximity of a keyword to text that matches the regex pattern. The distance can be 1 - 300 characters. The default value is 50.</p>
    public let maximumMatchDistance: Int
    /// <p>The regular expression (<i>regex</i>) that defines the pattern to match. The expression can contain as many as 512 characters.</p>
    public let regex: String?
    /// <p>The sample text to inspect by using the custom data identifier. The text can contain as many as 1,000 characters.</p>
    public let sampleText: String?

    public init (
        ignoreWords: [String]? = nil,
        keywords: [String]? = nil,
        maximumMatchDistance: Int = 0,
        regex: String? = nil,
        sampleText: String? = nil
    )
    {
        self.ignoreWords = ignoreWords
        self.keywords = keywords
        self.maximumMatchDistance = maximumMatchDistance
        self.regex = regex
        self.sampleText = sampleText
    }
}

struct TestCustomDataIdentifierInputBody: Equatable {
    public let ignoreWords: [String]?
    public let keywords: [String]?
    public let maximumMatchDistance: Int
    public let regex: String?
    public let sampleText: String?
}

extension TestCustomDataIdentifierInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ignoreWords = "ignoreWords"
        case keywords = "keywords"
        case maximumMatchDistance = "maximumMatchDistance"
        case regex = "regex"
        case sampleText = "sampleText"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ignoreWordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ignoreWords)
        var ignoreWordsDecoded0:[String]? = nil
        if let ignoreWordsContainer = ignoreWordsContainer {
            ignoreWordsDecoded0 = [String]()
            for string0 in ignoreWordsContainer {
                if let string0 = string0 {
                    ignoreWordsDecoded0?.append(string0)
                }
            }
        }
        ignoreWords = ignoreWordsDecoded0
        let keywordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .keywords)
        var keywordsDecoded0:[String]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [String]()
            for string0 in keywordsContainer {
                if let string0 = string0 {
                    keywordsDecoded0?.append(string0)
                }
            }
        }
        keywords = keywordsDecoded0
        let maximumMatchDistanceDecoded = try containerValues.decode(Int.self, forKey: .maximumMatchDistance)
        maximumMatchDistance = maximumMatchDistanceDecoded
        let regexDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regex)
        regex = regexDecoded
        let sampleTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sampleText)
        sampleText = sampleTextDecoded
    }
}

extension TestCustomDataIdentifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestCustomDataIdentifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestCustomDataIdentifierOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestCustomDataIdentifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestCustomDataIdentifierOutputResponse(matchCount: \(String(describing: matchCount)))"}
}

extension TestCustomDataIdentifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestCustomDataIdentifierOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.matchCount = output.matchCount
        } else {
            self.matchCount = 0
        }
    }
}

public struct TestCustomDataIdentifierOutputResponse: Equatable {
    /// <p>The number of instances of sample text that matched the detection criteria specified in the custom data identifier.</p>
    public let matchCount: Int

    public init (
        matchCount: Int = 0
    )
    {
        self.matchCount = matchCount
    }
}

struct TestCustomDataIdentifierOutputResponseBody: Equatable {
    public let matchCount: Int
}

extension TestCustomDataIdentifierOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case matchCount = "matchCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchCountDecoded = try containerValues.decode(Int.self, forKey: .matchCount)
        matchCount = matchCountDecoded
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an error that occurred because too many requests were sent during a certain amount of time.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The explanation of the error that occurred.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// <p>An inclusive time period that Amazon Macie usage data applies to. Possible values are:</p>
public enum TimeRange {
    case monthToDate
    case past30Days
    case sdkUnknown(String)
}

extension TimeRange : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TimeRange] {
        return [
            .monthToDate,
            .past30Days,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .monthToDate: return "MONTH_TO_DATE"
        case .past30Days: return "PAST_30_DAYS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TimeRange(rawValue: rawValue) ?? TimeRange.sdkUnknown(rawValue)
    }
}

public enum `Type` {
    case aes256
    case `none`
    case awsKms
    case sdkUnknown(String)
}

extension `Type` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Type`] {
        return [
            .aes256,
            .none,
            .awsKms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aes256: return "AES256"
        case .none: return "NONE"
        case .awsKms: return "aws:kms"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Type`(rawValue: rawValue) ?? `Type`.sdkUnknown(rawValue)
    }
}

public enum Unit {
    case terabytes
    case sdkUnknown(String)
}

extension Unit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Unit] {
        return [
            .terabytes,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .terabytes: return "TERABYTES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
    }
}

extension UnprocessedAccount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case errorCode = "errorCode"
        case errorMessage = "errorMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension UnprocessedAccount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnprocessedAccount(accountId: \(String(describing: accountId)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>Provides information about an account-related request that hasn't been processed.</p>
public struct UnprocessedAccount: Equatable {
    /// <p>The AWS account ID for the account that the request applies to.</p>
    public let accountId: String?
    /// <p>The source of the issue or delay in processing the request.</p>
    public let errorCode: ErrorCode?
    /// <p>The reason why the request hasn't been processed.</p>
    public let errorMessage: String?

    public init (
        accountId: String? = nil,
        errorCode: ErrorCode? = nil,
        errorMessage: String? = nil
    )
    {
        self.accountId = accountId
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the classification job, custom data identifier, findings filter, or member account.</p>
    public let resourceArn: String?
    /// <p>The key of the tag to remove from the resource. To remove multiple tags, append the tagKeys parameter and argument for each additional tag to remove, separated by an ampersand (&amp;).</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateClassificationJobInputBodyMiddleware: Middleware {
    public let id: String = "UpdateClassificationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClassificationJobInput>
    public typealias MOutput = OperationOutput<UpdateClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClassificationJobOutputError>
}

extension UpdateClassificationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClassificationJobInput(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension UpdateClassificationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobStatus = "jobStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
    }
}

public struct UpdateClassificationJobInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateClassificationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClassificationJobInput>
    public typealias MOutput = OperationOutput<UpdateClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClassificationJobOutputError>
}

public struct UpdateClassificationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateClassificationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClassificationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClassificationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClassificationJobInput>
    public typealias MOutput = OperationOutput<UpdateClassificationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClassificationJobOutputError>
}

public struct UpdateClassificationJobInput: Equatable {
    /// <p>The unique identifier for the classification job.</p>
    public let jobId: String?
    /// <p>The new status for the job. Valid values are:</p> <ul><li><p>CANCELLED - Stops the job permanently and cancels it. This value is valid only if the job's current status is IDLE, PAUSED, RUNNING, or USER_PAUSED.</p> <p>If you specify this value and the job's current status is RUNNING, Amazon Macie immediately begins to stop all processing tasks for the job. You can't resume or restart a job after you cancel it.</p></li> <li><p>RUNNING - Resumes the job. This value is valid only if the job's current status is USER_PAUSED.</p> <p>If you paused the job while it was actively running and you specify this value less than 30 days after you paused the job, Macie immediately resumes processing from the point where you paused the job. Otherwise, Macie resumes the job according to the schedule and other settings for the job.</p></li> <li><p>USER_PAUSED - Pauses the job temporarily. This value is valid only if the job's current status is IDLE, PAUSED, or RUNNING. If you specify this value and the job's current status is RUNNING, Macie immediately begins to pause all processing tasks for the job.</p> <p>If you pause a one-time job and you don't resume it within 30 days, the job expires and Macie cancels the job. If you pause a recurring job when its status is RUNNING and you don't resume it within 30 days, the job run expires and Macie cancels the run. To check the expiration date, refer to the UserPausedDetails.jobExpiresAt property.</p></li></ul>
    public let jobStatus: JobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct UpdateClassificationJobInputBody: Equatable {
    public let jobStatus: JobStatus?
}

extension UpdateClassificationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobStatus = "jobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

extension UpdateClassificationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClassificationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClassificationJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClassificationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClassificationJobOutputResponse()"}
}

extension UpdateClassificationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateClassificationJobOutputResponse: Equatable {

    public init() {}
}

struct UpdateClassificationJobOutputResponseBody: Equatable {
}

extension UpdateClassificationJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateFindingsFilterInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFindingsFilterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFindingsFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFindingsFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFindingsFilterInput>
    public typealias MOutput = OperationOutput<UpdateFindingsFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFindingsFilterOutputError>
}

extension UpdateFindingsFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFindingsFilterInput(action: \(String(describing: action)), description: \(String(describing: description)), findingCriteria: \(String(describing: findingCriteria)), id: \(String(describing: id)), name: \(String(describing: name)), position: \(String(describing: position)))"}
}

extension UpdateFindingsFilterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case position = "position"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingCriteria = findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if position != 0 {
            try encodeContainer.encode(position, forKey: .position)
        }
    }
}

public struct UpdateFindingsFilterInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFindingsFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFindingsFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFindingsFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFindingsFilterInput>
    public typealias MOutput = OperationOutput<UpdateFindingsFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFindingsFilterOutputError>
}

public struct UpdateFindingsFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFindingsFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFindingsFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFindingsFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFindingsFilterInput>
    public typealias MOutput = OperationOutput<UpdateFindingsFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFindingsFilterOutputError>
}

public struct UpdateFindingsFilterInput: Equatable {
    /// <p>The action to perform on findings that meet the filter criteria (findingCriteria). Valid values are: ARCHIVE, suppress (automatically archive) the findings; and, NOOP, don't perform any action on the findings.</p>
    public let action: FindingsFilterAction?
    /// <p>A custom description of the filter. The description can contain as many as 512 characters.</p> <p>We strongly recommend that you avoid including any sensitive data in the description of a filter. Other users might be able to see the filter's description, depending on the actions that they're allowed to perform in Amazon Macie.</p>
    public let description: String?
    /// <p>The criteria to use to filter findings.</p>
    public let findingCriteria: FindingCriteria?
    /// <p>The unique identifier for the Amazon Macie resource or account that the request applies to.</p>
    public let id: String?
    /// <p>A custom name for the filter. The name must contain at least 3 characters and can contain as many as 64 characters.</p> <p>We strongly recommend that you avoid including any sensitive data in the name of a filter. Other users might be able to see the filter's name, depending on the actions that they're allowed to perform in Amazon Macie.</p>
    public let name: String?
    /// <p>The position of the filter in the list of saved filters on the Amazon Macie console. This value also determines the order in which the filter is applied to findings, relative to other filters that are also applied to the findings.</p>
    public let position: Int

    public init (
        action: FindingsFilterAction? = nil,
        description: String? = nil,
        findingCriteria: FindingCriteria? = nil,
        id: String? = nil,
        name: String? = nil,
        position: Int = 0
    )
    {
        self.action = action
        self.description = description
        self.findingCriteria = findingCriteria
        self.id = id
        self.name = name
        self.position = position
    }
}

struct UpdateFindingsFilterInputBody: Equatable {
    public let action: FindingsFilterAction?
    public let description: String?
    public let findingCriteria: FindingCriteria?
    public let name: String?
    public let position: Int
}

extension UpdateFindingsFilterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case position = "position"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(FindingsFilterAction.self, forKey: .action)
        action = actionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let positionDecoded = try containerValues.decode(Int.self, forKey: .position)
        position = positionDecoded
    }
}

extension UpdateFindingsFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFindingsFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFindingsFilterOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFindingsFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFindingsFilterOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)))"}
}

extension UpdateFindingsFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFindingsFilterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct UpdateFindingsFilterOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the filter that was updated.</p>
    public let arn: String?
    /// <p>The unique identifier for the filter that was updated.</p>
    public let id: String?

    public init (
        arn: String? = nil,
        id: String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct UpdateFindingsFilterOutputResponseBody: Equatable {
    public let arn: String?
    public let id: String?
}

extension UpdateFindingsFilterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case id = "id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

public struct UpdateMacieSessionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMacieSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMacieSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMacieSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMacieSessionInput>
    public typealias MOutput = OperationOutput<UpdateMacieSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMacieSessionOutputError>
}

extension UpdateMacieSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMacieSessionInput(findingPublishingFrequency: \(String(describing: findingPublishingFrequency)), status: \(String(describing: status)))"}
}

extension UpdateMacieSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingPublishingFrequency = "findingPublishingFrequency"
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingPublishingFrequency = findingPublishingFrequency {
            try encodeContainer.encode(findingPublishingFrequency.rawValue, forKey: .findingPublishingFrequency)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateMacieSessionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMacieSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMacieSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMacieSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMacieSessionInput>
    public typealias MOutput = OperationOutput<UpdateMacieSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMacieSessionOutputError>
}

public struct UpdateMacieSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMacieSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMacieSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMacieSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMacieSessionInput>
    public typealias MOutput = OperationOutput<UpdateMacieSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMacieSessionOutputError>
}

public struct UpdateMacieSessionInput: Equatable {
    /// Specifies how often to publish updates to policy findings for the account. This includes publishing updates to AWS Security Hub and Amazon EventBridge (formerly called Amazon CloudWatch Events).
    public let findingPublishingFrequency: FindingPublishingFrequency?
    /// <p>Specifies a new status for the account. Valid values are: ENABLED, resume all Amazon Macie activities for the account; and, PAUSED, suspend all Macie activities for the account.</p>
    public let status: MacieStatus?

    public init (
        findingPublishingFrequency: FindingPublishingFrequency? = nil,
        status: MacieStatus? = nil
    )
    {
        self.findingPublishingFrequency = findingPublishingFrequency
        self.status = status
    }
}

struct UpdateMacieSessionInputBody: Equatable {
    public let findingPublishingFrequency: FindingPublishingFrequency?
    public let status: MacieStatus?
}

extension UpdateMacieSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingPublishingFrequency = "findingPublishingFrequency"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MacieStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateMacieSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMacieSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMacieSessionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMacieSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMacieSessionOutputResponse()"}
}

extension UpdateMacieSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMacieSessionOutputResponse: Equatable {

    public init() {}
}

struct UpdateMacieSessionOutputResponseBody: Equatable {
}

extension UpdateMacieSessionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateMemberSessionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMemberSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMemberSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMemberSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMemberSessionInput>
    public typealias MOutput = OperationOutput<UpdateMemberSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMemberSessionOutputError>
}

extension UpdateMemberSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMemberSessionInput(id: \(String(describing: id)), status: \(String(describing: status)))"}
}

extension UpdateMemberSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateMemberSessionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMemberSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMemberSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMemberSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMemberSessionInput>
    public typealias MOutput = OperationOutput<UpdateMemberSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMemberSessionOutputError>
}

public struct UpdateMemberSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMemberSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMemberSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMemberSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMemberSessionInput>
    public typealias MOutput = OperationOutput<UpdateMemberSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMemberSessionOutputError>
}

public struct UpdateMemberSessionInput: Equatable {
    /// <p>The unique identifier for the Amazon Macie resource or account that the request applies to.</p>
    public let id: String?
    /// <p>Specifies the new status for the account. Valid values are: ENABLED, resume all Amazon Macie activities for the account; and, PAUSED, suspend all Macie activities for the account.</p>
    public let status: MacieStatus?

    public init (
        id: String? = nil,
        status: MacieStatus? = nil
    )
    {
        self.id = id
        self.status = status
    }
}

struct UpdateMemberSessionInputBody: Equatable {
    public let status: MacieStatus?
}

extension UpdateMemberSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(MacieStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateMemberSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMemberSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMemberSessionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMemberSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMemberSessionOutputResponse()"}
}

extension UpdateMemberSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMemberSessionOutputResponse: Equatable {

    public init() {}
}

struct UpdateMemberSessionOutputResponseBody: Equatable {
}

extension UpdateMemberSessionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateOrganizationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateOrganizationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOrganizationConfigurationOutputError>
}

extension UpdateOrganizationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOrganizationConfigurationInput(autoEnable: \(String(describing: autoEnable)))"}
}

extension UpdateOrganizationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }
}

public struct UpdateOrganizationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateOrganizationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOrganizationConfigurationOutputError>
}

public struct UpdateOrganizationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateOrganizationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOrganizationConfigurationOutputError>
}

public struct UpdateOrganizationConfigurationInput: Equatable {
    /// <p>Specifies whether to enable Amazon Macie automatically for each account, when the account is added to the AWS organization.</p>
    public let autoEnable: Bool

    public init (
        autoEnable: Bool = false
    )
    {
        self.autoEnable = autoEnable
    }
}

struct UpdateOrganizationConfigurationInputBody: Equatable {
    public let autoEnable: Bool
}

extension UpdateOrganizationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoEnable = "autoEnable"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decode(Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

extension UpdateOrganizationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOrganizationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOrganizationConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOrganizationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOrganizationConfigurationOutputResponse()"}
}

extension UpdateOrganizationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateOrganizationConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateOrganizationConfigurationOutputResponseBody: Equatable {
}

extension UpdateOrganizationConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UsageByAccount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currency = "currency"
        case estimatedCost = "estimatedCost"
        case serviceLimit = "serviceLimit"
        case type = "type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if let estimatedCost = estimatedCost {
            try encodeContainer.encode(estimatedCost, forKey: .estimatedCost)
        }
        if let serviceLimit = serviceLimit {
            try encodeContainer.encode(serviceLimit, forKey: .serviceLimit)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyDecoded = try containerValues.decodeIfPresent(Currency.self, forKey: .currency)
        currency = currencyDecoded
        let estimatedCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedCost)
        estimatedCost = estimatedCostDecoded
        let serviceLimitDecoded = try containerValues.decodeIfPresent(ServiceLimit.self, forKey: .serviceLimit)
        serviceLimit = serviceLimitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(UsageType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UsageByAccount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageByAccount(currency: \(String(describing: currency)), estimatedCost: \(String(describing: estimatedCost)), serviceLimit: \(String(describing: serviceLimit)), type: \(String(describing: type)))"}
}

/// <p>Provides data for a specific usage metric and the corresponding quota for an Amazon Macie account.</p>
public struct UsageByAccount: Equatable {
    /// <p>The type of currency that the value for the metric (estimatedCost) is reported in.</p>
    public let currency: Currency?
    /// <p>The estimated value for the metric.</p>
    public let estimatedCost: String?
    /// <p>The current value for the quota that corresponds to the metric specified by the type field.</p>
    public let serviceLimit: ServiceLimit?
    /// <p>The name of the metric. Possible values are: DATA_INVENTORY_EVALUATION, for monitoring S3 buckets; and, SENSITIVE_DATA_DISCOVERY, for analyzing S3 objects to detect sensitive data.</p>
    public let type: UsageType?

    public init (
        currency: Currency? = nil,
        estimatedCost: String? = nil,
        serviceLimit: ServiceLimit? = nil,
        type: UsageType? = nil
    )
    {
        self.currency = currency
        self.estimatedCost = estimatedCost
        self.serviceLimit = serviceLimit
        self.type = type
    }
}

extension UsageRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case freeTrialStartDate = "freeTrialStartDate"
        case usage = "usage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let freeTrialStartDate = freeTrialStartDate {
            try encodeContainer.encode(freeTrialStartDate.timeIntervalSince1970, forKey: .freeTrialStartDate)
        }
        if let usage = usage {
            var usageContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usage)
            for __listofusagebyaccount0 in usage {
                try usageContainer.encode(__listofusagebyaccount0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let freeTrialStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .freeTrialStartDate)
        freeTrialStartDate = freeTrialStartDateDecoded
        let usageContainer = try containerValues.decodeIfPresent([UsageByAccount?].self, forKey: .usage)
        var usageDecoded0:[UsageByAccount]? = nil
        if let usageContainer = usageContainer {
            usageDecoded0 = [UsageByAccount]()
            for structure0 in usageContainer {
                if let structure0 = structure0 {
                    usageDecoded0?.append(structure0)
                }
            }
        }
        usage = usageDecoded0
    }
}

extension UsageRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageRecord(accountId: \(String(describing: accountId)), freeTrialStartDate: \(String(describing: freeTrialStartDate)), usage: \(String(describing: usage)))"}
}

/// <p>Provides quota and aggregated usage data for an Amazon Macie account.</p>
public struct UsageRecord: Equatable {
    /// <p>The unique identifier for the AWS account that the data applies to.</p>
    public let accountId: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the free trial started for the account.</p>
    public let freeTrialStartDate: Date?
    /// <p>An array of objects that contains usage data and quotas for the account. Each object contains the data for a specific usage metric and the corresponding quota.</p>
    public let usage: [UsageByAccount]?

    public init (
        accountId: String? = nil,
        freeTrialStartDate: Date? = nil,
        usage: [UsageByAccount]? = nil
    )
    {
        self.accountId = accountId
        self.freeTrialStartDate = freeTrialStartDate
        self.usage = usage
    }
}

extension UsageStatisticsFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparator = "comparator"
        case key = "key"
        case values = "values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparator = comparator {
            try encodeContainer.encode(comparator.rawValue, forKey: .comparator)
        }
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for __listof__string0 in values {
                try valuesContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparatorDecoded = try containerValues.decodeIfPresent(UsageStatisticsFilterComparator.self, forKey: .comparator)
        comparator = comparatorDecoded
        let keyDecoded = try containerValues.decodeIfPresent(UsageStatisticsFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension UsageStatisticsFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageStatisticsFilter(comparator: \(String(describing: comparator)), key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>Specifies a condition for filtering the results of a query for quota and usage data for one or more Amazon Macie accounts.</p>
public struct UsageStatisticsFilter: Equatable {
    /// <p>The operator to use in the condition. If the value for the key property is accountId, this value must be CONTAINS. If the value for the key property is any other supported field, this value can be EQ, GT, GTE, LT, LTE, or NE.</p>
    public let comparator: UsageStatisticsFilterComparator?
    /// <p>The field to use in the condition.</p>
    public let key: UsageStatisticsFilterKey?
    /// <p>An array that lists values to use in the condition, based on the value for the field specified by the key property. If the value for the key property is accountId, this array can specify multiple values. Otherwise, this array can specify only one value.</p> <p>Valid values for each supported field are:</p> <ul><li><p>accountId - The unique identifier for an AWS account.</p></li></ul> <ul><li><p>freeTrialStartDate - The date and time, in UTC and extended ISO 8601 format, when the free trial started for an account.</p></li></ul> <ul><li><p>serviceLimit - A Boolean (true or false) value that indicates whether an account has reached its monthly quota.</p></li></ul> <ul><li><p>total - A string that represents the current estimated cost for an account.</p></li></ul>
    public let values: [String]?

    public init (
        comparator: UsageStatisticsFilterComparator? = nil,
        key: UsageStatisticsFilterKey? = nil,
        values: [String]? = nil
    )
    {
        self.comparator = comparator
        self.key = key
        self.values = values
    }
}

/// <p>The operator to use in a condition that filters the results of a query for Amazon Macie account quotas and usage data. Valid values are:</p>
public enum UsageStatisticsFilterComparator {
    case contains
    case eq
    case gt
    case gte
    case lt
    case lte
    case ne
    case sdkUnknown(String)
}

extension UsageStatisticsFilterComparator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsageStatisticsFilterComparator] {
        return [
            .contains,
            .eq,
            .gt,
            .gte,
            .lt,
            .lte,
            .ne,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "CONTAINS"
        case .eq: return "EQ"
        case .gt: return "GT"
        case .gte: return "GTE"
        case .lt: return "LT"
        case .lte: return "LTE"
        case .ne: return "NE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsageStatisticsFilterComparator(rawValue: rawValue) ?? UsageStatisticsFilterComparator.sdkUnknown(rawValue)
    }
}

/// <p>The field to use in a condition that filters the results of a query for Amazon Macie account quotas and usage data. Valid values are:</p>
public enum UsageStatisticsFilterKey {
    case accountid
    case freetrialstartdate
    case servicelimit
    case total
    case sdkUnknown(String)
}

extension UsageStatisticsFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsageStatisticsFilterKey] {
        return [
            .accountid,
            .freetrialstartdate,
            .servicelimit,
            .total,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountid: return "accountId"
        case .freetrialstartdate: return "freeTrialStartDate"
        case .servicelimit: return "serviceLimit"
        case .total: return "total"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsageStatisticsFilterKey(rawValue: rawValue) ?? UsageStatisticsFilterKey.sdkUnknown(rawValue)
    }
}

extension UsageStatisticsSortBy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "key"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let orderBy = orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(UsageStatisticsSortKey.self, forKey: .key)
        key = keyDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension UsageStatisticsSortBy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageStatisticsSortBy(key: \(String(describing: key)), orderBy: \(String(describing: orderBy)))"}
}

/// <p>Specifies criteria for sorting the results of a query for Amazon Macie account quotas and usage data.</p>
public struct UsageStatisticsSortBy: Equatable {
    /// <p>The field to sort the results by.</p>
    public let key: UsageStatisticsSortKey?
    /// <p>The sort order to apply to the results, based on the value for the field specified by the key property. Valid values are: ASC, sort the results in ascending order; and, DESC, sort the results in descending order.</p>
    public let orderBy: OrderBy?

    public init (
        key: UsageStatisticsSortKey? = nil,
        orderBy: OrderBy? = nil
    )
    {
        self.key = key
        self.orderBy = orderBy
    }
}

/// <p>The field to use to sort the results of a query for Amazon Macie account quotas and usage data. Valid values are:</p>
public enum UsageStatisticsSortKey {
    case accountid
    case freetrialstartdate
    case servicelimitvalue
    case total
    case sdkUnknown(String)
}

extension UsageStatisticsSortKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsageStatisticsSortKey] {
        return [
            .accountid,
            .freetrialstartdate,
            .servicelimitvalue,
            .total,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountid: return "accountId"
        case .freetrialstartdate: return "freeTrialStartDate"
        case .servicelimitvalue: return "serviceLimitValue"
        case .total: return "total"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsageStatisticsSortKey(rawValue: rawValue) ?? UsageStatisticsSortKey.sdkUnknown(rawValue)
    }
}

extension UsageTotal: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currency = "currency"
        case estimatedCost = "estimatedCost"
        case type = "type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if let estimatedCost = estimatedCost {
            try encodeContainer.encode(estimatedCost, forKey: .estimatedCost)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyDecoded = try containerValues.decodeIfPresent(Currency.self, forKey: .currency)
        currency = currencyDecoded
        let estimatedCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedCost)
        estimatedCost = estimatedCostDecoded
        let typeDecoded = try containerValues.decodeIfPresent(UsageType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UsageTotal: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageTotal(currency: \(String(describing: currency)), estimatedCost: \(String(describing: estimatedCost)), type: \(String(describing: type)))"}
}

/// <p>Provides aggregated data for an Amazon Macie usage metric. The value for the metric reports estimated usage data for an account for the preceding 30 days or the current calendar month to date, depending on the time period (timeRange) specified in the request.</p>
public struct UsageTotal: Equatable {
    /// <p>The type of currency that the value for the metric (estimatedCost) is reported in.</p>
    public let currency: Currency?
    /// <p>The estimated value for the metric.</p>
    public let estimatedCost: String?
    /// <p>The name of the metric. Possible values are: DATA_INVENTORY_EVALUATION, for monitoring S3 buckets; and, SENSITIVE_DATA_DISCOVERY, for analyzing S3 objects to detect sensitive data.</p>
    public let type: UsageType?

    public init (
        currency: Currency? = nil,
        estimatedCost: String? = nil,
        type: UsageType? = nil
    )
    {
        self.currency = currency
        self.estimatedCost = estimatedCost
        self.type = type
    }
}

/// <p>The name of an Amazon Macie usage metric for an account. Possible values are:</p>
public enum UsageType {
    case dataInventoryEvaluation
    case sensitiveDataDiscovery
    case sdkUnknown(String)
}

extension UsageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsageType] {
        return [
            .dataInventoryEvaluation,
            .sensitiveDataDiscovery,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dataInventoryEvaluation: return "DATA_INVENTORY_EVALUATION"
        case .sensitiveDataDiscovery: return "SENSITIVE_DATA_DISCOVERY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsageType(rawValue: rawValue) ?? UsageType.sdkUnknown(rawValue)
    }
}

extension UserIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assumedRole = "assumedRole"
        case awsAccount = "awsAccount"
        case awsService = "awsService"
        case federatedUser = "federatedUser"
        case iamUser = "iamUser"
        case root = "root"
        case type = "type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assumedRole = assumedRole {
            try encodeContainer.encode(assumedRole, forKey: .assumedRole)
        }
        if let awsAccount = awsAccount {
            try encodeContainer.encode(awsAccount, forKey: .awsAccount)
        }
        if let awsService = awsService {
            try encodeContainer.encode(awsService, forKey: .awsService)
        }
        if let federatedUser = federatedUser {
            try encodeContainer.encode(federatedUser, forKey: .federatedUser)
        }
        if let iamUser = iamUser {
            try encodeContainer.encode(iamUser, forKey: .iamUser)
        }
        if let root = root {
            try encodeContainer.encode(root, forKey: .root)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assumedRoleDecoded = try containerValues.decodeIfPresent(AssumedRole.self, forKey: .assumedRole)
        assumedRole = assumedRoleDecoded
        let awsAccountDecoded = try containerValues.decodeIfPresent(AwsAccount.self, forKey: .awsAccount)
        awsAccount = awsAccountDecoded
        let awsServiceDecoded = try containerValues.decodeIfPresent(AwsService.self, forKey: .awsService)
        awsService = awsServiceDecoded
        let federatedUserDecoded = try containerValues.decodeIfPresent(FederatedUser.self, forKey: .federatedUser)
        federatedUser = federatedUserDecoded
        let iamUserDecoded = try containerValues.decodeIfPresent(IamUser.self, forKey: .iamUser)
        iamUser = iamUserDecoded
        let rootDecoded = try containerValues.decodeIfPresent(UserIdentityRoot.self, forKey: .root)
        root = rootDecoded
        let typeDecoded = try containerValues.decodeIfPresent(UserIdentityType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UserIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserIdentity(assumedRole: \(String(describing: assumedRole)), awsAccount: \(String(describing: awsAccount)), awsService: \(String(describing: awsService)), federatedUser: \(String(describing: federatedUser)), iamUser: \(String(describing: iamUser)), root: \(String(describing: root)), type: \(String(describing: type)))"}
}

/// <p>Provides information about the type and other characteristics of an entity that performed an action on an affected resource.</p>
public struct UserIdentity: Equatable {
    /// <p>If the action was performed with temporary security credentials that were obtained using the AssumeRole operation of the AWS Security Token Service (AWS STS) API, the identifiers, session context, and other details about the identity.</p>
    public let assumedRole: AssumedRole?
    /// <p>If the action was performed using the credentials for another AWS account, the details of that account.</p>
    public let awsAccount: AwsAccount?
    /// <p>If the action was performed by an AWS account that belongs to an AWS service, the name of the service.</p>
    public let awsService: AwsService?
    /// <p>If the action was performed with temporary security credentials that were obtained using the GetFederationToken operation of the AWS Security Token Service (AWS STS) API, the identifiers, session context, and other details about the identity.</p>
    public let federatedUser: FederatedUser?
    /// <p>If the action was performed using the credentials for an AWS Identity and Access Management (IAM) user, the name and other details about the user.</p>
    public let iamUser: IamUser?
    /// <p>If the action was performed using the credentials for your AWS account, the details of your account.</p>
    public let root: UserIdentityRoot?
    /// <p>The type of entity that performed the action.</p>
    public let type: UserIdentityType?

    public init (
        assumedRole: AssumedRole? = nil,
        awsAccount: AwsAccount? = nil,
        awsService: AwsService? = nil,
        federatedUser: FederatedUser? = nil,
        iamUser: IamUser? = nil,
        root: UserIdentityRoot? = nil,
        type: UserIdentityType? = nil
    )
    {
        self.assumedRole = assumedRole
        self.awsAccount = awsAccount
        self.awsService = awsService
        self.federatedUser = federatedUser
        self.iamUser = iamUser
        self.root = root
        self.type = type
    }
}

extension UserIdentityRoot: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case arn = "arn"
        case principalId = "principalId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension UserIdentityRoot: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserIdentityRoot(accountId: \(String(describing: accountId)), arn: \(String(describing: arn)), principalId: \(String(describing: principalId)))"}
}

/// <p>Provides information about an AWS account and entity that performed an action on an affected resource. The action was performed using the credentials for your AWS account.</p>
public struct UserIdentityRoot: Equatable {
    /// <p>The unique identifier for the AWS account.</p>
    public let accountId: String?
    /// <p>The Amazon Resource Name (ARN) of the principal that performed the action. The last section of the ARN contains the name of the user or role that performed the action.</p>
    public let arn: String?
    /// <p>The unique identifier for the entity that performed the action.</p>
    public let principalId: String?

    public init (
        accountId: String? = nil,
        arn: String? = nil,
        principalId: String? = nil
    )
    {
        self.accountId = accountId
        self.arn = arn
        self.principalId = principalId
    }
}

/// <p>The type of entity that performed the action on the affected resource. Possible values are:</p>
public enum UserIdentityType {
    case awsaccount
    case awsservice
    case assumedrole
    case federateduser
    case iamuser
    case root
    case sdkUnknown(String)
}

extension UserIdentityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UserIdentityType] {
        return [
            .awsaccount,
            .awsservice,
            .assumedrole,
            .federateduser,
            .iamuser,
            .root,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsaccount: return "AWSAccount"
        case .awsservice: return "AWSService"
        case .assumedrole: return "AssumedRole"
        case .federateduser: return "FederatedUser"
        case .iamuser: return "IAMUser"
        case .root: return "Root"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UserIdentityType(rawValue: rawValue) ?? UserIdentityType.sdkUnknown(rawValue)
    }
}

extension UserPausedDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobExpiresAt = "jobExpiresAt"
        case jobImminentExpirationHealthEventArn = "jobImminentExpirationHealthEventArn"
        case jobPausedAt = "jobPausedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobExpiresAt = jobExpiresAt {
            try encodeContainer.encode(jobExpiresAt.timeIntervalSince1970, forKey: .jobExpiresAt)
        }
        if let jobImminentExpirationHealthEventArn = jobImminentExpirationHealthEventArn {
            try encodeContainer.encode(jobImminentExpirationHealthEventArn, forKey: .jobImminentExpirationHealthEventArn)
        }
        if let jobPausedAt = jobPausedAt {
            try encodeContainer.encode(jobPausedAt.timeIntervalSince1970, forKey: .jobPausedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobExpiresAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .jobExpiresAt)
        jobExpiresAt = jobExpiresAtDecoded
        let jobImminentExpirationHealthEventArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobImminentExpirationHealthEventArn)
        jobImminentExpirationHealthEventArn = jobImminentExpirationHealthEventArnDecoded
        let jobPausedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .jobPausedAt)
        jobPausedAt = jobPausedAtDecoded
    }
}

extension UserPausedDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserPausedDetails(jobExpiresAt: \(String(describing: jobExpiresAt)), jobImminentExpirationHealthEventArn: \(String(describing: jobImminentExpirationHealthEventArn)), jobPausedAt: \(String(describing: jobPausedAt)))"}
}

/// <p>Provides information about when a classification job was paused. For a one-time job, this object also specifies when the job will expire and be cancelled if it isn't resumed. For a recurring job, this object also specifies when the paused job run will expire and be cancelled if it isn't resumed. This object is present only if a job's current status (jobStatus) is USER_PAUSED. The information in this object applies only to a job that was paused while it had a status of RUNNING.</p>
public struct UserPausedDetails: Equatable {
    /// <p>The date and time, in UTC and extended ISO 8601 format, when the job or job run will expire and be cancelled if you don't resume it first.</p>
    public let jobExpiresAt: Date?
    /// <p>The Amazon Resource Name (ARN) of the AWS Health event that Amazon Macie sent to notify you of the job or job run's pending expiration and cancellation. This value is null if a job has been paused for less than 23 days.</p>
    public let jobImminentExpirationHealthEventArn: String?
    /// <p>The date and time, in UTC and extended ISO 8601 format, when you paused the job.</p>
    public let jobPausedAt: Date?

    public init (
        jobExpiresAt: Date? = nil,
        jobImminentExpirationHealthEventArn: String? = nil,
        jobPausedAt: Date? = nil
    )
    {
        self.jobExpiresAt = jobExpiresAt
        self.jobImminentExpirationHealthEventArn = jobImminentExpirationHealthEventArn
        self.jobPausedAt = jobPausedAt
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an error that occurred due to a syntax error in a request.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The explanation of the error that occurred.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WeeklySchedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dayOfWeek = "dayOfWeek"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfWeek = dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
    }
}

extension WeeklySchedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WeeklySchedule(dayOfWeek: \(String(describing: dayOfWeek)))"}
}

/// <p>Specifies a weekly recurrence pattern for running a classification job.</p>
public struct WeeklySchedule: Equatable {
    /// <p>The day of the week when Amazon Macie runs the job.</p>
    public let dayOfWeek: DayOfWeek?

    public init (
        dayOfWeek: DayOfWeek? = nil
    )
    {
        self.dayOfWeek = dayOfWeek
    }
}
