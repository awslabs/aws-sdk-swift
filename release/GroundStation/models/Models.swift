// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AngleUnits {
    case degreeAngle
    case radian
    case sdkUnknown(String)
}

extension AngleUnits : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AngleUnits] {
        return [
            .degreeAngle,
            .radian,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .degreeAngle: return "DEGREE_ANGLE"
        case .radian: return "RADIAN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AngleUnits(rawValue: rawValue) ?? AngleUnits.sdkUnknown(rawValue)
    }
}

extension AntennaDemodDecodeDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outputNode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputNode = outputNode {
            try encodeContainer.encode(outputNode, forKey: .outputNode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputNodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputNode)
        outputNode = outputNodeDecoded
    }
}

extension AntennaDemodDecodeDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AntennaDemodDecodeDetails(outputNode: \(String(describing: outputNode)))"}
}

/// <p>Details about an antenna demod decode <code>Config</code> used in a contact.</p>
public struct AntennaDemodDecodeDetails: Equatable {
    /// <p>Name of an antenna demod decode output node used in a contact.</p>
    public let outputNode: String?

    public init (
        outputNode: String? = nil
    )
    {
        self.outputNode = outputNode
    }
}

extension AntennaDownlinkConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case spectrumConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spectrumConfig = spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(SpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
    }
}

extension AntennaDownlinkConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AntennaDownlinkConfig(spectrumConfig: \(String(describing: spectrumConfig)))"}
}

/// <p>Information about how AWS Ground Station should configure an
///          antenna for downlink during a contact.</p>
public struct AntennaDownlinkConfig: Equatable {
    /// <p>Object that describes a spectral <code>Config</code>.</p>
    public let spectrumConfig: SpectrumConfig?

    public init (
        spectrumConfig: SpectrumConfig? = nil
    )
    {
        self.spectrumConfig = spectrumConfig
    }
}

extension AntennaDownlinkDemodDecodeConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case decodeConfig
        case demodulationConfig
        case spectrumConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decodeConfig = decodeConfig {
            try encodeContainer.encode(decodeConfig, forKey: .decodeConfig)
        }
        if let demodulationConfig = demodulationConfig {
            try encodeContainer.encode(demodulationConfig, forKey: .demodulationConfig)
        }
        if let spectrumConfig = spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(SpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
        let demodulationConfigDecoded = try containerValues.decodeIfPresent(DemodulationConfig.self, forKey: .demodulationConfig)
        demodulationConfig = demodulationConfigDecoded
        let decodeConfigDecoded = try containerValues.decodeIfPresent(DecodeConfig.self, forKey: .decodeConfig)
        decodeConfig = decodeConfigDecoded
    }
}

extension AntennaDownlinkDemodDecodeConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AntennaDownlinkDemodDecodeConfig(decodeConfig: \(String(describing: decodeConfig)), demodulationConfig: \(String(describing: demodulationConfig)), spectrumConfig: \(String(describing: spectrumConfig)))"}
}

/// <p>Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.</p>
public struct AntennaDownlinkDemodDecodeConfig: Equatable {
    /// <p>Information about the decode <code>Config</code>.</p>
    public let decodeConfig: DecodeConfig?
    /// <p>Information about the demodulation <code>Config</code>.</p>
    public let demodulationConfig: DemodulationConfig?
    /// <p>Information about the spectral <code>Config</code>.</p>
    public let spectrumConfig: SpectrumConfig?

    public init (
        decodeConfig: DecodeConfig? = nil,
        demodulationConfig: DemodulationConfig? = nil,
        spectrumConfig: SpectrumConfig? = nil
    )
    {
        self.decodeConfig = decodeConfig
        self.demodulationConfig = demodulationConfig
        self.spectrumConfig = spectrumConfig
    }
}

extension AntennaUplinkConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case spectrumConfig
        case targetEirp
        case transmitDisabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spectrumConfig = spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
        if let targetEirp = targetEirp {
            try encodeContainer.encode(targetEirp, forKey: .targetEirp)
        }
        if let transmitDisabled = transmitDisabled {
            try encodeContainer.encode(transmitDisabled, forKey: .transmitDisabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transmitDisabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .transmitDisabled)
        transmitDisabled = transmitDisabledDecoded
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(UplinkSpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
        let targetEirpDecoded = try containerValues.decodeIfPresent(Eirp.self, forKey: .targetEirp)
        targetEirp = targetEirpDecoded
    }
}

extension AntennaUplinkConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AntennaUplinkConfig(spectrumConfig: \(String(describing: spectrumConfig)), targetEirp: \(String(describing: targetEirp)), transmitDisabled: \(String(describing: transmitDisabled)))"}
}

/// <p>Information about the uplink <code>Config</code> of an antenna.</p>
public struct AntennaUplinkConfig: Equatable {
    /// <p>Information about the uplink spectral <code>Config</code>.</p>
    public let spectrumConfig: UplinkSpectrumConfig?
    /// <p>EIRP of the target.</p>
    public let targetEirp: Eirp?
    /// <p>Whether or not uplink transmit is disabled.</p>
    public let transmitDisabled: Bool?

    public init (
        spectrumConfig: UplinkSpectrumConfig? = nil,
        targetEirp: Eirp? = nil,
        transmitDisabled: Bool? = nil
    )
    {
        self.spectrumConfig = spectrumConfig
        self.targetEirp = targetEirp
        self.transmitDisabled = transmitDisabled
    }
}

public enum BandwidthUnits {
    case ghz
    case khz
    case mhz
    case sdkUnknown(String)
}

extension BandwidthUnits : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BandwidthUnits] {
        return [
            .ghz,
            .khz,
            .mhz,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ghz: return "GHz"
        case .khz: return "kHz"
        case .mhz: return "MHz"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BandwidthUnits(rawValue: rawValue) ?? BandwidthUnits.sdkUnknown(rawValue)
    }
}

extension CancelContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelContactInput(contactId: \(String(describing: contactId)))"}
}

extension CancelContactInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelContactInputHeadersMiddleware: Middleware {
    public let id: String = "CancelContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelContactInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelContactInput>
    public typealias MOutput = OperationOutput<CancelContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelContactOutputError>
}

public struct CancelContactInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelContactInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelContactInput>
    public typealias MOutput = OperationOutput<CancelContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelContactOutputError>
}

/// <p/>
public struct CancelContactInput: Equatable {
    /// <p>UUID of a contact.</p>
    public let contactId: String?

    public init (
        contactId: String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct CancelContactInputBody: Equatable {
}

extension CancelContactInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelContactOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelContactOutputResponse(contactId: \(String(describing: contactId)))"}
}

extension CancelContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelContactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

/// <p/>
public struct CancelContactOutputResponse: Equatable {
    /// <p>UUID of a contact.</p>
    public let contactId: String?

    public init (
        contactId: String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct CancelContactOutputResponseBody: Equatable {
    public let contactId: String?
}

extension CancelContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

public enum ConfigCapabilityType {
    case antennaDownlink
    case antennaDownlinkDemodDecode
    case antennaUplink
    case dataflowEndpoint
    case s3Recording
    case tracking
    case uplinkEcho
    case sdkUnknown(String)
}

extension ConfigCapabilityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigCapabilityType] {
        return [
            .antennaDownlink,
            .antennaDownlinkDemodDecode,
            .antennaUplink,
            .dataflowEndpoint,
            .s3Recording,
            .tracking,
            .uplinkEcho,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .antennaDownlink: return "antenna-downlink"
        case .antennaDownlinkDemodDecode: return "antenna-downlink-demod-decode"
        case .antennaUplink: return "antenna-uplink"
        case .dataflowEndpoint: return "dataflow-endpoint"
        case .s3Recording: return "s3-recording"
        case .tracking: return "tracking"
        case .uplinkEcho: return "uplink-echo"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigCapabilityType(rawValue: rawValue) ?? ConfigCapabilityType.sdkUnknown(rawValue)
    }
}

extension ConfigDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case antennademoddecodedetails = "antennaDemodDecodeDetails"
        case endpointdetails = "endpointDetails"
        case s3recordingdetails = "s3RecordingDetails"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .antennademoddecodedetails(antennademoddecodedetails):
                try container.encode(antennademoddecodedetails, forKey: .antennademoddecodedetails)
            case let .endpointdetails(endpointdetails):
                try container.encode(endpointdetails, forKey: .endpointdetails)
            case let .s3recordingdetails(s3recordingdetails):
                try container.encode(s3recordingdetails, forKey: .s3recordingdetails)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let endpointdetailsDecoded = try values.decodeIfPresent(EndpointDetails.self, forKey: .endpointdetails)
        if let endpointdetails = endpointdetailsDecoded {
            self = .endpointdetails(endpointdetails)
            return
        }
        let antennademoddecodedetailsDecoded = try values.decodeIfPresent(AntennaDemodDecodeDetails.self, forKey: .antennademoddecodedetails)
        if let antennademoddecodedetails = antennademoddecodedetailsDecoded {
            self = .antennademoddecodedetails(antennademoddecodedetails)
            return
        }
        let s3recordingdetailsDecoded = try values.decodeIfPresent(S3RecordingDetails.self, forKey: .s3recordingdetails)
        if let s3recordingdetails = s3recordingdetailsDecoded {
            self = .s3recordingdetails(s3recordingdetails)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Details for certain <code>Config</code> object types in a contact.</p>
public enum ConfigDetails: Equatable {
    /// <p>Information about the endpoint details.</p>
    case endpointdetails(EndpointDetails)
    /// <p>Details for antenna demod decode <code>Config</code> in a contact.</p>
    case antennademoddecodedetails(AntennaDemodDecodeDetails)
    /// <p>Details for an S3 recording <code>Config</code> in a contact.</p>
    case s3recordingdetails(S3RecordingDetails)
    case sdkUnknown(String)
}

extension ConfigListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configArn
        case configId
        case configType
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configArn = configArn {
            try encodeContainer.encode(configArn, forKey: .configArn)
        }
        if let configId = configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configArn)
        configArn = configArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConfigListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigListItem(configArn: \(String(describing: configArn)), configId: \(String(describing: configId)), configType: \(String(describing: configType)), name: \(String(describing: name)))"}
}

/// <p>An item in a list of <code>Config</code> objects.</p>
public struct ConfigListItem: Equatable {
    /// <p>ARN of a <code>Config</code>.</p>
    public let configArn: String?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: ConfigCapabilityType?
    /// <p>Name of a <code>Config</code>.</p>
    public let name: String?

    public init (
        configArn: String? = nil,
        configId: String? = nil,
        configType: ConfigCapabilityType? = nil,
        name: String? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
        self.name = name
    }
}

extension ConfigTypeData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case antennadownlinkconfig = "antennaDownlinkConfig"
        case antennadownlinkdemoddecodeconfig = "antennaDownlinkDemodDecodeConfig"
        case antennauplinkconfig = "antennaUplinkConfig"
        case dataflowendpointconfig = "dataflowEndpointConfig"
        case s3recordingconfig = "s3RecordingConfig"
        case sdkUnknown
        case trackingconfig = "trackingConfig"
        case uplinkechoconfig = "uplinkEchoConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .antennadownlinkconfig(antennadownlinkconfig):
                try container.encode(antennadownlinkconfig, forKey: .antennadownlinkconfig)
            case let .antennadownlinkdemoddecodeconfig(antennadownlinkdemoddecodeconfig):
                try container.encode(antennadownlinkdemoddecodeconfig, forKey: .antennadownlinkdemoddecodeconfig)
            case let .antennauplinkconfig(antennauplinkconfig):
                try container.encode(antennauplinkconfig, forKey: .antennauplinkconfig)
            case let .dataflowendpointconfig(dataflowendpointconfig):
                try container.encode(dataflowendpointconfig, forKey: .dataflowendpointconfig)
            case let .s3recordingconfig(s3recordingconfig):
                try container.encode(s3recordingconfig, forKey: .s3recordingconfig)
            case let .trackingconfig(trackingconfig):
                try container.encode(trackingconfig, forKey: .trackingconfig)
            case let .uplinkechoconfig(uplinkechoconfig):
                try container.encode(uplinkechoconfig, forKey: .uplinkechoconfig)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let antennadownlinkconfigDecoded = try values.decodeIfPresent(AntennaDownlinkConfig.self, forKey: .antennadownlinkconfig)
        if let antennadownlinkconfig = antennadownlinkconfigDecoded {
            self = .antennadownlinkconfig(antennadownlinkconfig)
            return
        }
        let trackingconfigDecoded = try values.decodeIfPresent(TrackingConfig.self, forKey: .trackingconfig)
        if let trackingconfig = trackingconfigDecoded {
            self = .trackingconfig(trackingconfig)
            return
        }
        let dataflowendpointconfigDecoded = try values.decodeIfPresent(DataflowEndpointConfig.self, forKey: .dataflowendpointconfig)
        if let dataflowendpointconfig = dataflowendpointconfigDecoded {
            self = .dataflowendpointconfig(dataflowendpointconfig)
            return
        }
        let antennadownlinkdemoddecodeconfigDecoded = try values.decodeIfPresent(AntennaDownlinkDemodDecodeConfig.self, forKey: .antennadownlinkdemoddecodeconfig)
        if let antennadownlinkdemoddecodeconfig = antennadownlinkdemoddecodeconfigDecoded {
            self = .antennadownlinkdemoddecodeconfig(antennadownlinkdemoddecodeconfig)
            return
        }
        let antennauplinkconfigDecoded = try values.decodeIfPresent(AntennaUplinkConfig.self, forKey: .antennauplinkconfig)
        if let antennauplinkconfig = antennauplinkconfigDecoded {
            self = .antennauplinkconfig(antennauplinkconfig)
            return
        }
        let uplinkechoconfigDecoded = try values.decodeIfPresent(UplinkEchoConfig.self, forKey: .uplinkechoconfig)
        if let uplinkechoconfig = uplinkechoconfigDecoded {
            self = .uplinkechoconfig(uplinkechoconfig)
            return
        }
        let s3recordingconfigDecoded = try values.decodeIfPresent(S3RecordingConfig.self, forKey: .s3recordingconfig)
        if let s3recordingconfig = s3recordingconfigDecoded {
            self = .s3recordingconfig(s3recordingconfig)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Object containing the parameters of a <code>Config</code>.</p>
///          <p>See the subtype definitions for what each type of <code>Config</code> contains.</p>
public enum ConfigTypeData: Equatable {
    /// <p>Information about how AWS Ground Station should configure an antenna for downlink during a contact.</p>
    case antennadownlinkconfig(AntennaDownlinkConfig)
    /// <p>Object that determines whether tracking should be used during a contact executed with this <code>Config</code> in the mission profile. </p>
    case trackingconfig(TrackingConfig)
    /// <p>Information about the dataflow endpoint <code>Config</code>.</p>
    case dataflowendpointconfig(DataflowEndpointConfig)
    /// <p>Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.</p>
    case antennadownlinkdemoddecodeconfig(AntennaDownlinkDemodDecodeConfig)
    /// <p>Information about how AWS Ground Station should conﬁgure an antenna for uplink during a contact.</p>
    case antennauplinkconfig(AntennaUplinkConfig)
    /// <p>Information about an uplink echo <code>Config</code>.</p>
    ///          <p>Parameters from the <code>AntennaUplinkConfig</code>, corresponding to the specified <code>AntennaUplinkConfigArn</code>, are used when this <code>UplinkEchoConfig</code> is used in a contact.</p>
    case uplinkechoconfig(UplinkEchoConfig)
    /// <p>Information about an S3 recording <code>Config</code>.</p>
    case s3recordingconfig(S3RecordingConfig)
    case sdkUnknown(String)
}

extension ContactData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactId
        case contactStatus
        case endTime
        case errorMessage
        case groundStation
        case maximumElevation
        case missionProfileArn
        case postPassEndTime
        case prePassStartTime
        case region
        case satelliteArn
        case startTime
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let contactStatus = contactStatus {
            try encodeContainer.encode(contactStatus.rawValue, forKey: .contactStatus)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let groundStation = groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let maximumElevation = maximumElevation {
            try encodeContainer.encode(maximumElevation, forKey: .maximumElevation)
        }
        if let missionProfileArn = missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let postPassEndTime = postPassEndTime {
            try encodeContainer.encode(postPassEndTime.timeIntervalSince1970, forKey: .postPassEndTime)
        }
        if let prePassStartTime = prePassStartTime {
            try encodeContainer.encode(prePassStartTime.timeIntervalSince1970, forKey: .prePassStartTime)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let satelliteArn = satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let prePassStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .prePassStartTime)
        prePassStartTime = prePassStartTimeDecoded
        let postPassEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .postPassEndTime)
        postPassEndTime = postPassEndTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let contactStatusDecoded = try containerValues.decodeIfPresent(ContactStatus.self, forKey: .contactStatus)
        contactStatus = contactStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let maximumElevationDecoded = try containerValues.decodeIfPresent(Elevation.self, forKey: .maximumElevation)
        maximumElevation = maximumElevationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ContactData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContactData(contactId: \(String(describing: contactId)), contactStatus: \(String(describing: contactStatus)), endTime: \(String(describing: endTime)), errorMessage: \(String(describing: errorMessage)), groundStation: \(String(describing: groundStation)), maximumElevation: \(String(describing: maximumElevation)), missionProfileArn: \(String(describing: missionProfileArn)), postPassEndTime: \(String(describing: postPassEndTime)), prePassStartTime: \(String(describing: prePassStartTime)), region: \(String(describing: region)), satelliteArn: \(String(describing: satelliteArn)), startTime: \(String(describing: startTime)), tags: \(String(describing: tags)))"}
}

/// <p>Data describing a contact.</p>
public struct ContactData: Equatable {
    /// <p>UUID of a contact.</p>
    public let contactId: String?
    /// <p>Status of a contact.</p>
    public let contactStatus: ContactStatus?
    /// <p>End time of a contact.</p>
    public let endTime: Date?
    /// <p>Error message of a contact.</p>
    public let errorMessage: String?
    /// <p>Name of a ground station.</p>
    public let groundStation: String?
    /// <p>Maximum elevation angle of a contact.</p>
    public let maximumElevation: Elevation?
    /// <p>ARN of a mission profile.</p>
    public let missionProfileArn: String?
    /// <p>Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.</p>
    public let postPassEndTime: Date?
    /// <p>Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.</p>
    public let prePassStartTime: Date?
    /// <p>Region of a contact.</p>
    public let region: String?
    /// <p>ARN of a satellite.</p>
    public let satelliteArn: String?
    /// <p>Start time of a contact.</p>
    public let startTime: Date?
    /// <p>Tags assigned to a contact.</p>
    public let tags: [String:String]?

    public init (
        contactId: String? = nil,
        contactStatus: ContactStatus? = nil,
        endTime: Date? = nil,
        errorMessage: String? = nil,
        groundStation: String? = nil,
        maximumElevation: Elevation? = nil,
        missionProfileArn: String? = nil,
        postPassEndTime: Date? = nil,
        prePassStartTime: Date? = nil,
        region: String? = nil,
        satelliteArn: String? = nil,
        startTime: Date? = nil,
        tags: [String:String]? = nil
    )
    {
        self.contactId = contactId
        self.contactStatus = contactStatus
        self.endTime = endTime
        self.errorMessage = errorMessage
        self.groundStation = groundStation
        self.maximumElevation = maximumElevation
        self.missionProfileArn = missionProfileArn
        self.postPassEndTime = postPassEndTime
        self.prePassStartTime = prePassStartTime
        self.region = region
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
    }
}

public enum ContactStatus {
    case available
    case awsCancelled
    case awsFailed
    case cancelled
    case cancelling
    case completed
    case failed
    case failedToSchedule
    case pass
    case postpass
    case prepass
    case scheduled
    case scheduling
    case sdkUnknown(String)
}

extension ContactStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContactStatus] {
        return [
            .available,
            .awsCancelled,
            .awsFailed,
            .cancelled,
            .cancelling,
            .completed,
            .failed,
            .failedToSchedule,
            .pass,
            .postpass,
            .prepass,
            .scheduled,
            .scheduling,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .awsCancelled: return "AWS_CANCELLED"
        case .awsFailed: return "AWS_FAILED"
        case .cancelled: return "CANCELLED"
        case .cancelling: return "CANCELLING"
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .failedToSchedule: return "FAILED_TO_SCHEDULE"
        case .pass: return "PASS"
        case .postpass: return "POSTPASS"
        case .prepass: return "PREPASS"
        case .scheduled: return "SCHEDULED"
        case .scheduling: return "SCHEDULING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContactStatus(rawValue: rawValue) ?? ContactStatus.sdkUnknown(rawValue)
    }
}

public struct CreateConfigInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigInput>
    public typealias MOutput = OperationOutput<CreateConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigOutputError>
}

extension CreateConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigInput(configData: \(String(describing: configData)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configData
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configData = configData {
            try encodeContainer.encode(configData, forKey: .configData)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateConfigInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigInput>
    public typealias MOutput = OperationOutput<CreateConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigOutputError>
}

public struct CreateConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigInput>
    public typealias MOutput = OperationOutput<CreateConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigOutputError>
}

/// <p/>
public struct CreateConfigInput: Equatable {
    /// <p>Parameters of a <code>Config</code>.</p>
    public let configData: ConfigTypeData?
    /// <p>Name of a <code>Config</code>.</p>
    public let name: String?
    /// <p>Tags assigned to a <code>Config</code>.</p>
    public let tags: [String:String]?

    public init (
        configData: ConfigTypeData? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.configData = configData
        self.name = name
        self.tags = tags
    }
}

struct CreateConfigInputBody: Equatable {
    public let name: String?
    public let configData: ConfigTypeData?
    public let tags: [String:String]?
}

extension CreateConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configData
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigOutputResponse(configArn: \(String(describing: configArn)), configId: \(String(describing: configId)), configType: \(String(describing: configType)))"}
}

extension CreateConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

/// <p/>
public struct CreateConfigOutputResponse: Equatable {
    /// <p>ARN of a <code>Config</code>.</p>
    public let configArn: String?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: ConfigCapabilityType?

    public init (
        configArn: String? = nil,
        configId: String? = nil,
        configType: ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct CreateConfigOutputResponseBody: Equatable {
    public let configId: String?
    public let configType: ConfigCapabilityType?
    public let configArn: String?
}

extension CreateConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configArn
        case configId
        case configType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

public struct CreateDataflowEndpointGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateDataflowEndpointGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataflowEndpointGroupInput>
    public typealias MOutput = OperationOutput<CreateDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataflowEndpointGroupOutputError>
}

extension CreateDataflowEndpointGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataflowEndpointGroupInput(endpointDetails: \(String(describing: endpointDetails)), tags: \(String(describing: tags)))"}
}

extension CreateDataflowEndpointGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointDetails
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointDetails = endpointDetails {
            var endpointDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDetails)
            for endpointdetailslist0 in endpointDetails {
                try endpointDetailsContainer.encode(endpointdetailslist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDataflowEndpointGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDataflowEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataflowEndpointGroupInput>
    public typealias MOutput = OperationOutput<CreateDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataflowEndpointGroupOutputError>
}

public struct CreateDataflowEndpointGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDataflowEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataflowEndpointGroupInput>
    public typealias MOutput = OperationOutput<CreateDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataflowEndpointGroupOutputError>
}

/// <p/>
public struct CreateDataflowEndpointGroupInput: Equatable {
    /// <p>Endpoint details of each endpoint in the dataflow endpoint group.</p>
    public let endpointDetails: [EndpointDetails]?
    /// <p>Tags of a dataflow endpoint group.</p>
    public let tags: [String:String]?

    public init (
        endpointDetails: [EndpointDetails]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.endpointDetails = endpointDetails
        self.tags = tags
    }
}

struct CreateDataflowEndpointGroupInputBody: Equatable {
    public let endpointDetails: [EndpointDetails]?
    public let tags: [String:String]?
}

extension CreateDataflowEndpointGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointDetails
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDetailsContainer = try containerValues.decodeIfPresent([EndpointDetails?].self, forKey: .endpointDetails)
        var endpointDetailsDecoded0:[EndpointDetails]? = nil
        if let endpointDetailsContainer = endpointDetailsContainer {
            endpointDetailsDecoded0 = [EndpointDetails]()
            for structure0 in endpointDetailsContainer {
                if let structure0 = structure0 {
                    endpointDetailsDecoded0?.append(structure0)
                }
            }
        }
        endpointDetails = endpointDetailsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataflowEndpointGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataflowEndpointGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataflowEndpointGroupOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataflowEndpointGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataflowEndpointGroupOutputResponse(dataflowEndpointGroupId: \(String(describing: dataflowEndpointGroupId)))"}
}

extension CreateDataflowEndpointGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDataflowEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
        } else {
            self.dataflowEndpointGroupId = nil
        }
    }
}

/// <p/>
public struct CreateDataflowEndpointGroupOutputResponse: Equatable {
    /// <p>UUID of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupId: String?

    public init (
        dataflowEndpointGroupId: String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct CreateDataflowEndpointGroupOutputResponseBody: Equatable {
    public let dataflowEndpointGroupId: String?
}

extension CreateDataflowEndpointGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataflowEndpointGroupId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
    }
}

public struct CreateMissionProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateMissionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMissionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMissionProfileInput>
    public typealias MOutput = OperationOutput<CreateMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMissionProfileOutputError>
}

extension CreateMissionProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMissionProfileInput(contactPostPassDurationSeconds: \(String(describing: contactPostPassDurationSeconds)), contactPrePassDurationSeconds: \(String(describing: contactPrePassDurationSeconds)), dataflowEdges: \(String(describing: dataflowEdges)), minimumViableContactDurationSeconds: \(String(describing: minimumViableContactDurationSeconds)), name: \(String(describing: name)), tags: \(String(describing: tags)), trackingConfigArn: \(String(describing: trackingConfigArn)))"}
}

extension CreateMissionProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case tags
        case trackingConfigArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactPostPassDurationSeconds = contactPostPassDurationSeconds {
            try encodeContainer.encode(contactPostPassDurationSeconds, forKey: .contactPostPassDurationSeconds)
        }
        if let contactPrePassDurationSeconds = contactPrePassDurationSeconds {
            try encodeContainer.encode(contactPrePassDurationSeconds, forKey: .contactPrePassDurationSeconds)
        }
        if let dataflowEdges = dataflowEdges {
            var dataflowEdgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataflowEdges)
            for dataflowedgelist0 in dataflowEdges {
                var dataflowedgelist0Container = dataflowEdgesContainer.nestedUnkeyedContainer()
                for dataflowedge1 in dataflowedgelist0 {
                    try dataflowedgelist0Container.encode(dataflowedge1)
                }
            }
        }
        if let minimumViableContactDurationSeconds = minimumViableContactDurationSeconds {
            try encodeContainer.encode(minimumViableContactDurationSeconds, forKey: .minimumViableContactDurationSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let trackingConfigArn = trackingConfigArn {
            try encodeContainer.encode(trackingConfigArn, forKey: .trackingConfigArn)
        }
    }
}

public struct CreateMissionProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMissionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMissionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMissionProfileInput>
    public typealias MOutput = OperationOutput<CreateMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMissionProfileOutputError>
}

public struct CreateMissionProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMissionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMissionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMissionProfileInput>
    public typealias MOutput = OperationOutput<CreateMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMissionProfileOutputError>
}

/// <p/>
public struct CreateMissionProfileInput: Equatable {
    /// <p>Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.</p>
    public let contactPostPassDurationSeconds: Int?
    /// <p>Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.</p>
    public let contactPrePassDurationSeconds: Int?
    /// <p>A list of lists of ARNs. Each list of ARNs is an edge, with a <i>from</i>
    ///             <code>Config</code> and a <i>to</i>
    ///             <code>Config</code>.</p>
    public let dataflowEdges: [[String]]?
    /// <p>Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.</p>
    public let minimumViableContactDurationSeconds: Int?
    /// <p>Name of a mission profile.</p>
    public let name: String?
    /// <p>Tags assigned to a mission profile.</p>
    public let tags: [String:String]?
    /// <p>ARN of a tracking <code>Config</code>.</p>
    public let trackingConfigArn: String?

    public init (
        contactPostPassDurationSeconds: Int? = nil,
        contactPrePassDurationSeconds: Int? = nil,
        dataflowEdges: [[String]]? = nil,
        minimumViableContactDurationSeconds: Int? = nil,
        name: String? = nil,
        tags: [String:String]? = nil,
        trackingConfigArn: String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.name = name
        self.tags = tags
        self.trackingConfigArn = trackingConfigArn
    }
}

struct CreateMissionProfileInputBody: Equatable {
    public let name: String?
    public let contactPrePassDurationSeconds: Int?
    public let contactPostPassDurationSeconds: Int?
    public let minimumViableContactDurationSeconds: Int?
    public let dataflowEdges: [[String]]?
    public let trackingConfigArn: String?
    public let tags: [String:String]?
}

extension CreateMissionProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case tags
        case trackingConfigArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMissionProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMissionProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMissionProfileOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMissionProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMissionProfileOutputResponse(missionProfileId: \(String(describing: missionProfileId)))"}
}

extension CreateMissionProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

/// <p/>
public struct CreateMissionProfileOutputResponse: Equatable {
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: String?

    public init (
        missionProfileId: String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct CreateMissionProfileOutputResponseBody: Equatable {
    public let missionProfileId: String?
}

extension CreateMissionProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case missionProfileId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

public enum Criticality {
    case preferred
    case removed
    case `required`
    case sdkUnknown(String)
}

extension Criticality : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Criticality] {
        return [
            .preferred,
            .removed,
            .required,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .preferred: return "PREFERRED"
        case .removed: return "REMOVED"
        case .required: return "REQUIRED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Criticality(rawValue: rawValue) ?? Criticality.sdkUnknown(rawValue)
    }
}

extension DataflowDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination
        case errorMessage
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Destination.self, forKey: .destination)
        destination = destinationDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension DataflowDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataflowDetail(destination: \(String(describing: destination)), errorMessage: \(String(describing: errorMessage)), source: \(String(describing: source)))"}
}

/// <p>Information about a dataflow edge used in a contact.</p>
public struct DataflowDetail: Equatable {
    /// <p>Dataflow details for the destination side.</p>
    public let destination: Destination?
    /// <p>Error message for a dataflow.</p>
    public let errorMessage: String?
    /// <p>Dataflow details for the source side.</p>
    public let source: Source?

    public init (
        destination: Destination? = nil,
        errorMessage: String? = nil,
        source: Source? = nil
    )
    {
        self.destination = destination
        self.errorMessage = errorMessage
        self.source = source
    }
}

extension DataflowEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address
        case mtu
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let mtu = mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let addressDecoded = try containerValues.decodeIfPresent(SocketAddress.self, forKey: .address)
        address = addressDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EndpointStatus.self, forKey: .status)
        status = statusDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mtu)
        mtu = mtuDecoded
    }
}

extension DataflowEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataflowEndpoint(address: \(String(describing: address)), mtu: \(String(describing: mtu)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Information about a dataflow endpoint.</p>
public struct DataflowEndpoint: Equatable {
    /// <p>Socket address of a dataflow endpoint.</p>
    public let address: SocketAddress?
    /// <p>Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.</p>
    public let mtu: Int?
    /// <p>Name of a dataflow endpoint.</p>
    public let name: String?
    /// <p>Status of a dataflow endpoint.</p>
    public let status: EndpointStatus?

    public init (
        address: SocketAddress? = nil,
        mtu: Int? = nil,
        name: String? = nil,
        status: EndpointStatus? = nil
    )
    {
        self.address = address
        self.mtu = mtu
        self.name = name
        self.status = status
    }
}

extension DataflowEndpointConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataflowEndpointName
        case dataflowEndpointRegion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataflowEndpointName = dataflowEndpointName {
            try encodeContainer.encode(dataflowEndpointName, forKey: .dataflowEndpointName)
        }
        if let dataflowEndpointRegion = dataflowEndpointRegion {
            try encodeContainer.encode(dataflowEndpointRegion, forKey: .dataflowEndpointRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataflowEndpointName)
        dataflowEndpointName = dataflowEndpointNameDecoded
        let dataflowEndpointRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataflowEndpointRegion)
        dataflowEndpointRegion = dataflowEndpointRegionDecoded
    }
}

extension DataflowEndpointConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataflowEndpointConfig(dataflowEndpointName: \(String(describing: dataflowEndpointName)), dataflowEndpointRegion: \(String(describing: dataflowEndpointRegion)))"}
}

/// <p>Information about the dataflow endpoint <code>Config</code>.</p>
public struct DataflowEndpointConfig: Equatable {
    /// <p>Name of a dataflow endpoint.</p>
    public let dataflowEndpointName: String?
    /// <p>Region of a dataflow endpoint.</p>
    public let dataflowEndpointRegion: String?

    public init (
        dataflowEndpointName: String? = nil,
        dataflowEndpointRegion: String? = nil
    )
    {
        self.dataflowEndpointName = dataflowEndpointName
        self.dataflowEndpointRegion = dataflowEndpointRegion
    }
}

extension DataflowEndpointListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataflowEndpointGroupArn
        case dataflowEndpointGroupId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataflowEndpointGroupArn = dataflowEndpointGroupArn {
            try encodeContainer.encode(dataflowEndpointGroupArn, forKey: .dataflowEndpointGroupArn)
        }
        if let dataflowEndpointGroupId = dataflowEndpointGroupId {
            try encodeContainer.encode(dataflowEndpointGroupId, forKey: .dataflowEndpointGroupId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
        let dataflowEndpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataflowEndpointGroupArn)
        dataflowEndpointGroupArn = dataflowEndpointGroupArnDecoded
    }
}

extension DataflowEndpointListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataflowEndpointListItem(dataflowEndpointGroupArn: \(String(describing: dataflowEndpointGroupArn)), dataflowEndpointGroupId: \(String(describing: dataflowEndpointGroupId)))"}
}

/// <p>Item in a list of <code>DataflowEndpoint</code> groups.</p>
public struct DataflowEndpointListItem: Equatable {
    /// <p>ARN of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupArn: String?
    /// <p>UUID of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupId: String?

    public init (
        dataflowEndpointGroupArn: String? = nil,
        dataflowEndpointGroupId: String? = nil
    )
    {
        self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

extension DecodeConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case unvalidatedJSON
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unvalidatedJSON = unvalidatedJSON {
            try encodeContainer.encode(unvalidatedJSON, forKey: .unvalidatedJSON)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unvalidatedJSONDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unvalidatedJSON)
        unvalidatedJSON = unvalidatedJSONDecoded
    }
}

extension DecodeConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecodeConfig(unvalidatedJSON: \(String(describing: unvalidatedJSON)))"}
}

/// <p>Information about the decode <code>Config</code>.</p>
public struct DecodeConfig: Equatable {
    /// <p>Unvalidated JSON of a decode <code>Config</code>.</p>
    public let unvalidatedJSON: String?

    public init (
        unvalidatedJSON: String? = nil
    )
    {
        self.unvalidatedJSON = unvalidatedJSON
    }
}

extension DeleteConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigInput(configId: \(String(describing: configId)), configType: \(String(describing: configType)))"}
}

extension DeleteConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigInput>
    public typealias MOutput = OperationOutput<DeleteConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigOutputError>
}

public struct DeleteConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigInput>
    public typealias MOutput = OperationOutput<DeleteConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigOutputError>
}

/// <p/>
public struct DeleteConfigInput: Equatable {
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: ConfigCapabilityType?

    public init (
        configId: String? = nil,
        configType: ConfigCapabilityType? = nil
    )
    {
        self.configId = configId
        self.configType = configType
    }
}

struct DeleteConfigInputBody: Equatable {
}

extension DeleteConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigOutputResponse(configArn: \(String(describing: configArn)), configId: \(String(describing: configId)), configType: \(String(describing: configType)))"}
}

extension DeleteConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

/// <p/>
public struct DeleteConfigOutputResponse: Equatable {
    /// <p>ARN of a <code>Config</code>.</p>
    public let configArn: String?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: ConfigCapabilityType?

    public init (
        configArn: String? = nil,
        configId: String? = nil,
        configType: ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct DeleteConfigOutputResponseBody: Equatable {
    public let configId: String?
    public let configType: ConfigCapabilityType?
    public let configArn: String?
}

extension DeleteConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configArn
        case configId
        case configType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

extension DeleteDataflowEndpointGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataflowEndpointGroupInput(dataflowEndpointGroupId: \(String(describing: dataflowEndpointGroupId)))"}
}

extension DeleteDataflowEndpointGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDataflowEndpointGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDataflowEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataflowEndpointGroupInput>
    public typealias MOutput = OperationOutput<DeleteDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataflowEndpointGroupOutputError>
}

public struct DeleteDataflowEndpointGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDataflowEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataflowEndpointGroupInput>
    public typealias MOutput = OperationOutput<DeleteDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataflowEndpointGroupOutputError>
}

/// <p/>
public struct DeleteDataflowEndpointGroupInput: Equatable {
    /// <p>UUID of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupId: String?

    public init (
        dataflowEndpointGroupId: String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct DeleteDataflowEndpointGroupInputBody: Equatable {
}

extension DeleteDataflowEndpointGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDataflowEndpointGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataflowEndpointGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataflowEndpointGroupOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataflowEndpointGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataflowEndpointGroupOutputResponse(dataflowEndpointGroupId: \(String(describing: dataflowEndpointGroupId)))"}
}

extension DeleteDataflowEndpointGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDataflowEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
        } else {
            self.dataflowEndpointGroupId = nil
        }
    }
}

/// <p/>
public struct DeleteDataflowEndpointGroupOutputResponse: Equatable {
    /// <p>UUID of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupId: String?

    public init (
        dataflowEndpointGroupId: String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct DeleteDataflowEndpointGroupOutputResponseBody: Equatable {
    public let dataflowEndpointGroupId: String?
}

extension DeleteDataflowEndpointGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataflowEndpointGroupId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
    }
}

extension DeleteMissionProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMissionProfileInput(missionProfileId: \(String(describing: missionProfileId)))"}
}

extension DeleteMissionProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteMissionProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMissionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMissionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMissionProfileInput>
    public typealias MOutput = OperationOutput<DeleteMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMissionProfileOutputError>
}

public struct DeleteMissionProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMissionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMissionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMissionProfileInput>
    public typealias MOutput = OperationOutput<DeleteMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMissionProfileOutputError>
}

/// <p/>
public struct DeleteMissionProfileInput: Equatable {
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: String?

    public init (
        missionProfileId: String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct DeleteMissionProfileInputBody: Equatable {
}

extension DeleteMissionProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMissionProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMissionProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMissionProfileOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMissionProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMissionProfileOutputResponse(missionProfileId: \(String(describing: missionProfileId)))"}
}

extension DeleteMissionProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

/// <p/>
public struct DeleteMissionProfileOutputResponse: Equatable {
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: String?

    public init (
        missionProfileId: String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct DeleteMissionProfileOutputResponseBody: Equatable {
    public let missionProfileId: String?
}

extension DeleteMissionProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case missionProfileId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

extension DemodulationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case unvalidatedJSON
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unvalidatedJSON = unvalidatedJSON {
            try encodeContainer.encode(unvalidatedJSON, forKey: .unvalidatedJSON)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unvalidatedJSONDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unvalidatedJSON)
        unvalidatedJSON = unvalidatedJSONDecoded
    }
}

extension DemodulationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DemodulationConfig(unvalidatedJSON: \(String(describing: unvalidatedJSON)))"}
}

/// <p>Information about the demodulation <code>Config</code>.</p>
public struct DemodulationConfig: Equatable {
    /// <p>Unvalidated JSON of a demodulation <code>Config</code>.</p>
    public let unvalidatedJSON: String?

    public init (
        unvalidatedJSON: String? = nil
    )
    {
        self.unvalidatedJSON = unvalidatedJSON
    }
}

extension DependencyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DependencyException(message: \(String(describing: message)), parameterName: \(String(describing: parameterName)))"}
}

extension DependencyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DependencyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Dependency encountered an error.</p>
public struct DependencyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    /// <p/>
    public var parameterName: String?

    public init (
        message: String? = nil,
        parameterName: String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct DependencyExceptionBody: Equatable {
    public let message: String?
    public let parameterName: String?
}

extension DependencyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case parameterName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension DescribeContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeContactInput(contactId: \(String(describing: contactId)))"}
}

extension DescribeContactInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeContactInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeContactInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeContactInput>
    public typealias MOutput = OperationOutput<DescribeContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeContactOutputError>
}

public struct DescribeContactInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeContactInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeContactInput>
    public typealias MOutput = OperationOutput<DescribeContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeContactOutputError>
}

/// <p/>
public struct DescribeContactInput: Equatable {
    /// <p>UUID of a contact.</p>
    public let contactId: String?

    public init (
        contactId: String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct DescribeContactInputBody: Equatable {
}

extension DescribeContactInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeContactOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeContactOutputResponse(contactId: \(String(describing: contactId)), contactStatus: \(String(describing: contactStatus)), dataflowList: \(String(describing: dataflowList)), endTime: \(String(describing: endTime)), errorMessage: \(String(describing: errorMessage)), groundStation: \(String(describing: groundStation)), maximumElevation: \(String(describing: maximumElevation)), missionProfileArn: \(String(describing: missionProfileArn)), postPassEndTime: \(String(describing: postPassEndTime)), prePassStartTime: \(String(describing: prePassStartTime)), region: \(String(describing: region)), satelliteArn: \(String(describing: satelliteArn)), startTime: \(String(describing: startTime)), tags: \(String(describing: tags)))"}
}

extension DescribeContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeContactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactId = output.contactId
            self.contactStatus = output.contactStatus
            self.dataflowList = output.dataflowList
            self.endTime = output.endTime
            self.errorMessage = output.errorMessage
            self.groundStation = output.groundStation
            self.maximumElevation = output.maximumElevation
            self.missionProfileArn = output.missionProfileArn
            self.postPassEndTime = output.postPassEndTime
            self.prePassStartTime = output.prePassStartTime
            self.region = output.region
            self.satelliteArn = output.satelliteArn
            self.startTime = output.startTime
            self.tags = output.tags
        } else {
            self.contactId = nil
            self.contactStatus = nil
            self.dataflowList = nil
            self.endTime = nil
            self.errorMessage = nil
            self.groundStation = nil
            self.maximumElevation = nil
            self.missionProfileArn = nil
            self.postPassEndTime = nil
            self.prePassStartTime = nil
            self.region = nil
            self.satelliteArn = nil
            self.startTime = nil
            self.tags = nil
        }
    }
}

/// <p/>
public struct DescribeContactOutputResponse: Equatable {
    /// <p>UUID of a contact.</p>
    public let contactId: String?
    /// <p>Status of a contact.</p>
    public let contactStatus: ContactStatus?
    /// <p>List describing source and destination details for each dataflow edge.</p>
    public let dataflowList: [DataflowDetail]?
    /// <p>End time of a contact.</p>
    public let endTime: Date?
    /// <p>Error message for a contact.</p>
    public let errorMessage: String?
    /// <p>Ground station for a contact.</p>
    public let groundStation: String?
    /// <p>Maximum elevation angle of a contact.</p>
    public let maximumElevation: Elevation?
    /// <p>ARN of a mission profile.</p>
    public let missionProfileArn: String?
    /// <p>Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.</p>
    public let postPassEndTime: Date?
    /// <p>Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.</p>
    public let prePassStartTime: Date?
    /// <p>Region of a contact.</p>
    public let region: String?
    /// <p>ARN of a satellite.</p>
    public let satelliteArn: String?
    /// <p>Start time of a contact.</p>
    public let startTime: Date?
    /// <p>Tags assigned to a contact.</p>
    public let tags: [String:String]?

    public init (
        contactId: String? = nil,
        contactStatus: ContactStatus? = nil,
        dataflowList: [DataflowDetail]? = nil,
        endTime: Date? = nil,
        errorMessage: String? = nil,
        groundStation: String? = nil,
        maximumElevation: Elevation? = nil,
        missionProfileArn: String? = nil,
        postPassEndTime: Date? = nil,
        prePassStartTime: Date? = nil,
        region: String? = nil,
        satelliteArn: String? = nil,
        startTime: Date? = nil,
        tags: [String:String]? = nil
    )
    {
        self.contactId = contactId
        self.contactStatus = contactStatus
        self.dataflowList = dataflowList
        self.endTime = endTime
        self.errorMessage = errorMessage
        self.groundStation = groundStation
        self.maximumElevation = maximumElevation
        self.missionProfileArn = missionProfileArn
        self.postPassEndTime = postPassEndTime
        self.prePassStartTime = prePassStartTime
        self.region = region
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
    }
}

struct DescribeContactOutputResponseBody: Equatable {
    public let contactId: String?
    public let missionProfileArn: String?
    public let satelliteArn: String?
    public let startTime: Date?
    public let endTime: Date?
    public let prePassStartTime: Date?
    public let postPassEndTime: Date?
    public let groundStation: String?
    public let contactStatus: ContactStatus?
    public let errorMessage: String?
    public let maximumElevation: Elevation?
    public let tags: [String:String]?
    public let region: String?
    public let dataflowList: [DataflowDetail]?
}

extension DescribeContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId
        case contactStatus
        case dataflowList
        case endTime
        case errorMessage
        case groundStation
        case maximumElevation
        case missionProfileArn
        case postPassEndTime
        case prePassStartTime
        case region
        case satelliteArn
        case startTime
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let prePassStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .prePassStartTime)
        prePassStartTime = prePassStartTimeDecoded
        let postPassEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .postPassEndTime)
        postPassEndTime = postPassEndTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let contactStatusDecoded = try containerValues.decodeIfPresent(ContactStatus.self, forKey: .contactStatus)
        contactStatus = contactStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let maximumElevationDecoded = try containerValues.decodeIfPresent(Elevation.self, forKey: .maximumElevation)
        maximumElevation = maximumElevationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let dataflowListContainer = try containerValues.decodeIfPresent([DataflowDetail?].self, forKey: .dataflowList)
        var dataflowListDecoded0:[DataflowDetail]? = nil
        if let dataflowListContainer = dataflowListContainer {
            dataflowListDecoded0 = [DataflowDetail]()
            for structure0 in dataflowListContainer {
                if let structure0 = structure0 {
                    dataflowListDecoded0?.append(structure0)
                }
            }
        }
        dataflowList = dataflowListDecoded0
    }
}

extension Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configDetails
        case configId
        case configType
        case dataflowDestinationRegion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configDetails = configDetails {
            try encodeContainer.encode(configDetails, forKey: .configDetails)
        }
        if let configId = configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let dataflowDestinationRegion = dataflowDestinationRegion {
            try encodeContainer.encode(dataflowDestinationRegion, forKey: .dataflowDestinationRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configId)
        configId = configIdDecoded
        let configDetailsDecoded = try containerValues.decodeIfPresent(ConfigDetails.self, forKey: .configDetails)
        configDetails = configDetailsDecoded
        let dataflowDestinationRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataflowDestinationRegion)
        dataflowDestinationRegion = dataflowDestinationRegionDecoded
    }
}

extension Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Destination(configDetails: \(String(describing: configDetails)), configId: \(String(describing: configId)), configType: \(String(describing: configType)), dataflowDestinationRegion: \(String(describing: dataflowDestinationRegion)))"}
}

/// <p>Dataflow details for the destination side.</p>
public struct Destination: Equatable {
    /// <p>Additional details for a <code>Config</code>, if type is dataflow endpoint or antenna demod decode.</p>
    public let configDetails: ConfigDetails?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: ConfigCapabilityType?
    /// <p>Region of a dataflow destination.</p>
    public let dataflowDestinationRegion: String?

    public init (
        configDetails: ConfigDetails? = nil,
        configId: String? = nil,
        configType: ConfigCapabilityType? = nil,
        dataflowDestinationRegion: String? = nil
    )
    {
        self.configDetails = configDetails
        self.configId = configId
        self.configType = configType
        self.dataflowDestinationRegion = dataflowDestinationRegion
    }
}

extension Eirp: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(EirpUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension Eirp: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Eirp(units: \(String(describing: units)), value: \(String(describing: value)))"}
}

/// <p>Object that represents EIRP.</p>
public struct Eirp: Equatable {
    /// <p>Units of an EIRP.</p>
    public let units: EirpUnits?
    /// <p>Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.</p>
    public let value: Double?

    public init (
        units: EirpUnits? = nil,
        value: Double? = nil
    )
    {
        self.units = units
        self.value = value
    }
}

public enum EirpUnits {
    case dbw
    case sdkUnknown(String)
}

extension EirpUnits : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EirpUnits] {
        return [
            .dbw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dbw: return "dBW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EirpUnits(rawValue: rawValue) ?? EirpUnits.sdkUnknown(rawValue)
    }
}

extension Elevation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case unit
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(AngleUnits.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension Elevation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Elevation(unit: \(String(describing: unit)), value: \(String(describing: value)))"}
}

/// <p>Elevation angle of the satellite in the sky during a contact.</p>
public struct Elevation: Equatable {
    /// <p>Elevation angle units.</p>
    public let unit: AngleUnits?
    /// <p>Elevation angle value.</p>
    public let value: Double?

    public init (
        unit: AngleUnits? = nil,
        value: Double? = nil
    )
    {
        self.unit = unit
        self.value = value
    }
}

extension EndpointDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpoint
        case securityDetails
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let securityDetails = securityDetails {
            try encodeContainer.encode(securityDetails, forKey: .securityDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityDetailsDecoded = try containerValues.decodeIfPresent(SecurityDetails.self, forKey: .securityDetails)
        securityDetails = securityDetailsDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(DataflowEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension EndpointDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointDetails(endpoint: \(String(describing: endpoint)), securityDetails: \(String(describing: securityDetails)))"}
}

/// <p>Information about the endpoint details.</p>
public struct EndpointDetails: Equatable {
    /// <p>A dataflow endpoint.</p>
    public let endpoint: DataflowEndpoint?
    /// <p>Endpoint security details.</p>
    public let securityDetails: SecurityDetails?

    public init (
        endpoint: DataflowEndpoint? = nil,
        securityDetails: SecurityDetails? = nil
    )
    {
        self.endpoint = endpoint
        self.securityDetails = securityDetails
    }
}

public enum EndpointStatus {
    case created
    case creating
    case deleted
    case deleting
    case failed
    case sdkUnknown(String)
}

extension EndpointStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EndpointStatus] {
        return [
            .created,
            .creating,
            .deleted,
            .deleting,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .created: return "created"
        case .creating: return "creating"
        case .deleted: return "deleted"
        case .deleting: return "deleting"
        case .failed: return "failed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EndpointStatus(rawValue: rawValue) ?? EndpointStatus.sdkUnknown(rawValue)
    }
}

extension Frequency: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(FrequencyUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension Frequency: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Frequency(units: \(String(describing: units)), value: \(String(describing: value)))"}
}

/// <p>Object that describes the frequency.</p>
public struct Frequency: Equatable {
    /// <p>Frequency units.</p>
    public let units: FrequencyUnits?
    /// <p>Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.</p>
    public let value: Double?

    public init (
        units: FrequencyUnits? = nil,
        value: Double? = nil
    )
    {
        self.units = units
        self.value = value
    }
}

extension FrequencyBandwidth: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(BandwidthUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension FrequencyBandwidth: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FrequencyBandwidth(units: \(String(describing: units)), value: \(String(describing: value)))"}
}

/// <p>Object that describes the frequency bandwidth. </p>
public struct FrequencyBandwidth: Equatable {
    /// <p>Frequency bandwidth units.</p>
    public let units: BandwidthUnits?
    /// <p>Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:</p>
    ///             <ul>
    ///             <li>
    ///                <p>For <code>AntennaDownlinkDemodDecodeconfig</code>, valid values are between 125 kHz to 650 MHz.</p>
    ///             </li>
    ///             <li>
    ///                <p>For <code>AntennaDownlinkconfig</code>, valid values are between 10 kHz to 54 MHz.</p>
    ///             </li>
    ///             <li>
    ///                <p>For <code>AntennaUplinkConfig</code>, valid values are between 10 kHz to 54 MHz.</p>
    ///             </li>
    ///          </ul>
    public let value: Double?

    public init (
        units: BandwidthUnits? = nil,
        value: Double? = nil
    )
    {
        self.units = units
        self.value = value
    }
}

public enum FrequencyUnits {
    case ghz
    case khz
    case mhz
    case sdkUnknown(String)
}

extension FrequencyUnits : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FrequencyUnits] {
        return [
            .ghz,
            .khz,
            .mhz,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ghz: return "GHz"
        case .khz: return "kHz"
        case .mhz: return "MHz"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FrequencyUnits(rawValue: rawValue) ?? FrequencyUnits.sdkUnknown(rawValue)
    }
}

extension GetConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigInput(configId: \(String(describing: configId)), configType: \(String(describing: configType)))"}
}

extension GetConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigInput>
    public typealias MOutput = OperationOutput<GetConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigOutputError>
}

public struct GetConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigInput>
    public typealias MOutput = OperationOutput<GetConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigOutputError>
}

/// <p/>
public struct GetConfigInput: Equatable {
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: ConfigCapabilityType?

    public init (
        configId: String? = nil,
        configType: ConfigCapabilityType? = nil
    )
    {
        self.configId = configId
        self.configType = configType
    }
}

struct GetConfigInputBody: Equatable {
}

extension GetConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigOutputResponse(configArn: \(String(describing: configArn)), configData: \(String(describing: configData)), configId: \(String(describing: configId)), configType: \(String(describing: configType)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension GetConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configArn = output.configArn
            self.configData = output.configData
            self.configId = output.configId
            self.configType = output.configType
            self.name = output.name
            self.tags = output.tags
        } else {
            self.configArn = nil
            self.configData = nil
            self.configId = nil
            self.configType = nil
            self.name = nil
            self.tags = nil
        }
    }
}

/// <p/>
public struct GetConfigOutputResponse: Equatable {
    /// <p>ARN of a <code>Config</code>
    ///          </p>
    public let configArn: String?
    /// <p>Data elements in a <code>Config</code>.</p>
    public let configData: ConfigTypeData?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: ConfigCapabilityType?
    /// <p>Name of a <code>Config</code>.</p>
    public let name: String?
    /// <p>Tags assigned to a <code>Config</code>.</p>
    public let tags: [String:String]?

    public init (
        configArn: String? = nil,
        configData: ConfigTypeData? = nil,
        configId: String? = nil,
        configType: ConfigCapabilityType? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.configArn = configArn
        self.configData = configData
        self.configId = configId
        self.configType = configType
        self.name = name
        self.tags = tags
    }
}

struct GetConfigOutputResponseBody: Equatable {
    public let configId: String?
    public let configArn: String?
    public let name: String?
    public let configType: ConfigCapabilityType?
    public let configData: ConfigTypeData?
    public let tags: [String:String]?
}

extension GetConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configArn
        case configData
        case configId
        case configType
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configId)
        configId = configIdDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configArn)
        configArn = configArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDataflowEndpointGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataflowEndpointGroupInput(dataflowEndpointGroupId: \(String(describing: dataflowEndpointGroupId)))"}
}

extension GetDataflowEndpointGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDataflowEndpointGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetDataflowEndpointGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataflowEndpointGroupInput>
    public typealias MOutput = OperationOutput<GetDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataflowEndpointGroupOutputError>
}

public struct GetDataflowEndpointGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDataflowEndpointGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataflowEndpointGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataflowEndpointGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataflowEndpointGroupInput>
    public typealias MOutput = OperationOutput<GetDataflowEndpointGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataflowEndpointGroupOutputError>
}

/// <p/>
public struct GetDataflowEndpointGroupInput: Equatable {
    /// <p>UUID of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupId: String?

    public init (
        dataflowEndpointGroupId: String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct GetDataflowEndpointGroupInputBody: Equatable {
}

extension GetDataflowEndpointGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDataflowEndpointGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataflowEndpointGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataflowEndpointGroupOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataflowEndpointGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataflowEndpointGroupOutputResponse(dataflowEndpointGroupArn: \(String(describing: dataflowEndpointGroupArn)), dataflowEndpointGroupId: \(String(describing: dataflowEndpointGroupId)), endpointsDetails: \(String(describing: endpointsDetails)), tags: \(String(describing: tags)))"}
}

extension GetDataflowEndpointGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDataflowEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataflowEndpointGroupArn = output.dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
            self.endpointsDetails = output.endpointsDetails
            self.tags = output.tags
        } else {
            self.dataflowEndpointGroupArn = nil
            self.dataflowEndpointGroupId = nil
            self.endpointsDetails = nil
            self.tags = nil
        }
    }
}

/// <p/>
public struct GetDataflowEndpointGroupOutputResponse: Equatable {
    /// <p>ARN of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupArn: String?
    /// <p>UUID of a dataflow endpoint group.</p>
    public let dataflowEndpointGroupId: String?
    /// <p>Details of a dataflow endpoint.</p>
    public let endpointsDetails: [EndpointDetails]?
    /// <p>Tags assigned to a dataflow endpoint group.</p>
    public let tags: [String:String]?

    public init (
        dataflowEndpointGroupArn: String? = nil,
        dataflowEndpointGroupId: String? = nil,
        endpointsDetails: [EndpointDetails]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
        self.endpointsDetails = endpointsDetails
        self.tags = tags
    }
}

struct GetDataflowEndpointGroupOutputResponseBody: Equatable {
    public let dataflowEndpointGroupId: String?
    public let dataflowEndpointGroupArn: String?
    public let endpointsDetails: [EndpointDetails]?
    public let tags: [String:String]?
}

extension GetDataflowEndpointGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataflowEndpointGroupArn
        case dataflowEndpointGroupId
        case endpointsDetails
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
        let dataflowEndpointGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataflowEndpointGroupArn)
        dataflowEndpointGroupArn = dataflowEndpointGroupArnDecoded
        let endpointsDetailsContainer = try containerValues.decodeIfPresent([EndpointDetails?].self, forKey: .endpointsDetails)
        var endpointsDetailsDecoded0:[EndpointDetails]? = nil
        if let endpointsDetailsContainer = endpointsDetailsContainer {
            endpointsDetailsDecoded0 = [EndpointDetails]()
            for structure0 in endpointsDetailsContainer {
                if let structure0 = structure0 {
                    endpointsDetailsDecoded0?.append(structure0)
                }
            }
        }
        endpointsDetails = endpointsDetailsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct GetMinuteUsageInputBodyMiddleware: Middleware {
    public let id: String = "GetMinuteUsageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMinuteUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMinuteUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMinuteUsageInput>
    public typealias MOutput = OperationOutput<GetMinuteUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMinuteUsageOutputError>
}

extension GetMinuteUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMinuteUsageInput(month: \(String(describing: month)), year: \(String(describing: year)))"}
}

extension GetMinuteUsageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case month
        case year
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let month = month {
            try encodeContainer.encode(month, forKey: .month)
        }
        if let year = year {
            try encodeContainer.encode(year, forKey: .year)
        }
    }
}

public struct GetMinuteUsageInputHeadersMiddleware: Middleware {
    public let id: String = "GetMinuteUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMinuteUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMinuteUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMinuteUsageInput>
    public typealias MOutput = OperationOutput<GetMinuteUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMinuteUsageOutputError>
}

public struct GetMinuteUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMinuteUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMinuteUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMinuteUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMinuteUsageInput>
    public typealias MOutput = OperationOutput<GetMinuteUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMinuteUsageOutputError>
}

/// <p/>
public struct GetMinuteUsageInput: Equatable {
    /// <p>The month being requested, with a value of 1-12.</p>
    public let month: Int?
    /// <p>The year being requested, in the format of YYYY.</p>
    public let year: Int?

    public init (
        month: Int? = nil,
        year: Int? = nil
    )
    {
        self.month = month
        self.year = year
    }
}

struct GetMinuteUsageInputBody: Equatable {
    public let month: Int?
    public let year: Int?
}

extension GetMinuteUsageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case month
        case year
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .month)
        month = monthDecoded
        let yearDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .year)
        year = yearDecoded
    }
}

extension GetMinuteUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMinuteUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMinuteUsageOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMinuteUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMinuteUsageOutputResponse(estimatedMinutesRemaining: \(String(describing: estimatedMinutesRemaining)), isReservedMinutesCustomer: \(String(describing: isReservedMinutesCustomer)), totalReservedMinuteAllocation: \(String(describing: totalReservedMinuteAllocation)), totalScheduledMinutes: \(String(describing: totalScheduledMinutes)), upcomingMinutesScheduled: \(String(describing: upcomingMinutesScheduled)))"}
}

extension GetMinuteUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMinuteUsageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.estimatedMinutesRemaining = output.estimatedMinutesRemaining
            self.isReservedMinutesCustomer = output.isReservedMinutesCustomer
            self.totalReservedMinuteAllocation = output.totalReservedMinuteAllocation
            self.totalScheduledMinutes = output.totalScheduledMinutes
            self.upcomingMinutesScheduled = output.upcomingMinutesScheduled
        } else {
            self.estimatedMinutesRemaining = nil
            self.isReservedMinutesCustomer = nil
            self.totalReservedMinuteAllocation = nil
            self.totalScheduledMinutes = nil
            self.upcomingMinutesScheduled = nil
        }
    }
}

/// <p/>
public struct GetMinuteUsageOutputResponse: Equatable {
    /// <p>Estimated number of minutes remaining for an account, specific to the month being requested.</p>
    public let estimatedMinutesRemaining: Int?
    /// <p>Returns whether or not an account has signed up for the reserved minutes pricing plan, specific to the month being requested.</p>
    public let isReservedMinutesCustomer: Bool?
    /// <p>Total number of reserved minutes allocated, specific to the month being requested.</p>
    public let totalReservedMinuteAllocation: Int?
    /// <p>Total scheduled minutes for an account, specific to the month being requested.</p>
    public let totalScheduledMinutes: Int?
    /// <p>Upcoming minutes scheduled for an account, specific to the month being requested.</p>
    public let upcomingMinutesScheduled: Int?

    public init (
        estimatedMinutesRemaining: Int? = nil,
        isReservedMinutesCustomer: Bool? = nil,
        totalReservedMinuteAllocation: Int? = nil,
        totalScheduledMinutes: Int? = nil,
        upcomingMinutesScheduled: Int? = nil
    )
    {
        self.estimatedMinutesRemaining = estimatedMinutesRemaining
        self.isReservedMinutesCustomer = isReservedMinutesCustomer
        self.totalReservedMinuteAllocation = totalReservedMinuteAllocation
        self.totalScheduledMinutes = totalScheduledMinutes
        self.upcomingMinutesScheduled = upcomingMinutesScheduled
    }
}

struct GetMinuteUsageOutputResponseBody: Equatable {
    public let isReservedMinutesCustomer: Bool?
    public let totalReservedMinuteAllocation: Int?
    public let upcomingMinutesScheduled: Int?
    public let totalScheduledMinutes: Int?
    public let estimatedMinutesRemaining: Int?
}

extension GetMinuteUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case estimatedMinutesRemaining
        case isReservedMinutesCustomer
        case totalReservedMinuteAllocation
        case totalScheduledMinutes
        case upcomingMinutesScheduled
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isReservedMinutesCustomerDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isReservedMinutesCustomer)
        isReservedMinutesCustomer = isReservedMinutesCustomerDecoded
        let totalReservedMinuteAllocationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalReservedMinuteAllocation)
        totalReservedMinuteAllocation = totalReservedMinuteAllocationDecoded
        let upcomingMinutesScheduledDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .upcomingMinutesScheduled)
        upcomingMinutesScheduled = upcomingMinutesScheduledDecoded
        let totalScheduledMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalScheduledMinutes)
        totalScheduledMinutes = totalScheduledMinutesDecoded
        let estimatedMinutesRemainingDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .estimatedMinutesRemaining)
        estimatedMinutesRemaining = estimatedMinutesRemainingDecoded
    }
}

extension GetMissionProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMissionProfileInput(missionProfileId: \(String(describing: missionProfileId)))"}
}

extension GetMissionProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetMissionProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetMissionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMissionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMissionProfileInput>
    public typealias MOutput = OperationOutput<GetMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMissionProfileOutputError>
}

public struct GetMissionProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMissionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMissionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMissionProfileInput>
    public typealias MOutput = OperationOutput<GetMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMissionProfileOutputError>
}

/// <p/>
public struct GetMissionProfileInput: Equatable {
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: String?

    public init (
        missionProfileId: String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct GetMissionProfileInputBody: Equatable {
}

extension GetMissionProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetMissionProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMissionProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMissionProfileOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMissionProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMissionProfileOutputResponse(contactPostPassDurationSeconds: \(String(describing: contactPostPassDurationSeconds)), contactPrePassDurationSeconds: \(String(describing: contactPrePassDurationSeconds)), dataflowEdges: \(String(describing: dataflowEdges)), minimumViableContactDurationSeconds: \(String(describing: minimumViableContactDurationSeconds)), missionProfileArn: \(String(describing: missionProfileArn)), missionProfileId: \(String(describing: missionProfileId)), name: \(String(describing: name)), region: \(String(describing: region)), tags: \(String(describing: tags)), trackingConfigArn: \(String(describing: trackingConfigArn)))"}
}

extension GetMissionProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactPostPassDurationSeconds = output.contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = output.contactPrePassDurationSeconds
            self.dataflowEdges = output.dataflowEdges
            self.minimumViableContactDurationSeconds = output.minimumViableContactDurationSeconds
            self.missionProfileArn = output.missionProfileArn
            self.missionProfileId = output.missionProfileId
            self.name = output.name
            self.region = output.region
            self.tags = output.tags
            self.trackingConfigArn = output.trackingConfigArn
        } else {
            self.contactPostPassDurationSeconds = nil
            self.contactPrePassDurationSeconds = nil
            self.dataflowEdges = nil
            self.minimumViableContactDurationSeconds = nil
            self.missionProfileArn = nil
            self.missionProfileId = nil
            self.name = nil
            self.region = nil
            self.tags = nil
            self.trackingConfigArn = nil
        }
    }
}

/// <p/>
public struct GetMissionProfileOutputResponse: Equatable {
    /// <p>Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.</p>
    public let contactPostPassDurationSeconds: Int?
    /// <p>Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.</p>
    public let contactPrePassDurationSeconds: Int?
    /// <p>A list of lists of ARNs. Each list of ARNs is an edge, with a <i>from</i>
    ///             <code>Config</code> and a <i>to</i>
    ///             <code>Config</code>.</p>
    public let dataflowEdges: [[String]]?
    /// <p>Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.</p>
    public let minimumViableContactDurationSeconds: Int?
    /// <p>ARN of a mission profile.</p>
    public let missionProfileArn: String?
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: String?
    /// <p>Name of a mission profile.</p>
    public let name: String?
    /// <p>Region of a mission profile.</p>
    public let region: String?
    /// <p>Tags assigned to a mission profile.</p>
    public let tags: [String:String]?
    /// <p>ARN of a tracking <code>Config</code>.</p>
    public let trackingConfigArn: String?

    public init (
        contactPostPassDurationSeconds: Int? = nil,
        contactPrePassDurationSeconds: Int? = nil,
        dataflowEdges: [[String]]? = nil,
        minimumViableContactDurationSeconds: Int? = nil,
        missionProfileArn: String? = nil,
        missionProfileId: String? = nil,
        name: String? = nil,
        region: String? = nil,
        tags: [String:String]? = nil,
        trackingConfigArn: String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.missionProfileArn = missionProfileArn
        self.missionProfileId = missionProfileId
        self.name = name
        self.region = region
        self.tags = tags
        self.trackingConfigArn = trackingConfigArn
    }
}

struct GetMissionProfileOutputResponseBody: Equatable {
    public let missionProfileId: String?
    public let missionProfileArn: String?
    public let name: String?
    public let region: String?
    public let contactPrePassDurationSeconds: Int?
    public let contactPostPassDurationSeconds: Int?
    public let minimumViableContactDurationSeconds: Int?
    public let dataflowEdges: [[String]]?
    public let trackingConfigArn: String?
    public let tags: [String:String]?
}

extension GetMissionProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case missionProfileArn
        case missionProfileId
        case name
        case region
        case tags
        case trackingConfigArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSatelliteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSatelliteInput(satelliteId: \(String(describing: satelliteId)))"}
}

extension GetSatelliteInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSatelliteInputHeadersMiddleware: Middleware {
    public let id: String = "GetSatelliteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSatelliteInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSatelliteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSatelliteInput>
    public typealias MOutput = OperationOutput<GetSatelliteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSatelliteOutputError>
}

public struct GetSatelliteInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSatelliteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSatelliteInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSatelliteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSatelliteInput>
    public typealias MOutput = OperationOutput<GetSatelliteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSatelliteOutputError>
}

/// <p/>
public struct GetSatelliteInput: Equatable {
    /// <p>UUID of a satellite.</p>
    public let satelliteId: String?

    public init (
        satelliteId: String? = nil
    )
    {
        self.satelliteId = satelliteId
    }
}

struct GetSatelliteInputBody: Equatable {
}

extension GetSatelliteInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSatelliteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSatelliteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSatelliteOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSatelliteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSatelliteOutputResponse(groundStations: \(String(describing: groundStations)), noradSatelliteID: \(String(describing: noradSatelliteID)), satelliteArn: \(String(describing: satelliteArn)), satelliteId: \(String(describing: satelliteId)))"}
}

extension GetSatelliteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSatelliteOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groundStations = output.groundStations
            self.noradSatelliteID = output.noradSatelliteID
            self.satelliteArn = output.satelliteArn
            self.satelliteId = output.satelliteId
        } else {
            self.groundStations = nil
            self.noradSatelliteID = 0
            self.satelliteArn = nil
            self.satelliteId = nil
        }
    }
}

/// <p/>
public struct GetSatelliteOutputResponse: Equatable {
    /// <p>A list of ground stations to which the satellite is on-boarded.</p>
    public let groundStations: [String]?
    /// <p>NORAD satellite ID number.</p>
    public let noradSatelliteID: Int
    /// <p>ARN of a satellite.</p>
    public let satelliteArn: String?
    /// <p>UUID of a satellite.</p>
    public let satelliteId: String?

    public init (
        groundStations: [String]? = nil,
        noradSatelliteID: Int = 0,
        satelliteArn: String? = nil,
        satelliteId: String? = nil
    )
    {
        self.groundStations = groundStations
        self.noradSatelliteID = noradSatelliteID
        self.satelliteArn = satelliteArn
        self.satelliteId = satelliteId
    }
}

struct GetSatelliteOutputResponseBody: Equatable {
    public let satelliteId: String?
    public let satelliteArn: String?
    public let noradSatelliteID: Int
    public let groundStations: [String]?
}

extension GetSatelliteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groundStations
        case noradSatelliteID
        case satelliteArn
        case satelliteId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let noradSatelliteIDDecoded = try containerValues.decode(Int.self, forKey: .noradSatelliteID)
        noradSatelliteID = noradSatelliteIDDecoded
        let groundStationsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .groundStations)
        var groundStationsDecoded0:[String]? = nil
        if let groundStationsContainer = groundStationsContainer {
            groundStationsDecoded0 = [String]()
            for string0 in groundStationsContainer {
                if let string0 = string0 {
                    groundStationsDecoded0?.append(string0)
                }
            }
        }
        groundStations = groundStationsDecoded0
    }
}

extension GroundStationData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groundStationId
        case groundStationName
        case region
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groundStationId = groundStationId {
            try encodeContainer.encode(groundStationId, forKey: .groundStationId)
        }
        if let groundStationName = groundStationName {
            try encodeContainer.encode(groundStationName, forKey: .groundStationName)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groundStationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groundStationId)
        groundStationId = groundStationIdDecoded
        let groundStationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groundStationName)
        groundStationName = groundStationNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
    }
}

extension GroundStationData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroundStationData(groundStationId: \(String(describing: groundStationId)), groundStationName: \(String(describing: groundStationName)), region: \(String(describing: region)))"}
}

/// <p>Information about the ground station data.</p>
public struct GroundStationData: Equatable {
    /// <p>UUID of a ground station.</p>
    public let groundStationId: String?
    /// <p>Name of a ground station.</p>
    public let groundStationName: String?
    /// <p>Ground station Region.</p>
    public let region: String?

    public init (
        groundStationId: String? = nil,
        groundStationName: String? = nil,
        region: String? = nil
    )
    {
        self.groundStationId = groundStationId
        self.groundStationName = groundStationName
        self.region = region
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)), parameterName: \(String(describing: parameterName)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters are not valid.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p/>
    public var parameterName: String?

    public init (
        message: String? = nil,
        parameterName: String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
    public let parameterName: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case parameterName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension ListConfigsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListConfigsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigsInput>
    public typealias MOutput = OperationOutput<ListConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigsOutputError>
}

public struct ListConfigsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigsInput>
    public typealias MOutput = OperationOutput<ListConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigsOutputError>
}

/// <p/>
public struct ListConfigsInput: Equatable {
    /// <p>Maximum number of <code>Configs</code> returned.</p>
    public let maxResults: Int?
    /// <p>Next token returned in the request of a previous <code>ListConfigs</code> call. Used to get the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigsInputBody: Equatable {
}

extension ListConfigsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListConfigsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigsOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigsOutputResponse(configList: \(String(describing: configList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConfigsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configList = output.configList
            self.nextToken = output.nextToken
        } else {
            self.configList = nil
            self.nextToken = nil
        }
    }
}

/// <p/>
public struct ListConfigsOutputResponse: Equatable {
    /// <p>List of <code>Config</code> items.</p>
    public let configList: [ConfigListItem]?
    /// <p>Next token returned in the response of a previous <code>ListConfigs</code> call. Used to get the next page of results.</p>
    public let nextToken: String?

    public init (
        configList: [ConfigListItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.configList = configList
        self.nextToken = nextToken
    }
}

struct ListConfigsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let configList: [ConfigListItem]?
}

extension ListConfigsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configList
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let configListContainer = try containerValues.decodeIfPresent([ConfigListItem?].self, forKey: .configList)
        var configListDecoded0:[ConfigListItem]? = nil
        if let configListContainer = configListContainer {
            configListDecoded0 = [ConfigListItem]()
            for structure0 in configListContainer {
                if let structure0 = structure0 {
                    configListDecoded0?.append(structure0)
                }
            }
        }
        configList = configListDecoded0
    }
}

public struct ListContactsInputBodyMiddleware: Middleware {
    public let id: String = "ListContactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactsInput>
    public typealias MOutput = OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactsOutputError>
}

extension ListContactsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactsInput(endTime: \(String(describing: endTime)), groundStation: \(String(describing: groundStation)), maxResults: \(String(describing: maxResults)), missionProfileArn: \(String(describing: missionProfileArn)), nextToken: \(String(describing: nextToken)), satelliteArn: \(String(describing: satelliteArn)), startTime: \(String(describing: startTime)), statusList: \(String(describing: statusList)))"}
}

extension ListContactsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime
        case groundStation
        case maxResults
        case missionProfileArn
        case nextToken
        case satelliteArn
        case startTime
        case statusList
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let groundStation = groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let missionProfileArn = missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let satelliteArn = satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let statusList = statusList {
            var statusListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusList)
            for statuslist0 in statusList {
                try statusListContainer.encode(statuslist0.rawValue)
            }
        }
    }
}

public struct ListContactsInputHeadersMiddleware: Middleware {
    public let id: String = "ListContactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactsInput>
    public typealias MOutput = OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactsOutputError>
}

public struct ListContactsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListContactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContactsInput>
    public typealias MOutput = OperationOutput<ListContactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContactsOutputError>
}

/// <p/>
public struct ListContactsInput: Equatable {
    /// <p>End time of a contact.</p>
    public let endTime: Date?
    /// <p>Name of a ground station.</p>
    public let groundStation: String?
    /// <p>Maximum number of contacts returned.</p>
    public let maxResults: Int?
    /// <p>ARN of a mission profile.</p>
    public let missionProfileArn: String?
    /// <p>Next token returned in the request of a previous <code>ListContacts</code> call. Used to get the next page of results.</p>
    public let nextToken: String?
    /// <p>ARN of a satellite.</p>
    public let satelliteArn: String?
    /// <p>Start time of a contact.</p>
    public let startTime: Date?
    /// <p>Status of a contact reservation.</p>
    public let statusList: [ContactStatus]?

    public init (
        endTime: Date? = nil,
        groundStation: String? = nil,
        maxResults: Int? = nil,
        missionProfileArn: String? = nil,
        nextToken: String? = nil,
        satelliteArn: String? = nil,
        startTime: Date? = nil,
        statusList: [ContactStatus]? = nil
    )
    {
        self.endTime = endTime
        self.groundStation = groundStation
        self.maxResults = maxResults
        self.missionProfileArn = missionProfileArn
        self.nextToken = nextToken
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.statusList = statusList
    }
}

struct ListContactsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let statusList: [ContactStatus]?
    public let startTime: Date?
    public let endTime: Date?
    public let groundStation: String?
    public let satelliteArn: String?
    public let missionProfileArn: String?
}

extension ListContactsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime
        case groundStation
        case maxResults
        case missionProfileArn
        case nextToken
        case satelliteArn
        case startTime
        case statusList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusListContainer = try containerValues.decodeIfPresent([ContactStatus?].self, forKey: .statusList)
        var statusListDecoded0:[ContactStatus]? = nil
        if let statusListContainer = statusListContainer {
            statusListDecoded0 = [ContactStatus]()
            for string0 in statusListContainer {
                if let string0 = string0 {
                    statusListDecoded0?.append(string0)
                }
            }
        }
        statusList = statusListDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
    }
}

extension ListContactsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContactsOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContactsOutputResponse(contactList: \(String(describing: contactList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListContactsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListContactsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactList = output.contactList
            self.nextToken = output.nextToken
        } else {
            self.contactList = nil
            self.nextToken = nil
        }
    }
}

/// <p/>
public struct ListContactsOutputResponse: Equatable {
    /// <p>List of contacts.</p>
    public let contactList: [ContactData]?
    /// <p>Next token returned in the response of a previous <code>ListContacts</code> call. Used to get the next page of results.</p>
    public let nextToken: String?

    public init (
        contactList: [ContactData]? = nil,
        nextToken: String? = nil
    )
    {
        self.contactList = contactList
        self.nextToken = nextToken
    }
}

struct ListContactsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let contactList: [ContactData]?
}

extension ListContactsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactList
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactListContainer = try containerValues.decodeIfPresent([ContactData?].self, forKey: .contactList)
        var contactListDecoded0:[ContactData]? = nil
        if let contactListContainer = contactListContainer {
            contactListDecoded0 = [ContactData]()
            for structure0 in contactListContainer {
                if let structure0 = structure0 {
                    contactListDecoded0?.append(structure0)
                }
            }
        }
        contactList = contactListDecoded0
    }
}

extension ListDataflowEndpointGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataflowEndpointGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataflowEndpointGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDataflowEndpointGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDataflowEndpointGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataflowEndpointGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataflowEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataflowEndpointGroupsInput>
    public typealias MOutput = OperationOutput<ListDataflowEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataflowEndpointGroupsOutputError>
}

public struct ListDataflowEndpointGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDataflowEndpointGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataflowEndpointGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataflowEndpointGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataflowEndpointGroupsInput>
    public typealias MOutput = OperationOutput<ListDataflowEndpointGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataflowEndpointGroupsOutputError>
}

/// <p/>
public struct ListDataflowEndpointGroupsInput: Equatable {
    /// <p>Maximum number of dataflow endpoint groups returned.</p>
    public let maxResults: Int?
    /// <p>Next token returned in the request of a previous <code>ListDataflowEndpointGroups</code> call. Used to get the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataflowEndpointGroupsInputBody: Equatable {
}

extension ListDataflowEndpointGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDataflowEndpointGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataflowEndpointGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataflowEndpointGroupsOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataflowEndpointGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataflowEndpointGroupsOutputResponse(dataflowEndpointGroupList: \(String(describing: dataflowEndpointGroupList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataflowEndpointGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDataflowEndpointGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataflowEndpointGroupList = output.dataflowEndpointGroupList
            self.nextToken = output.nextToken
        } else {
            self.dataflowEndpointGroupList = nil
            self.nextToken = nil
        }
    }
}

/// <p/>
public struct ListDataflowEndpointGroupsOutputResponse: Equatable {
    /// <p>A list of dataflow endpoint groups.</p>
    public let dataflowEndpointGroupList: [DataflowEndpointListItem]?
    /// <p>Next token returned in the response of a previous <code>ListDataflowEndpointGroups</code> call. Used to get the next page of results.</p>
    public let nextToken: String?

    public init (
        dataflowEndpointGroupList: [DataflowEndpointListItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.dataflowEndpointGroupList = dataflowEndpointGroupList
        self.nextToken = nextToken
    }
}

struct ListDataflowEndpointGroupsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let dataflowEndpointGroupList: [DataflowEndpointListItem]?
}

extension ListDataflowEndpointGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataflowEndpointGroupList
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dataflowEndpointGroupListContainer = try containerValues.decodeIfPresent([DataflowEndpointListItem?].self, forKey: .dataflowEndpointGroupList)
        var dataflowEndpointGroupListDecoded0:[DataflowEndpointListItem]? = nil
        if let dataflowEndpointGroupListContainer = dataflowEndpointGroupListContainer {
            dataflowEndpointGroupListDecoded0 = [DataflowEndpointListItem]()
            for structure0 in dataflowEndpointGroupListContainer {
                if let structure0 = structure0 {
                    dataflowEndpointGroupListDecoded0?.append(structure0)
                }
            }
        }
        dataflowEndpointGroupList = dataflowEndpointGroupListDecoded0
    }
}

extension ListGroundStationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroundStationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), satelliteId: \(String(describing: satelliteId)))"}
}

extension ListGroundStationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListGroundStationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroundStationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroundStationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroundStationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroundStationsInput>
    public typealias MOutput = OperationOutput<ListGroundStationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroundStationsOutputError>
}

public struct ListGroundStationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroundStationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroundStationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroundStationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let satelliteId = input.operationInput.satelliteId {
            let satelliteIdQueryItem = URLQueryItem(name: "satelliteId".urlPercentEncoding(), value: String(satelliteId).urlPercentEncoding())
            input.builder.withQueryItem(satelliteIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroundStationsInput>
    public typealias MOutput = OperationOutput<ListGroundStationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroundStationsOutputError>
}

/// <p/>
public struct ListGroundStationsInput: Equatable {
    /// <p>Maximum number of ground stations returned.</p>
    public let maxResults: Int?
    /// <p>Next token that can be supplied in the next call to get the next page of ground stations.</p>
    public let nextToken: String?
    /// <p>Satellite ID to retrieve on-boarded ground stations.</p>
    public let satelliteId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        satelliteId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.satelliteId = satelliteId
    }
}

struct ListGroundStationsInputBody: Equatable {
}

extension ListGroundStationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListGroundStationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroundStationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroundStationsOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroundStationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroundStationsOutputResponse(groundStationList: \(String(describing: groundStationList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGroundStationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroundStationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groundStationList = output.groundStationList
            self.nextToken = output.nextToken
        } else {
            self.groundStationList = nil
            self.nextToken = nil
        }
    }
}

/// <p/>
public struct ListGroundStationsOutputResponse: Equatable {
    /// <p>List of ground stations.</p>
    public let groundStationList: [GroundStationData]?
    /// <p>Next token that can be supplied in the next call to get the next page of ground stations.</p>
    public let nextToken: String?

    public init (
        groundStationList: [GroundStationData]? = nil,
        nextToken: String? = nil
    )
    {
        self.groundStationList = groundStationList
        self.nextToken = nextToken
    }
}

struct ListGroundStationsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let groundStationList: [GroundStationData]?
}

extension ListGroundStationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groundStationList
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let groundStationListContainer = try containerValues.decodeIfPresent([GroundStationData?].self, forKey: .groundStationList)
        var groundStationListDecoded0:[GroundStationData]? = nil
        if let groundStationListContainer = groundStationListContainer {
            groundStationListDecoded0 = [GroundStationData]()
            for structure0 in groundStationListContainer {
                if let structure0 = structure0 {
                    groundStationListDecoded0?.append(structure0)
                }
            }
        }
        groundStationList = groundStationListDecoded0
    }
}

extension ListMissionProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMissionProfilesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMissionProfilesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListMissionProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListMissionProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMissionProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMissionProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMissionProfilesInput>
    public typealias MOutput = OperationOutput<ListMissionProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMissionProfilesOutputError>
}

public struct ListMissionProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMissionProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMissionProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMissionProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMissionProfilesInput>
    public typealias MOutput = OperationOutput<ListMissionProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMissionProfilesOutputError>
}

/// <p/>
public struct ListMissionProfilesInput: Equatable {
    /// <p>Maximum number of mission profiles returned.</p>
    public let maxResults: Int?
    /// <p>Next token returned in the request of a previous <code>ListMissionProfiles</code> call. Used to get the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMissionProfilesInputBody: Equatable {
}

extension ListMissionProfilesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListMissionProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMissionProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMissionProfilesOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMissionProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMissionProfilesOutputResponse(missionProfileList: \(String(describing: missionProfileList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMissionProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMissionProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.missionProfileList = output.missionProfileList
            self.nextToken = output.nextToken
        } else {
            self.missionProfileList = nil
            self.nextToken = nil
        }
    }
}

/// <p/>
public struct ListMissionProfilesOutputResponse: Equatable {
    /// <p>List of mission profiles.</p>
    public let missionProfileList: [MissionProfileListItem]?
    /// <p>Next token returned in the response of a previous <code>ListMissionProfiles</code> call. Used to get the next page of results.</p>
    public let nextToken: String?

    public init (
        missionProfileList: [MissionProfileListItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.missionProfileList = missionProfileList
        self.nextToken = nextToken
    }
}

struct ListMissionProfilesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let missionProfileList: [MissionProfileListItem]?
}

extension ListMissionProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case missionProfileList
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let missionProfileListContainer = try containerValues.decodeIfPresent([MissionProfileListItem?].self, forKey: .missionProfileList)
        var missionProfileListDecoded0:[MissionProfileListItem]? = nil
        if let missionProfileListContainer = missionProfileListContainer {
            missionProfileListDecoded0 = [MissionProfileListItem]()
            for structure0 in missionProfileListContainer {
                if let structure0 = structure0 {
                    missionProfileListDecoded0?.append(structure0)
                }
            }
        }
        missionProfileList = missionProfileListDecoded0
    }
}

extension ListSatellitesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSatellitesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSatellitesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSatellitesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSatellitesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSatellitesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSatellitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSatellitesInput>
    public typealias MOutput = OperationOutput<ListSatellitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSatellitesOutputError>
}

public struct ListSatellitesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSatellitesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSatellitesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSatellitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSatellitesInput>
    public typealias MOutput = OperationOutput<ListSatellitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSatellitesOutputError>
}

/// <p/>
public struct ListSatellitesInput: Equatable {
    /// <p>Maximum number of satellites returned.</p>
    public let maxResults: Int?
    /// <p>Next token that can be supplied in the next call to get the next page of satellites.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSatellitesInputBody: Equatable {
}

extension ListSatellitesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSatellitesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSatellitesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSatellitesOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSatellitesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSatellitesOutputResponse(nextToken: \(String(describing: nextToken)), satellites: \(String(describing: satellites)))"}
}

extension ListSatellitesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSatellitesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.satellites = output.satellites
        } else {
            self.nextToken = nil
            self.satellites = nil
        }
    }
}

/// <p/>
public struct ListSatellitesOutputResponse: Equatable {
    /// <p>Next token that can be supplied in the next call to get the next page of satellites.</p>
    public let nextToken: String?
    /// <p>List of satellites.</p>
    public let satellites: [SatelliteListItem]?

    public init (
        nextToken: String? = nil,
        satellites: [SatelliteListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.satellites = satellites
    }
}

struct ListSatellitesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let satellites: [SatelliteListItem]?
}

extension ListSatellitesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case satellites
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let satellitesContainer = try containerValues.decodeIfPresent([SatelliteListItem?].self, forKey: .satellites)
        var satellitesDecoded0:[SatelliteListItem]? = nil
        if let satellitesContainer = satellitesContainer {
            satellitesDecoded0 = [SatelliteListItem]()
            for structure0 in satellitesContainer {
                if let structure0 = structure0 {
                    satellitesDecoded0?.append(structure0)
                }
            }
        }
        satellites = satellitesDecoded0
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

/// <p/>
public struct ListTagsForResourceInput: Equatable {
    /// <p>ARN of a resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// <p/>
public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>Tags assigned to a resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MissionProfileListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case missionProfileArn
        case missionProfileId
        case name
        case region
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let missionProfileArn = missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let missionProfileId = missionProfileId {
            try encodeContainer.encode(missionProfileId, forKey: .missionProfileId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MissionProfileListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MissionProfileListItem(missionProfileArn: \(String(describing: missionProfileArn)), missionProfileId: \(String(describing: missionProfileId)), name: \(String(describing: name)), region: \(String(describing: region)))"}
}

/// <p>Item in a list of mission profiles.</p>
public struct MissionProfileListItem: Equatable {
    /// <p>ARN of a mission profile.</p>
    public let missionProfileArn: String?
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: String?
    /// <p>Name of a mission profile.</p>
    public let name: String?
    /// <p>Region of a mission profile.</p>
    public let region: String?

    public init (
        missionProfileArn: String? = nil,
        missionProfileId: String? = nil,
        name: String? = nil,
        region: String? = nil
    )
    {
        self.missionProfileArn = missionProfileArn
        self.missionProfileId = missionProfileId
        self.name = name
        self.region = region
    }
}

public enum Polarization {
    case leftHand
    case `none`
    case rightHand
    case sdkUnknown(String)
}

extension Polarization : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Polarization] {
        return [
            .leftHand,
            .none,
            .rightHand,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .leftHand: return "LEFT_HAND"
        case .none: return "NONE"
        case .rightHand: return "RIGHT_HAND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Polarization(rawValue: rawValue) ?? Polarization.sdkUnknown(rawValue)
    }
}

public struct ReserveContactInputBodyMiddleware: Middleware {
    public let id: String = "ReserveContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReserveContactInput>,
                  next: H) -> Swift.Result<OperationOutput<ReserveContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReserveContactInput>
    public typealias MOutput = OperationOutput<ReserveContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReserveContactOutputError>
}

extension ReserveContactInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReserveContactInput(endTime: \(String(describing: endTime)), groundStation: \(String(describing: groundStation)), missionProfileArn: \(String(describing: missionProfileArn)), satelliteArn: \(String(describing: satelliteArn)), startTime: \(String(describing: startTime)), tags: \(String(describing: tags)))"}
}

extension ReserveContactInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime
        case groundStation
        case missionProfileArn
        case satelliteArn
        case startTime
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let groundStation = groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let missionProfileArn = missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let satelliteArn = satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct ReserveContactInputHeadersMiddleware: Middleware {
    public let id: String = "ReserveContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReserveContactInput>,
                  next: H) -> Swift.Result<OperationOutput<ReserveContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReserveContactInput>
    public typealias MOutput = OperationOutput<ReserveContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReserveContactOutputError>
}

public struct ReserveContactInputQueryItemMiddleware: Middleware {
    public let id: String = "ReserveContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReserveContactInput>,
                  next: H) -> Swift.Result<OperationOutput<ReserveContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReserveContactInput>
    public typealias MOutput = OperationOutput<ReserveContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReserveContactOutputError>
}

/// <p/>
public struct ReserveContactInput: Equatable {
    /// <p>End time of a contact.</p>
    public let endTime: Date?
    /// <p>Name of a ground station.</p>
    public let groundStation: String?
    /// <p>ARN of a mission profile.</p>
    public let missionProfileArn: String?
    /// <p>ARN of a satellite</p>
    public let satelliteArn: String?
    /// <p>Start time of a contact.</p>
    public let startTime: Date?
    /// <p>Tags assigned to a contact.</p>
    public let tags: [String:String]?

    public init (
        endTime: Date? = nil,
        groundStation: String? = nil,
        missionProfileArn: String? = nil,
        satelliteArn: String? = nil,
        startTime: Date? = nil,
        tags: [String:String]? = nil
    )
    {
        self.endTime = endTime
        self.groundStation = groundStation
        self.missionProfileArn = missionProfileArn
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
    }
}

struct ReserveContactInputBody: Equatable {
    public let missionProfileArn: String?
    public let satelliteArn: String?
    public let startTime: Date?
    public let endTime: Date?
    public let groundStation: String?
    public let tags: [String:String]?
}

extension ReserveContactInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime
        case groundStation
        case missionProfileArn
        case satelliteArn
        case startTime
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ReserveContactOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReserveContactOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReserveContactOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReserveContactOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReserveContactOutputResponse(contactId: \(String(describing: contactId)))"}
}

extension ReserveContactOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReserveContactOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

/// <p/>
public struct ReserveContactOutputResponse: Equatable {
    /// <p>UUID of a contact.</p>
    public let contactId: String?

    public init (
        contactId: String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct ReserveContactOutputResponseBody: Equatable {
    public let contactId: String?
}

extension ReserveContactOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension ResourceLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceLimitExceededException(message: \(String(describing: message)), parameterName: \(String(describing: parameterName)))"}
}

extension ResourceLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Account limits for this resource have been exceeded.</p>
public struct ResourceLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p/>
    public var parameterName: String?

    public init (
        message: String? = nil,
        parameterName: String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct ResourceLimitExceededExceptionBody: Equatable {
    public let message: String?
    public let parameterName: String?
}

extension ResourceLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case parameterName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3RecordingConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketArn
        case prefix
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension S3RecordingConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3RecordingConfig(bucketArn: \(String(describing: bucketArn)), prefix: \(String(describing: prefix)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Information about an S3 recording <code>Config</code>.</p>
public struct S3RecordingConfig: Equatable {
    /// <p>ARN of the bucket to record to.</p>
    public let bucketArn: String?
    /// <p>S3 Key prefix to prefice data files.</p>
    public let prefix: String?
    /// <p>ARN of the role Ground Station assumes to write data to the bucket.</p>
    public let roleArn: String?

    public init (
        bucketArn: String? = nil,
        prefix: String? = nil,
        roleArn: String? = nil
    )
    {
        self.bucketArn = bucketArn
        self.prefix = prefix
        self.roleArn = roleArn
    }
}

extension S3RecordingDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketArn
        case keyTemplate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let keyTemplate = keyTemplate {
            try encodeContainer.encode(keyTemplate, forKey: .keyTemplate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let keyTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyTemplate)
        keyTemplate = keyTemplateDecoded
    }
}

extension S3RecordingDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3RecordingDetails(bucketArn: \(String(describing: bucketArn)), keyTemplate: \(String(describing: keyTemplate)))"}
}

/// <p>Details about an S3 recording <code>Config</code> used in a contact.</p>
public struct S3RecordingDetails: Equatable {
    /// <p>ARN of the bucket used.</p>
    public let bucketArn: String?
    /// <p>Template of the S3 key used.</p>
    public let keyTemplate: String?

    public init (
        bucketArn: String? = nil,
        keyTemplate: String? = nil
    )
    {
        self.bucketArn = bucketArn
        self.keyTemplate = keyTemplate
    }
}

extension SatelliteListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groundStations
        case noradSatelliteID
        case satelliteArn
        case satelliteId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groundStations = groundStations {
            var groundStationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groundStations)
            for groundstationidlist0 in groundStations {
                try groundStationsContainer.encode(groundstationidlist0)
            }
        }
        if noradSatelliteID != 0 {
            try encodeContainer.encode(noradSatelliteID, forKey: .noradSatelliteID)
        }
        if let satelliteArn = satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let satelliteId = satelliteId {
            try encodeContainer.encode(satelliteId, forKey: .satelliteId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let noradSatelliteIDDecoded = try containerValues.decode(Int.self, forKey: .noradSatelliteID)
        noradSatelliteID = noradSatelliteIDDecoded
        let groundStationsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .groundStations)
        var groundStationsDecoded0:[String]? = nil
        if let groundStationsContainer = groundStationsContainer {
            groundStationsDecoded0 = [String]()
            for string0 in groundStationsContainer {
                if let string0 = string0 {
                    groundStationsDecoded0?.append(string0)
                }
            }
        }
        groundStations = groundStationsDecoded0
    }
}

extension SatelliteListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SatelliteListItem(groundStations: \(String(describing: groundStations)), noradSatelliteID: \(String(describing: noradSatelliteID)), satelliteArn: \(String(describing: satelliteArn)), satelliteId: \(String(describing: satelliteId)))"}
}

/// <p>Item in a list of satellites.</p>
public struct SatelliteListItem: Equatable {
    /// <p>A list of ground stations to which the satellite is on-boarded.</p>
    public let groundStations: [String]?
    /// <p>NORAD satellite ID number.</p>
    public let noradSatelliteID: Int
    /// <p>ARN of a satellite.</p>
    public let satelliteArn: String?
    /// <p>UUID of a satellite.</p>
    public let satelliteId: String?

    public init (
        groundStations: [String]? = nil,
        noradSatelliteID: Int = 0,
        satelliteArn: String? = nil,
        satelliteId: String? = nil
    )
    {
        self.groundStations = groundStations
        self.noradSatelliteID = noradSatelliteID
        self.satelliteArn = satelliteArn
        self.satelliteId = satelliteId
    }
}

extension SecurityDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn
        case securityGroupIds
        case subnetIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension SecurityDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityDetails(roleArn: \(String(describing: roleArn)), securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)))"}
}

/// <p>Information about endpoints.</p>
public struct SecurityDetails: Equatable {
    /// <p>ARN to a role needed for connecting streams to your instances. </p>
    public let roleArn: String?
    /// <p>The security groups to attach to the elastic network interfaces.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.</p>
    public let subnetIds: [String]?

    public init (
        roleArn: String? = nil,
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.roleArn = roleArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
    }
}

extension SocketAddress: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case port
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
    }
}

extension SocketAddress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SocketAddress(name: \(String(describing: name)), port: \(String(describing: port)))"}
}

/// <p>Information about the socket address.</p>
public struct SocketAddress: Equatable {
    /// <p>Name of a socket address.</p>
    public let name: String?
    /// <p>Port of a socket address.</p>
    public let port: Int?

    public init (
        name: String? = nil,
        port: Int? = nil
    )
    {
        self.name = name
        self.port = port
    }
}

extension Source: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configDetails
        case configId
        case configType
        case dataflowSourceRegion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configDetails = configDetails {
            try encodeContainer.encode(configDetails, forKey: .configDetails)
        }
        if let configId = configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let dataflowSourceRegion = dataflowSourceRegion {
            try encodeContainer.encode(dataflowSourceRegion, forKey: .dataflowSourceRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configId)
        configId = configIdDecoded
        let configDetailsDecoded = try containerValues.decodeIfPresent(ConfigDetails.self, forKey: .configDetails)
        configDetails = configDetailsDecoded
        let dataflowSourceRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataflowSourceRegion)
        dataflowSourceRegion = dataflowSourceRegionDecoded
    }
}

extension Source: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Source(configDetails: \(String(describing: configDetails)), configId: \(String(describing: configId)), configType: \(String(describing: configType)), dataflowSourceRegion: \(String(describing: dataflowSourceRegion)))"}
}

/// <p>Dataflow details for the source side.</p>
public struct Source: Equatable {
    /// <p>Additional details for a <code>Config</code>, if type is dataflow endpoint or antenna demod decode.</p>
    public let configDetails: ConfigDetails?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: ConfigCapabilityType?
    /// <p>Region of a dataflow source.</p>
    public let dataflowSourceRegion: String?

    public init (
        configDetails: ConfigDetails? = nil,
        configId: String? = nil,
        configType: ConfigCapabilityType? = nil,
        dataflowSourceRegion: String? = nil
    )
    {
        self.configDetails = configDetails
        self.configId = configId
        self.configType = configType
        self.dataflowSourceRegion = dataflowSourceRegion
    }
}

extension SpectrumConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bandwidth
        case centerFrequency
        case polarization
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let centerFrequency = centerFrequency {
            try encodeContainer.encode(centerFrequency, forKey: .centerFrequency)
        }
        if let polarization = polarization {
            try encodeContainer.encode(polarization.rawValue, forKey: .polarization)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let centerFrequencyDecoded = try containerValues.decodeIfPresent(Frequency.self, forKey: .centerFrequency)
        centerFrequency = centerFrequencyDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(FrequencyBandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let polarizationDecoded = try containerValues.decodeIfPresent(Polarization.self, forKey: .polarization)
        polarization = polarizationDecoded
    }
}

extension SpectrumConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SpectrumConfig(bandwidth: \(String(describing: bandwidth)), centerFrequency: \(String(describing: centerFrequency)), polarization: \(String(describing: polarization)))"}
}

/// <p>Object that describes a spectral <code>Config</code>.</p>
public struct SpectrumConfig: Equatable {
    /// <p>Bandwidth of a spectral <code>Config</code>. AWS Ground Station currently has the following bandwidth limitations:</p>
    ///             <ul>
    ///             <li>
    ///                <p>For <code>AntennaDownlinkDemodDecodeconfig</code>, valid values are between 125 kHz to 650 MHz.</p>
    ///             </li>
    ///             <li>
    ///                <p>For <code>AntennaDownlinkconfig</code> valid values are between 10 kHz to 54 MHz.</p>
    ///             </li>
    ///             <li>
    ///                <p>For <code>AntennaUplinkConfig</code>, valid values are between 10 kHz to 54 MHz.</p>
    ///             </li>
    ///          </ul>
    public let bandwidth: FrequencyBandwidth?
    /// <p>Center frequency of a spectral <code>Config</code>. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.</p>
    public let centerFrequency: Frequency?
    /// <p>Polarization of a spectral <code>Config</code>. Capturing both <code>"RIGHT_HAND"</code> and <code>"LEFT_HAND"</code> polarization requires two separate configs.</p>
    public let polarization: Polarization?

    public init (
        bandwidth: FrequencyBandwidth? = nil,
        centerFrequency: Frequency? = nil,
        polarization: Polarization? = nil
    )
    {
        self.bandwidth = bandwidth
        self.centerFrequency = centerFrequency
        self.polarization = polarization
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// <p/>
public struct TagResourceInput: Equatable {
    /// <p>ARN of a resource tag.</p>
    public let resourceArn: String?
    /// <p>Tags assigned to a resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p/>
public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TrackingConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autotrack
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autotrack = autotrack {
            try encodeContainer.encode(autotrack.rawValue, forKey: .autotrack)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autotrackDecoded = try containerValues.decodeIfPresent(Criticality.self, forKey: .autotrack)
        autotrack = autotrackDecoded
    }
}

extension TrackingConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrackingConfig(autotrack: \(String(describing: autotrack)))"}
}

/// <p>Object that determines whether tracking should be used during a contact
///          executed with this <code>Config</code> in the mission profile.</p>
public struct TrackingConfig: Equatable {
    /// <p>Current setting for autotrack.</p>
    public let autotrack: Criticality?

    public init (
        autotrack: Criticality? = nil
    )
    {
        self.autotrack = autotrack
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

/// <p/>
public struct UntagResourceInput: Equatable {
    /// <p>ARN of a resource.</p>
    public let resourceArn: String?
    /// <p>Keys of a resource tag.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p/>
public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigInput>
    public typealias MOutput = OperationOutput<UpdateConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigOutputError>
}

extension UpdateConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigInput(configData: \(String(describing: configData)), configId: \(String(describing: configId)), configType: \(String(describing: configType)), name: \(String(describing: name)))"}
}

extension UpdateConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configData
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configData = configData {
            try encodeContainer.encode(configData, forKey: .configData)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigInput>
    public typealias MOutput = OperationOutput<UpdateConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigOutputError>
}

public struct UpdateConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigInput>
    public typealias MOutput = OperationOutput<UpdateConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigOutputError>
}

/// <p/>
public struct UpdateConfigInput: Equatable {
    /// <p>Parameters of a <code>Config</code>.</p>
    public let configData: ConfigTypeData?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: ConfigCapabilityType?
    /// <p>Name of a <code>Config</code>.</p>
    public let name: String?

    public init (
        configData: ConfigTypeData? = nil,
        configId: String? = nil,
        configType: ConfigCapabilityType? = nil,
        name: String? = nil
    )
    {
        self.configData = configData
        self.configId = configId
        self.configType = configType
        self.name = name
    }
}

struct UpdateConfigInputBody: Equatable {
    public let name: String?
    public let configData: ConfigTypeData?
}

extension UpdateConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configData
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
    }
}

extension UpdateConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigOutputResponse(configArn: \(String(describing: configArn)), configId: \(String(describing: configId)), configType: \(String(describing: configType)))"}
}

extension UpdateConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

/// <p/>
public struct UpdateConfigOutputResponse: Equatable {
    /// <p>ARN of a <code>Config</code>.</p>
    public let configArn: String?
    /// <p>UUID of a <code>Config</code>.</p>
    public let configId: String?
    /// <p>Type of a <code>Config</code>.</p>
    public let configType: ConfigCapabilityType?

    public init (
        configArn: String? = nil,
        configId: String? = nil,
        configType: ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct UpdateConfigOutputResponseBody: Equatable {
    public let configId: String?
    public let configType: ConfigCapabilityType?
    public let configArn: String?
}

extension UpdateConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configArn
        case configId
        case configType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

public struct UpdateMissionProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMissionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMissionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMissionProfileInput>
    public typealias MOutput = OperationOutput<UpdateMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMissionProfileOutputError>
}

extension UpdateMissionProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMissionProfileInput(contactPostPassDurationSeconds: \(String(describing: contactPostPassDurationSeconds)), contactPrePassDurationSeconds: \(String(describing: contactPrePassDurationSeconds)), dataflowEdges: \(String(describing: dataflowEdges)), minimumViableContactDurationSeconds: \(String(describing: minimumViableContactDurationSeconds)), missionProfileId: \(String(describing: missionProfileId)), name: \(String(describing: name)), trackingConfigArn: \(String(describing: trackingConfigArn)))"}
}

extension UpdateMissionProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case trackingConfigArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactPostPassDurationSeconds = contactPostPassDurationSeconds {
            try encodeContainer.encode(contactPostPassDurationSeconds, forKey: .contactPostPassDurationSeconds)
        }
        if let contactPrePassDurationSeconds = contactPrePassDurationSeconds {
            try encodeContainer.encode(contactPrePassDurationSeconds, forKey: .contactPrePassDurationSeconds)
        }
        if let dataflowEdges = dataflowEdges {
            var dataflowEdgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataflowEdges)
            for dataflowedgelist0 in dataflowEdges {
                var dataflowedgelist0Container = dataflowEdgesContainer.nestedUnkeyedContainer()
                for dataflowedge1 in dataflowedgelist0 {
                    try dataflowedgelist0Container.encode(dataflowedge1)
                }
            }
        }
        if let minimumViableContactDurationSeconds = minimumViableContactDurationSeconds {
            try encodeContainer.encode(minimumViableContactDurationSeconds, forKey: .minimumViableContactDurationSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let trackingConfigArn = trackingConfigArn {
            try encodeContainer.encode(trackingConfigArn, forKey: .trackingConfigArn)
        }
    }
}

public struct UpdateMissionProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMissionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMissionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMissionProfileInput>
    public typealias MOutput = OperationOutput<UpdateMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMissionProfileOutputError>
}

public struct UpdateMissionProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMissionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMissionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMissionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMissionProfileInput>
    public typealias MOutput = OperationOutput<UpdateMissionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMissionProfileOutputError>
}

/// <p/>
public struct UpdateMissionProfileInput: Equatable {
    /// <p>Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.</p>
    public let contactPostPassDurationSeconds: Int?
    /// <p>Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.</p>
    public let contactPrePassDurationSeconds: Int?
    /// <p>A list of lists of ARNs. Each list of ARNs is an edge, with a <i>from</i>
    ///             <code>Config</code> and a <i>to</i>
    ///             <code>Config</code>.</p>
    public let dataflowEdges: [[String]]?
    /// <p>Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.</p>
    public let minimumViableContactDurationSeconds: Int?
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: String?
    /// <p>Name of a mission profile.</p>
    public let name: String?
    /// <p>ARN of a tracking <code>Config</code>.</p>
    public let trackingConfigArn: String?

    public init (
        contactPostPassDurationSeconds: Int? = nil,
        contactPrePassDurationSeconds: Int? = nil,
        dataflowEdges: [[String]]? = nil,
        minimumViableContactDurationSeconds: Int? = nil,
        missionProfileId: String? = nil,
        name: String? = nil,
        trackingConfigArn: String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.missionProfileId = missionProfileId
        self.name = name
        self.trackingConfigArn = trackingConfigArn
    }
}

struct UpdateMissionProfileInputBody: Equatable {
    public let name: String?
    public let contactPrePassDurationSeconds: Int?
    public let contactPostPassDurationSeconds: Int?
    public let minimumViableContactDurationSeconds: Int?
    public let dataflowEdges: [[String]]?
    public let trackingConfigArn: String?
}

extension UpdateMissionProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case trackingConfigArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
    }
}

extension UpdateMissionProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMissionProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMissionProfileOutputError: Swift.Error, Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMissionProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMissionProfileOutputResponse(missionProfileId: \(String(describing: missionProfileId)))"}
}

extension UpdateMissionProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

/// <p/>
public struct UpdateMissionProfileOutputResponse: Equatable {
    /// <p>UUID of a mission profile.</p>
    public let missionProfileId: String?

    public init (
        missionProfileId: String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct UpdateMissionProfileOutputResponseBody: Equatable {
    public let missionProfileId: String?
}

extension UpdateMissionProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case missionProfileId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

extension UplinkEchoConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case antennaUplinkConfigArn
        case enabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let antennaUplinkConfigArn = antennaUplinkConfigArn {
            try encodeContainer.encode(antennaUplinkConfigArn, forKey: .antennaUplinkConfigArn)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let antennaUplinkConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .antennaUplinkConfigArn)
        antennaUplinkConfigArn = antennaUplinkConfigArnDecoded
    }
}

extension UplinkEchoConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UplinkEchoConfig(antennaUplinkConfigArn: \(String(describing: antennaUplinkConfigArn)), enabled: \(String(describing: enabled)))"}
}

/// <p>Information about an uplink echo <code>Config</code>.</p>
///          <p>Parameters from the <code>AntennaUplinkConfig</code>, corresponding to the
///          specified <code>AntennaUplinkConfigArn</code>, are used when this <code>UplinkEchoConfig</code>
///          is used in a contact.</p>
public struct UplinkEchoConfig: Equatable {
    /// <p>ARN of an uplink <code>Config</code>.</p>
    public let antennaUplinkConfigArn: String?
    /// <p>Whether or not an uplink <code>Config</code> is enabled.</p>
    public let enabled: Bool?

    public init (
        antennaUplinkConfigArn: String? = nil,
        enabled: Bool? = nil
    )
    {
        self.antennaUplinkConfigArn = antennaUplinkConfigArn
        self.enabled = enabled
    }
}

extension UplinkSpectrumConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case centerFrequency
        case polarization
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let centerFrequency = centerFrequency {
            try encodeContainer.encode(centerFrequency, forKey: .centerFrequency)
        }
        if let polarization = polarization {
            try encodeContainer.encode(polarization.rawValue, forKey: .polarization)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let centerFrequencyDecoded = try containerValues.decodeIfPresent(Frequency.self, forKey: .centerFrequency)
        centerFrequency = centerFrequencyDecoded
        let polarizationDecoded = try containerValues.decodeIfPresent(Polarization.self, forKey: .polarization)
        polarization = polarizationDecoded
    }
}

extension UplinkSpectrumConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UplinkSpectrumConfig(centerFrequency: \(String(describing: centerFrequency)), polarization: \(String(describing: polarization)))"}
}

/// <p>Information about the uplink spectral <code>Config</code>.</p>
public struct UplinkSpectrumConfig: Equatable {
    /// <p>Center frequency of an uplink spectral <code>Config</code>. Valid values are between 2025 to 2120 MHz.</p>
    public let centerFrequency: Frequency?
    /// <p>Polarization of an uplink spectral <code>Config</code>. Capturing both <code>"RIGHT_HAND"</code> and <code>"LEFT_HAND"</code> polarization requires two separate configs.</p>
    public let polarization: Polarization?

    public init (
        centerFrequency: Frequency? = nil,
        polarization: Polarization? = nil
    )
    {
        self.centerFrequency = centerFrequency
        self.polarization = polarization
    }
}
