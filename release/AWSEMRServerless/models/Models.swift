// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension EmrServerlessClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case arn
        case autoStartConfiguration
        case autoStopConfiguration
        case createdAt
        case initialCapacity
        case maximumCapacity
        case name
        case networkConfiguration
        case releaseLabel
        case state
        case stateDetails
        case tags
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let autoStartConfiguration = self.autoStartConfiguration {
            try encodeContainer.encode(autoStartConfiguration, forKey: .autoStartConfiguration)
        }
        if let autoStopConfiguration = self.autoStopConfiguration {
            try encodeContainer.encode(autoStopConfiguration, forKey: .autoStopConfiguration)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let initialCapacity = initialCapacity {
            var initialCapacityContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .initialCapacity)
            for (dictKey0, initialcapacityconfigmap0) in initialCapacity {
                try initialCapacityContainer.encode(initialcapacityconfigmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let maximumCapacity = self.maximumCapacity {
            try encodeContainer.encode(maximumCapacity, forKey: .maximumCapacity)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = self.stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.ApplicationState.self, forKey: .state)
        state = stateDecoded
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let initialCapacityContainer = try containerValues.decodeIfPresent([Swift.String: EmrServerlessClientTypes.InitialCapacityConfig?].self, forKey: .initialCapacity)
        var initialCapacityDecoded0: [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]? = nil
        if let initialCapacityContainer = initialCapacityContainer {
            initialCapacityDecoded0 = [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]()
            for (key0, initialcapacityconfig0) in initialCapacityContainer {
                if let initialcapacityconfig0 = initialcapacityconfig0 {
                    initialCapacityDecoded0?[key0] = initialcapacityconfig0
                }
            }
        }
        initialCapacity = initialCapacityDecoded0
        let maximumCapacityDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.MaximumAllowedResources.self, forKey: .maximumCapacity)
        maximumCapacity = maximumCapacityDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let autoStartConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.AutoStartConfig.self, forKey: .autoStartConfiguration)
        autoStartConfiguration = autoStartConfigurationDecoded
        let autoStopConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.AutoStopConfig.self, forKey: .autoStopConfiguration)
        autoStopConfiguration = autoStopConfigurationDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
    }
}

extension EmrServerlessClientTypes {
    /// Information about an application. EMR Serverless uses applications to run jobs.
    public struct Application: Swift.Equatable {
        /// The ID of the application.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The ARN of the application.
        /// This member is required.
        public var arn: Swift.String?
        /// The configuration for an application to automatically start on job submission.
        public var autoStartConfiguration: EmrServerlessClientTypes.AutoStartConfig?
        /// The configuration for an application to automatically stop after a certain amount of time being idle.
        public var autoStopConfiguration: EmrServerlessClientTypes.AutoStopConfig?
        /// The date and time when the application run was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The initial capacity of the application.
        public var initialCapacity: [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]?
        /// The maximum capacity of the application. This is cumulative across all workers at any given point in time during the lifespan of the application is created. No new resources will be created once any one of the defined limits is hit.
        public var maximumCapacity: EmrServerlessClientTypes.MaximumAllowedResources?
        /// The name of the application.
        public var name: Swift.String?
        /// The network configuration for customer VPC connectivity for the application.
        public var networkConfiguration: EmrServerlessClientTypes.NetworkConfiguration?
        /// The EMR release version associated with the application.
        /// This member is required.
        public var releaseLabel: Swift.String?
        /// The state of the application.
        /// This member is required.
        public var state: EmrServerlessClientTypes.ApplicationState?
        /// The state details of the application.
        public var stateDetails: Swift.String?
        /// The tags assigned to the application.
        public var tags: [Swift.String:Swift.String]?
        /// The type of application, such as Spark or Hive.
        /// This member is required.
        public var type: Swift.String?
        /// The date and time when the application run was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            autoStartConfiguration: EmrServerlessClientTypes.AutoStartConfig? = nil,
            autoStopConfiguration: EmrServerlessClientTypes.AutoStopConfig? = nil,
            createdAt: ClientRuntime.Date? = nil,
            initialCapacity: [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]? = nil,
            maximumCapacity: EmrServerlessClientTypes.MaximumAllowedResources? = nil,
            name: Swift.String? = nil,
            networkConfiguration: EmrServerlessClientTypes.NetworkConfiguration? = nil,
            releaseLabel: Swift.String? = nil,
            state: EmrServerlessClientTypes.ApplicationState? = nil,
            stateDetails: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.autoStartConfiguration = autoStartConfiguration
            self.autoStopConfiguration = autoStopConfiguration
            self.createdAt = createdAt
            self.initialCapacity = initialCapacity
            self.maximumCapacity = maximumCapacity
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.releaseLabel = releaseLabel
            self.state = state
            self.stateDetails = stateDetails
            self.tags = tags
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension EmrServerlessClientTypes {
    public enum ApplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case started
        case starting
        case stopped
        case stopping
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationState] {
            return [
                .created,
                .creating,
                .started,
                .starting,
                .stopped,
                .stopping,
                .terminated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .started: return "STARTED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationState(rawValue: rawValue) ?? ApplicationState.sdkUnknown(rawValue)
        }
    }
}

extension EmrServerlessClientTypes.ApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case name
        case releaseLabel
        case state
        case stateDetails
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = self.stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.ApplicationState.self, forKey: .state)
        state = stateDecoded
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension EmrServerlessClientTypes {
    /// The summary of attributes associated with an application.
    public struct ApplicationSummary: Swift.Equatable {
        /// The ARN of the application.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the application was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the application.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the application.
        public var name: Swift.String?
        /// The EMR release version associated with the application.
        /// This member is required.
        public var releaseLabel: Swift.String?
        /// The state of the application.
        /// This member is required.
        public var state: EmrServerlessClientTypes.ApplicationState?
        /// The state details of the application.
        public var stateDetails: Swift.String?
        /// The type of application, such as Spark or Hive.
        /// This member is required.
        public var type: Swift.String?
        /// The date and time when the application was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            releaseLabel: Swift.String? = nil,
            state: EmrServerlessClientTypes.ApplicationState? = nil,
            stateDetails: Swift.String? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.releaseLabel = releaseLabel
            self.state = state
            self.stateDetails = stateDetails
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension EmrServerlessClientTypes.AutoStartConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension EmrServerlessClientTypes {
    /// The configuration for an application to automatically start on job submission.
    public struct AutoStartConfig: Swift.Equatable {
        /// Enables the application to automatically start on job submission. Defaults to true.
        public var enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension EmrServerlessClientTypes.AutoStopConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case idleTimeoutMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let idleTimeoutMinutes = self.idleTimeoutMinutes {
            try encodeContainer.encode(idleTimeoutMinutes, forKey: .idleTimeoutMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let idleTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleTimeoutMinutes)
        idleTimeoutMinutes = idleTimeoutMinutesDecoded
    }
}

extension EmrServerlessClientTypes {
    /// The configuration for an application to automatically stop after a certain amount of time being idle.
    public struct AutoStopConfig: Swift.Equatable {
        /// Enables the application to automatically stop after a certain amount of time being idle. Defaults to true.
        public var enabled: Swift.Bool?
        /// The amount of idle time in minutes after which your application will automatically stop. Defaults to 15 minutes.
        public var idleTimeoutMinutes: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            idleTimeoutMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.idleTimeoutMinutes = idleTimeoutMinutes
        }
    }

}

extension CancelJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let jobRunId = jobRunId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/jobruns/\(jobRunId.urlPercentEncoding())"
    }
}

public struct CancelJobRunInput: Swift.Equatable {
    /// The ID of the application on which the job run will be canceled.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the job run to cancel.
    /// This member is required.
    public var jobRunId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        jobRunId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.jobRunId = jobRunId
    }
}

struct CancelJobRunInputBody: Swift.Equatable {
}

extension CancelJobRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelJobRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelJobRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.jobRunId = output.jobRunId
        } else {
            self.applicationId = nil
            self.jobRunId = nil
        }
    }
}

public struct CancelJobRunOutputResponse: Swift.Equatable {
    /// The output contains the application ID on which the job run is cancelled.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The output contains the ID of the cancelled job run.
    /// This member is required.
    public var jobRunId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        jobRunId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.jobRunId = jobRunId
    }
}

struct CancelJobRunOutputResponseBody: Swift.Equatable {
    let applicationId: Swift.String?
    let jobRunId: Swift.String?
}

extension CancelJobRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case jobRunId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let jobRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobRunId)
        jobRunId = jobRunIdDecoded
    }
}

extension EmrServerlessClientTypes.Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classification
        case configurations
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classification = self.classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurations)
            for configurationlist0 in configurations {
                try configurationsContainer.encode(configurationlist0)
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, sensitivepropertiesmap0) in properties {
                try propertiesContainer.encode(sensitivepropertiesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classificationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classification)
        classification = classificationDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string10240) in propertiesContainer {
                if let string10240 = string10240 {
                    propertiesDecoded0?[key0] = string10240
                }
            }
        }
        properties = propertiesDecoded0
        let configurationsContainer = try containerValues.decodeIfPresent([EmrServerlessClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[EmrServerlessClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [EmrServerlessClientTypes.Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

extension EmrServerlessClientTypes.Configuration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Configuration(classification: \(Swift.String(describing: classification)), configurations: \(Swift.String(describing: configurations)), properties: \"CONTENT_REDACTED\")"}
}

extension EmrServerlessClientTypes {
    /// A configuration specification to be used when provisioning an application. A configuration consists of a classification, properties, and optional nested configurations. A classification refers to an application-specific configuration file. Properties are the settings you want to change in that file.
    public struct Configuration: Swift.Equatable {
        /// The classification within a configuration.
        /// This member is required.
        public var classification: Swift.String?
        /// A list of additional configurations to apply within a configuration object.
        public var configurations: [EmrServerlessClientTypes.Configuration]?
        /// A set of properties specified within a configuration classification.
        public var properties: [Swift.String:Swift.String]?

        public init (
            classification: Swift.String? = nil,
            configurations: [EmrServerlessClientTypes.Configuration]? = nil,
            properties: [Swift.String:Swift.String]? = nil
        )
        {
            self.classification = classification
            self.configurations = configurations
            self.properties = properties
        }
    }

}

extension EmrServerlessClientTypes.ConfigurationOverrides: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfiguration
        case monitoringConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfiguration = applicationConfiguration {
            var applicationConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationConfiguration)
            for configurationlist0 in applicationConfiguration {
                try applicationConfigurationContainer.encode(configurationlist0)
            }
        }
        if let monitoringConfiguration = self.monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationContainer = try containerValues.decodeIfPresent([EmrServerlessClientTypes.Configuration?].self, forKey: .applicationConfiguration)
        var applicationConfigurationDecoded0:[EmrServerlessClientTypes.Configuration]? = nil
        if let applicationConfigurationContainer = applicationConfigurationContainer {
            applicationConfigurationDecoded0 = [EmrServerlessClientTypes.Configuration]()
            for structure0 in applicationConfigurationContainer {
                if let structure0 = structure0 {
                    applicationConfigurationDecoded0?.append(structure0)
                }
            }
        }
        applicationConfiguration = applicationConfigurationDecoded0
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.MonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
    }
}

extension EmrServerlessClientTypes {
    /// A configuration specification to be used to override existing configurations.
    public struct ConfigurationOverrides: Swift.Equatable {
        /// The override configurations for the application.
        public var applicationConfiguration: [EmrServerlessClientTypes.Configuration]?
        /// The override configurations for monitoring.
        public var monitoringConfiguration: EmrServerlessClientTypes.MonitoringConfiguration?

        public init (
            applicationConfiguration: [EmrServerlessClientTypes.Configuration]? = nil,
            monitoringConfiguration: EmrServerlessClientTypes.MonitoringConfiguration? = nil
        )
        {
            self.applicationConfiguration = applicationConfiguration
            self.monitoringConfiguration = monitoringConfiguration
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoStartConfiguration
        case autoStopConfiguration
        case clientToken
        case initialCapacity
        case maximumCapacity
        case name
        case networkConfiguration
        case releaseLabel
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoStartConfiguration = self.autoStartConfiguration {
            try encodeContainer.encode(autoStartConfiguration, forKey: .autoStartConfiguration)
        }
        if let autoStopConfiguration = self.autoStopConfiguration {
            try encodeContainer.encode(autoStopConfiguration, forKey: .autoStopConfiguration)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let initialCapacity = initialCapacity {
            var initialCapacityContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .initialCapacity)
            for (dictKey0, initialcapacityconfigmap0) in initialCapacity {
                try initialCapacityContainer.encode(initialcapacityconfigmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let maximumCapacity = self.maximumCapacity {
            try encodeContainer.encode(maximumCapacity, forKey: .maximumCapacity)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// The configuration for an application to automatically start on job submission.
    public var autoStartConfiguration: EmrServerlessClientTypes.AutoStartConfig?
    /// The configuration for an application to automatically stop after a certain amount of time being idle.
    public var autoStopConfiguration: EmrServerlessClientTypes.AutoStopConfig?
    /// The client idempotency token of the application to create. Its value must be unique for each request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The capacity to initialize when the application is created.
    public var initialCapacity: [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]?
    /// The maximum capacity to allocate when the application is created. This is cumulative across all workers at any given point in time, not just when an application is created. No new resources will be created once any one of the defined limits is hit.
    public var maximumCapacity: EmrServerlessClientTypes.MaximumAllowedResources?
    /// The name of the application.
    public var name: Swift.String?
    /// The network configuration for customer VPC connectivity.
    public var networkConfiguration: EmrServerlessClientTypes.NetworkConfiguration?
    /// The EMR release version associated with the application.
    /// This member is required.
    public var releaseLabel: Swift.String?
    /// The tags assigned to the application.
    public var tags: [Swift.String:Swift.String]?
    /// The type of application you want to start, such as Spark or Hive.
    /// This member is required.
    public var type: Swift.String?

    public init (
        autoStartConfiguration: EmrServerlessClientTypes.AutoStartConfig? = nil,
        autoStopConfiguration: EmrServerlessClientTypes.AutoStopConfig? = nil,
        clientToken: Swift.String? = nil,
        initialCapacity: [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]? = nil,
        maximumCapacity: EmrServerlessClientTypes.MaximumAllowedResources? = nil,
        name: Swift.String? = nil,
        networkConfiguration: EmrServerlessClientTypes.NetworkConfiguration? = nil,
        releaseLabel: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil
    )
    {
        self.autoStartConfiguration = autoStartConfiguration
        self.autoStopConfiguration = autoStopConfiguration
        self.clientToken = clientToken
        self.initialCapacity = initialCapacity
        self.maximumCapacity = maximumCapacity
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.releaseLabel = releaseLabel
        self.tags = tags
        self.type = type
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let releaseLabel: Swift.String?
    let type: Swift.String?
    let clientToken: Swift.String?
    let initialCapacity: [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]?
    let maximumCapacity: EmrServerlessClientTypes.MaximumAllowedResources?
    let tags: [Swift.String:Swift.String]?
    let autoStartConfiguration: EmrServerlessClientTypes.AutoStartConfig?
    let autoStopConfiguration: EmrServerlessClientTypes.AutoStopConfig?
    let networkConfiguration: EmrServerlessClientTypes.NetworkConfiguration?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoStartConfiguration
        case autoStopConfiguration
        case clientToken
        case initialCapacity
        case maximumCapacity
        case name
        case networkConfiguration
        case releaseLabel
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let initialCapacityContainer = try containerValues.decodeIfPresent([Swift.String: EmrServerlessClientTypes.InitialCapacityConfig?].self, forKey: .initialCapacity)
        var initialCapacityDecoded0: [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]? = nil
        if let initialCapacityContainer = initialCapacityContainer {
            initialCapacityDecoded0 = [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]()
            for (key0, initialcapacityconfig0) in initialCapacityContainer {
                if let initialcapacityconfig0 = initialcapacityconfig0 {
                    initialCapacityDecoded0?[key0] = initialcapacityconfig0
                }
            }
        }
        initialCapacity = initialCapacityDecoded0
        let maximumCapacityDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.MaximumAllowedResources.self, forKey: .maximumCapacity)
        maximumCapacity = maximumCapacityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let autoStartConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.AutoStartConfig.self, forKey: .autoStartConfiguration)
        autoStartConfiguration = autoStartConfigurationDecoded
        let autoStopConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.AutoStopConfig.self, forKey: .autoStopConfiguration)
        autoStopConfiguration = autoStopConfigurationDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
    }
}

extension CreateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.name = output.name
        } else {
            self.applicationId = nil
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Swift.Equatable {
    /// The output contains the application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The output contains the ARN of the application.
    /// This member is required.
    public var arn: Swift.String?
    /// The output contains the name of the application.
    public var name: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.name = name
    }
}

struct CreateApplicationOutputResponseBody: Swift.Equatable {
    let applicationId: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The ID of the application that will be deleted.
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension GetApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    /// The ID of the application that will be described.
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct GetApplicationOutputResponse: Swift.Equatable {
    /// The output displays information about the specified application.
    /// This member is required.
    public var application: EmrServerlessClientTypes.Application?

    public init (
        application: EmrServerlessClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

struct GetApplicationOutputResponseBody: Swift.Equatable {
    let application: EmrServerlessClientTypes.Application?
}

extension GetApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
    }
}

extension GetJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let jobRunId = jobRunId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/jobruns/\(jobRunId.urlPercentEncoding())"
    }
}

public struct GetJobRunInput: Swift.Equatable {
    /// The ID of the application on which the job run is submitted.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the job run.
    /// This member is required.
    public var jobRunId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        jobRunId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.jobRunId = jobRunId
    }
}

struct GetJobRunInputBody: Swift.Equatable {
}

extension GetJobRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetJobRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetJobRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobRun = output.jobRun
        } else {
            self.jobRun = nil
        }
    }
}

public struct GetJobRunOutputResponse: Swift.Equatable {
    /// The output displays information about the job run.
    /// This member is required.
    public var jobRun: EmrServerlessClientTypes.JobRun?

    public init (
        jobRun: EmrServerlessClientTypes.JobRun? = nil
    )
    {
        self.jobRun = jobRun
    }
}

struct GetJobRunOutputResponseBody: Swift.Equatable {
    let jobRun: EmrServerlessClientTypes.JobRun?
}

extension GetJobRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobRun
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.JobRun.self, forKey: .jobRun)
        jobRun = jobRunDecoded
    }
}

extension EmrServerlessClientTypes.Hive: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initQueryFile
        case parameters
        case query
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initQueryFile = self.initQueryFile {
            try encodeContainer.encode(initQueryFile, forKey: .initQueryFile)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let query = self.query {
            try encodeContainer.encode(query, forKey: .query)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .query)
        query = queryDecoded
        let initQueryFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initQueryFile)
        initQueryFile = initQueryFileDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension EmrServerlessClientTypes.Hive: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Hive(initQueryFile: \"CONTENT_REDACTED\", parameters: \"CONTENT_REDACTED\", query: \"CONTENT_REDACTED\")"}
}

extension EmrServerlessClientTypes {
    /// The configurations for the Hive job driver.
    public struct Hive: Swift.Equatable {
        /// The query file for the Hive job run.
        public var initQueryFile: Swift.String?
        /// The parameters for the Hive job run.
        public var parameters: Swift.String?
        /// The query for the Hive job run.
        /// This member is required.
        public var query: Swift.String?

        public init (
            initQueryFile: Swift.String? = nil,
            parameters: Swift.String? = nil,
            query: Swift.String? = nil
        )
        {
            self.initQueryFile = initQueryFile
            self.parameters = parameters
            self.query = query
        }
    }

}

extension EmrServerlessClientTypes.InitialCapacityConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workerConfiguration
        case workerCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workerConfiguration = self.workerConfiguration {
            try encodeContainer.encode(workerConfiguration, forKey: .workerConfiguration)
        }
        if workerCount != 0 {
            try encodeContainer.encode(workerCount, forKey: .workerCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workerCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .workerCount)
        workerCount = workerCountDecoded
        let workerConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.WorkerResourceConfig.self, forKey: .workerConfiguration)
        workerConfiguration = workerConfigurationDecoded
    }
}

extension EmrServerlessClientTypes {
    /// The initial capacity configuration per worker.
    public struct InitialCapacityConfig: Swift.Equatable {
        /// The resource configuration of the initial capacity configuration.
        public var workerConfiguration: EmrServerlessClientTypes.WorkerResourceConfig?
        /// The number of workers in the initial capacity configuration.
        /// This member is required.
        public var workerCount: Swift.Int

        public init (
            workerConfiguration: EmrServerlessClientTypes.WorkerResourceConfig? = nil,
            workerCount: Swift.Int = 0
        )
        {
            self.workerConfiguration = workerConfiguration
            self.workerCount = workerCount
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request processing failed because of an error or failure with the service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EmrServerlessClientTypes.JobDriver: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hive
        case sdkUnknown
        case sparksubmit = "sparkSubmit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .hive(hive):
                try container.encode(hive, forKey: .hive)
            case let .sparksubmit(sparksubmit):
                try container.encode(sparksubmit, forKey: .sparksubmit)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let sparksubmitDecoded = try values.decodeIfPresent(EmrServerlessClientTypes.SparkSubmit.self, forKey: .sparksubmit)
        if let sparksubmit = sparksubmitDecoded {
            self = .sparksubmit(sparksubmit)
            return
        }
        let hiveDecoded = try values.decodeIfPresent(EmrServerlessClientTypes.Hive.self, forKey: .hive)
        if let hive = hiveDecoded {
            self = .hive(hive)
            return
        }
        self = .sdkUnknown("")
    }
}

extension EmrServerlessClientTypes {
    /// The driver that the job runs on.
    public enum JobDriver: Swift.Equatable {
        /// The job driver parameters specified for Spark.
        case sparksubmit(EmrServerlessClientTypes.SparkSubmit)
        /// The job driver parameters specified for Hive.
        case hive(EmrServerlessClientTypes.Hive)
        case sdkUnknown(Swift.String)
    }

}

extension EmrServerlessClientTypes.JobRun: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case arn
        case configurationOverrides
        case createdAt
        case createdBy
        case executionRole
        case jobDriver
        case jobRunId
        case name
        case networkConfiguration
        case releaseLabel
        case state
        case stateDetails
        case tags
        case totalExecutionDurationSeconds
        case totalResourceUtilization
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let jobDriver = self.jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let jobRunId = self.jobRunId {
            try encodeContainer.encode(jobRunId, forKey: .jobRunId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = self.stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let totalExecutionDurationSeconds = self.totalExecutionDurationSeconds {
            try encodeContainer.encode(totalExecutionDurationSeconds, forKey: .totalExecutionDurationSeconds)
        }
        if let totalResourceUtilization = self.totalResourceUtilization {
            try encodeContainer.encode(totalResourceUtilization, forKey: .totalResourceUtilization)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let jobRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobRunId)
        jobRunId = jobRunIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.JobRunState.self, forKey: .state)
        state = stateDecoded
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let totalResourceUtilizationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.TotalResourceUtilization.self, forKey: .totalResourceUtilization)
        totalResourceUtilization = totalResourceUtilizationDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let totalExecutionDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalExecutionDurationSeconds)
        totalExecutionDurationSeconds = totalExecutionDurationSecondsDecoded
    }
}

extension EmrServerlessClientTypes {
    /// Information about a job run. A job run is a unit of work, such as a Spark JAR, Hive query, or SparkSQL query, that you submit to an EMR Serverless application.
    public struct JobRun: Swift.Equatable {
        /// The ID of the application the job is running on.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The execution role ARN of the job run.
        /// This member is required.
        public var arn: Swift.String?
        /// The configuration settings that are used to override default configuration.
        public var configurationOverrides: EmrServerlessClientTypes.ConfigurationOverrides?
        /// The date and time when the job run was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user who created the job run.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The execution role ARN of the job run.
        /// This member is required.
        public var executionRole: Swift.String?
        /// The job driver for the job run.
        /// This member is required.
        public var jobDriver: EmrServerlessClientTypes.JobDriver?
        /// The ID of the job run.
        /// This member is required.
        public var jobRunId: Swift.String?
        /// The optional job run name. This doesn't have to be unique.
        public var name: Swift.String?
        /// The network configuration for customer VPC connectivity.
        public var networkConfiguration: EmrServerlessClientTypes.NetworkConfiguration?
        /// The EMR release version associated with the application your job is running on.
        /// This member is required.
        public var releaseLabel: Swift.String?
        /// The state of the job run.
        /// This member is required.
        public var state: EmrServerlessClientTypes.JobRunState?
        /// The state details of the job run.
        /// This member is required.
        public var stateDetails: Swift.String?
        /// The tags assigned to the job run.
        public var tags: [Swift.String:Swift.String]?
        /// The job run total execution duration in seconds. This field is only available for job runs in a COMPLETED, FAILED, or CANCELLED state.
        public var totalExecutionDurationSeconds: Swift.Int?
        /// The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.
        public var totalResourceUtilization: EmrServerlessClientTypes.TotalResourceUtilization?
        /// The date and time when the job run was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            configurationOverrides: EmrServerlessClientTypes.ConfigurationOverrides? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            jobDriver: EmrServerlessClientTypes.JobDriver? = nil,
            jobRunId: Swift.String? = nil,
            name: Swift.String? = nil,
            networkConfiguration: EmrServerlessClientTypes.NetworkConfiguration? = nil,
            releaseLabel: Swift.String? = nil,
            state: EmrServerlessClientTypes.JobRunState? = nil,
            stateDetails: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            totalExecutionDurationSeconds: Swift.Int? = nil,
            totalResourceUtilization: EmrServerlessClientTypes.TotalResourceUtilization? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.configurationOverrides = configurationOverrides
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.executionRole = executionRole
            self.jobDriver = jobDriver
            self.jobRunId = jobRunId
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.releaseLabel = releaseLabel
            self.state = state
            self.stateDetails = stateDetails
            self.tags = tags
            self.totalExecutionDurationSeconds = totalExecutionDurationSeconds
            self.totalResourceUtilization = totalResourceUtilization
            self.updatedAt = updatedAt
        }
    }

}

extension EmrServerlessClientTypes {
    public enum JobRunState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case pending
        case running
        case scheduled
        case submitted
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [JobRunState] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .pending,
                .running,
                .scheduled,
                .submitted,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .scheduled: return "SCHEDULED"
            case .submitted: return "SUBMITTED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobRunState(rawValue: rawValue) ?? JobRunState.sdkUnknown(rawValue)
        }
    }
}

extension EmrServerlessClientTypes.JobRunSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case arn
        case createdAt
        case createdBy
        case executionRole
        case id
        case name
        case releaseLabel
        case state
        case stateDetails
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = self.stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.JobRunState.self, forKey: .state)
        state = stateDecoded
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension EmrServerlessClientTypes {
    /// The summary of attributes associated with a job run.
    public struct JobRunSummary: Swift.Equatable {
        /// The ID of the application the job is running on.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The ARN of the job run.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the job run was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user who created the job run.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The execution role ARN of the job run.
        /// This member is required.
        public var executionRole: Swift.String?
        /// The ID of the job run.
        /// This member is required.
        public var id: Swift.String?
        /// The optional job run name. This doesn't have to be unique.
        public var name: Swift.String?
        /// The EMR release version associated with the application your job is running on.
        /// This member is required.
        public var releaseLabel: Swift.String?
        /// The state of the job run.
        /// This member is required.
        public var state: EmrServerlessClientTypes.JobRunState?
        /// The state details of the job run.
        /// This member is required.
        public var stateDetails: Swift.String?
        /// The type of job run, such as Spark or Hive.
        public var type: Swift.String?
        /// The date and time when the job run was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            applicationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            releaseLabel: Swift.String? = nil,
            state: EmrServerlessClientTypes.JobRunState? = nil,
            stateDetails: Swift.String? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.executionRole = executionRole
            self.id = id
            self.name = name
            self.releaseLabel = releaseLabel
            self.state = state
            self.stateDetails = stateDetails
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension ListApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let states = states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The maximum number of applications that can be listed.
    public var maxResults: Swift.Int?
    /// The token for the next set of application results.
    public var nextToken: Swift.String?
    /// An optional filter for application states. Note that if this filter contains multiple states, the resulting list will be grouped by the state.
    public var states: Swift.Set<EmrServerlessClientTypes.ApplicationState>?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: Swift.Set<EmrServerlessClientTypes.ApplicationState>? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Swift.Equatable {
    /// The output lists the specified applications.
    /// This member is required.
    public var applications: [EmrServerlessClientTypes.ApplicationSummary]?
    /// The output displays the token for the next set of application results. This is required for pagination and is available as a response of the previous request.
    public var nextToken: Swift.String?

    public init (
        applications: [EmrServerlessClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Swift.Equatable {
    let applications: [EmrServerlessClientTypes.ApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([EmrServerlessClientTypes.ApplicationSummary?].self, forKey: .applications)
        var applicationsDecoded0:[EmrServerlessClientTypes.ApplicationSummary]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [EmrServerlessClientTypes.ApplicationSummary]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobRunsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let createdAtAfter = createdAtAfter {
            let createdAtAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAtAfter".urlPercentEncoding(), value: Swift.String(createdAtAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(createdAtAfterQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let createdAtBefore = createdAtBefore {
            let createdAtBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdAtBefore".urlPercentEncoding(), value: Swift.String(createdAtBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(createdAtBeforeQueryItem)
        }
        if let states = states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListJobRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/jobruns"
    }
}

public struct ListJobRunsInput: Swift.Equatable {
    /// The ID of the application for which to list the job run.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The lower bound of the option to filter by creation date and time.
    public var createdAtAfter: ClientRuntime.Date?
    /// The upper bound of the option to filter by creation date and time.
    public var createdAtBefore: ClientRuntime.Date?
    /// The maximum number of job runs that can be listed.
    public var maxResults: Swift.Int?
    /// The token for the next set of job run results.
    public var nextToken: Swift.String?
    /// An optional filter for job run states. Note that if this filter contains multiple states, the resulting list will be grouped by the state.
    public var states: Swift.Set<EmrServerlessClientTypes.JobRunState>?

    public init (
        applicationId: Swift.String? = nil,
        createdAtAfter: ClientRuntime.Date? = nil,
        createdAtBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: Swift.Set<EmrServerlessClientTypes.JobRunState>? = nil
    )
    {
        self.applicationId = applicationId
        self.createdAtAfter = createdAtAfter
        self.createdAtBefore = createdAtBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
    }
}

struct ListJobRunsInputBody: Swift.Equatable {
}

extension ListJobRunsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListJobRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobRunsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListJobRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobRuns = output.jobRuns
            self.nextToken = output.nextToken
        } else {
            self.jobRuns = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobRunsOutputResponse: Swift.Equatable {
    /// The output lists information about the specified job runs.
    /// This member is required.
    public var jobRuns: [EmrServerlessClientTypes.JobRunSummary]?
    /// The output displays the token for the next set of job run results. This is required for pagination and is available as a response of the previous request.
    public var nextToken: Swift.String?

    public init (
        jobRuns: [EmrServerlessClientTypes.JobRunSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobRuns = jobRuns
        self.nextToken = nextToken
    }
}

struct ListJobRunsOutputResponseBody: Swift.Equatable {
    let jobRuns: [EmrServerlessClientTypes.JobRunSummary]?
    let nextToken: Swift.String?
}

extension ListJobRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobRuns
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunsContainer = try containerValues.decodeIfPresent([EmrServerlessClientTypes.JobRunSummary?].self, forKey: .jobRuns)
        var jobRunsDecoded0:[EmrServerlessClientTypes.JobRunSummary]? = nil
        if let jobRunsContainer = jobRunsContainer {
            jobRunsDecoded0 = [EmrServerlessClientTypes.JobRunSummary]()
            for structure0 in jobRunsContainer {
                if let structure0 = structure0 {
                    jobRunsDecoded0?.append(structure0)
                }
            }
        }
        jobRuns = jobRunsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for. Currently, the supported resources are Amazon EMR Serverless applications and job runs.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EmrServerlessClientTypes.ManagedPersistenceMonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case encryptionKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
    }
}

extension EmrServerlessClientTypes {
    /// The managed log persistence configuration for a job run.
    public struct ManagedPersistenceMonitoringConfiguration: Swift.Equatable {
        /// Enables managed logging and defaults to true. If set to false, managed logging will be turned off.
        public var enabled: Swift.Bool?
        /// The KMS key ARN to encrypt the logs stored in managed log persistence.
        public var encryptionKeyArn: Swift.String?

        public init (
            enabled: Swift.Bool? = nil,
            encryptionKeyArn: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.encryptionKeyArn = encryptionKeyArn
        }
    }

}

extension EmrServerlessClientTypes.MaximumAllowedResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpu
        case disk
        case memory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpu = self.cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let disk = self.disk {
            try encodeContainer.encode(disk, forKey: .disk)
        }
        if let memory = self.memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpu)
        cpu = cpuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memory)
        memory = memoryDecoded
        let diskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disk)
        disk = diskDecoded
    }
}

extension EmrServerlessClientTypes {
    /// The maximum allowed cumulative resources for an application. No new resources will be created once the limit is hit.
    public struct MaximumAllowedResources: Swift.Equatable {
        /// The maximum allowed CPU for an application.
        /// This member is required.
        public var cpu: Swift.String?
        /// The maximum allowed disk for an application.
        public var disk: Swift.String?
        /// The maximum allowed resources for an application.
        /// This member is required.
        public var memory: Swift.String?

        public init (
            cpu: Swift.String? = nil,
            disk: Swift.String? = nil,
            memory: Swift.String? = nil
        )
        {
            self.cpu = cpu
            self.disk = disk
            self.memory = memory
        }
    }

}

extension EmrServerlessClientTypes.MonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managedPersistenceMonitoringConfiguration
        case s3MonitoringConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let managedPersistenceMonitoringConfiguration = self.managedPersistenceMonitoringConfiguration {
            try encodeContainer.encode(managedPersistenceMonitoringConfiguration, forKey: .managedPersistenceMonitoringConfiguration)
        }
        if let s3MonitoringConfiguration = self.s3MonitoringConfiguration {
            try encodeContainer.encode(s3MonitoringConfiguration, forKey: .s3MonitoringConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3MonitoringConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.S3MonitoringConfiguration.self, forKey: .s3MonitoringConfiguration)
        s3MonitoringConfiguration = s3MonitoringConfigurationDecoded
        let managedPersistenceMonitoringConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.ManagedPersistenceMonitoringConfiguration.self, forKey: .managedPersistenceMonitoringConfiguration)
        managedPersistenceMonitoringConfiguration = managedPersistenceMonitoringConfigurationDecoded
    }
}

extension EmrServerlessClientTypes {
    /// The configuration setting for monitoring.
    public struct MonitoringConfiguration: Swift.Equatable {
        /// The managed log persistence configuration for a job run.
        public var managedPersistenceMonitoringConfiguration: EmrServerlessClientTypes.ManagedPersistenceMonitoringConfiguration?
        /// The Amazon S3 configuration for monitoring log publishing.
        public var s3MonitoringConfiguration: EmrServerlessClientTypes.S3MonitoringConfiguration?

        public init (
            managedPersistenceMonitoringConfiguration: EmrServerlessClientTypes.ManagedPersistenceMonitoringConfiguration? = nil,
            s3MonitoringConfiguration: EmrServerlessClientTypes.S3MonitoringConfiguration? = nil
        )
        {
            self.managedPersistenceMonitoringConfiguration = managedPersistenceMonitoringConfiguration
            self.s3MonitoringConfiguration = s3MonitoringConfiguration
        }
    }

}

extension EmrServerlessClientTypes.NetworkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
        case subnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension EmrServerlessClientTypes {
    /// The network configuration for customer VPC connectivity.
    public struct NetworkConfiguration: Swift.Equatable {
        /// The array of security group Ids for customer VPC connectivity.
        public var securityGroupIds: [Swift.String]?
        /// The array of subnet Ids for customer VPC connectivity.
        public var subnetIds: [Swift.String]?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EmrServerlessClientTypes.S3MonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKeyArn
        case logUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let logUri = self.logUri {
            try encodeContainer.encode(logUri, forKey: .logUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUri)
        logUri = logUriDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
    }
}

extension EmrServerlessClientTypes {
    /// The Amazon S3 configuration for monitoring log publishing. You can configure your jobs to send log information to Amazon S3.
    public struct S3MonitoringConfiguration: Swift.Equatable {
        /// The KMS key ARN to encrypt the logs published to the given Amazon S3 destination.
        public var encryptionKeyArn: Swift.String?
        /// The Amazon S3 destination URI for log publishing.
        public var logUri: Swift.String?

        public init (
            encryptionKeyArn: Swift.String? = nil,
            logUri: Swift.String? = nil
        )
        {
            self.encryptionKeyArn = encryptionKeyArn
            self.logUri = logUri
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of resources per account has been reached.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EmrServerlessClientTypes.SparkSubmit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryPoint
        case entryPointArguments
        case sparkSubmitParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryPoint = self.entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let entryPointArguments = entryPointArguments {
            var entryPointArgumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entryPointArguments)
            for entrypointarguments0 in entryPointArguments {
                try entryPointArgumentsContainer.encode(entrypointarguments0)
            }
        }
        if let sparkSubmitParameters = self.sparkSubmitParameters {
            try encodeContainer.encode(sparkSubmitParameters, forKey: .sparkSubmitParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let entryPointArgumentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entryPointArguments)
        var entryPointArgumentsDecoded0:[Swift.String]? = nil
        if let entryPointArgumentsContainer = entryPointArgumentsContainer {
            entryPointArgumentsDecoded0 = [Swift.String]()
            for string0 in entryPointArgumentsContainer {
                if let string0 = string0 {
                    entryPointArgumentsDecoded0?.append(string0)
                }
            }
        }
        entryPointArguments = entryPointArgumentsDecoded0
        let sparkSubmitParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sparkSubmitParameters)
        sparkSubmitParameters = sparkSubmitParametersDecoded
    }
}

extension EmrServerlessClientTypes.SparkSubmit: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SparkSubmit(entryPointArguments: \(Swift.String(describing: entryPointArguments)), entryPoint: \"CONTENT_REDACTED\", sparkSubmitParameters: \"CONTENT_REDACTED\")"}
}

extension EmrServerlessClientTypes {
    /// The configurations for the Spark submit job driver.
    public struct SparkSubmit: Swift.Equatable {
        /// The entry point for the Spark submit job run.
        /// This member is required.
        public var entryPoint: Swift.String?
        /// The arguments for the Spark submit job run.
        public var entryPointArguments: [Swift.String]?
        /// The parameters for the Spark submit job run.
        public var sparkSubmitParameters: Swift.String?

        public init (
            entryPoint: Swift.String? = nil,
            entryPointArguments: [Swift.String]? = nil,
            sparkSubmitParameters: Swift.String? = nil
        )
        {
            self.entryPoint = entryPoint
            self.entryPointArguments = entryPointArguments
            self.sparkSubmitParameters = sparkSubmitParameters
        }
    }

}

extension StartApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/start"
    }
}

public struct StartApplicationInput: Swift.Equatable {
    /// The ID of the application to start.
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct StartApplicationInputBody: Swift.Equatable {
}

extension StartApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension StartJobRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case executionTimeoutMinutes
        case jobDriver
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if executionTimeoutMinutes != 0 {
            try encodeContainer.encode(executionTimeoutMinutes, forKey: .executionTimeoutMinutes)
        }
        if let jobDriver = self.jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/jobruns"
    }
}

public struct StartJobRunInput: Swift.Equatable {
    /// The ID of the application on which to run the job.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The client idempotency token of the job run to start. Its value must be unique for each request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The configuration overrides for the job run.
    public var configurationOverrides: EmrServerlessClientTypes.ConfigurationOverrides?
    /// The execution role ARN for the job run.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The maximum duration for the job run to run. If the job run runs beyond this duration, it will be automatically cancelled.
    public var executionTimeoutMinutes: Swift.Int
    /// The job driver for the job run.
    public var jobDriver: EmrServerlessClientTypes.JobDriver?
    /// The optional job run name. This doesn't have to be unique.
    public var name: Swift.String?
    /// The tags assigned to the job run.
    public var tags: [Swift.String:Swift.String]?

    public init (
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configurationOverrides: EmrServerlessClientTypes.ConfigurationOverrides? = nil,
        executionRoleArn: Swift.String? = nil,
        executionTimeoutMinutes: Swift.Int = 0,
        jobDriver: EmrServerlessClientTypes.JobDriver? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.configurationOverrides = configurationOverrides
        self.executionRoleArn = executionRoleArn
        self.executionTimeoutMinutes = executionTimeoutMinutes
        self.jobDriver = jobDriver
        self.name = name
        self.tags = tags
    }
}

struct StartJobRunInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let executionRoleArn: Swift.String?
    let jobDriver: EmrServerlessClientTypes.JobDriver?
    let configurationOverrides: EmrServerlessClientTypes.ConfigurationOverrides?
    let tags: [Swift.String:Swift.String]?
    let executionTimeoutMinutes: Swift.Int
    let name: Swift.String?
}

extension StartJobRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case executionTimeoutMinutes
        case jobDriver
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let executionTimeoutMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .executionTimeoutMinutes)
        executionTimeoutMinutes = executionTimeoutMinutesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartJobRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartJobRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartJobRunOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartJobRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartJobRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.arn = output.arn
            self.jobRunId = output.jobRunId
        } else {
            self.applicationId = nil
            self.arn = nil
            self.jobRunId = nil
        }
    }
}

public struct StartJobRunOutputResponse: Swift.Equatable {
    /// This output displays the application ID on which the job run was submitted.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The output lists the execution role ARN of the job run.
    /// This member is required.
    public var arn: Swift.String?
    /// The output contains the ID of the started job run.
    /// This member is required.
    public var jobRunId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        jobRunId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.jobRunId = jobRunId
    }
}

struct StartJobRunOutputResponseBody: Swift.Equatable {
    let applicationId: Swift.String?
    let jobRunId: Swift.String?
    let arn: Swift.String?
}

extension StartJobRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId
        case arn
        case jobRunId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let jobRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobRunId)
        jobRunId = jobRunIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StopApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/stop"
    }
}

public struct StopApplicationInput: Swift.Equatable {
    /// The ID of the application to stop.
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct StopApplicationInputBody: Swift.Equatable {
}

extension StopApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for. Currently, the supported resources are Amazon EMR Serverless applications and job runs.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension EmrServerlessClientTypes.TotalResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memoryGBHour
        case storageGBHour
        case vCPUHour
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memoryGBHour = self.memoryGBHour {
            try encodeContainer.encode(memoryGBHour, forKey: .memoryGBHour)
        }
        if let storageGBHour = self.storageGBHour {
            try encodeContainer.encode(storageGBHour, forKey: .storageGBHour)
        }
        if let vCPUHour = self.vCPUHour {
            try encodeContainer.encode(vCPUHour, forKey: .vCPUHour)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vCPUHourDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .vCPUHour)
        vCPUHour = vCPUHourDecoded
        let memoryGBHourDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .memoryGBHour)
        memoryGBHour = memoryGBHourDecoded
        let storageGBHourDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .storageGBHour)
        storageGBHour = storageGBHourDecoded
    }
}

extension EmrServerlessClientTypes {
    /// The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.
    public struct TotalResourceUtilization: Swift.Equatable {
        /// The aggregated memory used per hour from the time job start executing till the time job is terminated.
        public var memoryGBHour: Swift.Double?
        /// The aggregated storage used per hour from the time job start executing till the time job is terminated.
        public var storageGBHour: Swift.Double?
        /// The aggregated vCPU used per hour from the time job start executing till the time job is terminated.
        public var vCPUHour: Swift.Double?

        public init (
            memoryGBHour: Swift.Double? = nil,
            storageGBHour: Swift.Double? = nil,
            vCPUHour: Swift.Double? = nil
        )
        {
            self.memoryGBHour = memoryGBHour
            self.storageGBHour = storageGBHour
            self.vCPUHour = vCPUHour
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for. Currently, the supported resources are Amazon EMR Serverless applications and job runs.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoStartConfiguration
        case autoStopConfiguration
        case clientToken
        case initialCapacity
        case maximumCapacity
        case networkConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoStartConfiguration = self.autoStartConfiguration {
            try encodeContainer.encode(autoStartConfiguration, forKey: .autoStartConfiguration)
        }
        if let autoStopConfiguration = self.autoStopConfiguration {
            try encodeContainer.encode(autoStopConfiguration, forKey: .autoStopConfiguration)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let initialCapacity = initialCapacity {
            var initialCapacityContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .initialCapacity)
            for (dictKey0, initialcapacityconfigmap0) in initialCapacity {
                try initialCapacityContainer.encode(initialcapacityconfigmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let maximumCapacity = self.maximumCapacity {
            try encodeContainer.encode(maximumCapacity, forKey: .maximumCapacity)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The ID of the application to update.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration for an application to automatically start on job submission.
    public var autoStartConfiguration: EmrServerlessClientTypes.AutoStartConfig?
    /// The configuration for an application to automatically stop after a certain amount of time being idle.
    public var autoStopConfiguration: EmrServerlessClientTypes.AutoStopConfig?
    /// The client idempotency token of the application to update. Its value must be unique for each request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The capacity to initialize when the application is updated.
    public var initialCapacity: [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]?
    /// The maximum capacity to allocate when the application is updated. This is cumulative across all workers at any given point in time during the lifespan of the application. No new resources will be created once any one of the defined limits is hit.
    public var maximumCapacity: EmrServerlessClientTypes.MaximumAllowedResources?
    /// The network configuration for customer VPC connectivity.
    public var networkConfiguration: EmrServerlessClientTypes.NetworkConfiguration?

    public init (
        applicationId: Swift.String? = nil,
        autoStartConfiguration: EmrServerlessClientTypes.AutoStartConfig? = nil,
        autoStopConfiguration: EmrServerlessClientTypes.AutoStopConfig? = nil,
        clientToken: Swift.String? = nil,
        initialCapacity: [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]? = nil,
        maximumCapacity: EmrServerlessClientTypes.MaximumAllowedResources? = nil,
        networkConfiguration: EmrServerlessClientTypes.NetworkConfiguration? = nil
    )
    {
        self.applicationId = applicationId
        self.autoStartConfiguration = autoStartConfiguration
        self.autoStopConfiguration = autoStopConfiguration
        self.clientToken = clientToken
        self.initialCapacity = initialCapacity
        self.maximumCapacity = maximumCapacity
        self.networkConfiguration = networkConfiguration
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let initialCapacity: [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]?
    let maximumCapacity: EmrServerlessClientTypes.MaximumAllowedResources?
    let autoStartConfiguration: EmrServerlessClientTypes.AutoStartConfig?
    let autoStopConfiguration: EmrServerlessClientTypes.AutoStopConfig?
    let networkConfiguration: EmrServerlessClientTypes.NetworkConfiguration?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoStartConfiguration
        case autoStopConfiguration
        case clientToken
        case initialCapacity
        case maximumCapacity
        case networkConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let initialCapacityContainer = try containerValues.decodeIfPresent([Swift.String: EmrServerlessClientTypes.InitialCapacityConfig?].self, forKey: .initialCapacity)
        var initialCapacityDecoded0: [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]? = nil
        if let initialCapacityContainer = initialCapacityContainer {
            initialCapacityDecoded0 = [Swift.String:EmrServerlessClientTypes.InitialCapacityConfig]()
            for (key0, initialcapacityconfig0) in initialCapacityContainer {
                if let initialcapacityconfig0 = initialcapacityconfig0 {
                    initialCapacityDecoded0?[key0] = initialcapacityconfig0
                }
            }
        }
        initialCapacity = initialCapacityDecoded0
        let maximumCapacityDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.MaximumAllowedResources.self, forKey: .maximumCapacity)
        maximumCapacity = maximumCapacityDecoded
        let autoStartConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.AutoStartConfig.self, forKey: .autoStartConfiguration)
        autoStartConfiguration = autoStartConfigurationDecoded
        let autoStopConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.AutoStopConfig.self, forKey: .autoStopConfiguration)
        autoStopConfiguration = autoStopConfigurationDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
    }
}

extension UpdateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Swift.Equatable {
    /// Information about the updated application.
    /// This member is required.
    public var application: EmrServerlessClientTypes.Application?

    public init (
        application: EmrServerlessClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

struct UpdateApplicationOutputResponseBody: Swift.Equatable {
    let application: EmrServerlessClientTypes.Application?
}

extension UpdateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(EmrServerlessClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EmrServerlessClientTypes.WorkerResourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpu
        case disk
        case memory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpu = self.cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let disk = self.disk {
            try encodeContainer.encode(disk, forKey: .disk)
        }
        if let memory = self.memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpu)
        cpu = cpuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memory)
        memory = memoryDecoded
        let diskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disk)
        disk = diskDecoded
    }
}

extension EmrServerlessClientTypes {
    /// The cumulative configuration requirements for every worker instance of the worker type.
    public struct WorkerResourceConfig: Swift.Equatable {
        /// The CPU requirements for every worker instance of the worker type.
        /// This member is required.
        public var cpu: Swift.String?
        /// The disk requirements for every worker instance of the worker type.
        public var disk: Swift.String?
        /// The memory requirements for every worker instance of the worker type.
        /// This member is required.
        public var memory: Swift.String?

        public init (
            cpu: Swift.String? = nil,
            disk: Swift.String? = nil,
            memory: Swift.String? = nil
        )
        {
            self.cpu = cpu
            self.disk = disk
            self.memory = memory
        }
    }

}
